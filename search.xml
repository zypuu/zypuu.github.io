<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于Mysql数据库使用的优化]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%85%B3%E4%BA%8EMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[关于数据库索引原理及优化]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[关于Mysql的sql注入问题]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%85%B3%E4%BA%8EMysql%E7%9A%84sql%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[关于数据库redis与Mysql的区别以及在web开发中的配合使用]]></title>
    <url>%2F2018%2F08%2F18%2F%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93redis%E4%B8%8EMysql%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8web%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[传统型关系数据库Mysql的瓶颈在互联网领域，MySQL作为一款关系型数据库为互联网的发展做出了卓越的贡献。然而随着互联网的发展，在大数据量高并发的环境下，应用开发也越来越复杂，具有很强的技术挑战性。分表分库子库等无不在增加数据库结构的复杂程度。MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差，大数据下IO压力大，表结构更改困难。 Nosql与redisNoSQL最常见的解释是“non-relational”，“Not Only SQL”也被很多人接受，指的是非关系型的数据库。 Nosql的优势易扩展：NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。大数据量，高性能：NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单灵活的数据模型：NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦高可用：NoSQL在不太影响性能的情况，就可以方便的实现高可用的架构。 redisRedis是一个开源（BSD许可）的、内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。redis是一个高性能的key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sortedset–有序集合)和hash（哈希类型）。redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Python，Ruby，Erlang，PHP客户端，使用很方便Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。 结论NoSQL数据库的出现，弥补了关系数据（比如MySQL）在某些方面的不足，在某些方面能极大的节省开发成本和维护成本MySQL和NoSQL都有各自的特点和使用的应用场景，两者的紧密结合将会给数据库发展带来新的思路。让关系数据库关注在关系上，NoSQL关注在存储上。 利用redis做mysql的缓存前面部分已经介绍mysql的瓶颈，当网站的处理和访问量非常大的时候，我们的数据库的压力就变大了，数据库的连接池，数据库同时处理数据的能力就会受到很大的挑战，一旦数据库承受了其最大承受能力，网站的数据处理效率就会大打折扣。此时就要使用高并发处理、负载均衡和分布式数据库，而这些技术既花费人力，又花费资金。 缓存 页面缓存经常用在CMS(content manage system)内存管理系统里面。数据缓存经常会用在页面的具体数据里面。 Redis缓存原理采用redis nosql数据库作为Mysql数据库的缓存，在查找的时候，首先查找redis缓存，如果找到则返回结果；如果在redis中没有找到，那么查找Mysql数据库，找到的花则返回结果并且更新redis；如果没有找到则返回空。 对于写入：用户增删改数据库，先访问mysql，mysql再把数据更新到redis。 Mysql中的数据都是按表存储的；更微观地看，这些表都是按行存储的。每执行一次select查询，Mysql都会返回一个结果集，这个结果集由若干行组成。所以，一个自然而然的想法就是在Redis中找到一种对应于Mysql行的数据结构。Redis中提供了五种基本数据结构，即字符串（string）、列表（list）、哈希（hash）、集合（set）和有序集合（sorted set）。经过调研，发现适合存储行的数据结构有两种，即string和hash。 用户的缓存数据在返回时一般都是JSON的字典格式，对应的存到redis里就是hash格式，这个与python的字典是相对应的。 redis中的hash python中的字典 key 对象 field key value value 即hash会根据要缓存的数据生成唯一标识UUID，UUID作为键，用户的字典数据中的键值对作为UUID键的值，存储到redis中。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库,redis,mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch的使用]]></title>
    <url>%2F2018%2F08%2F01%2FElasticsearch%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[ESES=elaticsearch简写， Elasticsearch是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。 ES工作原理当ElasticSearch的节点启动后，它会利用多播(multicast)(或者单播，如果用户更改了配置)寻找集群中的其它节点，并与之建立连接。这个过程如下图所示： ES核心概念Cluster：集群ES可以作为一个独立的单个搜索服务器。不过，为了处理大型数据集，实现容错和高可用性，ES可以运行在许多互相合作的服务器上。这些服务器的集合称为集群。 Node：节点形成集群的每个服务器称为节点。 Shard：分片当有大量的文档时，由于内存的限制、磁盘处理能力不足、无法足够快的响应客户端的请求等，一个节点可能不够。这种情况下，数据可以分为较小的分片。每个分片放到不同的服务器上。当你查询的索引分布在多个分片上时，ES会把查询发送给每个相关的分片，并将结果组合在一起，而应用程序并不知道分片的存在。即：这个过程对用户来说是透明的。 Replia：副本为提高查询吞吐量或实现高可用性，可以使用分片副本。副本是一个分片的精确复制，每个分片可以有零个或多个副本。ES中可以有许多相同的分片，其中之一被选择更改索引操作，这种特殊的分片称为主分片。当主分片丢失时，如：该分片所在的数据不可用时，集群将副本提升为新的主分片。 全文检索全文检索就是对一篇文章进行索引，可以根据关键字搜索，类似于mysql里的like语句。全文索引就是把内容根据词的意义进行分词，然后分别创建索引，例如”你们的激情是因为什么事情来的” 可能会被分词成：“你们“，”激情“，“什么事情“，”来“ 等token，这样当你搜索“你们” 或者 “激情” 都会把这句搜出来。 ES数据架构的主要概念（与关系数据库Mysql对比） （1）关系型数据库中的数据库（DataBase），等价于ES中的索引（Index）（2）一个数据库下面有N张表（Table），等价于1个索引Index下面有N多类型（Type），（3）一个数据库表（Table）下的数据由多行（ROW）多列（column，属性）组成，等价于1个Type由多个文档（Document）和多Field组成。（4）在一个关系型数据库里面，schema定义了表、每个表的字段，还有表和字段之间的关系。 与之对应的，在ES中：Mapping定义索引下的Type的字段处理规则，即索引如何建立、索引类型、是否保存原始索引JSON文档、是否压缩原始JSON文档、是否需要分词处理、如何进行分词处理等。（5）在数据库中的增insert、删delete、改update、查search操作等价于ES中的增PUT/POST、删Delete、改_update、查GET. 简单使用ES使用Docker安装Elasticsearch及其扩展获取镜像，可以通过网络pull 1docker image pull delron/elasticsearch-ik:2.4.6-1.0 修改elasticsearch的配置文件 elasticsearc-2.4.6/config/elasticsearch.yml第54行，更改ip地址为本机ip地址 1network.host: 自己机器的IP地址 创建docker容器运行 1docker run -dti --network=host --name=elasticsearch -v /home/python/elasticsearch-2.4.6/config:/usr/share/elasticsearch/config delron/elasticsearch-ik:2.4.6-1.0 使用haystack对接ElasticsearchHaystack为Django提供了模块化的搜索。它的特点是统一的，熟悉的API，可以让你在不修改代码的情况下使用不同的搜索后端（比如 Solr, Elasticsearch, Whoosh, Xapian 等等）。 这里通过使用haystack来调用Elasticsearch搜索引擎。 安装12pip install drf-haystackpip install elasticsearch==2.4.1 drf-haystack是为了在REST framework中使用haystack而进行的封装（如果在Django中使用haystack，则安装django-haystack即可）。 注册应用1234INSTALLED_APPS = [ ... 'haystack',] 配置12345678910111213# HaystackHAYSTACK_CONNECTIONS = &#123; 'default': &#123; 'ENGINE': 'haystack.backends.elasticsearch_backend.ElasticsearchSearchEngine', # 端口号固定为9200 'URL': 'http://es的IP:9200/', # 指定elasticsearch建立的索引库的名称 'INDEX_NAME': '名称自定', &#125;,&#125;# 当添加、修改、删除数据时，自动生成索引HAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor' 注意： HAYSTACK_SIGNAL_PROCESSOR 的配置保证了在Django运行起来后，有新的数据产生时，haystack仍然可以让Elasticsearch实时生成新数据的索引 创建索引类123456789101112131415161718from haystack import indexesfrom .models import SKUclass SKUIndex(indexes.SearchIndex, indexes.Indexable): """ SKU索引数据模型类 """ text = indexes.CharField(document=True, use_template=True) def get_model(self): """返回建立索引的模型类""" return SKU def index_queryset(self, using=None): """返回要建立索引的数据查询集""" return self.get_model().objects.filter(is_launched=True) 在SKUIndex建立的字段，都可以借助haystack由elasticsearch搜索引擎查询。 其中text字段我们声明为document=True，表名该字段是主要进行关键字查询的字段， 该字段的索引值可以由多个数据库模型类字段组成，具体由哪些模型类字段组成，我们用use_template=True表示后续通过模板来指明。 在REST framework中，索引类的字段会作为查询结果返回数据的来源。 在templates目录中创建text字段使用的模板文件具体在templates/search/indexes/goods/sku_text.txt文件中定义 12&#123;&#123; object.name &#125;&#125;&#123;&#123; object.caption &#125;&#125; 此模板指明当将关键词通过text参数名传递时，可以通过sku的name、caption、id来进行关键字索引查询。 手动生成初始索引1python manage.py rebuild_index 创建序列化器在goods/serializers.py中创建haystack序列化器 123456789101112131415from drf_haystack.serializers import HaystackSerializerfrom .search_indexes import SKUIndexclass SKUIndexSerializer(HaystackSerializer): """ SKU索引结果数据序列化器 """ object = SKUSerializer(read_only=True) class Meta: index_classes = [SKUIndex] fields = ( 'text', # 用于接收查询关键字 'object' # 用于返回查询结果 ) 下面的搜索视图使用SKUIndexSerializer序列化器用来检查前端传入的参数text，并且检索出数据后再使用这个序列化器返回给前端； SKUIndexSerializer序列化器中的object字段是用来向前端返回数据时序列化的字段。 Haystack通过Elasticsearch检索出匹配关键词的搜索结果后，还会在数据库中取出完整的数据库模型类对象，放到搜索结果的object属性中，并将结果通过SKUIndexSerializer序列化器进行序列化。所以我们可以通过声明搜索结果的object字段以SKUSerializer序列化的形式进行处理，明确要返回的搜索结果中每个数据对象包含哪些字段。 创建视图在goods/views.py中创建视图 12345678910from drf_haystack.viewsets import HaystackViewSetfrom .serializers import SKUIndexSerializerclass SKUSearchViewSet(HaystackViewSet): """ SKU搜索 """ index_models = [SKU] serializer_class = SKUIndexSerializer 注意：该视图会返回搜索结果的列表数据，所以可以为视图增加REST framework的分页功能。我们在实现商品列表页面时已经定义了全局的分页配置，所以此搜索视图会使用全局的分页配置。 定义路由在goods/urls.py中通过REST framework的router来定义路由12345678from rest_framework.routers import DefaultRouter...router = DefaultRouter()router.register('skus/search', views.SKUSearchViewSet, base_name='skus_search')urlpatterns += router.urls bug说明如果在配置完haystack并启动程序后，出现如下异常，是因为drf-haystack还没有适配最新版本的REST framework框架可以通过修改REST framework框架代码，补充_get_count函数定义即可 文件路径 虚拟环境下的 lib/python3.6/site-packages/rest_framework/pagination.py 12345678def _get_count(queryset): """ Determine an object count, supporting either querysets or regular lists. """ try: return queryset.count() except (AttributeError, TypeError): return len(queryset)]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>web,search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于docker的个人理解]]></title>
    <url>%2F2018%2F08%2F01%2F%E5%85%B3%E4%BA%8Edocker%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Docker通俗理解什么是docker，docker翻译过来的名称就是容器，而容器是干什么用的，容器用来装东西的，就像一个集装箱，一个密闭的容器，不受外部的干扰，也无法干扰外部。docker就是这么一个密闭的容器，将那些程序服务就放在docker里来运行。 为什么使用Docker将程序软件安装在docker容器里去运行，本质上讲是一种虚拟技术，提到虚拟技术，就会想到虚拟机，那为什么要将程序安装到docker里运行，不直接在本机安装，使用虚拟技术，它又与虚拟机有和区别呢？ 将程序直接安装在本机上，对于服务或者运行效率当然是最佳的体验，所以为什么使用容器，最主要原因就是成本原因，每一台主机都是有成本的，如果为了保证效率，每一台主机只跑部分服务，而需要多台主机的话，那成本就高了，当然有钱的另说，比如银行，追求省心稳定，一个服务器挂一台主机，性能用不完。但是一般的商业公司追求一定的经济性，一个主机只跑一些服务太浪费了，所以就出现把主机分开独立运行的手段—docker，降低服务器成本，还要保证一定的使用效率。 还有VM虚拟机，同样是虚拟技术，docker相对于虚拟机有何优点？docker是直接调用原生系统资源，不像虚拟机是安装在操作系统上层层吃配置的软件服务。它比虚拟机更加强大，体积小，运行速度快，启动和关闭只需要几秒。相对于普通虚拟机来说，启动时间在分钟级别，占用内存大。所以这就是docker出现之后的优势。 docker的应用场景容器提供了隔离性，结论是，容器可以为各种测试提供很好的沙盒环境。并且，容器本 身就具有“标准性”的特征，非常适合为服务创建构建块。Docker 的一些应用场景如下:1.加速本地开发和构建流程，使其更加高效、更加轻量化。本地开发人员可以构建、 运行并分享 Docker 容器。容器可以在开发环境中构建，然后轻松的提交到测试环境中，并 最终进入生产环境。2.能够让独立的服务或应用程序在不同的环境中，得到相同的运行结果。这一点在 面向服务的架构和重度依赖微型服务的部署由其实用。3.用 Docker 创建隔离的环境来进行测试。例如，用 Jenkins CI 这样的持续集成工具 启动一个用于测试的容器。4.Docker 可以让开发者先在本机上构建一个复杂的程序或架构来进行测试，而不是 一开始就在生产环境部署、测试。 镜像、容器与仓库镜像创建虚拟机和docker 都必不可少的东西。 用过虚拟机的朋友都知道，创建一个虚拟机就先得下载操作系统的ISO镜像文件，然后通过镜像文件安装操作系统，和实体机类似，然后能在虚拟机中去安装各种软件。也可以将镜像当作容器的“源代码”。镜像体积很小，非常便携，易于分享、存储和更新。Docker 容器启动是需要一些文件的， 而这些文件就可以称为 Docker 镜像。 容器通俗拿VM虚拟机和docker来举例，一个容器就类似于一个虚拟机，只不过在docker技术的术语上称为容器。这个容器装的就是我们部署的应用在运行，和虚拟机一样可以开机，关机，重启。docker称为容器的运行，关闭，重启。而且这个容器可以打包为镜像文件，类似虚拟机快照的文件，放在其它虚拟机上又可以保持原样能运行，docker也是如此，把容器打包为镜像文件，然后在新的服务器安装好的docker环境下导入进去，保持原来的状态能够运行。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。 仓库如果你使用过git和github就很容易理解Docker的仓库概念。Docker 仓库的概念跟Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。 Docker 仓库是用来包含镜像的位置，Docker提供一个注册服务器（Register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像。Docker运行中使用的默认仓库是 Docker Hub 公共仓库。 仓库支持的操作类似git，当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。. docker、容器、镜像的安装与操作docker的安装与操作添加Docker官方GPG key1sudo apt-key add gpg 安装Docker稳定版1sudo dpkg -i docker-ce_17.03.2~ce-0~ubuntu-xenial_amd64.deb 检查Docker是否安装正确1sudo docker run hello-world 为了避免每次命令都输入sudo，可以设置用户权限，注意执行后须注销重新登录1sudo usermod -a -G docker $USER 安装完成Docker后，默认已经启动了docker服务，如需手动控制docker服务的启停，可执行如下命令 12345678# 启动dockersudo service docker start# 停止dockersudo service docker stop# 重启dockersudo service docker restart 镜像操作列出镜像 1docker image ls 拉取镜像。即从官方仓库docker hub上拉取。docker hub 1docker image pull library/hello-world 由于 Docker 官方提供的 image 文件，都放在library组里面，所以它的是默认组，可以省略，hello world 是镜像文件名字。 删除镜像 1docker image rm 镜像名或镜像id 容器操作创建容器 1docker run [option] 镜像名 [向启动容器中传入的命令] -i 表示以“交互模式”运行容器-t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即 分配一个伪终端。–name 为创建的容器命名-v 表示目录映射关系(前者是宿主机目录，后者是映射到宿主机上的目录，即 宿主机目录:容器中目录)，可以使 用多个-v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后 共享到容器上。-d 在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不 会自动登录容器，如果只加-i -t 两个参数，创建后就会自动进去容器)。-p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p 做多个端口映射-e 为容器设置环境变量–network=host 表示将主机的网络环境映射到容器中，容器的网络与主机相同例：交互式容器 1docker run -it --name=myubuntu ubuntu /bin/bash 可以执行linux命令。守护式容器 1docker run -dit --name=myubuntu2 ubuntu 如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器。在容器内部exit退出时，容器也不会停止。 查看容器 12345# 列出本机正在运行的容器docker container ls# 列出本机所有容器，包括已经终止运行的docker container ls --all 停止与启动容器 12345678# 停止一个已经在运行的容器docker container stop 容器名或容器id# 启动一个已经停止的容器docker container start 容器名或容器id# kill掉一个已经在运行的容器docker container kill 容器名或容器id 删除容器 1docker container rm 容器名或容器id 将容器保存为镜像，备份迁移将容器保存为镜像1docker commit 容器名 镜像名 将镜像打包成文件，拷贝给别人使用 1docker save -o 保存的文件名 镜像名 拿到镜像文件加载到本地 1docker load -i ./ubuntu.tar 当前目录下的ubantu为例]]></content>
      <categories>
        <category>环境安装</category>
      </categories>
      <tags>
        <tag>虚拟技术,docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于FastDFS文件分布式系统]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%85%B3%E4%BA%8EFastDFS%E6%96%87%E4%BB%B6%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[FastDFS简介什么是FastDFSFastDFS 是一个开源的高性能分布式文件系统（DFS）。 它的主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡。主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB &lt; file_size &lt;500MB）为载体的在线服务。 FastDFS 系统有三个角色：跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)。 Tracker Server：跟踪服务器，主要做调度工作，起到均衡的作用；负责管理所有的 storage server和 group，每个 storage 在启动后会连接 Tracker，告知自己所属 group 等信息，并保持周期性心跳。 Storage Server：存储服务器，主要提供容量和备份服务；以 group 为单位，每个 group 内可以有多台 storage server，数据互为备份。 Client：客户端，上传下载数据的服务器，也就是我们自己的项目所部署在的服务器。 服务端两个角色: Tracker: 管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。Storage: 实际保存文件， Storage 分为多个组，每个组之间保存的文件是不同的。每 个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有 主从的概念。 FastDFS存储策略为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。 在卷中增加服务器时，同步已有的文件由系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了存储系统的容量。 文件上传流程FastDFS向使用者提供基本文件访问接口，比如upload、download、append、delete等，以客户端库的方式提供给用户使用。 Storage Server会定期的向Tracker Server发送自己的存储信息。当Tracker Server Cluster中的Tracker Server不止一个时，各个Tracker之间的关系是对等的，所以客户端上传时可以选择任意一个Tracker。当Tracker收到客户端上传文件的请求时，会为该文件分配一个可以存储文件的group，当选定了group后就要决定给客户端分配group中的哪一个storage server。当分配好storage server后，客户端向storage发送写文件请求，storage将会为文件分配一个数据存储目录。然后为文件分配一个fileid，最后根据以上的信息生成文件名存储文件。 文件名组成文件名如下：组名：文件上传后所在的 storage 组名称，在文件上传成功后有 storage 服务器返回， 需要客户端自行保存。虚拟磁盘路径：storage 配置的虚拟路径，与磁盘选项 store_path对应。如果配置了 store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推。数据两级目录：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据 文件。文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含:源存储 服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。 简易FastDFS构建使用docker安装FastDFS拉取镜像 1docker image pull delron/fastdfs 运行tracker 1docker run -dti --network=host --name tracker -v /var/fdfs/tracker:/var/fdfs delron/fastdfs tracker 运行storage 1docker run -dti --network=host --name storage -e TRACKER_SERVER=本机ip:22122 -v /var/fdfs/storage:/var/fdfs delron/fastdfs storage 然后可使用docker命令进行管理操作。 FastDFS的Python客户端，Django使用FastDFS参考：点这里 安装环境下载安装包 123pip install fdfs_client-py-master.zippip install mutagenpip install requests 配置我们在utils包下新建fastdfs包，client.conf配置文件放到这个目录中。然后改一下其中的配置 12base_path=FastDFS客户端存放日志文件的目录tracker_server=运行tracker服务的机器ip:22122 上传文件需要先创建fdfs_client.client.Fdfs_client的对象，并指明配置文件，如 12from fdfs_client.client import Fdfs_clientclient = Fdfs_client('utils/fastdfs/client.conf') 通过创建的对象，执行上传文件的方法 12from fdfs_client.client import Fdfs_clientclient = Fdfs_client('utils/fastdfs/client.conf') 自定义Django文件存储系统django自带文件存储系统，但是存储路径是本地，怎样将文件存储到FastDFS的服务器上呢参考文档：点这里 自定义文件存储系统的方法如下：1）需要继承自django.core.files.storage.Storage，如 123from django.core.files.storage import Storageclass FastDFSStorage(Storage): 2）支持Django不带任何参数来实例化存储类，也就是说任何设置都应该从django.conf.settings中获取 1234567891011from django.conf import settingsfrom django.core.files.storage import Storageclass FastDFSStorage(Storage): def __init__(self, base_url=None, client_conf=None): if base_url is None: base_url = settings.FDFS_URL self.base_url = base_url if client_conf is None: client_conf = settings.FDFS_CLIENT_CONF self.client_conf = client_conf 3）存储类中必须实现_open()和_save()方法，以及任何后续使用中可能用到的其他方法。 123456789101112131415_open(name, mode='rb')# 被Storage.open()调用，在打开文件时被使用。_save(name, content)# 被Storage.save()调用，name是传入的文件名，content是Django接收到的文件内容，该方法需要将content文件内容保存。# Django会将该方法的返回值保存到数据库中对应的文件字段，也就是说该方法应该返回要保存在数据库中的文件名称信息。exists(name)# 如果名为name的文件在文件系统中存在，则返回True，否则返回False。url(name)# 返回文件的完整访问URLdelete(name)# 删除name的文件listdir(path)# 列出指定路径的内容size(name)# 返回name文件的总大小 4）需要为存储类添加django.utils.deconstruct.deconstructible装饰器我们在utils/fastdfs目录中创建fdfs_storage.py文件，实现可以使用FastDFS存储文件的存储类如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from django.conf import settingsfrom django.core.files.storage import Storagefrom django.utils.deconstruct import deconstructiblefrom fdfs_client.client import Fdfs_client@deconstructibleclass FastDFSStorage(Storage): def __init__(self, base_url=None, client_conf=None): """ 初始化 :param base_url: 用于构造图片完整路径使用，图片服务器的域名 :param client_conf: FastDFS客户端配置文件的路径 """ if base_url is None: base_url = settings.FDFS_URL self.base_url = base_url if client_conf is None: client_conf = settings.FDFS_CLIENT_CONF self.client_conf = client_conf def _open(self, name, mode='rb'): """ 用不到打开文件，所以省略 """ pass def _save(self, name, content): """ 在FastDFS中保存文件 :param name: 传入的文件名 :param content: 文件内容 :return: 保存到数据库中的FastDFS的文件名 """ client = Fdfs_client(self.client_conf) ret = client.upload_by_buffer(content.read()) if ret.get("Status") != "Upload successed.": raise Exception("upload file failed") file_name = ret.get("Remote file_id") return file_name def url(self, name): """ 返回文件的完整URL路径 :param name: 数据库中保存的文件名 :return: 完整的URL """ return self.base_url + name def exists(self, name): """ 判断文件是否存在，FastDFS可以自行解决文件的重名问题 所以此处返回False，告诉Django上传的都是新文件 :param name: 文件名 :return: False """ return False 在Django配置中设置自定义文件存储类在settings.py文件中添加设置 123456# django文件存储DEFAULT_FILE_STORAGE = 'utils.fastdfs.fdfs_storage.FastDFSStorage'# FastDFSFDFS_URL = '你的域名:8888/' FDFS_CLIENT_CONF = os.path.join(BASE_DIR, 'utils/fastdfs/client.conf') 添加image域名在/etc/hosts中添加访问FastDFS storage服务器的域名1IP image.域名]]></content>
      <categories>
        <category>环境安装</category>
      </categories>
      <tags>
        <tag>文件存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面静态化与定时任务]]></title>
    <url>%2F2018%2F07%2F08%2F%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[网站的首页频繁被访问，为了提升访问速度，除了缓存技术，还可以使用页面静态化技术。其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。 页面静态化什么是页面静态化页面静态化即将动态渲染生成的页面结果保存成html文件，放到静态文件服务器中。用户访问的时候访问的是处理好之后的html静态文件。 页面中有些区域，因登录用户不同，而显示不同的数据，可以在用户请求完html页面后，通过ajax向后端发送请求，获取属于用户的特殊的数据。 首页配置静态化在settings.py中添加保存静态文件的目录 12# 生成的静态html文件保存目录GENERATED_STATIC_HTML_FILES_DIR = os.path.join(os.path.dirname(BASE_DIR), 'front_end_pc') front_end_pc为前端文件的存放目录 然后将静态化的页面数据例:index.html放置在templates文件里 静态化逻辑，生成静态化页面 1234567891011121314# 获取要生成的数据 context = &#123; 'categories': categories, 'contents': contents &#125; # 加载模板 template = loader.get_template('index.html') # 渲染模板 html_text = template.render(context) # 静态文件保存的路径 file_path = os.path.join(settings.GENERATED_STATIC_HTML_FILES_DIR, 'index.html') # 打开该路径下的文件，没有则生成创建 with open(file_path, 'w', encoding='utf-8') as f: f.write(html_text) 实现静态化的两种方式定时任务使用在Django执行定时任务，可以通过django-crontab扩展来实现。 1pip install django-crontab 然后配置中添加应用 1234INSTALLED_APPS = [ ... 'django_crontab', # 定时任务] 设置任务的定时时间 12345# 定时任务CRONJOBS = [ # 每5分钟执行一次生成主页静态文件 ('*/5 * * * *', 'contents.crons.generate_static_index_html', '&gt;&gt; 日志路径/logs/crontab.log')] 基本格式 : 分 时 日 月 周 命令 M: 分钟（0-59）。每分钟用或者 /1表示 H：小时（0-23）。（0表示0点） D：天（1-31）。 m: 月（1-12）。 d: 一星期内的天（0~6，0为星期天） 开启定时任务 1python manage.py crontab add 显示已经激活的定时任务 1python manage.py crontab show 移除定时任务 1python manage.py crontab remove 解决中文字符问题在定时任务中，如果出现非英文字符，会出现字符异常错误在settings中配置12# 解决crontab中文问题CRONTAB_COMMAND_PREFIX = 'LANG_ALL=zh_cn.UTF-8' 脚本手动生成静态化页面为了开发方便，可以编写手动生成所有商品静态页面的脚本 在项目下新建包scripts，再创建regenerate_detail_html.py 1234567891011121314151617181920212223242526272829#!/usr/bin/env python#指定执行此py文件的命令为python#/usr/bin/env表示在当前环境中查找python命令，当前为虚拟环境py3_django"""功能：手动生成所有SKU的静态detail html文件使用方法: ./regenerate_detail_html.py"""import syssys.path.insert(0, '../')import osos.environ.setdefault("DJANGO_SETTINGS_MODULE", "meiduo_api.settings")import djangodjango.setup()from goods.models import SKU# 异步任务执行静态化from celery_tasks.html.tasks import generate_static_sku_detail_htmlif __name__ == '__main__': skus = SKU.objects.all() for sku in skus: print(sku.id) generate_static_sku_detail_html(sku.id)]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>html静态化,处理高并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CKEditor富文本编辑器]]></title>
    <url>%2F2018%2F07%2F02%2FCKEditor%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在运营后台，运营人员需要录入并编辑模型类的详情信息，而这些信息不是普通的文本，可以是包含了HTML语法格式的字符串。为了快速简单的让用户能够在页面中编辑带格式的文本，富文本即具备丰富样式格式的文本。 安装1pip install django-ckeditor 添加应用1234567在INSTALLED_APPS中添加INSTALLED_APPS = [ ... 'ckeditor', # 富文本编辑器 'ckeditor_uploader', # 富文本编辑器上传图片模块] 添加CKEditor配置在settings.py中添加 12345678910# 富文本编辑器ckeditor配置CKEDITOR_CONFIGS = &#123; 'default': &#123; 'toolbar': 'full', # 工具条功能 'height': 300, # 编辑器高度 # 'width': 300, # 编辑器宽度 &#125;,&#125;CKEDITOR_UPLOAD_PATH = '' # 上传图片保存路径，使用了FastDFS，所以此处设为' ' 添加ckeditor路由1url(r'^ckeditor/', include('ckeditor_uploader.urls')), 为模型类添加字段12ckeditor.fields.RichTextField 不支持上传文件的富文本字段ckeditor_uploader.fields.RichTextUploadingField 支持上传文件的富文本字段 在需要编辑的模型类的设置可以编辑的字段。别忘了数据库迁移。]]></content>
      <categories>
        <category>环境安装</category>
      </categories>
      <tags>
        <tag>富文本编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于web开发用户注册功能的图形验证码与短信验证码]]></title>
    <url>%2F2018%2F06%2F18%2F%E5%85%B3%E4%BA%8Eweb%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E4%B8%8E%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Flask框架前后端不分离 图片验证码Captcha1.基于captcha实现图片验证码，什么是captcha？Captcha是一个第三方工具，提供生成验证码图片通用解决办法，提供了非常灵活的生成验证码图片的框架，可以自由的组合生成图片过程中的各种元素，例如，字体、颜色、背景、扭曲样式等，不仅提供了丰富的变形资源，即使不能满足需求的情况下，也可以实现固有的接口，创造出自己的字体变形的方式，所以该框架应该可以满足生成验证图片的大部分需求。#### Flask框架中使用captcha完成图片验证码功能将chptcha的第三方包放在utils文件夹中，utils是基于python创建一个flask工程后一个专门存放第三方工具包的文件夹。然后在功能视图模块中 1from utils.captcha.captcha import captcha 视图函数中 1234567891011121314# @user_blueprint是flask框架中，经过创建蓝图，蓝图注册的路由，后面是路由地址@user_blueprint.route('/image_code')def image_code(): # 调用第三方的工具，生成图形验证码数据 name, text, image = captcha.generate_captcha() # 保存text值，存放于session中，用于后续的对比验证 session['image_code'] = text # 创建响应对象，响应体为图片数据 response = make_response(image) # 注意：这里一定要设置响应数据的类型为图片，不然会在网页上无法显示，生成乱码数据 response.content_type = 'image/png' # 返回到响应体 return response 在首页的页面中index.html中，添加如下代码： 1&lt;img src="/user/image_code?1" class="get_pic_code" onclick="generateImageCode()"&gt; 显示图片，设置css样式，并绑定点击事件，生成图片验证码然后在main.js（主页js里）添加： 123function generateImageCode() &#123; $('.get_pic_code').attr('src', $('.get_pic_code').attr('src') + '1');&#125; 点击事件，点击即修改他的src属性，重新生成图片验证码，即可实现$(‘.get_pic_code’)是类选择器，attr获取其src属性进行修改 短信验证码容联云通讯容联云通讯为第三方服务，云通讯平台将传统电信网络通讯能力、基于IP的通讯能力，通过开放API的方式提供给开发者与合作伙伴，让开发者们在应用程序中集成网络电话和电话会议功能变得简单。可提供语音、IVR、短信、IM、视频等web开发接口，这里使用短信功能，详情可查看官方开发文档点这里查看基于python的短信发送接口。 实现短信验证码发送功能将云通讯第三方工具包放入utils文件夹中，云通讯文档使用说明：1.接口声明文件：SDK \CCPRestSDK.py 2.接口函数定义：def sendTemplateSMS(self, to,datas,tempId) 3.参数说明： to: 短信接收手机号码集合,用英文逗号分开,如 ‘13810001000,13810011001’,最多一次发送200个。 datas：内容数据，需定义成数组方式，如模板中有两个参数，定义方式为array[‘Marry’,’Alon’]。 templateId: 模板Id,如使用测试模板，模板id为”1”，如使用自己创建的模板，则使用自己创建的短信模板id即可。4.接口调用示例： 12345678910111213141516171819202122232425262728293031323334编码说明：coding=utf-8或gbk from CCPRestSDK import REST import ConfigParser accountSid= '您的主账号'; #说明：主账号，登陆云通讯网站后，可在控制台首页中看到开发者主账号ACCOUNT SID。 accountToken= '您的主账号Token'; #说明：主账号Token，登陆云通讯网站后，可在控制台首页中看到开发者主账号AUTH TOKEN。 appId='您的应用ID'; #请使用管理控制台中已创建应用的APPID。 serverIP='app.cloopen.com'; #说明：请求地址，生产环境配置成app.cloopen.com。 serverPort='8883'; #说明：请求端口 ，生产环境为8883. softVersion='2013-12-26'; #说明：REST API版本号保持不变。 def sendTemplateSMS(to,datas,tempId): #初始化REST SDK rest = REST(serverIP,serverPort,softVersion) rest.setAccount(accountSid,accountToken) rest.setAppId(appId) result = rest.sendTemplateSMS(to,datas,tempId) for k,v in result.iteritems(): if k=='templateSMS' : for k,s in v.iteritems(): print '%s:%s' % (k, s) else: print '%s:%s' % (k, v) 在视图函数中定义如下视图： 12345678910111213141516171819202122232425262728293031323334# 蓝图注册@user_blueprint.route('/sms_code')def sms_code(): # 接收:手机号，图形验证码，从请求报文中接收 mobile = request.args.get('mobile') imagecode = request.args.get('imagecode') # 验证 # 1.值必填 空在python中为False # 如果都不为空 if not all([mobile, imagecode]): # 返回json数据格式，由前端代码进一步处理 return jsonify(result=1) # 2.检验图形验证码一致，之前图形验证码已经存在session中 imagecode_session = session.get('image_code') if not imagecode_session: return jsonify(result=4) # 删除session中的数据，强制图形验证码过期，防止客户端不停尝试 del session['image_code'] # 验证码不对的情况 if imagecode != imagecode_session: return jsonify(result=2) # 处理 # 1.通过random随机数生成随机的验证码 smscode = str(random.randint(100000, 999999)) # 2.保存验证码，用于后续验证，存到session中 session['sms_code'] = smscode # 3.发送短信，云通讯工具包中封装好的函数功能 ytx_send.sendTemplateSMS(mobile, [smscode, '10'], 1) # 响应 return jsonify(result=3) 在mian.JS中修改如下代码： 123456789101112131415161718192021222324252627282930313233343536373839// 发送短信验证码的点击事件，页面css已经由前端绑定好function sendSMSCode() &#123; // 校验参数，保证输入框有数据填写 // 先移除绑定事件，防止用户不符合条件下点击执行函数 $(".get_code").removeAttr("onclick"); // 前端检验规则 var mobile = $("#register_mobile").val(); if (!mobile) &#123; $("#register-mobile-err").html("请填写正确的手机号！"); $("#register-mobile-err").show(); $(".get_code").attr("onclick", "sendSMSCode();"); return; &#125; var imageCode = $("#imagecode").val(); if (!imageCode) &#123; $("#image-code-err").html("请填写验证码！"); $("#image-code-err").show(); $(".get_code").attr("onclick", "sendSMSCode();"); return; &#125; // TODO 发送短信验证码 // 根据后端返回的json数据实现不同提示，局部刷新，要使用ajax请求 $.get('/user/sms_code',&#123; 'mobile':mobile, 'imagecode':imageCode, &#125;,function (data) &#123; if(data.result==1)&#123; alert('请填写完整数据'); &#125;else if(data.result==2 || data.result==4)&#123; alert('图形验证码错误'); $(".get_code").attr("onclick", "sendSMSCode();"); generateImageCode(); $("#imagecode").val(''); &#125;else if(data.result==3)&#123; alert('请查看手机'); &#125; &#125;);&#125; 至于短信验证码等待60秒功能会在下文Django的框架中实现。 Django框架前后端分离相比于Flas,k所以不需要再写前端代码，只要按照restful的开发格式，返回json数据即可 短信验证码djang框架实现短信验证码功能，同样使用第三方工具包云通讯功能，云通讯配置及使用方法在上述过程中已有介绍，这里就不在赘述。 Django框架API接口设计访问方式： GET /sms_codes/(?P1[3-9]\d{9})/ 请求参数： 路径参数与查询字符串参数 参数 类型 是否必须 说明 mobile str 是 手机号 返回数据：json 返回值 类型 是否必传 说明 message str 否 OK，发送成功 后端代码在应用的urls.py中配置路由 123urlpatterns = [ url(r'^sms_code/(?P&lt;mobile&gt;1[3-9]\d&#123;9&#125;)/$',views.SMSCodeView.as_view()),] 在应用的views.py中定义视图 12345678910111213141516171819202122232425class SMSCodeView(APIView): def get(self, request, mobile): ''' 接收手机号，发送短信验证码 :param mobile: 手机号 :return: 是否成功 ''' # 获取redis的连接 redis_cli = get_redis_connection('verify_code') # 检查是否在60s内有发送记录 sms_flag = redis_cli.get('sms_flag_' + mobile) if sms_flag: raise serializers.ValidationError('请稍候再发送短信验证码') # 生成短信验证码 sms_code = str(random.randint(100000, 999999)) # 保存短信验证码与发送记录 # 存验证码，300秒 redis_cli.setex('sms_code_' + mobile, 300, sms_code) # 存发送标记，60秒 redis_cli.setex('sms_flag_' + mobile, 60, 1) # 发送短信 CCP.sendTemplateSMS(mobile,sms_code,5,1) return Response(&#123;'message': 'OK'&#125;) 用的djang的drf框架，别忘了导入各种包(response对象，redis数据库连接，APIview，云通讯，random，序列化器) 关于与redis数据库交互的优化上边代码 12345# 保存短信验证码与发送记录 # 存验证码，300秒 redis_cli.setex('sms_code_' + mobile, 300, sms_code) # 存发送标记，60秒 redis_cli.setex('sms_flag_' + mobile, 60, 1) 这部分代码与redis数据库交互了两次，如何进行优化，只交互一次呢？采用redis管道，代码如下： 12345# 优化redis交互，减少通信的次数，管道pipeline redis_pl = redis_cli.pipeline() redis_pl.setex('sms_code_' + mobile, 300, sms_code) redis_pl.setex('sms_flag_' + mobile, 60, 1) redis_pl.execute() 即可优化redis的交互次数。]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>web,验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DJANGO框架如何实现用户多认证方式登录与第三方授权登录]]></title>
    <url>%2F2018%2F06%2F11%2FDJANGO%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[多种认证方式登录Django框架提供了认证系统，详情看文档Django认证系统官方文档 在这个认证系统中，有一个用户认证的方法authenticate（）来验证一组凭据，默认的是username和password，官方调用源码如下： 123456from django.contrib.auth import authenticateuser = authenticate(username=&apos;john&apos;, password=&apos;secret&apos;)if user is not None: # A backend authenticated the credentialselse: # No backend authenticated the credentials 所以只需要重写这个方法，就可以实现多凭证登录。方法如下：1.在user应用下新建utils.py文件2.定义类继承Modelbackend，重写authenticate方法3.重写规则，代码如下 123456789101112131415161718192021# 重写authenticate方法，继承ModelBackend这个类来重写方法from django.contrib.auth.backends import ModelBackendfrom .models import Userclass UserModelBackend(ModelBackend): def authenticate(self, request, username=None, password=None, **kwargs): # 判断用户输入的是手机号还是用户名 try: # 查询对象，如果能查到对象则得到返回的对象 user = User.objects.filter(mobile=username) # 如果不是手机用户，则执行except except: # 判断是否用户名，与用户名对比 try: user = User.objects.filter(username=username) except: # 都不是返回空 return None # 如果查询到用户对象，则检查密码 if user.check_password(password): return user return None 4.配置中设置，settings中添加 123AUTHENTICATION_BACKENDS=[ 'users.utils.UsernameMobileModelBackend', ] 即可实现使用用户手机号登录。 授权第三方登录（QQ为例）QQ登录，即第三方登录，用户不在本网站输入账户密码，由第三方授权验证就可以登录本网站。如何实现授权qq登录呢，步骤如下： 第一步：QQ互联开发者注册要想实现第三方QQ登录，需要成为QQ互联的开发者，通过审核后，方可继续下面的步骤，注册参考文档：看这里登录成功后，填写注册信息，如下图所示注册成功即可。 第二步：创建应用注册成功后要创建应用，选择创建网站应用还是移动应用，并填写相关资料进行创建。如图所示点击创建应用。填写相关资料回调地址与备案信息要写规范最后创建成功，如图所示网站应用创建完成，点击“应用管理”，进入管理中心，在管理中心可以查看到网站获取的appid和appkey，如下图所示：记住这两条数据，后面会用到。 第三步：设置QQ登录按钮（前端代码）按钮的图标样式，还有前端ui规范，以及示例代码，均在官方文档里有详细介绍，这里就不说了，主要是后端代码的开发设置QQ登录按钮：点这里 第四步：网站后端代码开发由于后端代码开发流程比较复杂，首先梳理一下授权QQ登录的流程图 使用QQ登录的流程如图所示由流程可见，后端代码开发需要创建三个视图，下面进行代码实现。 配置中添加QQ开发者信息在settings.py文件中添加如下代码： 12345# QQ登录参数QQ_CLIENT_ID = '你的APPID'QQ_CLIENT_SECRET = ‘你的APPKEY’QQ_REDIRECT_URI = '网站回调网址'QQ_STATE = '/' # 默认state初始网址为根目录 新建应用、创建模型类在项目目录下的utils文件包内新建models.py（没有utils先建utils），里面添加如下代码： 123456789from django.db import models# 创建模型类基类，用于增加数据新建时间和更新时间。class BaseModel(models.Model): """为模型类补充字段""" create_time = models.DateTimeField(auto_now_add=True, verbose_name="创建时间") update_time = models.DateTimeField(auto_now=True, verbose_name="更新时间") class Meta: abstract = True # 说明是抽象模型类, 用于继承使用，数据库迁移时不会创建BaseModel的表 然后新建应用oauth，配置url与根目录url，在oauth的models里添加如下代码： 12345678910111213141516from django.db import modelsfrom 根目录.utils.models import BaseModel# 新建模型类，user与openid的关联表class OAuthQQUser(BaseModel): """ QQ登录用户数据 """ # 定义user，openid字段 user = models.ForeignKey('users.User', on_delete=models.CASCADE, verbose_name='用户') openid = models.CharField(max_length=64, verbose_name='openid', db_index=True) class Meta: # 表名，与字段后台显示名 db_table = 'tb_oauth_qq' verbose_name = 'QQ登录用户数据' verbose_name_plural = verbose_name 然后进行数据库迁移，终端命令如下： 12python manage.py makemigrationspython manage.py migrate 未来会有很多第三方账户集成登录，所以新建应用oauth并不修改原有表结构，而是新建表，完成第三方登录好处：1.不影响原有操作 未来会实现多种登录的可能性，提供出更方便的扩展方案：新建表 创建qq登录辅助工具在oauth应用下新建utils.py文件，在该文件下添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839from urllib.parse import urlencode, parse_qsfrom urllib.request import urlopenfrom itsdangerous import TimedJSONWebSignatureSerializer as Serializer, BadDatafrom django.conf import settingsimport jsonimport loggingfrom . import constantslogger = logging.getLogger('django')class OAuthQQ(object): """ QQ认证辅助工具类 """ # 初始化属性，接收四个参数，客户的appid，appkey，回调地址，初始跳转页面 def __init__(self, client_id=None, client_secret=None, redirect_uri=None, state=None): # or：代表if not ，如果接收到参数值，就是用接收的，如果接收none，就用配置的 self.client_id = client_id or settings.QQ_CLIENT_ID self.client_secret = client_secret or settings.QQ_CLIENT_SECRET self.redirect_uri = redirect_uri or settings.QQ_REDIRECT_URI self.state = state or settings.QQ_STATE # 用于保存登录成功后的跳转页面路径 # 定义生成url登录地址的函数，返回登录页面url的函数 def get_qq_login_url(self): """ 获取qq登录的网址 :return: url网址 """ params = &#123; 'response_type': 'code', 'client_id': self.client_id, 'redirect_uri': self.redirect_uri, 'state': self.state, 'scope': 'get_user_info', &#125; url = 'https://graph.qq.com/oauth2.0/authorize?' + urlencode(params) return url 补充技术点1：urllib1urllib.parse.urlencode(query) 将query字典转换为url路径中的查询字符串 1urllib.parse.parse_qs(qs) 将qs查询字符串格式数据转换为python的字典 1urllib.request.urlopen(url, data=None) 发送http请求，如果data为None，发送GET请求，如果data不为None，发送POST请求 返回response响应对象，可以通过read()读取响应体数据，需要注意读取出的响应体数据为bytes类型 创建第一个视图函数配置第一个视图函数的url：url(r’^qq/authorization/$’, views.QQAuthURLView.as_view())12345678910111213141516class QQAuthURLView(APIView): """ 获取QQ登录的url """ def get(self, request): """ 提供用于qq登录的url """ # 获取next的地址，即登陆成功后返回之前浏览的页面 next = request.query_params.get('next') # OAuthQQ是辅助工具的类，创建对象将next赋值给state初始状态的页面 oauth = OAuthQQ(state=next) # 调用辅助工具的get_qq_login_url函数得到url login_url = oauth.get_qq_login_url() # 返回URL地址 return Response(&#123;'login_url': login_url&#125;) 到此第一步完成，即返回用户的登录页面，接下里用户进行授权登录 第二个视图函数即用户登陆后，获取登录数据code，然后根据code，去获取accesstoken与openid代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class QQAuthUserView(APIView): """ QQ登录的用户 """ def get(self, request): """ 获取qq登录的用户数据 """ # 从请求地址的查询参数中获取code code = request.query_params.get('code') # 没有code抛出异常 if not code: return Response(&#123;'message': '缺少code'&#125;, status=status.HTTP_400_BAD_REQUEST) # 创建oauth对象，类来自定义的qq登录辅助工具 oauth = OAuthQQ() # 获取用户openid try: # 通过code获取token access_token = oauth.get_access_token(code) # 通过token获取openid openid = oauth.get_openid(access_token) # 没有获取到的话抛出异常 except QQAPIError: return Response(&#123;'message': 'QQ服务异常'&#125;, status=status.HTTP_503_SERVICE_UNAVAILABLE) # 判断用户是否存在 try: # 通过openid查询用户，创建的关联表里 qq_user = OAuthQQUser.objects.get(openid=openid) except OAuthQQUser.DoesNotExist: # 用户第一次使用QQ登录，显示绑定界面 token = oauth.generate_save_user_token(openid) return Response(&#123;'access_token': token&#125;) else: # 找到用户，认为登录成功， 生成jwt_token user = qq_user.user jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER payload = jwt_payload_handler(user) token = jwt_encode_handler(payload) # 响应返回 response = Response(&#123; 'token': token, 'user_id': user.id, 'username': user.username &#125;) return response QQ辅助工具中添加代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283def get_access_token(self, code): """ 获取access_token :param code: qq提供的code :return: access_token """ # 1.构造参数 params = &#123; 'grant_type': 'authorization_code', 'client_id': self.client_id, 'client_secret': self.client_secret, 'code': code, 'redirect_uri': self.redirect_uri &#125; # 2.发起http请求，请求qq服务器 url = 'https://graph.qq.com/oauth2.0/token?' + urlencode(params) response = urlopen(url) # 3.接收响应数据，解码 response_data = response.read().decode() # access_token=**&amp;expires_in=**&amp;refresh_token=** 转成python字典 data = parse_qs(response_data) # 4.从字典中获取token access_token = data.get('access_token', None) # 如果没有token，写日志抛出异常 if not access_token: logger.error('code=%s msg=%s' % (data.get('code'), data.get('msg'))) raise QQAPIError # 取出accesstoken的值的列表的第一个元素 return access_token[0] def get_openid(self, access_token): """ 获取用户的openid :param access_token: qq提供的access_token :return: open_id """ # 发起qq服务器请求 url = 'https://graph.qq.com/oauth2.0/me?access_token=' + access_token response = urlopen(url) # 返回数据二进制解码 response_data = response.read().decode() try: # 返回的数据 callback( &#123;"client_id":"YOUR_APPID","openid":"YOUR_OPENID"&#125; )\n;cogn # 将字符串转成字典 data = json.loads(response_data[10:-4]) except Exception: # 没获取到抛出异常 data = parse_qs(response_data) logger.error('code=%s msg=%s' % (data.get('code'), data.get('msg'))) raise QQAPIError # 从字典中获取数据 openid = data.get('openid', None) return openid # 将返回的openid通过itsdangerous加密，然后返回token，发送这个token @staticmethod def generate_save_user_token(openid): """ 生成保存用户数据的token :param openid: 用户的openid :return: token """ serializer = Serializer(settings.SECRET_KEY, expires_in=constants.SAVE_QQ_USER_TOKEN_EXPIRES) data = &#123;'openid': openid&#125; token = serializer.dumps(data) return token.decode() # 加载读取接收到的token，解密，获取openid @staticmethod def check_save_user_token(token): """ 检验保存用户数据的token :param token: token :return: openid or None """ serializer = Serializer(settings.SECRET_KEY, expires_in=constants.SAVE_QQ_USER_TOKEN_EXPIRES) try: data = serializer.loads(token) except BadData: return None else: return data.get('openid') 以上第二步完成，获取到openid，并对用户是否第一次登录，是否需要绑定进行了判断，如果用户是第一次登录，需要绑定，则转到绑定页面，执行第三步。 补充技术点2：itsdangerous官方文档：点这里itsdangerous是一种加密签名方式，可以通过秘钥加密，也可以通过秘钥解密确保自己的数据在返回时没有经过别人的篡改，保证数据传输的安全性安装：pip install itsdangerous使用：以时间戳为例 1234567891011121314151617from itsdangerous import TimedJSONWebSignatureSerializer as Serializerfrom django.conf import settings# serializer = Serializer(秘钥, 有效期秒)serializer = Serializer(settings.SECRET_KEY, 300)# serializer.dumps(数据), 返回bytes类型，加密数据token = serializer.dumps(&#123;'mobile': '18512345678'&#125;)token = token.decode()# 检验token# 验证失败，会抛出itsdangerous.BadData异常serializer = Serializer(settings.SECRET_KEY, 300)try:# 加载token数据，解密数据 data = serializer.loads(token)except BadData: return None 第三个视图函数视图代码如下：因为是绑定数据库增加数据，所以在第二个视图函数中继续定义post方法即可，不用单独创建视图类，该视图实现用户绑定的方法123456789101112def post(self,request): # 指定序列化器 serializer = OAuthQQUserSerializer(data=request.data) serializer.is_valid(raise_exception=True) user = serializer.save() response = Response(&#123; 'token': user.token, 'user_id': user.id, 'username': user.username &#125;) return response 定义序列器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class OAuthQQUserSerializer(serializers.ModelSerializer): """ 保存QQ用户序列化器 """ # 添加字段 sms_code = serializers.CharField(label='短信验证码', write_only=True) access_token = serializers.CharField(label='操作凭证', write_only=True) token = serializers.CharField(read_only=True) mobile = serializers.RegexField(label='手机号', regex=r'^1[3-9]\d&#123;9&#125;$') class Meta: model = User fields = ('mobile', 'password', 'sms_code', 'access_token', 'id', 'username', 'token') extra_kwargs = &#123; 'username': &#123; 'read_only': True &#125;, 'password': &#123; 'write_only': True, 'min_length': 8, 'max_length': 20, 'error_messages': &#123; 'min_length': '仅允许8-20个字符的密码', 'max_length': '仅允许8-20个字符的密码', &#125; &#125; &#125; # 验证 def validate(self, attrs): # 检验access_token，获取加密的token值 access_token = attrs['access_token'] # 解密 openid = OAuthQQ.check_save_user_token(access_token) if not openid: raise serializers.ValidationError('无效的access_token') attrs['openid'] = openid # 检验短信验证码 mobile = attrs['mobile'] sms_code = attrs['sms_code'] redis_conn = get_redis_connection('verify_code') real_sms_code = redis_conn.get('sms_code_%s' % mobile) if real_sms_code.decode() != sms_code: raise serializers.ValidationError('短信验证码错误') # 如果用户存在，检查用户密码 try: user = User.objects.get(mobile=mobile) except User.DoesNotExist: pass else: password = attrs['password'] if not user.check_password(password): raise serializers.ValidationError('密码错误') # attrs中添加user数据 attrs['user'] = user return attrs def create(self, validated_data): openid = validated_data['openid'] user = validated_data.get('user') mobile = validated_data['mobile'] password = validated_data['password'] # 获取user if not user: # 如果用户不存在，创建用户，绑定openid（创建了OAuthQQUser数据） user = User.objects.create_user(username=mobile, mobile=mobile, password=password) # 在用户与openid中的关联表中添加数据 OAuthQQUser.objects.create(user=user, openid=openid) # 签发jwt token jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER payload = jwt_payload_handler(user) token = jwt_encode_handler(payload) user.token = token return user 到此，可实现授权QQ第三方登录的功能]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>web,Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Celery的异步服务使用]]></title>
    <url>%2F2018%2F05%2F26%2F%E5%85%B3%E4%BA%8ECelery%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是Celery？Celery是一个专注于实时处理和任务调度的分布式任务队列。所谓任务就是消息，消息中的有效载荷中包含要执行任务需要的全部数据。 为什么使用Celery在开发应用中，我们难免会遇到耗时操作，或者需要添加一些定时任务，而服务器本身的框架对于多进程、线程等已经写好，这些附加工作就会被耗时处理，而使用Celery则可以很好的处理这些任务，相当于开了一个额外的进程来处理这些耗时任务，增强了执行效率。 应用场景 Web应用。当用户触发的一个操作需要较长时间才能执行完成时，可以把它作为任务交给Celery去异步执行，执行完再返回给用户。这段时间用户不需要等待，提高了用户体验与程序执行效率。 定时任务。生产环境经常会跑一些定时任务。假如你有上千台的服务器、上千种任务，定时任务的管理很困难，Celery可以帮助我们快速在不同的机器设定不同种任务。 同步完成的附加工作都可以异步完成。比如发送短信/邮件、推送消息、清理/设置缓存等。 Celery架构 Celery Beat：任务调度器，Beat进程会读取配置文件的内容，周期性地将配置中到期需要执行的任务发送给任务队列。Result Backend：任务处理完后保存状态信息和结果，以供查询。Celery默认已支持Redis、RabbitMQ、MongoDB、Django ORM、SQLAlchemy等方式，当然Redis应该是最佳选择。 例：对于django框架web开发中发送短信功能使用Celery优化为什么要进行优化因为发送短信是一个等待操作，用户那边也会设置一个60秒等待操作，为了提高用户体验，增强效率，采用Celery进行优化，设置异步任务，处理短信发送功能。 1.在mamange.py同目录下，新建工具包celery_tasks2.创建config.py 设置代理人，指定队列，这里连接redis第14个数据库 1broker_url='redis://‘设置的ip地址’/14' 3.创建main.py，创建Celery的对象 12345678910111213141516from celery import Celeryfrom . import configimport os#设置django的配置os.environ.setdefault("DJANGO_SETTINGS_MODULE", "项目的settings")# 创建对象app = Celery('任意字符串')# 加载配置app.config_from_object(config)# 初始化任务# 在指定的包中找tasks.py文件，在这个文件中找@app.task的函数app.autodiscover_tasks([ 'celery_tasks.sms',]) 4.新建sms工具包，在包中新建tasks.py文件，定义发送短信的函任务 123456from utils.ytx_sdk.sendSMS import CCPfrom celery_tasks.main import app# 发送短信任务@app.task(name='sms_send')def sms_send(mobile, sms_code, expires, template_id): CCP.sendTemplateSMS(mobile, sms_code, expires, template_id) 5.启动celery的工人 celery -A celery_tasks.main worker -l info 6.调用：sms_send.delay(参数)]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>web,Celery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现Django框架邮箱验证功能]]></title>
    <url>%2F2018%2F05%2F24%2F%E5%AE%9E%E7%8E%B0Django%E6%A1%86%E6%9E%B6%E9%82%AE%E7%AE%B1%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Django框架中，实现用户中心页面的设置邮箱功能，并根据用户设置的邮箱，发送验证邮箱，用户通过点击验证地址，完成邮箱验证。 用户表添加字段在用户的user表中添加字段，代表该用户使用的邮箱是否通过验证，true为通过验证，相反为false。1email_active = models.BooleanField(default=False, verbose_name='邮箱验证状态') 然后进行数据库迁移，完成字段创建。 保存用户邮箱，并发送验证邮箱用户根据页面输入框输入邮箱后，点击保存，将用户输入的邮箱验证，并保存到数据库user表中，然后根据这个地址，发送验证邮件。 定义序列化器继承自modelserializer12345678910111213141516171819202122class EmailSerializer(serializers.ModelSerializer): """ 邮箱序列化器 """ # 指定模型类，属性 class Meta: model = User fields = ('id', 'email') extra_kwargs = &#123; 'email': &#123; # 验证邮箱为必填字段 'required': True &#125; &#125; # 重写update方法，数据库修改该用户的邮箱 def update(self, instance, validated_data): # 从请求体中接收数据，后面向这个邮箱发送邮件 email = validated_data['email'] # instance要序列化的对象，即user，给email属性赋值 instance.email = validated_data['email'] # 提交 instance.save() 定义保存的视图类因为不是根据用户id来修改邮箱，而是根据当前登录的用户，所以不传pk，而是重写get_object方法，来获取当前登录的对象123456789class SaveEmail(UpdateAPIView): # 验证用户是否登陆，Drf提供的验证功能 permission_classes = [IsAuthenticated] # 指定序列化器 serializer_class = EmailSerializer # 因为不获取ｐｋ，所以保存的时候获取当前登陆用户的对象 def get_object(self): # 将对象存到ｒｅｑｕｅｓｔ里 return self.request.user 然后配置url即可。 生成验证地址保存用户输入的邮箱之后，向这个邮箱发送验证地址，首先需要生成验证地址。在user的models里添加方法，实现生成地址的功能，在拼接地址时要经过加密，导入jwt，使用jwt加密 123456789101112# 定义生成地址的方法 def generate_verify_email_url(self): """ 生成验证邮箱的url """ # 设置itsdangerous加密 serializer = TJWSSerializer(settings.SECRET_KEY, expires_in=constants.VERIFY_EMAIL_TOKEN_EXPIRES) data = &#123;'user_id': self.id, 'email': self.email&#125; token = serializer.dumps(data).decode() verify_url = 'http://www.meiduo.site:8080/success_verify_email.html?token=' + token # 返回生成的地址 return verify_url 然后在序列化器 EmailSerializer下的update方法下添加代码： 12# 生成验证链接，调用生成验证连接的函数 verify_url = instance.generate_verify_email_url() 接收生成后的url地址 向用户的邮箱发送验证地址发送邮箱，属于等待耗时操作，所以使用Celery异步服务（详情看：点这里）在celery_tasks下新建包email，在包里新建文件tasks.py,然后在main.py里添加&#39;celery_tasks.email&#39;,在tasks文件里添加任务代码如下： 12345678910111213141516171819from celery_tasks.main import appfrom django.core.mail import send_mailfrom django.conf import settings@app.task(name='send_verify_email')def send_verify_email(to_email, verify_url): """ 发送验证邮箱邮件 :param to_email: 收件人邮箱 :param verify_url: 验证链接 :return: None """ subject = "邮件标题（例：***邮箱验证）" html_message = '&lt;p&gt;尊敬的用户您好！&lt;/p&gt;' \ '&lt;p&gt;感谢您使用*****。&lt;/p&gt;' \ '&lt;p&gt;您的邮箱为：%s 。请点击此链接激活您的邮箱：&lt;/p&gt;' \ '&lt;p&gt;&lt;a href="%s"&gt;%s&lt;a&gt;&lt;/p&gt;' % (to_email, verify_url, verify_url) # Django自带的发送邮件功能 send_mail(subject, "", settings.EMAIL_FROM, [to_email], html_message=html_message) 然后在序列化器 EmailSerializer下的update方法下添加代码： 12345# 发送验证邮件，邮箱，与验证连接作为参数 # 使用celery异步服务发送验证，在tasks里面 send_verify_email.delay(email, verify_url) # 最后，经过保存，接收验证地址，发送地址等功能后，返回该对象 return instance 到此发送验证邮件完成 技术补充点：Django发送邮件首先注册一个专门用来发送邮件的邮箱163,126，qq等，然后在这些邮箱配置SMTP服务器（设置中开启，经过手机验证后会收到授权码的短信，然后填写授权码，开启。详情可百度） 然后在配置中添加代码： 123456789EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'EMAIL_HOST = 'smtp.163.com' # （163为例）EMAIL_PORT = 25#发送邮件的邮箱EMAIL_HOST_USER = '你的账号'#在邮箱中设置的客户端授权密码EMAIL_HOST_PASSWORD = '你的授权密码'#收件人看到的发件人EMAIL_FROM = '&lt;你的邮箱&gt;' 使用django发送邮件： 在django.core.mail模块提供了send_mail来发送邮件。 123456789在django.core.mail模块提供了send_mail来发送邮件。send_mail(subject, message, from_email, recipient_list,html_message=None)# 各个参数的含义 subject 邮件标题 message 普通邮件正文， 普通字符串 from_email 发件人 recipient_list 收件人列表 html_message 多媒体邮件正文，可以是html字符串可以呈现html页面 验证邮箱用户在邮箱收到验证邮件后，点击地址进行验证，验证成功返回用户中心页面。 设置解密因为生成的验证邮箱地址时带有itsdangerous加密的token的，所以要先解密，在user的models里添加解密方法，代码如下： 123456789101112131415161718192021222324# 设置解密方法 @staticmethod def check_verify_email_token(token): """ 检查验证邮件的token """ # 解密 serializer = TJWSSerializer(settings.SECRET_KEY, expires_in=constants.VERIFY_EMAIL_TOKEN_EXPIRES) try: data = serializer.loads(token) except BadData: return None else: # 解密之后，获取data里面的数据 email = data.get('email') user_id = data.get('user_id') try: # 根据数据，获取对象 user = User.objects.get(id=user_id, email=email) except User.DoesNotExist: return None else: # 返回对象 return user 然后新建constants.py常量文件，然后添加代码： 1VERIFY_EMAIL_TOKEN_EXPIRES=60*60*24 设置过期时间。 定义视图函数1234567891011121314151617181920class SendEmail(APIView): def get(self, request): # 获取token，由jwt签发的token，在查询参数里，获取查询参数 token = request.query_params.get('token') if not token: # 如果没有token，则返回信息，与状态码 return Response(&#123;'message': '缺少token'&#125;, status=status.HTTP_400_BAD_REQUEST) # 验证过程 # 取得token后验证token，解密，确定是否被更改 # 接收解密后返回的对象 user = User.check_verify_email_token(token) if user is None: return Response(&#123;'message': '链接信息无效'&#125;, status=status.HTTP_400_BAD_REQUEST) else: # 没被更改即验证成功 # 数据库在邮箱验证的通过字段添加信息 user.email_active = True # 提交保存 user.save() return Response(&#123;'message': 'OK'&#125;) 由前端代码收到这个return后，跳转回用户页面即可。]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>web,Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python连接Mysql]]></title>
    <url>%2F2018%2F05%2F07%2FPython%E8%BF%9E%E6%8E%A5Mysql%2F</url>
    <content type="text"><![CDATA[通过python操作mysql，面向对象的编程思想 导入包1from pymysql import * 面向对象封装init初始化方法创建连接，建立游标对象1234567class JD(object): def __init__(self): # 1创建链接对象 self.conn = connect(host='主机名', port=3306, database='数据库名', user='账户名', password='密码',charset='utf8') # 2 创建游标对象 self.cs = self.conn.cursor() del方法关闭游标，关闭连接 1234def __del__(self): # 5 关闭 self.cs.close() self.conn.close() sql语句执行方法123456def my_execute_sql(self,sql): """执行ｓｑｌ语句""" self.cs.execute(sql) # 4 获取数据 content = self.cs.fetchall() 写sql语句例：12345def show_all_goods(self): """显示所有的商品信息""" sql = "select * from goods;" self.my_execute_sql(sql) 运行12def run(self): self.show_all_goods()]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库,Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Mysql的视图与事务]]></title>
    <url>%2F2018%2F04%2F30%2F%E5%85%B3%E4%BA%8EMysql%E7%9A%84%E8%A7%86%E5%9B%BE%E3%80%81%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[视图简介视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。视图是存储在数据库中的查询的SQL 语句，它主要出于两种原因：安全原因， 视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。这个视图就像一个“窗口”，从中只能看到你想看的数据列。这意味着你可以在这个视图上使用SELECT 语句，而你看到的将是你在视图定义里给出的那些数据列。 特点1.视图能简化用户操作视图机制使用户可以将注意力集中在所关心地数据上。如果这些数据不是直接来自基本表，则可以通过定义视图，使数据库看起来结构简单、清晰，并且可以简化用户的的数据查询操作。2.使用户能以多种角度看待同一数据视图机制能使不同的用户以不同的方式看待同一数据，当许多不同种类的用户共享同一个数据库时，这种灵活性是非常必要的。3.视图对重构数据库提供了一定程度的逻辑独立性数据的物理独立性是指用户的应用程序不依赖于数据库的物理结构。数据的逻辑独立性是指当数据库重构造时，如增加新的关系或对原有的关系增加新的字段，用户的应用程序不会受影响。层次数据库和网状数据库一般能较好地支持数据的物理独立性，而对于逻辑独立性则不能完全的支持。在关许数据库中，数据库的重构造往往是不可避免的。重构数据库最常见的是将一个基本表“垂直”地分成多个基本表。如果使用视图，应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。当然，视图只能在一定程度上提供数据的逻辑独立，比如由于视图的更新是有条件的，因此应用程序中修改数据的语句可能仍会因为基本表构造的改变而改变。4.视图能够对机密数据提供安全保护有了视图机制，就可以在设计数据库应用系统时，对不同的用户定义不同的视图，使机密数据不出现在不应该看到这些数据的用户视图上。这样视图机制就自动提供了对机密数据的安全保护功能。 创建视图1create view v-表名 as 查询语句 删除视图1drop view v-表名； 事务什么是事务所谓事务,它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。 四大特性（ACID）原子性（A）一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性 一致性（C）数据库总是从一个一致性的状态转换到另一个一致性的状态。事务不提交是不会修改数据的。 隔离性（I）通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。 持久性（D）一旦事务提交，则其所做的修改会永久保存到数据库。 事务命令表的引擎类型必须是innodb类型才可以使用事务，这是mysql表的默认引擎。 开启事务123begin;或者start transaction; 提交事务1commit; 回滚事务1rollback; 注意：修改数据的命令会自动的触发事务，包括insert、update、delete而在SQL语句中有手动开启事务的原因是：可以进行多次数据的修改，如果成功一起成功，否则一起会滚到之前的数据。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库,Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django视图使用说明]]></title>
    <url>%2F2018%2F04%2F25%2FDjango%E8%A7%86%E5%9B%BE%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[两个基类APIViewAPIView是django rest_framework提供的所有视图的基类，继承自django的view父类。导入： 1rest_framework.views.APIView APIView相对于View封装了drf的request对象，response对象，异常捕获功能以及身份认证，权限检查，流量控制等功能。 提供的属性：authentication_classes 列表或元祖，身份认证类permissoin_classes 列表或元祖，权限检查类throttle_classes 列表或元祖，流量控制类 经常以常规类视图的定义方法来实现get，post等请求方式。所以在业务逻辑的视图选择时，如果功能上不包含对数据库的操作（增删改查），不包含序列化器，则继承APIView，直接定义请求方式方法即可。 GenericAPIView继承自APIVIew，增加了对于列表视图和详情视图可能用到的通用支持方法。通常使用时，可搭配一个或多个Mixin扩展类。导入： 1rest_framework.generics.GenericAPIView 支持定义的属性： 1.列表视图与详情视图通用：queryset 列表视图的查询集serializer_class 视图使用的序列化器2.列表视图使用：pagination_class 分页控制类filter_backends 过滤控制后端3.详情页视图使用：lookup_field 查询单一数据库对象时使用的条件字段，默认为’pk’lookup_url_kwarg 查询单一数据时URL中的参数关键字名称，默认与look_field相同 提供的方法：列表视图与详情视图通用：1.get_queryset(self)返回视图使用的查询集，是列表视图与详情视图获取数据的基础，默认返回queryset属性，可以重写，例： 12345678910def get_queryset(self): """ 提供数据集 """ if self.action == 'list': # 如果是list方法，则反回省的查询结果，返回省的列表即parent为none的 return Area.objects.filter(parent=None) else: # 不是list则是retrieve,返回所有 return Area.objects.all() 可以添加判断，根据不同请求返回指定不同的查询集。2.get_serializer_class(self) 返回序列化器类，默认返回serializer_class，可以重写，例如： 12345678910def get_serializer_class(self): """ 提供序列化器 """ if self.action == 'list': # 是list，返回省的序列化器 return AreaSerializer else: # 不是list，返回区县的序列化器 return SubAreaSerializer 3.get_serializer(self, args, *kwargs) 返回序列化器对象，被其他视图或扩展类使用，如果我们在视图中想要获取序列化器对象，可以直接调用此方法。 注意，在提供序列化器对象的时候，REST framework会向对象的context属性补充三个数据：request、format、view，这三个数据对象可以在定义序列化器时使用。详情视图使用：get_object(self) 返回详情视图所需的模型类数据对象，默认使用lookup_field参数来过滤queryset。 在试图中可以调用该方法获取详情信息的模型类对象。 若详情访问的模型类对象不存在，会返回404。 该方法会默认使用APIView提供的check_object_permissions方法检查当前对象是否有权限被访问。 五个扩展类 ListModelMixin列表视图扩展类，用于查询数据库多个对象，会对list的数据进行过滤和分页，成功返回200 CreateModelMixin创建视图扩展类，用于增加数据库信息，成功返回201 RetrieveModelMixin详情视图扩展类，用于单一对象的查询，成功返回200 UpdateModelMixin更新视图扩展类，用于修改数据库信息，局部更新（partial_update方法），成功返回200 DestroyModelMixin删除视图扩展类，用于删除数据库信息（一般都是逻辑删除），成功返回204 可用子类（组合类） 1） CreateAPIView 提供 post 方法 继承自： GenericAPIView、CreateModelMixin 2）ListAPIView 提供 get 方法 继承自：GenericAPIView、ListModelMixin 3）RetireveAPIView 提供 get 方法 继承自: GenericAPIView、RetrieveModelMixin 4）DestoryAPIView 提供 delete 方法 继承自：GenericAPIView、DestoryModelMixin 5）UpdateAPIView 提供 put 和 patch 方法 继承自：GenericAPIView、UpdateModelMixin 6）RetrieveUpdateAPIView 提供 get、put、patch方法 继承自： GenericAPIView、RetrieveModelMixin、UpdateModelMixin 7）RetrieveUpdateDestoryAPIView 提供 get、put、patch、delete方法 继承自：GenericAPIView、RetrieveModelMixin、UpdateModelMixin、DestoryModelMixin 视图集ViewSet相对于前面的视图类，进一步封装list() 提供一组数据retrieve() 提供单个数据create() 创建数据update() 保存数据destory() 删除数据ViewSet视图集类不再实现get()、post()等方法，而是实现动作 action 如 list() 、create() 等，这些动作与请求方式对应。如果url中使用as_View方法，要把action与请求方式对应。 1url(r'路由规则', ViewSet.as_view(&#123;'get':'list'&#125;), action属性可以使用self.action获取当前请求视图的action动作，例如： 12345def get_serializer_class(self): if self.action == 'create': return OrderCommitSerializer else: return OrderDataSerializer 可以根据请求动作的不同进行if判断，来指定不同的序列化器与查询集 常用视图集父类1） ViewSet 继承自APIView，作用也与APIView基本类似，提供了身份认证、权限校验、流量管理等。 在ViewSet中，没有提供任何动作action方法，需要我们自己实现action方法。 2）GenericViewSet 继承自GenericAPIView，作用也与GenericAPIVIew类似，提供了get_object、get_queryset等方法便于列表视图与详情信息视图的开发。 3）ModelViewSet 继承自GenericAPIVIew，同时包括了ListModelMixin、RetrieveModelMixin、CreateModelMixin、UpdateModelMixin、DestoryModelMixin。 4）ReadOnlyModelViewSet 继承自GenericAPIVIew，同时包括了ListModelMixin、RetrieveModelMixin。 视图定义中附加action动作添加自定义动作需要使用装饰器 1rest_framework.decorators.action 该装饰器可以接收两个参数methods: 该action支持的请求方式，列表传递detail: 表示是action中要处理的是否是视图资源的对象（即是否通过url路径获取主键）True 表示使用通过URL获取的主键对应的数据对象False 表示不使用URL获取主键 路由routers在视图集中，可以使用routers快速实现路由信息的配置。首先在urls.py中导入routers 1from rest_framework import routers 然后创建router对象 12router = routers.SimpleRouter()router = routers.DefaultRouter() DefaultRouter与SimpleRouter的区别是，DefaultRouter会多附带一个默认的API根视图，返回一个包含所有列表视图的超链接响应数据。接下来注册router 1router.register(r'路由', 视图集, base_name='路由名称前缀') 上述代码会形成的路由如下： 12^路由/$ name: 前缀-list^路由/&#123;pk&#125;/$ name: 前缀-detail 然后添加路由数据： 1234urlpatterns = [ ...]urlpatterns += router.urls 如果视图中附加了action动作，则形成的路由： 12^路由/方法名/$ name: 前缀-方法名^路由/&#123;pk&#125;/方法名/$ name: 前缀-方法名]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>web,Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置缓存]]></title>
    <url>%2F2018%2F04%2F20%2FDjango%E5%BA%94%E7%94%A8%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[Django配置缓存在Django REST framework中使用缓存，可以通过drf-extensions扩展来实现。使用文档点这里 安装1pip install drf-extensions 使用方法直接添加装饰器首先导入工具 1from rest_framework_extensions.cache.decorators import cache_response 即在视图类里面的方法前添加装饰器 1234class CityView(views.APIView): @cache_response() def get(self, request, *args, **kwargs): ... cache_response可以添加两个参数 1@cache_response(timeout=60*60, cache='default') timeout : 缓存的过期时间cache=’default’ ：django的缓存后端，即在settings中的cache配置 如果不写参数，则使用默认值，默认值在配置中添加代码： 1234567# DRF扩展REST_FRAMEWORK_EXTENSIONS = &#123; # 缓存时间 'DEFAULT_CACHE_RESPONSE_TIMEOUT': 60 * 60, # 缓存存储 'DEFAULT_USE_CACHE': 'default',&#125; 使用扩展类继承除了直接添加装饰器的方法，也可以使用drf-extensions提供的扩展类 drf-extensions提供了三种扩展类导入工具： 1rest_framework_extensions.cache.mixins 三个扩展类都在里面。 1.ListCacheResponseMixin 用于缓存列表数据类的视图，配合ListModelMixin扩展类使用 RetrieveCacheResponseMixin用于缓存返回单一数据的视图，与RetrieveModelMixin扩展类配合使用 CacheResponseMixin为视图集同时补充List和Retrieve两种缓存，与ListModelMixin和RetrieveModelMixin一起配合使用。 使用方法直接视图类继承即可。在settings中添加配置，即可设置过期时间与cache 1234567# DRF扩展REST_FRAMEWORK_EXTENSIONS = &#123; # 缓存时间 'DEFAULT_CACHE_RESPONSE_TIMEOUT': 60 * 60, # 缓存存储 'DEFAULT_USE_CACHE': 'default',&#125; Flask配置缓存]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql的常用命令]]></title>
    <url>%2F2018%2F04%2F03%2FMysql%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Mysql两种引擎的区别Innodb引擎Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。 MyIASM引擎MyIASM引擎没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。 主要区别1、MyIASM是非事务安全的，而InnoDB是事务安全的 2、MyIASM锁的粒度是表级的，而InnoDB支持行级锁 3、MyIASM支持全文类型索引，而InnoDB不支持全文索引 4、MyIASM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyIASM 5、MyIASM表保存成文件形式，跨平台使用更加方便 应用场景1、MyIASM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyIASM2、InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB 常用命令常用数据类型1.整数：int2.小数：decinal（总位数，小数位数）3.字符串：varchar（可变长度），char（固定长度）4.日期时间：datetime5.枚举类型：（enum）‘选择’ 数据库操作连接数据库1mysql -uroot -p 退出1quit/exit 查看版本1select version()； 显示时间1select now()； 查看当前使用数据库1select datebase（）； 查看所有数据库1select databases(); 创建数据库1create database 数据库名； 查看字符集1show create database 数据库名； 删除数据库1drop database 数据库名； 使用数据库1use 数据库名； 数据库备份1mysql dump -uroot -p 数据库名 &gt; 文件名.sql 数据库恢复1mysql dump -uroot -p 数据库名 &lt; 文件名.sql 导入数据1source 文件名.sql 数据表的操作查看所有表1show tables; 创建表1create table 表名(id int unsigned...) 查看表结构1desc 表名 查看字符集1show create table 表名; 添加字段1alter table 表名 add 字段名 数据类型; 修改字段12alter table 表名 modify 字段名 约束;alter table 表名 change 原名 新名 约束； 删除字段1alter table 表名 drop 字段名; 删除表1drop table 表名; 数据的操作插入数据1insert into 表名 values (),(); # 数据，()按字段位置写入(),()是多行插入 部分插入1insert into 表名（字段名） values (); 修改数据1update 表名 set 字段名=‘’ where 条件； 删除数据1delete from 表名 where 条件； 查询数据库查看表1select * from 表名 查看字段数据，起名1select 表名.字段名 as '别名' from 表名 去重复12select distinct 字段 from 表名；select key from 表 group by key having count (*)&gt;1; 并不会修改数据。 条件查询12select * from 表名 where 字段名 &gt; &lt; &gt;= &lt;= != 或&lt;&gt;# 也可以在条件里加逻辑 and 、or、 not（条件）、 模糊查询123where like ‘小%’ # 以小字为开头的% 替换任意个_ 替换一个 范围查询123where 字段名 in （）；# 具体值not in（not）between and # 区间查询 判空1where 字段 is null （not null）； 排序1select * from 表名 order by 字段 asc；升序 （desc 降序）； 分组（按字段分组）1select 字段 from 表名 group by 字段； 各个小组数据1select count（*）.字段一 【group_concat(字段二)】.字段一 from 表名 group by 字段一 having 条件； 按这个字段一分组，该组的统计，该组的字段二数据注意： 这里的条件用having 不用where 分页1select * from 表名 limit 0,5；# 第一个参数从第几页开始（显示个数*（第几页-1）），第二个参数显示数量 分页是为了限制查询，防止数据过大，limit放最后 聚合函数统计个数1select count（*） from 表名 where 条件； 最大值1select max（字段）from 表名； 最小值1select min（字段）from 表名； 求和1select sum（字段） from 表名； 平均1select round（avg（字段）） from 表名；# 保留小数 关联查询关联查询1select * from 表一 inner join 表二 on 表一.字段=表二.字段； 将表一的字段按表二的字段对应，合成一个表查询后面的表是大表 子查询1select * from表 where 字段 &gt; (上一个表的查询结果)； 自关联1select * from 表名 as 别名一 inner join 表名 as 别名二 on 别名一.字段 =别名二.字段 外键关联1alter table 表一 addforeignkey（字段） references 表二（字段）； 拆表已知表一 创建表二1create table if not exists （字段属性） if not exists 如果不存在 将表一的数据分组1select 字段from 表一 group by 字段 插入新表二1insert into 表二（字段） （第二步查询语句） 用子查询 连接两个表，更新表一字段为表二的连接字段1update（select * from 表一 inner join 表二 on 表二.字段 = 表一.字段） set 表一.字段= 表二.字段]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库,Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于session与JWT的认证机制]]></title>
    <url>%2F2018%2F03%2F21%2F%E5%85%B3%E4%BA%8Esession%E4%B8%8EJWT%E7%9A%84%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[什么是状态保持说到状态保持，首先要讲一下什么是无状态，http 就是一种无状态协议，浏览器请求服务器是无状态的。 无状态指用户请求过一次后，浏览器与服务器无法知道这个用户做过什么，下一次请求还是新的请求。发生无状态的原因：浏览器与服务器之间是使用socket套接字通讯的，在一次访问结束后，服务器将访问结果返回给浏览器之后，会关闭当前的socket连接，浏览器在关闭后，服务器也会销毁当前的页面对象。 无状态协议1.协议对于事务处理没有记忆能力。2.对同一个 url 请求没有上下文关系。3.每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的4请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况。4.服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器。 有状态与无状态相反，相当于有记忆能力，可以记录之前用户的操作，即状态保持，那怎么实现状态保持呢？ CookieCookie的定义指某些网站为了辨别用户身份、进行会话跟踪而储存在用户本地的数据。（通常经过加密）cookie由服务器端生成，发送给客户端浏览器，浏览器可以将cookie的key/value进行保存，下次请求同一网站时就会将cookie同请求信息发送给服务器。通过cookie就实现了状态保持，即用户登陆过的信息，访问过的页面数据，都会被放在cookie里进行记录，保存在浏览器，下次请求这个网站时会发送给服务器，服务器就能从cookie中快速获取信息，即知道了用户已经登陆过，访问了哪些数据，保持了用户的登录状态，将相关数据快速呈现。 使用cookie的注意事项 cookie是基于域名安全的，不同域名的cookie是不能互相访问的，即同源策略。（在这个页面里可以嵌入窗口iframe，来访问其他域名的cookie） Cookie是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用。 因为cookie被放在请求报文里发送给服务器，所以服务器端可以通过request对象来获取cookie信息，进行操作。 设置cookie与获取cookie设置cookie获取response对象 1response.set_cookie(‘键’，‘值’，max_age=3600） max_age为过期时间，即第一次访问产生cookie之后，3600秒会自动删除。 获取cookie请求对象request 1request.cookies.get('键') 根据之前设置的键就能获取到cookie的值。 Sessioncookie说到建议不要保存用户的敏感信息，很容易会被破解，那么这些敏感信息怎么解决，比如用户登录的用户名，密码，这就要用到session来认证用户。 理解session的机制对于敏感的信息，要保存在服务器中，不能存储在浏览器中，而服务器采用的状态保持的方案就是session认证。当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 session依赖于cookie客户端在访问后，由服务端生成session，根据每一个session都会生成它的唯一标识（uuid），然后以session为键，这个唯一标识为值，存放在cookie里。同时服务端本地也会存session（非关系型数据库存储，如redis），以uuid为键，session的键值对为值，存进服务端本地，访问时，根据这个唯一标识在本地进行读取操作。 url重写技术由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面，附加方式也有两种，一种是作为URL路径的附加信息，表现形式为http://...../xxx;jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764另一种是作为查询字符串附加在URL后面，表现形式为http://...../xxx?jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764这两种方式对于用户来说是没有区别的，只是服务器在解析的时候处理的方式不同，采用第一种方式也有利于把session id的信息和正常程序参数区分开来。为了在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个session id。 表单隐藏字段技术另一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如下面的表单： &lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;/form&gt; 在被传递给客户端之前将被改写成： &lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;jsessionid&quot; value=&quot;ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;/form&gt; 这种技术使用相对较少了。 session数据的读写读取session数据1session.get('键') 写入session数据1session['键'] = '值' JWTsession认证所显露的问题1.用户通过session认证，都要在服务器端做一次记录，而session是保存在服务器端的内存中，随着用户的增多，服务器端的开销会明显增大。2.而且用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。3.session是依赖于cookie，如果cookie被截获，很容易受到跨站请求伪造的攻击（csrf），安全性不足。这就引入了jwt认证机制 什么是JWTJWT，全名Json Web Token，是一种基于token的认证机制，类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。流程上是这样的： 用户使用用户名密码来请求服务器 服务器进行验证用户的信息 服务器通过验证发送给用户一个token 客户端存储token，并在每次请求时附送上这个token值 服务端验证token值，并返回数据 JWT的构成例：1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 如上所示，是一个JWT的token，分为三个部分 header头部第一部分header存两部分信息1234&#123; 'typ': 'JWT', # 声明类型为jwt 'alg': 'HS256' # 加密算法 HMAC SHA256&#125; 通过base64算法加密构成第一部分，eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 payload载荷载荷是存放有效信息的地方，有效信息分为三部分： 标准中注册的声明：iss: jwt签发者sub: jwt所面向的用户aud: 接收jwt的一方exp: jwt的过期时间，这个过期时间必须要大于签发时间nbf: 定义在什么时间之前，该jwt都是不可用的.iat: jwt的签发时间jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 公共的声明：添加用户信息，不建议添加敏感信息，因为base64算法是对称算法，可解密 私有的声明：私有声明是提供者和消费者所共同定义的声明。定义一个payload 12345&#123; "sub": "1234567890", "name": "John Doe", "admin": true&#125; base64算法加密后就是第二段eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 signaturejwt的第三部分是一个签证信息，签证信息由三部分组成：headerpayloadsecret这部分信息将header、payload中的base64加密后的信息连接成字符串，然后通过header里声明的HS256算法加上secret进行加密，就构成了jwt的第三部分。 123var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);var signature = HMACSHA256(encodedString, 'secret'); 构成第三部分TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ三部分构成完整的JWT的token PS：secret是保存在服务端的，jwt签发也是在服务端，所以secret是服务端的私钥，不能泄露出去。虽然header和payload可以通过base64解密，但是没有secret是无法进行认证的，这就保证了安全性。 JWT的应用Django rest framework中应用jwt详情可参考文档网站：JWT官方文档 安装jwt应用1pip install djangorestframework-jwt 配置设置指定jwt认证1234567891011REST_FRAMEWORK = &#123; 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework_jwt.authentication.JSONWebTokenAuthentication', 'rest_framework.authentication.SessionAuthentication', 'rest_framework.authentication.BasicAuthentication', ),&#125;JWT_AUTH = &#123; 'JWT_EXPIRATION_DELTA': datetime.timedelta(days=1),&#125; JWT_EXPIRATION_DELTA指明jwt的有效期 使用jwt返回token生成口令并返回1234567from rest_framework_jwt.settings import api_settingsjwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLERjwt_encode_handler = api_settings.JWT_ENCODE_HANDLERpayload = jwt_payload_handler(user)token = jwt_encode_handler(payload) 比如注册中使用token，因为token要返回输出，所以在定义序列化器时要添加token字段 1token = serializers.CharField(label='登录状态token', read_only=True) # 增加token字段 登录功能中使用JWT返回指定字段将上面的jwt应用于登录认证时，登录成功后，发现api接口只返回了jwt的token，如图所示 如果想将用户的其他字段比如用户名，怎么返回呢jwt配合django的内部框架提供了登录验证功能，在Django框架中直接使用jwt的登录验证视图函数obtain_jwt_token 12from rest_framework_jwt.views import obtain_jwt_token # 导入包url(r'^路由规则$', obtain_jwt_token), # url中配置地址 定义以上路由地址即可，jwt自带的登录验证便可应用jwt提供的视图obtain_jwt_token内部逻辑： 1.定义视图类，继承自APIView 2.定义序列化器，继承自Serializer，然后调用django内部贡献的authenticate()方法 3.接收用户名、密码 4.查询数据库，进行密码对比 5.如果成功，则生成口令并返回这是查看obtain_jwt_token的源码，和jwt的官方文档，就可以理解这个视图的工作原理。 然后自定义接口响应值：1.在users应用下新建utils.py。2.创建函数 12345def jwt_response_payload_handler(token, user=None, request=None): return &#123; 'token': token, 'username':user.username &#125; 3.在settings.py中配置添加 ‘JWT_RESPONSE_PAYLOAD_HANDLER’:’users.utils.jwt_response_payload_handler’, 然后重新运行即可，效果如下 jwt的优点1.因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。2.因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。3.便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。4.它不需要在服务端保存会话信息, 所以它易于应用的扩展]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>web,状态保持</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库设计规范与原则]]></title>
    <url>%2F2018%2F03%2F20%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E4%B8%8E%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[MYSQL数据库设计规范1、数据库命名规范采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’_’组成;命名简洁明确(长度不能超过30个字符);例如:user, stat, log, 也可以wifi_user, wifi_stat, wifi_log给数据库加个前缀;除非是备份数据库可以加0-9的自然数:user_db_20151210; 2、数据库表名命名规范采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’‘组成;命名简洁明确,多个单词用下划线’‘分隔;例如:user_login, user_profile, user_detail, user_role, user_role_relation,user_role_right, user_role_right_relation表前缀’user_’可以有效的把相同关系的表显示在一起; 3、数据库表字段名命名规范采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’‘组成;命名简洁明确,多个单词用下划线’‘分隔;例如:user_login表字段 user_id, user_name, pass_word, eamil, tickit, status, mobile, add_time;每个表中必须有自增主键,add_time(默认系统时间)表与表之间的相关联字段名称要求尽可能的相同; 4、数据库表字段类型规范用尽量少的存储空间来存数一个字段的数据;例如:能使用int就不要使用varchar、char,能用varchar(16)就不要使用varchar(256);IP地址最好使用int类型;固定长度的类型最好使用char,例如:邮编;能使用tinyint就不要使用smallint,int;最好给每个字段一个默认值,最好不能为null; 5、数据库表索引规范命名简洁明确,例如:user_login表user_name字段的索引应为user_name_index唯一索引;为每个表创建一个主键索引;为每个表创建合理的索引;建立复合索引请慎重; 6、简单熟悉数据库范式第一范式(1NF):字段值具有原子性,不能再分(所有关系型数据库系统都满足第一范式);例如:姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;第二范式(2NF):一个表必须有主键,即每行数据都能被唯一的区分;备注:必须先满足第一范式;第三范式(3NF):一个表中不能包涵其他相关表中非关键字段的信息,即数据表不能有沉余字段;备注:必须先满足第二范式;备注:往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询;例如:相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段; MYSQL数据库设计原则1、核心原则不在数据库做运算;cpu计算务必移至业务层;控制列数量(字段少而精,字段数建议在20以内);平衡范式与冗余(效率优先;往往牺牲范式)拒绝3B(拒绝大sql语句:big sql、拒绝大事物:big transaction、拒绝大批量:big batch); 2、字段类原则用好数值类型(用合适的字段类型节约空间);字符转化为数字(能转化的最好转化,同样节约空间、提高查询性能);避免使用NULL字段(NULL字段很难查询优化、NULL字段的索引需要额外空间、NULL字段的复合索引无效);少用text类型(尽量使用varchar代替text字段); 3、索引类原则合理使用索引(改善查询,减慢更新,索引一定不是越多越好);字符字段必须建前缀索引;不在索引做列运算;innodb主键推荐使用自增列(主键建立聚簇索引,主键不应该被修改,字符串不应该做主键)(理解Innodb的索引保存结构就知道了);不用外键(由程序保证约束); 4、sql类原则sql语句尽可能简单(一条sql只能在一个cpu运算,大语句拆小语句,减少锁时间,一条大sql可以堵死整个库);简单的事务;避免使用trig/func(触发器、函数不用客户端程序取而代之);不用select (消耗cpu,io,内存,带宽,这种程序不具有扩展性);OR改写为IN(or的效率是n级别);OR改写为UNION(mysql的索引合并很弱智);select id from t where phone = ’159′ or name = ‘john’;=&gt;select id from t where phone=’159′unionselect id from t where name=’jonh’慎用count();limit高效分页(limit越大,效率越低);使用union all替代union(union有去重开销);少用连接join;使用group by;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库,Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表格模型类字段属性]]></title>
    <url>%2F2018%2F03%2F17%2F%E6%A8%A1%E5%9E%8B%E7%B1%BB%E5%AD%97%E6%AE%B5%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Django创建模型类，表格字段属性导入models123# django要导入modelsfrom django.db import models# 创建模型类要继承models.Mode Django自带一个user模型类，创建user模型类的时候可以继承django的 12from django.contrib.auth.models import AbstractUserclass User(AbstractUser): 之后就可以在这个类下面自定添加新的字段属性。 创建模型类在models.py文件中，编写如下代码：例： 123456789101112131415class 类名(models.Model): 字段一 = models.CharField(max_length=20, verbose_name='名称') 日期 = models.DateField(verbose_name='日期') 数字类型= models.IntegerField(default=0, verbose_name='整型') is_delete = models.BooleanField(default=False, verbose_name='逻辑删除') class Meta: db_table = '表名' # 指明数据库表名 verbose_name = '名称' # 在admin站点中显示的名称 verbose_name_plural = verbose_name # 显示的复数名称 def __str__(self): """定义每个数据对象的显示信息""" return self.字段一 如示例所示即可创建一个模型类 字段属性1） 数据库表名 模型类如果未指明表名，Django默认以 小写app应用名_小写模型类名 为数据库表名。 可通过db_table 指明数据库表名。 2） 关于主键 django会为表创建自动增长的主键列，每个模型只能有一个主键列，如果使用选项设置某属性为主键列后django不会再创建自动增长的主键列。 默认创建的主键列属性为id，可以使用pk代替，pk全拼为primary key。 3） 属性命名限制 不能是python的保留关键字。不允许使用连续的下划线，这是由django的查询方式决定的。定义属性时需要指定字段类型，通过字段类型的参数指定选项，语法如下： 属性=models.字段类型(选项) 4） 外键 在设置外键时，需要通过on_delete选项指明主表删除数据时，对于外键引用表数据如何处理，在django.db.models中包含了可选常量： CASCADE 级联，删除主表数据时连通一起删除外键表中数据 PROTECT 保护，通过抛出ProtectedError异常，来阻止删除主表中被外键应用的数据 SET_NULL 设置为NULL，仅在该字段null=True允许为null时可用 SET_DEFAULT 设置为默认值，仅在该字段设置了默认值时可用 SET() 设置为特定值或者调用特定方法，如 123456789101112from django.conf import settingsfrom django.contrib.auth import get_user_modelfrom django.db import modelsdef get_sentinel_user(): return get_user_model().objects.get_or_create(username='deleted')[0]class MyModel(models.Model): user = models.ForeignKey( settings.AUTH_USER_MODEL, on_delete=models.SET(get_sentinel_user), ) DO_NOTHING 不做任何操作，如果数据库前置指明级联性，此选项会抛出IntegrityError异常。 5） 字段类型6） 选项 Flask创建模型类，表格字段属性数据库连接连接数据库需要安装pymysql和flask-sqlalchemy 12pip install Flask-MySQLdb==0.2.0pip install Flask-SQLAlchemy==2.3.2 然后进行设置，数据库使用url指定 1app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://root:mysql@localhost:3306/数据库名' 然后在mysql创建你要连接的数据库其他配置 定义模型类定义模型类12345class 类名(db.Model): 属性1=db.Column(类型,约束) 属性2=db.Column(类型,约束) 属性3=db.Column(类型,约束) ... 创建表 1db.create_all() 字段属性和选项常用的SQLAlchemy字段类型常用的SQLAlchemy列选项常用的SQLAlchemy关系选项 SKU与SPUSPU = Standard Product Unit （标准产品单位） SPU是商品信息聚合的最小单位，是一组可服用、易检索的标准化信息的集合，该集合描述了一个产品的特性。 个人理解，属性值特性类似相同，可归为一起的商品类就是spu SKU = Stock Keeping Unit （库存量单位） SKU即库存进出计量的单位，可以是以件、盒、托盘等为单位，是物理上不可分割的最小存货单元。在使用时要根据不同业态，不同管理模式来处理。在服装、鞋类商品中使用最多最普遍。 个人理解，有具体属性值，具体规格的商品就是sku]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>web,表格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Linux的常用基本命令（二）]]></title>
    <url>%2F2018%2F01%2F24%2F%E5%85%B3%E4%BA%8ELinux%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[接上面《关于Linux的常用基本命令（一）》点这里#### 管道命令1【命令1】 | 【命令2】 # 命令1的输出结果作为命令2的输入#### 查找某个文件的文本1234grep 【选项】 “字符串” 【文件】选项：-i 忽略大小写 -n 显示匹配行及行号 -v 取反（显示余下的信息）例： ps -aux | grep ’mysql‘ 查看运行中的进程，带有mysql的进程 查找文件1234find 【路径】 【选项】选项：-name ’字符串‘ # 查找该文件名的文件 -size +（-）’大小‘ # 查找文件大于（小于）多少的文件 -permission 权限 # 查找拥有该权限的文件 tar打包压缩文件与解压缩12345678tar 【选项】【打包后的文件名】【 要打包的文件名】选项： -c 生成打包文件 -v 显示进度 -f 指定打包文件名称，所以f选项要放最后 -x 拆包解包 -z gzip格式压缩解压 -j bzip2格式压缩解压 c 指定目录 gzip格式压缩解压12gizp 【文件名】 # 压缩文件gzip -d 【文件名】 # 解压缩文件 查看命令位置1which 查看当前用户登录1who # tty 本地登录 pts 远程登录 授权当前用户执行命令1sudo # 管理员权限 退出终端，回到上一用户，退出远程1exit 软件卸载与安装123sudo apt-get install “安装包” # 安装sudo apt-get remove “安装包” # 删除sudo apt-get update “安装包” # 更新 关机重启12shutdown -h now （或加时间） # 立即关机，或者多少时间后关机 -r # 重启]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Linux终端的常用命令（一）]]></title>
    <url>%2F2018%2F01%2F15%2F%E5%85%B3%E4%BA%8ELinux%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux由Unix发展而来，于1991年林纳斯（linus）发布，分为内核与发行版，内核（kernel）是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，主要做一些基本的，也是重要的操作。比如进程管理、内存管理、磁盘管理、驱动管理、电源管理、安全管理等。Linux 内核版本又分为 稳定版 和 开发版，两种版本是相互关联，相互循环。稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些 bug 或加入一些新的驱动程序开发版：由于要试验各种解决方案，所以变化很快内核源码网址：点这里&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux发行版通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件。主要有：ubantu，centos，redhat, debian等，这里主要是ubantu的基本常用命令。### Linux终端命令基本使用———-终端命令格式：Command 【-options（选项，可以配合使用）】【parameter（对象）】 1. 查看文件信息（在当前路径下输入即可查看当前路径文件）123ls -l # 查看详情ls -a # 查看所有文件ls -h # 配合-l显示文件大小 2. 通配符，可以代替字符12* # 代表0个或多个任意字符？ # 代表任意一个字符 3. 清屏12clear按键：ctrl +L 4. 切换路径（分为相对路径和绝对路径，相对路径从当前目录开始；绝对路径从根目录（/）开始）12cd ./Desktop # .代表当前路径cd ../ # ..代表上一级路径 5. 显示当前绝对路径1pwd 6. 创建目录12mkdir 目录名mkdir a/b/c -p # 创建级联目录 7. 创建文件（文件名指定后缀名）12touch 文件名touch 文件1 文件2 文件3 # 创建多个文件 8. 删除文件，目录123rm -i # 删除文件给予交互提示rm -f # 强制删除rm -r # 递归删除，删除目录 9. 拷贝文件，目录12345cp 【源文件名】【目标目录路径】# 拷贝文件不能在本目录下，不能重名例： cp 1.txt ./a 将1.txt复制到当前目录的a目录下cp 【源文件名】【目标文件名】# 拷贝并重命名例： cp a.txt b.txt 复制a并命名为b选项： -r 拷贝文件夹 -f 强制拷贝 -i交互提示 10. 移动文件，文件夹12mv 【源文件名】【移动目标路径】# 移动目录不用-r 例：mv 1.txt ./a 将1文件移动到当前目录的a目录下mv 【源文件名】【移动后文件名】# 重命名，不能重名 例： mv a.py b.py 11. 树状显示目录1tree 12. 查看历史命令12history # 显示历史命令！数字 # 引用某一行命令 例：！20，引用20行命令 13. 查看，写入文件内容12cat 【文件名】 # 查看 例：cat 1.txtgedit 【文件名】# 写入 例 ： gedit 1.txt 14. 重定向（将命令执行结果保存到另一个文件中）123&gt; # 覆盖&gt;&gt; # 追加 例： cat 1.txt 2.txt &gt; 3,txt 将1,2两个文件的内容重定向到3里，3.txt不存在则创建 15. 分屏显示内容1more # 分屏显示文件内容，一般接到其他命令后，空格切换屏幕]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2018%2F01%2F13%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言 学习编程之后，逐渐在这一领域有了一定的了解，在CSDN博客上看各种大神写的文章，那些未知的技术，引起了我的求知欲，同时看着别人炫酷的博客，也让我有了一个搭建自己的博客网站的想法，来对自己学过的知识，进行总结梳理，于是开始了我的博客之旅。 1.搭建自己的博客网站需要耐心 对于我这种博客小白来说，搭建自己的个人博客，着实费了一番功夫，经过大约一周时间的研究学习，查阅各种资料，解决各种bug，尝试不同的主题效果，终于搭建好我自己的个人博客网站，可以开始写自己的第一篇博客文章，此刻我的心情是非常激动的，毕竟这大约一周时间的努力，取得了一定的成果，效果还比较满意，不过还要继续完善。 总的来说，过程非常繁琐，需要耐心，网上教程都很详细，一步步按照教程走即可，但是过程中有些细节需要综合自己的实际情况来定，不然会出一些难解决的bug，所以要懂一些js，css知识的原理。我用的是github+hexo搭建的，个人认为比较简单吧，也研究过ruby，jkelly那些方法，不过没安装上环境，就换了hexo，有兴趣的可以好好研究下。 2. IT知识研究领域 我主要学习的是Python，所以我的博客内容主要围绕着python来展开的，当然这只是一种编写程序的语言方式，所以本质上还是编程以及相关内容，比如Linux，web开发，框架，算法，爬虫，人工智能等，我个人对人工智能非常感兴趣，所以也会慢慢往这个方向去靠近，机器学习，神经网络等，自己慢慢研究学习吧。 3. 写博客文章的一些基本格式与上传命令 为了以后方便写博客，对于我这个博客小白，还是有必要在这里对于一些文章相关格式及命令，进行总结的。 通过github+hexo搭建好博客后，如何创建一篇新博客呢 在搭建博客的时候，会安装git软件，在根目录下打开git，通过git命令来执行，新建一篇博客：1$ hexo new "你的博客的名称" 然后在根目录文件夹下source/_posts下新生成一个md文件，名称就是你自己起的名字，打开就可以开始写博客啦，要用markdown语法写，所以要提前准备一款编辑器，我个人用的是小书匠编辑器，还不错。 文章的一些格式属性有以下几种可以自己设置：12345title: 文章标题date: 创建时间，这里可以随意修改categories: 文章分类目录，可以为空tags: 文章标签，可空，多标签请用格式[tag1,tag2,tag3]description: 对本页的描述，相当于是一个简介，如果这个定义了，就会在首页中出现这里的内容而不会出现整个文章详细内容。 然后下面就可以开始写文章了，写完即可通过git上传了 123$ hexo clean$ hexo g$ hexo d 即可部署到github上。 4.开启博客之旅 以前的学习笔记都记录在本子上，或者其他文档里，之后将会慢慢整理在自己的博客上，来完善自己的学习体系，同时搭建自己的博客，让自己的博客更炫酷。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>第一篇</tag>
      </tags>
  </entry>
</search>
