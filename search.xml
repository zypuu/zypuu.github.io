<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AVL树和红黑树</title>
    <url>/2021/03/26/AVL%E6%A0%91%E5%AE%9E%E7%8E%B0%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h3 id="AVL树（平衡二叉搜索树）"><a href="#AVL树（平衡二叉搜索树）" class="headerlink" title="AVL树（平衡二叉搜索树）"></a>AVL树（平衡二叉搜索树）</h3><p>基于作者名字命名</p>
<p>平衡因子： 某个结点的左子树的高度减去右子树的高度得到的差值</p>
<p>AVL树的特点：<br>1、左右子树的高度差的绝对值小于1，即平衡因子{-1,0,1}<br>2、其每一颗子树均为平衡二叉树</p>
<p>节点会储存额外的信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type AVLTreeNode struct &#123;</span><br><span class="line">    value int</span><br><span class="line">    high  int</span><br><span class="line">    left  *AVLTreeNode</span><br><span class="line">    right *AVLTreeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AVL树具有监督机制：树的某一部分的不平衡度超过平衡因子后触发相应的平衡操作。保证树的平衡度在平衡因子范围内</p>
<p>通过左旋、右旋操作，分为四种情况</p>
<p>单次左右旋， 注意旋转的与被旋转的节点更换</p>
<p><img src="/2021/03/26/AVL%E6%A0%91%E5%AE%9E%E7%8E%B0%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91/1.png" alt="1"></p>
<p>双次旋转</p>
<p><img src="/2021/03/26/AVL%E6%A0%91%E5%AE%9E%E7%8E%B0%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91/2.png" alt="2"></p>
<p>case2情况下，需要先对y结点进行一次左旋转，然后再对z结点进行一次右旋转<br>case3情况下，需要先对y结点进行一次右旋转，然后再对z结点进行一次左旋转</p>
<p>实现AVL树</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树节点</span></span><br><span class="line">type AVLTreeNode struct &#123;</span><br><span class="line">    value int   <span class="comment">// 节点值</span></span><br><span class="line">    high  int   <span class="comment">// 节点高度，最底层新插入的高度是0</span></span><br><span class="line">    left  *AVLTreeNode</span><br><span class="line">    right *AVLTreeNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化一个AVL树</span></span><br><span class="line">func NewAVLTreeRoot(root int) *AVLTreeNode &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;AVLTreeNode&#123;root, <span class="number">0</span>, nil, nil&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line">func (<span class="built_in">this</span> *AVLTreeNode) InsertNode(v int) *AVLTreeNode &#123;</span><br><span class="line">    <span class="comment">// 到叶子节点为nil时，插入v的值，递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">this</span> == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;AVLTreeNode&#123;v, <span class="number">0</span>, nil, nil&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// v小于当前节点的value，左子树往下</span></span><br><span class="line">    <span class="keyword">if</span> v &lt; <span class="built_in">this</span>.value &#123;</span><br><span class="line">        <span class="comment">// 左节点往下插入。开始递归，最终得到要插入的节点，就是this.left</span></span><br><span class="line">        <span class="comment">// 到最底层，此时的this是插入后的新节点的父节点，开始向上递归平衡</span></span><br><span class="line">        <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.InsertNode(v)</span><br><span class="line">        <span class="comment">// 开始回溯时，从倒数第二层开始向上，更新新节点的父节点得到的高度</span></span><br><span class="line">        <span class="built_in">this</span>.high = getMax(<span class="built_in">this</span>.left.getNodeHigh(), <span class="built_in">this</span>.right.getNodeHigh()) + <span class="number">1</span></span><br><span class="line">        <span class="comment">// 检查高度差，高度差为2则复发平衡，触发第一次回溯时候就是新插入的节点的父父节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">this</span>.left.getNodeHigh()-<span class="built_in">this</span>.right.getNodeHigh() == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="comment">// 如果要插入的值小于当前节点左节点的值，则右旋，否则 左右旋</span></span><br><span class="line">            <span class="keyword">if</span> v &lt; <span class="built_in">this</span>.left.value &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.rightRotation()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.leftRightRotation()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 与上面相反，插入的时候左右交替比较插入，回溯的时候也是左右交替回溯</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = <span class="built_in">this</span>.right.InsertNode(v)</span><br><span class="line">        <span class="built_in">this</span>.high = getMax(<span class="built_in">this</span>.left.getNodeHigh(), <span class="built_in">this</span>.right.getNodeHigh()) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">this</span>.right.getNodeHigh()-<span class="built_in">this</span>.left.getNodeHigh() == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> v &lt; <span class="built_in">this</span>.right.value &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.rightLeftRotation()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.leftRotation()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左旋</span></span><br><span class="line">func (<span class="built_in">this</span> *AVLTreeNode) leftRotation() *AVLTreeNode &#123;</span><br><span class="line">    <span class="comment">// 更换节点</span></span><br><span class="line">    node := <span class="built_in">this</span>.right</span><br><span class="line">    <span class="built_in">this</span>.right = node.left</span><br><span class="line">    node.left = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    <span class="built_in">this</span>.high = getMax(<span class="built_in">this</span>.left.getNodeHigh(), <span class="built_in">this</span>.right.getNodeHigh()) + <span class="number">1</span></span><br><span class="line">    node.high = getMax(node.left.getNodeHigh(), node.right.getNodeHigh()) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋</span></span><br><span class="line">func (<span class="built_in">this</span> *AVLTreeNode) rightRotation() *AVLTreeNode &#123;</span><br><span class="line">    node := <span class="built_in">this</span>.left</span><br><span class="line">    <span class="built_in">this</span>.left = node.right</span><br><span class="line">    node.right = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.high = getMax(<span class="built_in">this</span>.left.getNodeHigh(), <span class="built_in">this</span>.right.getNodeHigh()) + <span class="number">1</span></span><br><span class="line">    node.high = getMax(node.left.getNodeHigh(), node.right.getNodeHigh()) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左右旋</span></span><br><span class="line">func (<span class="built_in">this</span> *AVLTreeNode) leftRightRotation() *AVLTreeNode &#123;</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.leftRotation()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.rightRotation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右左旋</span></span><br><span class="line">func (<span class="built_in">this</span> *AVLTreeNode) rightLeftRotation() *AVLTreeNode &#123;</span><br><span class="line">    <span class="built_in">this</span>.right = <span class="built_in">this</span>.right.rightRotation()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.leftRotation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点高度</span></span><br><span class="line">func (<span class="built_in">this</span> *AVLTreeNode) getNodeHigh() int &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">this</span> == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.high</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取最大值</span></span><br><span class="line">func getMax(a, b int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是一种自平衡的二叉搜索树，它包含了二叉搜索树的特性，同时具备以下性质：</p>
<p>1、所有节点的颜色不是红色就是黑色。<br>2、根节点是黑色。<br>3、每个叶子节点都是黑色的空节点(nil)。<br>4、每个红色节点的两个子节点都是黑色。(从每个叶子到根节点的所有路径上不能有两个连续的红色节点)<br>5、从任一节点到其叶子节点的所有路径上都包含相同数目的黑节点</p>
<p>与AVL树相比，没有AVL树那么严格的自平衡，允许比较大的平衡因子</p>
<p>查询多，更新少的用AVL， 更新多一点的用红黑树</p>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>CKEditor富文本编辑器</title>
    <url>/2018/07/02/CKEditor%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<p>在运营后台，运营人员需要录入并编辑模型类的详情信息，而这些信息不是普通的文本，可以是包含了HTML语法格式的字符串。为了快速简单的让用户能够在页面中编辑带格式的文本，富文本即具备丰富样式格式的文本。<br><img src="/2018/07/02/CKEditor%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/1.jpg" alt="1"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pip install django-ckeditor</span><br></pre></td></tr></table></figure>
<h2 id="添加应用"><a href="#添加应用" class="headerlink" title="添加应用"></a>添加应用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">在INSTALLED_APPS中添加</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    &#x27;ckeditor&#x27;,  # 富文本编辑器</span><br><span class="line">    &#x27;ckeditor_uploader&#x27;,  # 富文本编辑器上传图片模块</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="添加CKEditor配置"><a href="#添加CKEditor配置" class="headerlink" title="添加CKEditor配置"></a>添加CKEditor配置</h2><p>在settings.py中添加</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 富文本编辑器ckeditor配置</span><br><span class="line">CKEDITOR_CONFIGS = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        &#x27;toolbar&#x27;: &#x27;full&#x27;,  # 工具条功能</span><br><span class="line">        &#x27;height&#x27;: 300,  # 编辑器高度</span><br><span class="line">        # &#x27;width&#x27;: 300,  # 编辑器宽度</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">CKEDITOR_UPLOAD_PATH = &#x27;&#x27;  # 上传图片保存路径，使用了FastDFS，所以此处设为&#x27; &#x27;</span><br></pre></td></tr></table></figure>
<h2 id="添加ckeditor路由"><a href="#添加ckeditor路由" class="headerlink" title="添加ckeditor路由"></a>添加ckeditor路由</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">url(r<span class="string">&#x27;^ckeditor/&#x27;</span>, include(<span class="string">&#x27;ckeditor_uploader.urls&#x27;</span>)),</span><br></pre></td></tr></table></figure>
<h2 id="为模型类添加字段"><a href="#为模型类添加字段" class="headerlink" title="为模型类添加字段"></a>为模型类添加字段</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ckeditor.fields.RichTextField 不支持上传文件的富文本字段</span><br><span class="line">ckeditor_uploader.fields.RichTextUploadingField 支持上传文件的富文本字段</span><br></pre></td></tr></table></figure>
<p>在需要编辑的模型类的设置可以编辑的字段。<br>别忘了数据库迁移。</p>
]]></content>
      <categories>
        <category>环境运维</category>
      </categories>
      <tags>
        <tag>富文本编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF攻击原理与预防</title>
    <url>/2018/07/12/CSRF%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E9%A2%84%E9%98%B2/</url>
    <content><![CDATA[<h2 id="CSRF简介"><a href="#CSRF简介" class="headerlink" title="CSRF简介"></a>CSRF简介</h2><p> CSRF概念：CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：<br>       攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。</p>
<h2 id="CSRF攻击原理"><a href="#CSRF攻击原理" class="headerlink" title="CSRF攻击原理"></a>CSRF攻击原理</h2><p><img src="/2018/07/12/CSRF%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E9%A2%84%E9%98%B2/1.jpg" alt="1"></p>
<ol>
<li>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；<br>2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</li>
<li>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</li>
<li>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</li>
<li>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</li>
</ol>
<h2 id="预防CSRF攻击"><a href="#预防CSRF攻击" class="headerlink" title="预防CSRF攻击"></a>预防CSRF攻击</h2><p>  目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。</p>
<h3 id="验证-HTTP-Referer-字段"><a href="#验证-HTTP-Referer-字段" class="headerlink" title="验证 HTTP Referer 字段"></a>验证 HTTP Referer 字段</h3><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory%EF%BC%8C">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，</a> 用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>
<p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p>
<p>   然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</p>
<p>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>
<p>a标签添加rel = norferer，可以不发送referer</p>
<h3 id="在请求地址中添加-token-并验证"><a href="#在请求地址中添加-token-并验证" class="headerlink" title="在请求地址中添加 token 并验证"></a>在请求地址中添加 token 并验证</h3><p>  CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<p>  这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url/?csrftoken=tokenvalue%E3%80%82">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上 <input type="”hidden”" name="”csrftoken”" value="”tokenvalue”/">，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p>
<p>   该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p>
<h3 id="在-HTTP-头中自定义属性并验证"><a href="#在-HTTP-头中自定义属性并验证" class="headerlink" title="在 HTTP 头中自定义属性并验证"></a>在 HTTP 头中自定义属性并验证</h3><p> 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。<br>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>配置缓存</title>
    <url>/2018/04/20/Django%E5%BA%94%E7%94%A8%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="Django配置缓存"><a href="#Django配置缓存" class="headerlink" title="Django配置缓存"></a>Django配置缓存</h2><p>在Django REST framework中使用缓存，可以通过drf-extensions扩展来实现。使用文档<a href="http://chibisov.github.io/drf-extensions/docs/#caching">点这里</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pip install drf-extensions</span><br></pre></td></tr></table></figure>

<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="直接添加装饰器"><a href="#直接添加装饰器" class="headerlink" title="直接添加装饰器"></a>直接添加装饰器</h4><p>首先导入工具</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework_extensions.cache.decorators <span class="keyword">import</span> cache_response</span><br></pre></td></tr></table></figure>
<p>即在视图类里面的方法前添加装饰器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class CityView(views.APIView):</span><br><span class="line">    @cache_response()</span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>cache_response可以添加两个参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@cache_response(timeout=<span class="number">60</span>*<span class="number">60</span>, cache=<span class="string">&#x27;default&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>timeout : 缓存的过期时间<br>cache=’default’ ：django的缓存后端，即在settings中的cache配置</p>
<p>如果不写参数，则使用默认值，默认值在配置中添加代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># DRF扩展</span><br><span class="line">REST_FRAMEWORK_EXTENSIONS = &#123;</span><br><span class="line">    # 缓存时间</span><br><span class="line">    <span class="string">&#x27;DEFAULT_CACHE_RESPONSE_TIMEOUT&#x27;</span>: <span class="number">60</span> * <span class="number">60</span>,</span><br><span class="line">    # 缓存存储</span><br><span class="line">    <span class="string">&#x27;DEFAULT_USE_CACHE&#x27;</span>: <span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用扩展类继承"><a href="#使用扩展类继承" class="headerlink" title="使用扩展类继承"></a>使用扩展类继承</h4><p>除了直接添加装饰器的方法，也可以使用drf-extensions提供的扩展类</p>
<p>drf-extensions提供了三种扩展类<br>导入工具：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rest_framework_extensions.cache.mixins</span><br></pre></td></tr></table></figure>
<p>三个扩展类都在里面。</p>
<p> 1.ListCacheResponseMixin<br> 用于缓存列表数据类的视图，配合ListModelMixin扩展类使用<br> 2. RetrieveCacheResponseMixin<br>用于缓存返回单一数据的视图，与RetrieveModelMixin扩展类配合使用<br> 3. CacheResponseMixin<br> 为视图集同时补充List和Retrieve两种缓存，与ListModelMixin和RetrieveModelMixin一起配合使用。</p>
<p>使用方法直接视图类继承即可。<br>在settings中添加配置，即可设置过期时间与cache</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># DRF扩展</span><br><span class="line">REST_FRAMEWORK_EXTENSIONS = &#123;</span><br><span class="line">    # 缓存时间</span><br><span class="line">    <span class="string">&#x27;DEFAULT_CACHE_RESPONSE_TIMEOUT&#x27;</span>: <span class="number">60</span> * <span class="number">60</span>,</span><br><span class="line">    # 缓存存储</span><br><span class="line">    <span class="string">&#x27;DEFAULT_USE_CACHE&#x27;</span>: <span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>DJANGO框架如何实现用户多认证方式登录与第三方授权登录</title>
    <url>/2018/06/11/DJANGO%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h2 id="多种认证方式登录"><a href="#多种认证方式登录" class="headerlink" title="多种认证方式登录"></a>多种认证方式登录</h2><p>Django框架提供了认证系统，详情看文档<a href="https://yiyibooks.cn/xx/Django_1.11.6/topics/auth/index.html">Django认证系统官方文档</a></p>
<p>在这个认证系统中，有一个用户认证的方法authenticate（）来验证一组凭据，默认的是username和password，官方调用源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib.auth import authenticate</span><br><span class="line">user &#x3D; authenticate(username&#x3D;&#39;john&#39;, password&#x3D;&#39;secret&#39;)</span><br><span class="line">if user is not None:</span><br><span class="line">    # A backend authenticated the credentials</span><br><span class="line">else:</span><br><span class="line">    # No backend authenticated the credentials</span><br></pre></td></tr></table></figure>
<p>所以只需要重写这个方法，就可以实现多凭证登录。<br>方法如下：<br>1.在user应用下新建utils.py文件<br>2.定义类继承Modelbackend，重写authenticate方法<br>3.重写规则，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 重写authenticate方法，继承ModelBackend这个类来重写方法</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.backends <span class="keyword">import</span> ModelBackend</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> User</span><br><span class="line">class UserModelBackend(ModelBackend):</span><br><span class="line">    def authenticate(self, request, username=None, password=None, **kwargs):</span><br><span class="line">        # 判断用户输入的是手机号还是用户名</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            # 查询对象，如果能查到对象则得到返回的对象</span><br><span class="line">            user = User.objects.filter(mobile=username)</span><br><span class="line">            # 如果不是手机用户，则执行except</span><br><span class="line">        except:</span><br><span class="line">            # 判断是否用户名，与用户名对比</span><br><span class="line">            <span class="keyword">try</span>: </span><br><span class="line">                user = User.objects.filter(username=username)</span><br><span class="line">            except:</span><br><span class="line">                # 都不是返回空</span><br><span class="line">                <span class="keyword">return</span> None</span><br><span class="line">        # 如果查询到用户对象，则检查密码</span><br><span class="line">        <span class="keyword">if</span> user.check_password(password):</span><br><span class="line">            <span class="keyword">return</span> user</span><br><span class="line">        <span class="keyword">return</span> None</span><br></pre></td></tr></table></figure>
<p>4.配置中设置，settings中添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">AUTHENTICATION_BACKENDS=[</span><br><span class="line">			<span class="string">&#x27;users.utils.UsernameMobileModelBackend&#x27;</span>,</span><br><span class="line">		]</span><br></pre></td></tr></table></figure>
<p>即可实现使用用户手机号登录。</p>
<h2 id="授权第三方登录（QQ为例）"><a href="#授权第三方登录（QQ为例）" class="headerlink" title="授权第三方登录（QQ为例）"></a>授权第三方登录（QQ为例）</h2><p>QQ登录，即第三方登录，用户不在本网站输入账户密码，由第三方授权验证就可以登录本网站。如何实现授权qq登录呢，步骤如下：</p>
<h3 id="第一步：QQ互联开发者注册"><a href="#第一步：QQ互联开发者注册" class="headerlink" title="第一步：QQ互联开发者注册"></a>第一步：QQ互联开发者注册</h3><p>要想实现第三方QQ登录，需要成为QQ互联的开发者，通过审核后，方可继续下面的步骤，注册参考文档：<a href="http://wiki.connect.qq.com/%E6%88%90%E4%B8%BA%E5%BC%80%E5%8F%91%E8%80%85">看这里</a><br>登录成功后，填写注册信息，如下图所示<br><img src="/2018/06/11/DJANGO%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/1.jpg" alt="1"><br>注册成功即可。</p>
<h3 id="第二步：创建应用"><a href="#第二步：创建应用" class="headerlink" title="第二步：创建应用"></a>第二步：创建应用</h3><p>注册成功后要创建应用，选择创建网站应用还是移动应用，并填写相关资料进行创建。<br>如图所示点击创建应用。<br><img src="/2018/06/11/DJANGO%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/2.jpg" alt="2"><br>填写相关资料<br><img src="/2018/06/11/DJANGO%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/3.jpg" alt="3"><br>回调地址与备案信息要写规范<br><img src="/2018/06/11/DJANGO%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/4.jpg" alt="4"><br>最后创建成功，如图所示<br><img src="/2018/06/11/DJANGO%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/5.jpg" alt="5"><br>网站应用创建完成，点击“应用管理”，进入管理中心，在管理中心可以查看到网站获取的appid和appkey，如下图所示：<br><img src="/2018/06/11/DJANGO%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/6.jpg" alt="6"><br>记住这两条数据，后面会用到。</p>
<h3 id="第三步：设置QQ登录按钮（前端代码）"><a href="#第三步：设置QQ登录按钮（前端代码）" class="headerlink" title="第三步：设置QQ登录按钮（前端代码）"></a>第三步：设置QQ登录按钮（前端代码）</h3><p>按钮的图标样式，还有前端ui规范，以及示例代码，均在官方文档里有详细介绍，这里就不说了，主要是后端代码的开发<br>设置QQ登录按钮：<a href="http://wiki.connect.qq.com/%E6%94%BE%E7%BD%AEqq%E7%99%BB%E5%BD%95%E6%8C%89%E9%92%AE_oauth2-0">点这里</a></p>
<h3 id="第四步：网站后端代码开发"><a href="#第四步：网站后端代码开发" class="headerlink" title="第四步：网站后端代码开发"></a>第四步：网站后端代码开发</h3><p>由于后端代码开发流程比较复杂，首先梳理一下授权QQ登录的流程图</p>
<h4 id="使用QQ登录的流程"><a href="#使用QQ登录的流程" class="headerlink" title="使用QQ登录的流程"></a>使用QQ登录的流程</h4><p>如图所示<br><img src="/2018/06/11/DJANGO%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/7.jpg" alt="7"><br>由流程可见，后端代码开发需要创建三个视图，下面进行代码实现。</p>
<h4 id="配置中添加QQ开发者信息"><a href="#配置中添加QQ开发者信息" class="headerlink" title="配置中添加QQ开发者信息"></a>配置中添加QQ开发者信息</h4><p>在settings.py文件中添加如下代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># QQ登录参数</span><br><span class="line">QQ_CLIENT_ID = <span class="string">&#x27;你的APPID&#x27;</span></span><br><span class="line">QQ_CLIENT_SECRET = ‘你的APPKEY’</span><br><span class="line">QQ_REDIRECT_URI = <span class="string">&#x27;网站回调网址&#x27;</span></span><br><span class="line">QQ_STATE = &#x27;/&#x27; # 默认state初始网址为根目录</span><br></pre></td></tr></table></figure>

<h4 id="新建应用、创建模型类"><a href="#新建应用、创建模型类" class="headerlink" title="新建应用、创建模型类"></a>新建应用、创建模型类</h4><p>在项目目录下的utils文件包内新建models.py（没有utils先建utils），里面添加如下代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"># 创建模型类基类，用于增加数据新建时间和更新时间。</span><br><span class="line">class BaseModel(models.Model):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;为模型类补充字段&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    create_time = models.DateTimeField(auto_now_add=True, verbose_name=<span class="string">&quot;创建时间&quot;</span>)</span><br><span class="line">    update_time = models.DateTimeField(auto_now=True, verbose_name=<span class="string">&quot;更新时间&quot;</span>)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        abstract = True  # 说明是抽象模型类, 用于继承使用，数据库迁移时不会创建BaseModel的表</span><br></pre></td></tr></table></figure>
<p>然后新建应用oauth，配置url与根目录url，在oauth的models里添加如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> 根目录.utils.models <span class="keyword">import</span> BaseModel</span><br><span class="line"># 新建模型类，user与openid的关联表</span><br><span class="line">class OAuthQQUser(BaseModel):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    QQ登录用户数据</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">	# 定义user，openid字段</span><br><span class="line">    user = models.ForeignKey(<span class="string">&#x27;users.User&#x27;</span>, on_delete=models.CASCADE, verbose_name=<span class="string">&#x27;用户&#x27;</span>)</span><br><span class="line">    openid = models.CharField(max_length=<span class="number">64</span>, verbose_name=<span class="string">&#x27;openid&#x27;</span>, db_index=True)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">	# 表名，与字段后台显示名</span><br><span class="line">        db_table = <span class="string">&#x27;tb_oauth_qq&#x27;</span></span><br><span class="line">        verbose_name = <span class="string">&#x27;QQ登录用户数据&#x27;</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br></pre></td></tr></table></figure>
<p>然后进行数据库迁移，终端命令如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>
<p>未来会有很多第三方账户集成登录，所以新建应用oauth<br>并不修改原有表结构，而是新建表，完成第三方登录<br>好处：<br>1.不影响原有操作<br>2. 未来会实现多种登录的可能性，提供出更方便的扩展方案：新建表</p>
<h4 id="创建qq登录辅助工具"><a href="#创建qq登录辅助工具" class="headerlink" title="创建qq登录辅助工具"></a>创建qq登录辅助工具</h4><p>在oauth应用下新建utils.py文件，在该文件下添加如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode, parse_qs</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> itsdangerous <span class="keyword">import</span> TimedJSONWebSignatureSerializer <span class="keyword">as</span> Serializer, BadData</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> constants</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;django&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class OAuthQQ(object):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    QQ认证辅助工具类</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">	# 初始化属性，接收四个参数，客户的appid，appkey，回调地址，初始跳转页面</span><br><span class="line">    def __init__(self, client_id=None, client_secret=None, redirect_uri=None, state=None):</span><br><span class="line">	# or：代表if not ，如果接收到参数值，就是用接收的，如果接收none，就用配置的</span><br><span class="line">        self.client_id = client_id or settings.QQ_CLIENT_ID</span><br><span class="line">        self.client_secret = client_secret or settings.QQ_CLIENT_SECRET</span><br><span class="line">        self.redirect_uri = redirect_uri or settings.QQ_REDIRECT_URI</span><br><span class="line">        self.state = state or settings.QQ_STATE  # 用于保存登录成功后的跳转页面路径</span><br><span class="line">	</span><br><span class="line">	# 定义生成url登录地址的函数，返回登录页面url的函数</span><br><span class="line">    def get_qq_login_url(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        获取qq登录的网址</span></span><br><span class="line"><span class="string">        :return: url网址</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        params = &#123;</span><br><span class="line">            <span class="string">&#x27;response_type&#x27;</span>: <span class="string">&#x27;code&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;client_id&#x27;</span>: self.client_id,</span><br><span class="line">            <span class="string">&#x27;redirect_uri&#x27;</span>: self.redirect_uri,</span><br><span class="line">            <span class="string">&#x27;state&#x27;</span>: self.state,</span><br><span class="line">            <span class="string">&#x27;scope&#x27;</span>: <span class="string">&#x27;get_user_info&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        url = <span class="string">&#x27;https://graph.qq.com/oauth2.0/authorize?&#x27;</span> + urlencode(params)</span><br><span class="line">        <span class="keyword">return</span> url</span><br></pre></td></tr></table></figure>

<h4 id="补充技术点1：urllib"><a href="#补充技术点1：urllib" class="headerlink" title="补充技术点1：urllib"></a>补充技术点1：urllib</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">urllib.parse.urlencode(query)</span><br></pre></td></tr></table></figure>
<p>将query字典转换为url路径中的查询字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">urllib.parse.parse_qs(qs)</span><br></pre></td></tr></table></figure>
<p>将qs查询字符串格式数据转换为python的字典</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">urllib.request.urlopen(url, data=None)</span><br></pre></td></tr></table></figure>
<p>发送http请求，如果data为None，发送GET请求，如果data不为None，发送POST请求</p>
<p>返回response响应对象，可以通过read()读取响应体数据，需要注意读取出的响应体数据为bytes类型</p>
<h4 id="创建第一个视图函数"><a href="#创建第一个视图函数" class="headerlink" title="创建第一个视图函数"></a>创建第一个视图函数</h4><p>配置第一个视图函数的url：url(r’^qq/authorization/$’, views.QQAuthURLView.as_view())</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class QQAuthURLView(APIView):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    获取QQ登录的url</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    def get(self, request):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        提供用于qq登录的url</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">		# 获取next的地址，即登陆成功后返回之前浏览的页面</span><br><span class="line">        next = request.query_params.get(<span class="string">&#x27;next&#x27;</span>)</span><br><span class="line">		# OAuthQQ是辅助工具的类，创建对象将next赋值给state初始状态的页面</span><br><span class="line">        oauth = OAuthQQ(state=next)</span><br><span class="line">		# 调用辅助工具的get_qq_login_url函数得到url</span><br><span class="line">        login_url = oauth.get_qq_login_url()</span><br><span class="line">		# 返回URL地址</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;login_url&#x27;</span>: login_url&#125;)</span><br></pre></td></tr></table></figure>
<p>到此第一步完成，即返回用户的登录页面，接下里用户进行授权登录</p>
<h4 id="第二个视图函数"><a href="#第二个视图函数" class="headerlink" title="第二个视图函数"></a>第二个视图函数</h4><p>即用户登陆后，获取登录数据code，然后根据code，去获取accesstoken与openid<br>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class QQAuthUserView(APIView):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    QQ登录的用户</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    def get(self, request):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        获取qq登录的用户数据</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">		# 从请求地址的查询参数中获取code</span><br><span class="line">        code = request.query_params.get(<span class="string">&#x27;code&#x27;</span>)</span><br><span class="line">		# 没有code抛出异常</span><br><span class="line">        <span class="keyword">if</span> not code:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;缺少code&#x27;</span>&#125;, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line">		# 创建oauth对象，类来自定义的qq登录辅助工具</span><br><span class="line">        oauth = OAuthQQ()</span><br><span class="line"></span><br><span class="line">        # 获取用户openid</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">		# 通过code获取token</span><br><span class="line">            access_token = oauth.get_access_token(code)</span><br><span class="line">			# 通过token获取openid</span><br><span class="line">            openid = oauth.get_openid(access_token)</span><br><span class="line">			# 没有获取到的话抛出异常</span><br><span class="line">        except QQAPIError:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;QQ服务异常&#x27;</span>&#125;, status=status.HTTP_503_SERVICE_UNAVAILABLE)</span><br><span class="line"></span><br><span class="line">        # 判断用户是否存在</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">		# 通过openid查询用户，创建的关联表里</span><br><span class="line">            qq_user = OAuthQQUser.objects.get(openid=openid)</span><br><span class="line">        except OAuthQQUser.DoesNotExist:</span><br><span class="line">            # 用户第一次使用QQ登录，显示绑定界面</span><br><span class="line">            token = oauth.generate_save_user_token(openid)</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;access_token&#x27;</span>: token&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            # 找到用户，认为登录成功， 生成jwt_token</span><br><span class="line">            user = qq_user.user</span><br><span class="line">            jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">            jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</span><br><span class="line"></span><br><span class="line">            payload = jwt_payload_handler(user)</span><br><span class="line">            token = jwt_encode_handler(payload)</span><br><span class="line">			# 响应返回</span><br><span class="line">            response = Response(&#123;</span><br><span class="line">                <span class="string">&#x27;token&#x27;</span>: token,</span><br><span class="line">                <span class="string">&#x27;user_id&#x27;</span>: user.id,</span><br><span class="line">                <span class="string">&#x27;username&#x27;</span>: user.username</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<h4 id="QQ辅助工具中添加代码"><a href="#QQ辅助工具中添加代码" class="headerlink" title="QQ辅助工具中添加代码"></a>QQ辅助工具中添加代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def get_access_token(self, code):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        获取access_token</span></span><br><span class="line"><span class="string">        :param code: qq提供的code</span></span><br><span class="line"><span class="string">        :return: access_token</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">     	# 1.构造参数</span><br><span class="line">        params = &#123;</span><br><span class="line">            <span class="string">&#x27;grant_type&#x27;</span>: <span class="string">&#x27;authorization_code&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;client_id&#x27;</span>: self.client_id,</span><br><span class="line">            <span class="string">&#x27;client_secret&#x27;</span>: self.client_secret,</span><br><span class="line">            <span class="string">&#x27;code&#x27;</span>: code,</span><br><span class="line">            <span class="string">&#x27;redirect_uri&#x27;</span>: self.redirect_uri</span><br><span class="line">        &#125;</span><br><span class="line">        # 2.发起http请求，请求qq服务器</span><br><span class="line">        url = <span class="string">&#x27;https://graph.qq.com/oauth2.0/token?&#x27;</span> + urlencode(params)</span><br><span class="line">        response = urlopen(url)</span><br><span class="line">        # 3.接收响应数据，解码</span><br><span class="line">        response_data = response.read().decode()</span><br><span class="line">        # access_token=**&amp;expires_in=**&amp;refresh_token=**</span><br><span class="line">		转成python字典</span><br><span class="line">        data = parse_qs(response_data)</span><br><span class="line">        # 4.从字典中获取token</span><br><span class="line">        access_token = data.get(<span class="string">&#x27;access_token&#x27;</span>, None)</span><br><span class="line">		# 如果没有token，写日志抛出异常</span><br><span class="line">        <span class="keyword">if</span> not access_token:</span><br><span class="line">            logger.error(<span class="string">&#x27;code=%s msg=%s&#x27;</span> % (data.get(<span class="string">&#x27;code&#x27;</span>), data.get(<span class="string">&#x27;msg&#x27;</span>)))</span><br><span class="line">            raise QQAPIError</span><br><span class="line">        # 取出accesstoken的值的列表的第一个元素</span><br><span class="line">        <span class="keyword">return</span> access_token[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    def get_openid(self, access_token):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        获取用户的openid</span></span><br><span class="line"><span class="string">        :param access_token: qq提供的access_token</span></span><br><span class="line"><span class="string">        :return: open_id</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">		# 发起qq服务器请求</span><br><span class="line">        url = <span class="string">&#x27;https://graph.qq.com/oauth2.0/me?access_token=&#x27;</span> + access_token</span><br><span class="line">        response = urlopen(url)</span><br><span class="line">		# 返回数据二进制解码</span><br><span class="line">        response_data = response.read().decode()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">        # 返回的数据 callback( &#123;&quot;client_id&quot;:&quot;YOUR_APPID&quot;,&quot;openid&quot;:&quot;YOUR_OPENID&quot;&#125; )\n;cogn</span><br><span class="line">			# 将字符串转成字典</span><br><span class="line">            data = json.loads(response_data[<span class="number">10</span>:-<span class="number">4</span>])</span><br><span class="line">        except Exception:</span><br><span class="line">			# 没获取到抛出异常</span><br><span class="line">            data = parse_qs(response_data)</span><br><span class="line">            logger.error(<span class="string">&#x27;code=%s msg=%s&#x27;</span> % (data.get(<span class="string">&#x27;code&#x27;</span>), data.get(<span class="string">&#x27;msg&#x27;</span>)))</span><br><span class="line">            raise QQAPIError</span><br><span class="line">		# 从字典中获取数据</span><br><span class="line">        openid = data.get(<span class="string">&#x27;openid&#x27;</span>, None)</span><br><span class="line">        <span class="keyword">return</span> openid</span><br><span class="line">		</span><br><span class="line"># 将返回的openid通过itsdangerous加密，然后返回token，发送这个token</span><br><span class="line">	@staticmethod</span><br><span class="line">    def generate_save_user_token(openid):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        生成保存用户数据的token</span></span><br><span class="line"><span class="string">        :param openid: 用户的openid</span></span><br><span class="line"><span class="string">        :return: token</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        serializer = Serializer(settings.SECRET_KEY, expires_in=constants.SAVE_QQ_USER_TOKEN_EXPIRES)</span><br><span class="line">        data = &#123;<span class="string">&#x27;openid&#x27;</span>: openid&#125;</span><br><span class="line">        token = serializer.dumps(data)</span><br><span class="line">        <span class="keyword">return</span> token.decode()</span><br><span class="line">		</span><br><span class="line">	# 加载读取接收到的token，解密，获取openid</span><br><span class="line">    @staticmethod</span><br><span class="line">    def check_save_user_token(token):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        检验保存用户数据的token</span></span><br><span class="line"><span class="string">        :param token: token</span></span><br><span class="line"><span class="string">        :return: openid or None</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        serializer = Serializer(settings.SECRET_KEY, expires_in=constants.SAVE_QQ_USER_TOKEN_EXPIRES)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = serializer.loads(token)</span><br><span class="line">        except BadData:</span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> data.get(<span class="string">&#x27;openid&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>以上第二步完成，获取到openid，并对用户是否第一次登录，是否需要绑定进行了判断，如果用户是第一次登录，需要绑定，则转到绑定页面，执行第三步。</p>
<h4 id="补充技术点2：itsdangerous"><a href="#补充技术点2：itsdangerous" class="headerlink" title="补充技术点2：itsdangerous"></a>补充技术点2：itsdangerous</h4><p>官方文档：<a href="http://itsdangerous.readthedocs.io/en/latest/">点这里</a><br>itsdangerous是一种加密签名方式，可以通过秘钥加密，也可以通过秘钥解密<br>确保自己的数据在返回时没有经过别人的篡改，保证数据传输的安全性<br>安装：<code>pip install itsdangerous</code><br>使用：以时间戳为例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itsdangerous <span class="keyword">import</span> TimedJSONWebSignatureSerializer <span class="keyword">as</span> Serializer</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"># serializer = Serializer(秘钥, 有效期秒)</span><br><span class="line">serializer = Serializer(settings.SECRET_KEY, <span class="number">300</span>)</span><br><span class="line"># serializer.dumps(数据), 返回bytes类型，加密数据</span><br><span class="line">token = serializer.dumps(&#123;<span class="string">&#x27;mobile&#x27;</span>: <span class="string">&#x27;18512345678&#x27;</span>&#125;)</span><br><span class="line">token = token.decode()</span><br><span class="line"></span><br><span class="line"># 检验token</span><br><span class="line"># 验证失败，会抛出itsdangerous.BadData异常</span><br><span class="line">serializer = Serializer(settings.SECRET_KEY, <span class="number">300</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"># 加载token数据，解密数据</span><br><span class="line">    data = serializer.loads(token)</span><br><span class="line">except BadData:</span><br><span class="line">    <span class="keyword">return</span> None</span><br></pre></td></tr></table></figure>


<h4 id="第三个视图函数"><a href="#第三个视图函数" class="headerlink" title="第三个视图函数"></a>第三个视图函数</h4><p>视图代码如下：<br>因为是绑定数据库增加数据，所以在第二个视图函数中继续定义post方法即可，不用单独创建视图类，该视图实现用户绑定的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def post(self,request):</span><br><span class="line">		# 指定序列化器</span><br><span class="line">        serializer = OAuthQQUserSerializer(data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=True)</span><br><span class="line">        user = serializer.save()</span><br><span class="line"></span><br><span class="line">        response = Response(&#123;</span><br><span class="line">            <span class="string">&#x27;token&#x27;</span>: user.token,</span><br><span class="line">            <span class="string">&#x27;user_id&#x27;</span>: user.id,</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span>: user.username</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
<p>定义序列器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class OAuthQQUserSerializer(serializers.ModelSerializer):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    保存QQ用户序列化器</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">	# 添加字段</span><br><span class="line">    sms_code = serializers.CharField(label=<span class="string">&#x27;短信验证码&#x27;</span>, write_only=True)</span><br><span class="line">    access_token = serializers.CharField(label=<span class="string">&#x27;操作凭证&#x27;</span>, write_only=True)</span><br><span class="line">    token = serializers.CharField(read_only=True)</span><br><span class="line">    mobile = serializers.RegexField(label=<span class="string">&#x27;手机号&#x27;</span>, regex=r<span class="string">&#x27;^1[3-9]\d&#123;9&#125;$&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        model = User</span><br><span class="line">        fields = (<span class="string">&#x27;mobile&#x27;</span>, <span class="string">&#x27;password&#x27;</span>, <span class="string">&#x27;sms_code&#x27;</span>, <span class="string">&#x27;access_token&#x27;</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">        extra_kwargs = &#123;</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;read_only&#x27;</span>: True</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;write_only&#x27;</span>: True,</span><br><span class="line">                <span class="string">&#x27;min_length&#x27;</span>: <span class="number">8</span>,</span><br><span class="line">                <span class="string">&#x27;max_length&#x27;</span>: <span class="number">20</span>,</span><br><span class="line">                <span class="string">&#x27;error_messages&#x27;</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;min_length&#x27;</span>: <span class="string">&#x27;仅允许8-20个字符的密码&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;max_length&#x27;</span>: <span class="string">&#x27;仅允许8-20个字符的密码&#x27;</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	# 验证</span><br><span class="line">    def validate(self, attrs):</span><br><span class="line">        # 检验access_token，获取加密的token值</span><br><span class="line">        access_token = attrs[<span class="string">&#x27;access_token&#x27;</span>]</span><br><span class="line">		# 解密</span><br><span class="line">        openid = OAuthQQ.check_save_user_token(access_token)</span><br><span class="line">        <span class="keyword">if</span> not openid:</span><br><span class="line">            raise serializers.ValidationError(<span class="string">&#x27;无效的access_token&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        attrs[<span class="string">&#x27;openid&#x27;</span>] = openid</span><br><span class="line"></span><br><span class="line">        # 检验短信验证码</span><br><span class="line">        mobile = attrs[<span class="string">&#x27;mobile&#x27;</span>]</span><br><span class="line">        sms_code = attrs[<span class="string">&#x27;sms_code&#x27;</span>]</span><br><span class="line">        redis_conn = get_redis_connection(<span class="string">&#x27;verify_code&#x27;</span>)</span><br><span class="line">        real_sms_code = redis_conn.get(<span class="string">&#x27;sms_code_%s&#x27;</span> % mobile)</span><br><span class="line">        <span class="keyword">if</span> real_sms_code.decode() != sms_code:</span><br><span class="line">            raise serializers.ValidationError(<span class="string">&#x27;短信验证码错误&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        # 如果用户存在，检查用户密码</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            user = User.objects.get(mobile=mobile)</span><br><span class="line">        except User.DoesNotExist:</span><br><span class="line">            pass</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            password = attrs[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">            <span class="keyword">if</span> not user.check_password(password):</span><br><span class="line">                raise serializers.ValidationError(<span class="string">&#x27;密码错误&#x27;</span>)</span><br><span class="line">				# attrs中添加user数据</span><br><span class="line">            attrs[<span class="string">&#x27;user&#x27;</span>] = user</span><br><span class="line">        <span class="keyword">return</span> attrs</span><br><span class="line"></span><br><span class="line">    def create(self, validated_data):</span><br><span class="line">        openid = validated_data[<span class="string">&#x27;openid&#x27;</span>]</span><br><span class="line">        user = validated_data.get(<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line">        mobile = validated_data[<span class="string">&#x27;mobile&#x27;</span>]</span><br><span class="line">        password = validated_data[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">		# 获取user</span><br><span class="line">        <span class="keyword">if</span> not user:</span><br><span class="line">            # 如果用户不存在，创建用户，绑定openid（创建了OAuthQQUser数据）</span><br><span class="line">            user = User.objects.create_user(username=mobile, mobile=mobile, password=password)</span><br><span class="line">		# 在用户与openid中的关联表中添加数据</span><br><span class="line">        OAuthQQUser.objects.create(user=user, openid=openid)</span><br><span class="line"></span><br><span class="line">        # 签发jwt token</span><br><span class="line">        jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">        jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</span><br><span class="line"></span><br><span class="line">        payload = jwt_payload_handler(user)</span><br><span class="line">        token = jwt_encode_handler(payload)</span><br><span class="line"></span><br><span class="line">        user.token = token</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure>
<p>到此，可实现授权QQ第三方登录的功能</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Cors跨域技术应用</title>
    <url>/2018/04/22/Cors%E8%B7%A8%E5%9F%9F%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="CORS简介"><a href="#CORS简介" class="headerlink" title="CORS简介"></a>CORS简介</h2><p>CORS全称是”跨域资源共享”（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出Request请求，从而克服了AJAX只能同源使用的限制。</p>
<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h2 id="简单请求与非简单请求"><a href="#简单请求与非简单请求" class="headerlink" title="简单请求与非简单请求"></a>简单请求与非简单请求</h2><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><p>满足以下条件，就属于简单请求：<br>（1) 请求方法是以下三种方法之一：<br>HEAD<br>GET<br>POST<br>（2）HTTP的头信息不超出以下几种字段：</p>
<p>Accept<br>Accept-Language<br>Content-Language<br>Last-Event-ID<br>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</p>
<h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。<br>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>
<p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line"># 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line"># 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie</span><br><span class="line">#另一方面，开发者必须在AJAX请求中打开withCredentials属性。</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line"># XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定</span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>

<h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><h4 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h4><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<h4 id="处理流程-1"><a href="#处理流程-1" class="headerlink" title="处理流程"></a>处理流程</h4><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。<br>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">OPTIONS /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>..</span><br></pre></td></tr></table></figure>

<p>“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</p>
<h3 id="Django代码实现"><a href="#Django代码实现" class="headerlink" title="Django代码实现"></a>Django代码实现</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pip install django-cors-headers</span><br></pre></td></tr></table></figure>

<h4 id="添加应用"><a href="#添加应用" class="headerlink" title="添加应用"></a>添加应用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;corsheaders&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="中间层设置"><a href="#中间层设置" class="headerlink" title="中间层设置"></a>中间层设置</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">&#x27;corsheaders.middleware.CorsMiddleware&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="添加白名单"><a href="#添加白名单" class="headerlink" title="添加白名单"></a>添加白名单</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># CORS</span><br><span class="line">CORS_ORIGIN_WHITELIST = (</span><br><span class="line">    <span class="string">&#x27;127.0.0.1:8080&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;localhost:8080&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;www.meiduo.site:8080&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;api.meiduo.site:8000&#x27;</span></span><br><span class="line">)</span><br><span class="line">CORS_ALLOW_CREDENTIALS = True  # 允许携带cookie</span><br></pre></td></tr></table></figure>
<p>凡是出现在白名单中的域名，都可以访问后端接口<br>CORS_ALLOW_CREDENTIALS 指明在跨域访问中，后端是否支持对cookie的操作。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>Django视图使用说明</title>
    <url>/2018/04/25/Django%E8%A7%86%E5%9B%BE%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="两个基类"><a href="#两个基类" class="headerlink" title="两个基类"></a>两个基类</h2><h3 id="APIView"><a href="#APIView" class="headerlink" title="APIView"></a>APIView</h3><p>APIView是django rest_framework提供的所有视图的基类，继承自django的view父类。<br>导入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rest_framework.views.APIView</span><br></pre></td></tr></table></figure>
<p>APIView相对于View封装了drf的request对象，response对象，异常捕获功能以及身份认证，权限检查，流量控制等功能。</p>
<p>提供的属性：<br>authentication_classes 列表或元祖，身份认证类，可重写。<br>permissoin_classes 列表或元祖，权限检查类<br>throttle_classes 列表或元祖，流量控制类</p>
<p>经常以常规类视图的定义方法来实现get，post等请求方式。<br>所以在业务逻辑的视图选择时，如果功能上不包含对数据库的操作（增删改查），不包含序列化器，则继承APIView，直接定义请求方式方法即可。</p>
<h3 id="GenericAPIView"><a href="#GenericAPIView" class="headerlink" title="GenericAPIView"></a>GenericAPIView</h3><p>继承自APIVIew，增加了对于列表视图和详情视图可能用到的通用支持方法。通常使用时，可搭配一个或多个Mixin扩展类。<br>导入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rest_framework.generics.GenericAPIView</span><br></pre></td></tr></table></figure>
<p>支持定义的属性：</p>
<p>1.列表视图与详情视图通用：<br>queryset 列表视图的查询集<br>serializer_class 视图使用的序列化器<br>2.列表视图使用：<br>pagination_class 分页控制类<br>filter_backends 过滤控制后端<br>3.详情页视图使用：<br>lookup_field 查询单一数据库对象时使用的条件字段，默认为’pk’<br>lookup_url_kwarg 查询单一数据时URL中的参数关键字名称，默认与look_field相同</p>
<p>提供的方法：<br>列表视图与详情视图通用：<br>1.get_queryset(self)<br>返回视图使用的查询集，是列表视图与详情视图获取数据的基础，默认返回queryset属性，可以重写，例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def get_queryset(self):</span><br><span class="line">       <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">       提供数据集</span></span><br><span class="line"><span class="string">       &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">       <span class="keyword">if</span> self.action == <span class="string">&#x27;list&#x27;</span>:</span><br><span class="line">           # 如果是list方法，则反回省的查询结果，返回省的列表即parent为none的</span><br><span class="line">           <span class="keyword">return</span> Area.objects.filter(parent=None)</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           # 不是list则是retrieve,返回所有</span><br><span class="line">           <span class="keyword">return</span> Area.objects.all()</span><br></pre></td></tr></table></figure>
<p>可以添加判断，根据不同请求返回指定不同的查询集。<br>2.get_serializer_class(self)</p>
<p>返回序列化器类，默认返回serializer_class，可以重写，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def get_serializer_class(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        提供序列化器</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.action == <span class="string">&#x27;list&#x27;</span>:</span><br><span class="line">            # 是list，返回省的序列化器</span><br><span class="line">            <span class="keyword">return</span> AreaSerializer</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            # 不是list，返回区县的序列化器</span><br><span class="line">            <span class="keyword">return</span> SubAreaSerializer</span><br></pre></td></tr></table></figure>
<p>3.get_serializer(self, args, *kwargs)</p>
<p>返回序列化器对象，被其他视图或扩展类使用，如果我们在视图中想要获取序列化器对象，可以直接调用此方法。</p>
<p>注意，在提供序列化器对象的时候，REST framework会向对象的context属性补充三个数据：request、format、view，这三个数据对象可以在定义序列化器时使用。<br>详情视图使用：<br>get_object(self) 返回详情视图所需的模型类数据对象，默认使用lookup_field参数来过滤queryset。 在试图中可以调用该方法获取详情信息的模型类对象。</p>
<p>若详情访问的模型类对象不存在，会返回404。</p>
<p>该方法会默认使用APIView提供的check_object_permissions方法检查当前对象是否有权限被访问。</p>
<h2 id="五个扩展类"><a href="#五个扩展类" class="headerlink" title="五个扩展类"></a>五个扩展类</h2><ol>
<li>ListModelMixin<br>列表视图扩展类，用于查询数据库多个对象，会对list的数据进行过滤和分页，成功返回200</li>
<li>CreateModelMixin<br>创建视图扩展类，用于增加数据库信息，成功返回201</li>
<li>RetrieveModelMixin<br>详情视图扩展类，用于单一对象的查询，成功返回200</li>
<li>UpdateModelMixin<br>更新视图扩展类，用于修改数据库信息，局部更新（partial_update方法），成功返回200</li>
<li>DestroyModelMixin<br>删除视图扩展类，用于删除数据库信息（一般都是逻辑删除），成功返回204</li>
</ol>
<h2 id="可用子类（组合类）"><a href="#可用子类（组合类）" class="headerlink" title="可用子类（组合类）"></a>可用子类（组合类）</h2><p> 1） CreateAPIView</p>
<p>提供 post 方法</p>
<p>继承自： GenericAPIView、CreateModelMixin</p>
<p>2）ListAPIView</p>
<p>提供 get 方法</p>
<p>继承自：GenericAPIView、ListModelMixin</p>
<p>3）RetireveAPIView</p>
<p>提供 get 方法</p>
<p>继承自: GenericAPIView、RetrieveModelMixin</p>
<p>4）DestoryAPIView</p>
<p>提供 delete 方法</p>
<p>继承自：GenericAPIView、DestoryModelMixin</p>
<p>5）UpdateAPIView</p>
<p>提供 put 和 patch 方法</p>
<p>继承自：GenericAPIView、UpdateModelMixin</p>
<p>6）RetrieveUpdateAPIView</p>
<p>提供 get、put、patch方法</p>
<p>继承自： GenericAPIView、RetrieveModelMixin、UpdateModelMixin</p>
<p>7）RetrieveUpdateDestoryAPIView</p>
<p>提供 get、put、patch、delete方法</p>
<p>继承自：GenericAPIView、RetrieveModelMixin、UpdateModelMixin、DestoryModelMixin</p>
<h2 id="视图集ViewSet"><a href="#视图集ViewSet" class="headerlink" title="视图集ViewSet"></a>视图集ViewSet</h2><p>相对于前面的视图类，进一步封装<br>list() 提供一组数据<br>retrieve() 提供单个数据<br>create() 创建数据<br>update() 保存数据<br>destory() 删除数据<br>ViewSet视图集类不再实现get()、post()等方法，而是实现动作 action 如 list() 、create() 等，这些动作与请求方式对应。<br>如果url中使用as_View方法，要把action与请求方式对应。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">url(r<span class="string">&#x27;路由规则&#x27;</span>, ViewSet.as_view(&#123;<span class="string">&#x27;get&#x27;</span>:<span class="string">&#x27;list&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure>

<h3 id="action属性"><a href="#action属性" class="headerlink" title="action属性"></a>action属性</h3><p>可以使用self.action获取当前请求视图的action动作，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def get_serializer_class(self):</span><br><span class="line">    <span class="keyword">if</span> self.action == <span class="string">&#x27;create&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> OrderCommitSerializer</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> OrderDataSerializer</span><br></pre></td></tr></table></figure>
<p>可以根据请求动作的不同进行if判断，来指定不同的序列化器与查询集</p>
<h3 id="常用视图集父类"><a href="#常用视图集父类" class="headerlink" title="常用视图集父类"></a>常用视图集父类</h3><p>1） ViewSet</p>
<p>继承自APIView，作用也与APIView基本类似，提供了身份认证、权限校验、流量管理等。</p>
<p>在ViewSet中，没有提供任何动作action方法，需要我们自己实现action方法。</p>
<p>2）GenericViewSet</p>
<p>继承自GenericAPIView，作用也与GenericAPIVIew类似，提供了get_object、get_queryset等方法便于列表视图与详情信息视图的开发。</p>
<p>3）ModelViewSet</p>
<p>继承自GenericAPIVIew，同时包括了ListModelMixin、RetrieveModelMixin、CreateModelMixin、UpdateModelMixin、DestoryModelMixin。</p>
<p>4）ReadOnlyModelViewSet</p>
<p>继承自GenericAPIVIew，同时包括了ListModelMixin、RetrieveModelMixin。</p>
<h3 id="视图定义中附加action动作"><a href="#视图定义中附加action动作" class="headerlink" title="视图定义中附加action动作"></a>视图定义中附加action动作</h3><p>添加自定义动作需要使用装饰器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rest_framework.decorators.action</span><br></pre></td></tr></table></figure>
<p>该装饰器可以接收两个参数<br>methods: 该action支持的请求方式，列表传递<br>detail: 表示是action中要处理的是否是视图资源的对象（即是否通过url路径获取主键）<br>True 表示使用通过URL获取的主键对应的数据对象<br>False 表示不使用URL获取主键</p>
<h3 id="路由routers"><a href="#路由routers" class="headerlink" title="路由routers"></a>路由routers</h3><p>在视图集中，可以使用routers快速实现路由信息的配置。<br>首先在urls.py中导入routers</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> routers</span><br></pre></td></tr></table></figure>
<p>然后创建router对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router = routers.SimpleRouter()</span><br><span class="line">router = routers.DefaultRouter()</span><br></pre></td></tr></table></figure>
<p>DefaultRouter与SimpleRouter的区别是，DefaultRouter会多附带一个默认的API根视图，返回一个包含所有列表视图的超链接响应数据。<br>接下来注册router</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.register(r<span class="string">&#x27;路由&#x27;</span>, 视图集, base_name=<span class="string">&#x27;路由名称前缀&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上述代码会形成的路由如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">^路由/$    name: 前缀-list</span><br><span class="line">^路由/&#123;pk&#125;/$   name: 前缀-detail</span><br></pre></td></tr></table></figure>
<p>然后添加路由数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line">urlpatterns += router.urls</span><br></pre></td></tr></table></figure>
<p>如果视图中附加了action动作，则形成的路由：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">^路由/方法名/$    name: 前缀-方法名</span><br><span class="line">^路由/&#123;pk&#125;/方法名/$  name: 前缀-方法名</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch的使用</title>
    <url>/2018/08/01/Elasticsearch%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h2><p>ES=elaticsearch简写， Elasticsearch是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。<br>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p>
<h2 id="ES工作原理"><a href="#ES工作原理" class="headerlink" title="ES工作原理"></a>ES工作原理</h2><p>当ElasticSearch的节点启动后，它会利用多播(multicast)(或者单播，如果用户更改了配置)寻找集群中的其它节点，并与之建立连接。这个过程如下图所示：<br><img src="/2018/08/01/Elasticsearch%E7%9A%84%E4%BD%BF%E7%94%A8/1.jpg" alt="1"></p>
<h2 id="ES核心概念"><a href="#ES核心概念" class="headerlink" title="ES核心概念"></a>ES核心概念</h2><h3 id="Cluster：集群"><a href="#Cluster：集群" class="headerlink" title="Cluster：集群"></a>Cluster：集群</h3><p>ES可以作为一个独立的单个搜索服务器。不过，为了处理大型数据集，实现容错和高可用性，ES可以运行在许多互相合作的服务器上。这些服务器的集合称为集群。</p>
<h3 id="Node：节点"><a href="#Node：节点" class="headerlink" title="Node：节点"></a>Node：节点</h3><p>形成集群的每个服务器称为节点。</p>
<h3 id="Shard：分片"><a href="#Shard：分片" class="headerlink" title="Shard：分片"></a>Shard：分片</h3><p>当有大量的文档时，由于内存的限制、磁盘处理能力不足、无法足够快的响应客户端的请求等，一个节点可能不够。这种情况下，数据可以分为较小的分片。每个分片放到不同的服务器上。<br>当你查询的索引分布在多个分片上时，ES会把查询发送给每个相关的分片，并将结果组合在一起，而应用程序并不知道分片的存在。即：这个过程对用户来说是透明的。</p>
<h3 id="Replia：副本"><a href="#Replia：副本" class="headerlink" title="Replia：副本"></a>Replia：副本</h3><p>为提高查询吞吐量或实现高可用性，可以使用分片副本。<br>副本是一个分片的精确复制，每个分片可以有零个或多个副本。ES中可以有许多相同的分片，其中之一被选择更改索引操作，这种特殊的分片称为主分片。<br>当主分片丢失时，如：该分片所在的数据不可用时，集群将副本提升为新的主分片。</p>
<h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><p>全文检索就是对一篇文章进行索引，可以根据关键字搜索，类似于mysql里的like语句。<br>全文索引就是把内容根据词的意义进行分词，然后分别创建索引，例如”你们的激情是因为什么事情来的” 可能会被分词成：“你们“，”激情“，“什么事情“，”来“ 等token，这样当你搜索“你们” 或者 “激情” 都会把这句搜出来。</p>
<h2 id="ES数据架构的主要概念（与关系数据库Mysql对比）"><a href="#ES数据架构的主要概念（与关系数据库Mysql对比）" class="headerlink" title="ES数据架构的主要概念（与关系数据库Mysql对比）"></a>ES数据架构的主要概念（与关系数据库Mysql对比）</h2><img src="/2018/08/01/Elasticsearch%E7%9A%84%E4%BD%BF%E7%94%A8/08/01/Elasticsearch%E7%9A%84%E4%BD%BF%E7%94%A8/2.jpg" class>
<p>（1）关系型数据库中的数据库（DataBase），等价于ES中的索引（Index）<br>（2）一个数据库下面有N张表（Table），等价于1个索引Index下面有N多类型（Type），<br>（3）一个数据库表（Table）下的数据由多行（ROW）多列（column，属性）组成，等价于1个Type由多个文档（Document）和多Field组成。<br>（4）在一个关系型数据库里面，schema定义了表、每个表的字段，还有表和字段之间的关系。 与之对应的，在ES中：Mapping定义索引下的Type的字段处理规则，即索引如何建立、索引类型、是否保存原始索引JSON文档、是否压缩原始JSON文档、是否需要分词处理、如何进行分词处理等。<br>（5）在数据库中的增insert、删delete、改update、查search操作等价于ES中的增PUT/POST、删Delete、改_update、查GET.</p>
<h2 id="简单使用ES"><a href="#简单使用ES" class="headerlink" title="简单使用ES"></a>简单使用ES</h2><h3 id="使用Docker安装Elasticsearch及其扩展"><a href="#使用Docker安装Elasticsearch及其扩展" class="headerlink" title="使用Docker安装Elasticsearch及其扩展"></a>使用Docker安装Elasticsearch及其扩展</h3><p>获取镜像，可以通过网络pull</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker image pull delron/elasticsearch-ik:<span class="number">2.4</span><span class="number">.6</span>-<span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>修改elasticsearch的配置文件 elasticsearc-2.4.6/config/elasticsearch.yml第54行，更改ip地址为本机ip地址</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">network.host: 自己机器的IP地址</span><br></pre></td></tr></table></figure>
<p>创建docker容器运行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker run -dti --network=host --name=elasticsearch -v /home/python/elasticsearch-<span class="number">2.4</span><span class="number">.6</span>/config:<span class="regexp">/usr/</span>share/elasticsearch/config delron/elasticsearch-ik:<span class="number">2.4</span><span class="number">.6</span>-<span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<h3 id="使用haystack对接Elasticsearch"><a href="#使用haystack对接Elasticsearch" class="headerlink" title="使用haystack对接Elasticsearch"></a>使用haystack对接Elasticsearch</h3><p>Haystack为Django提供了模块化的搜索。它的特点是统一的，熟悉的API，可以让你在不修改代码的情况下使用不同的搜索后端（比如 Solr, Elasticsearch, Whoosh, Xapian 等等）。</p>
<p>这里通过使用haystack来调用Elasticsearch搜索引擎。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pip install drf-haystack</span><br><span class="line">pip install elasticsearch==<span class="number">2.4</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<p>drf-haystack是为了在REST framework中使用haystack而进行的封装（如果在Django中使用haystack，则安装django-haystack即可）。</p>
<h4 id="注册应用"><a href="#注册应用" class="headerlink" title="注册应用"></a>注册应用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;haystack&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># Haystack</span><br><span class="line">HAYSTACK_CONNECTIONS = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;haystack.backends.elasticsearch_backend.ElasticsearchSearchEngine&#x27;</span>,</span><br><span class="line">        # 端口号固定为9200</span><br><span class="line">        <span class="string">&#x27;URL&#x27;</span>: <span class="string">&#x27;http://es的IP:9200/&#x27;</span>,</span><br><span class="line">        # 指定elasticsearch建立的索引库的名称</span><br><span class="line">        <span class="string">&#x27;INDEX_NAME&#x27;</span>: <span class="string">&#x27;名称自定&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 当添加、修改、删除数据时，自动生成索引</span><br><span class="line">HAYSTACK_SIGNAL_PROCESSOR = <span class="string">&#x27;haystack.signals.RealtimeSignalProcessor&#x27;</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>HAYSTACK_SIGNAL_PROCESSOR 的配置保证了在Django运行起来后，有新的数据产生时，haystack仍然可以让Elasticsearch实时生成新数据的索引</p>
<h4 id="创建索引类"><a href="#创建索引类" class="headerlink" title="创建索引类"></a>创建索引类</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> haystack <span class="keyword">import</span> indexes</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> SKU</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SKUIndex(indexes.SearchIndex, indexes.Indexable):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    SKU索引数据模型类</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    text = indexes.CharField(<span class="built_in">document</span>=True, use_template=True)</span><br><span class="line"></span><br><span class="line">    def get_model(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;返回建立索引的模型类&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> SKU</span><br><span class="line"></span><br><span class="line">    def index_queryset(self, using=None):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;返回要建立索引的数据查询集&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.get_model().objects.filter(is_launched=True)</span><br></pre></td></tr></table></figure>
<p>在SKUIndex建立的字段，都可以借助haystack由elasticsearch搜索引擎查询。</p>
<p>其中text字段我们声明为document=True，表名该字段是主要进行关键字查询的字段， 该字段的索引值可以由多个数据库模型类字段组成，具体由哪些模型类字段组成，我们用use_template=True表示后续通过模板来指明。</p>
<p>在REST framework中，索引类的字段会作为查询结果返回数据的来源。</p>
<h4 id="在templates目录中创建text字段使用的模板文件"><a href="#在templates目录中创建text字段使用的模板文件" class="headerlink" title="在templates目录中创建text字段使用的模板文件"></a>在templates目录中创建text字段使用的模板文件</h4><p>具体在templates/search/indexes/goods/sku_text.txt文件中定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123; object.name &#125;&#125;</span><br><span class="line">&#123;&#123; object.caption &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>此模板指明当将关键词通过text参数名传递时，可以通过sku的name、caption、id来进行关键字索引查询。</p>
<h4 id="手动生成初始索引"><a href="#手动生成初始索引" class="headerlink" title="手动生成初始索引"></a>手动生成初始索引</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">python manage.py rebuild_index</span><br></pre></td></tr></table></figure>

<h4 id="创建序列化器"><a href="#创建序列化器" class="headerlink" title="创建序列化器"></a>创建序列化器</h4><p>在goods/serializers.py中创建haystack序列化器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> drf_haystack.serializers <span class="keyword">import</span> HaystackSerializer</span><br><span class="line"><span class="keyword">from</span> .search_indexes <span class="keyword">import</span> SKUIndex</span><br><span class="line"></span><br><span class="line">class SKUIndexSerializer(HaystackSerializer):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    SKU索引结果数据序列化器</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    object = SKUSerializer(read_only=True)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        index_classes = [SKUIndex]</span><br><span class="line">        fields = (</span><br><span class="line">            &#x27;text&#x27;,  # 用于接收查询关键字</span><br><span class="line">            &#x27;object&#x27;  # 用于返回查询结果</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>下面的搜索视图使用SKUIndexSerializer序列化器用来检查前端传入的参数text，并且检索出数据后再使用这个序列化器返回给前端；</p>
<p>SKUIndexSerializer序列化器中的object字段是用来向前端返回数据时序列化的字段。</p>
<p>Haystack通过Elasticsearch检索出匹配关键词的搜索结果后，还会在数据库中取出完整的数据库模型类对象，放到搜索结果的object属性中，并将结果通过SKUIndexSerializer序列化器进行序列化。所以我们可以通过声明搜索结果的object字段以SKUSerializer序列化的形式进行处理，明确要返回的搜索结果中每个数据对象包含哪些字段。</p>
<h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><p>在goods/views.py中创建视图</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> drf_haystack.viewsets <span class="keyword">import</span> HaystackViewSet</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> SKUIndexSerializer</span><br><span class="line"></span><br><span class="line">class SKUSearchViewSet(HaystackViewSet):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    SKU搜索</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    index_models = [SKU]</span><br><span class="line"></span><br><span class="line">    serializer_class = SKUIndexSerializer</span><br></pre></td></tr></table></figure>
<p>注意：<br>该视图会返回搜索结果的列表数据，所以可以为视图增加REST framework的分页功能。<br>我们在实现商品列表页面时已经定义了全局的分页配置，所以此搜索视图会使用全局的分页配置。</p>
<h4 id="定义路由"><a href="#定义路由" class="headerlink" title="定义路由"></a>定义路由</h4><p>在goods/urls.py中通过REST framework的router来定义路由</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> DefaultRouter</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">router = DefaultRouter()</span><br><span class="line">router.register(<span class="string">&#x27;skus/search&#x27;</span>, views.SKUSearchViewSet, base_name=<span class="string">&#x27;skus_search&#x27;</span>)</span><br><span class="line"></span><br><span class="line">urlpatterns += router.urls</span><br></pre></td></tr></table></figure>

<h4 id="bug说明"><a href="#bug说明" class="headerlink" title="bug说明"></a>bug说明</h4><p>如果在配置完haystack并启动程序后，出现如下异常，是因为drf-haystack还没有适配最新版本的REST framework框架</p>
<img src="/2018/08/01/Elasticsearch%E7%9A%84%E4%BD%BF%E7%94%A8/08/01/Elasticsearch%E7%9A%84%E4%BD%BF%E7%94%A8/3.jpg" class>
<p>可以通过修改REST framework框架代码，补充_get_count函数定义即可</p>
<p>文件路径 虚拟环境下的 lib/python3.6/site-packages/rest_framework/pagination.py</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def _get_count(queryset):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    Determine an object count, supporting either querysets or regular lists.</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> queryset.count()</span><br><span class="line">    except (AttributeError, <span class="built_in">TypeError</span>):</span><br><span class="line">        <span class="keyword">return</span> len(queryset)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>GO的WaitGroup及源码分析</title>
    <url>/2024/04/20/GO%E7%9A%84WaitGroup%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>Go语言中的WaitGroup类似Java的CountDownLatch，任务检查点，任务等待点，比如有一个主任务，执行到某一时刻需要执行两个子任务，主任务等待阻塞，两个子任务执行完毕后再执行主任务，这就需要一个任务阻塞检查点，等待子任务执行完毕</p>
<h3 id="WaitGroup使用"><a href="#WaitGroup使用" class="headerlink" title="WaitGroup使用"></a>WaitGroup使用</h3><p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> createRand()</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> sumResult()</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> resultChan &#123;</span><br><span class="line">	j := (*v).job</span><br><span class="line">	s := (*v).sum</span><br><span class="line">	fmt.Println(<span class="string">&quot;1111&quot;</span>, j, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建两个协程方法，产生随机数，计算结果，主线程等待计算结果后，再打印结果</p>
<p>一共有三个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(wg *WaitGroup) Add(delta int)</span><br><span class="line">(wg *WaitGroup) Done()</span><br><span class="line">(wg *WaitGroup) Wait()</span><br></pre></td></tr></table></figure>

<p><code>Add</code> 方法用于设置 WaitGroup 的计数值，可以理解为子任务的数量</p>
<p><code>Done</code> 方法用于将 WaitGroup 的计数值减一，可以理解为完成一个子任务</p>
<p><code>Wait</code> 方法用于阻塞调用者，直到 WaitGroup 的计数值为0，即所有子任务都完成</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="WaitGroup结构"><a href="#WaitGroup结构" class="headerlink" title="WaitGroup结构"></a>WaitGroup结构</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy <span class="comment">// noCopy 字段标识，由于 WaitGroup 不能复制，方便工具检测</span></span><br><span class="line">    state1 [<span class="number">3</span>]<span class="keyword">uint32</span>  <span class="comment">// 12个字节，8个字节标识 计数值和等待数量，4个字节用于标识信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>state1 是个复合字段，会拆分为两部分： 64位（8个字节）的 statep 作为一个整体用于原子操作, 其中前面4个字节表示计数值，后面四个字节表示等待数量；剩余 32位（4个字节）semap 用于标识信号量。</p>
<p>Go语言中对于64位的变量进行原子操作，需要保证该变量是 64位对齐 的，也就是要保证这 8个字节 的首地址是 8 的整数倍。因此当 state1 的首地址是 8 的整数倍时，取前8个字节作为 statep ，后4个字节作为 semap；当 state1 的首地址不是 8 的整数倍时，取后8个字节作为 statep ，前4个字节作为 semap。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">state</span><span class="params">()</span> <span class="params">(statep *<span class="keyword">uint64</span>, semap *<span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 首地址是8的倍数时，前8个字节为 statep, 后四个字节为 semap</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="number">2</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 后8个字节为 statep, 前四个字节为 semap  </span></span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), &amp;wg.state1[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到计数值等待者变量 statep 和 信号量 semap</span></span><br><span class="line">    statep, semap := wg.state()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数值加上 delta: statep 的前四个字节是计数值，因此将 delta 前移 32位</span></span><br><span class="line">    state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数值</span></span><br><span class="line">    v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待者数量</span></span><br><span class="line">    w := <span class="keyword">uint32</span>(state)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果加上 delta 之后，计数值变为负数，不合法，panic</span></span><br><span class="line">    <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delta &gt; 0 &amp;&amp; v == int32(delta) : 表示从 0 开始添加计数值</span></span><br><span class="line">    <span class="comment">// w!=0 ：表示已经有了等待者</span></span><br><span class="line">    <span class="comment">// 说明在添加计数值的时候，同时添加了等待者，非法操作。添加等待者需要在添加计数值之后</span></span><br><span class="line">    <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="keyword">int32</span>(delta) &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v&gt;0 : 计数值不等于0，不需要唤醒等待者，直接返回</span></span><br><span class="line">    <span class="comment">// w==0: 没有等待者，不需要唤醒，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查数据是否一致</span></span><br><span class="line">    <span class="keyword">if</span> *statep != state &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里说明计数值为0，且等待者大于0，需要唤醒所有的等待者，并把系统置为初始状态（0状态）</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将计数值和等待者数量都置为0</span></span><br><span class="line">    *statep = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒等待者</span></span><br><span class="line">    <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">        runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完成一个任务，将计数值减一，当计数值减为0时，需要唤醒所有的等待者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Add 方法用于添加一个计数值（负数相当于减），当计数值变为0后， Wait 方法阻塞的所有等待者都会被释放，计数值变为负数是非法操作，产生 panic，当计数值为0时（初始状态），Add 方法不能和 Wait 方法并发调用，需要保证 Add 方法在 Wait 方法之前调用，否则会 panic</p>
<h4 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用 Wait 方法会被阻塞，直到 计数值 变为0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取计数、等待数和信号量</span></span><br><span class="line">    statep, semap := wg.state()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := atomic.LoadUint64(statep)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数值</span></span><br><span class="line">        v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待者数量</span></span><br><span class="line">        w := <span class="keyword">uint32</span>(state)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数值数量为0，直接返回，无需等待</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里说明计数值数量大于0</span></span><br><span class="line">        <span class="comment">// 增加等待者数量：这里会有竞争，比如多个 Wait 调用，或者在同时调用 Add 方法，增加不成功会继续 for 循环</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 增加成功后，阻塞在信号量这里，等待被唤醒</span></span><br><span class="line">            runtime_Semacquire(semap)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 被唤醒的时候，应该是0状态。如果重用 WaitGroup，需要等 Wait 返回</span></span><br><span class="line">            <span class="keyword">if</span> *statep != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>根据源码分析，我们可以得到如何使用waitGroup可以避免panic：</p>
<p>1、保证 Add 在 Wait 前调用</p>
<p>2、Add 中不传递负数</p>
<p>3、任务完成后不要忘记调用 Done 方法，建议使用 defer wg.Done()</p>
<p>4、不要复制使用 WaitGroup，函数传递时使用指针传递</p>
<p>5、尽量不复用 WaigGroup，减少出问题的风险</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO的context</title>
    <url>/2021/01/21/GO%E7%9A%84context/</url>
    <content><![CDATA[<h2 id="场景问题"><a href="#场景问题" class="headerlink" title="场景问题"></a>场景问题</h2><p>通过done channel 可以用于协程间通信，由主协程告知子协程取消，结束，终止任务等</p>
<p>假如主协程中有多个任务1, 2, …m，主协程对这些任务有超时控制；而其中任务1又有多个子任务1, 2, …n，任务1对这些子任务也有自己的超时控制，那么这些子任务既要感知主协程的取消信号，也需要感知任务1的取消信号</p>
<p>如果还是使用done channel的用法，我们需要定义两个done channel，子任务们需要同时监听这两个done channel。如果层级更深，如果这些子任务还有子任务，那么使用done channel的方式将会变得非常繁琐且混乱</p>
<p>通过context，可以实现：</p>
<p>1.上层任务取消后，所有的下层任务都会被取消；</p>
<p>2.中间某一层的任务取消后，只会将当前任务的下层任务取消，而不会影响上层的任务以及同级任务</p>
<h2 id="context实现"><a href="#context实现" class="headerlink" title="context实现"></a>context实现</h2><p>context是Go并发编程中常用到一种编程模式， 使用context可以使开发者方便的在这些goroutine里传递request相关的数据、取消goroutine的signal或截止日期</p>
<h3 id="context接口"><a href="#context接口" class="headerlink" title="context接口"></a>context接口</h3><p>context包含4个接口方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type Context interface &#123;</span><br><span class="line"></span><br><span class="line">    Deadline() (deadline time.Time, ok bool)</span><br><span class="line"></span><br><span class="line">    Done() &lt;-chan struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Err() error</span><br><span class="line"></span><br><span class="line">    Value(key interface&#123;&#125;) interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Deadline：返回绑定当前context的任务被取消的截止时间；如果没有设定期限，将返回ok == false</p>
<p>Done：当绑定当前context的任务被取消时，将返回一个关闭的channel；如果当前context不会被取消，将返回nil</p>
<p>当一个父operation启动一个goroutine用于子operation，这些子operation不能够取消父operation。下面描述的WithCancel函数提供一种方式可以取消新创建的Context.</p>
<p>Context可以安全的被多个goroutine使用。开发者可以把一个Context传递给任意多个goroutine然后cancel这个context的时候就能够通知到所有的goroutine</p>
<p>Err：如果Done返回的channel没有关闭，将返回nil;如果Done返回的channel已经关闭，将返回非空的值表示任务结束的原因。如果是context被取消，Err将返回Canceled；如果是context超时，Err将返回DeadlineExceeded</p>
<p>Value： 返回context存储的键值对中当前key对应的值，如果没有对应的key,则返回nil</p>
<h3 id="emptyCtx"><a href="#emptyCtx" class="headerlink" title="emptyCtx"></a>emptyCtx</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An emptyCtx is never canceled, has no values, and has no deadline. It is not</span></span><br><span class="line"><span class="comment">// struct&#123;&#125;, since vars of this type must have distinct addresses.</span></span><br><span class="line">type emptyCtx int</span><br><span class="line"></span><br><span class="line">func (*emptyCtx) Deadline() (deadline time.Time, ok bool) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*emptyCtx) Done() &lt;-chan struct&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*emptyCtx) Err() error &#123;</span><br><span class="line">    <span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*emptyCtx) Value(key interface&#123;&#125;) interface&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *emptyCtx) <span class="built_in">String</span>() string &#123;</span><br><span class="line">    <span class="keyword">switch</span> e &#123;</span><br><span class="line">    <span class="keyword">case</span> background:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;context.Background&quot;</span></span><br><span class="line">    <span class="keyword">case</span> todo:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;context.TODO&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;unknown empty Context&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    background = <span class="keyword">new</span>(emptyCtx)</span><br><span class="line">    todo       = <span class="keyword">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Background() Context &#123;</span><br><span class="line">    <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TODO() Context &#123;</span><br><span class="line">    <span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般不会直接使用emptyCtx，emptyCtx没有任何功能，常用作顶层的context</p>
<p>通过Background和todo拿到两个emptyCtx实例：</p>
<p>Background：通常被用于主函数、初始化以及测试中，作为一个顶层的context，也就是说一般我们创建的context都是基于Background</p>
<p>TODO：是在不确定使用什么context的时候才会使用</p>
<h3 id="valueCtx"><a href="#valueCtx" class="headerlink" title="valueCtx"></a>valueCtx</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type valueCtx struct &#123;</span><br><span class="line">	Context   <span class="comment">// 继承父节点conntext</span></span><br><span class="line">	key, val interface&#123;&#125; <span class="comment">// 携带键值对</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func WithValue(parent Context, key, val interface&#123;&#125;) Context &#123;</span><br><span class="line">	<span class="keyword">if</span> key == nil &#123;</span><br><span class="line">		panic(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">		panic(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *valueCtx) Value(key interface&#123;&#125;) interface&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>0.有一个context变量作为父节点</p>
<p>1.用一个context变量，继承父节点的context的所有信息，并且携带kv结构，可以携带额外信息</p>
<p>2.valueCtx实现了Value方法，用以在context链路上获取key对应的值，如果当前context上不存在需要的key,会沿着context链向上寻找key对应的值，直到根节点， 获取value的过程就是在这条context链上由尾部上前搜寻</p>
<p>3.WithValue用以向context添加键值对</p>
<p>4.添加键值对不是在原context结构体上直接添加，而是以此context作为父节点，重新创建一个新的valueCtx子节点，将键值对添加在子节点上，由此形成一条context链</p>
<h3 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type cancelCtx struct &#123;</span><br><span class="line">    Context</span><br><span class="line"></span><br><span class="line">    mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">    done     chan struct&#123;&#125;         <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">    children map[canceler]struct&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      error                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type canceler interface &#123;</span><br><span class="line">    cancel(removeFromParent bool, err error)</span><br><span class="line">    Done() &lt;-chan struct&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.cancelCtx中也有一个context变量作为父节点</p>
<p>2.done表示一个channel，用来表示传递关闭信号</p>
<p>3.children是个map，存储子节点</p>
<p>4.err用于存储错误信息表示任务结束的原因</p>
<h4 id="cancel方法"><a href="#cancel方法" class="headerlink" title="cancel方法"></a>cancel方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func (c *cancelCtx) Done() &lt;-chan struct&#123;&#125; &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.done == nil &#123;</span><br><span class="line">        c.done = make(chan struct&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    d := c.done</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *cancelCtx) Err() error &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    err := c.err</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *cancelCtx) <span class="function"><span class="title">cancel</span>(<span class="params">removeFromParent bool, err error</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == nil &#123;</span><br><span class="line">        panic(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.err != nil &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置取消原因</span></span><br><span class="line">    c.err = err</span><br><span class="line">    设置一个关闭的channel或者将done channel关闭，用以发送关闭信号</span><br><span class="line">    <span class="keyword">if</span> c.done == nil &#123;</span><br><span class="line">        c.done = closedchan</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(c.done)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将子节点context依次取消</span></span><br><span class="line">    <span class="keyword">for</span> child := range c.children &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    c.children = nil <span class="comment">// 后续就不用removeFromParent了</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        <span class="comment">// 将当前context节点从父节点上移除</span></span><br><span class="line">        removeChild(c.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cancel 有两个参数，一个是 removeFromParent，表示当前的取消操作是否需要把自己从父 Context 中移除，第二个参数就是执行取消操作需要返回的错误提示</p>
<p>1.如果 c.done 是 nil (父 Context 是 emptyCtx 的情况)，就赋值 closedchan，  closedchan 是一个被关闭的channel</p>
<p>2.如果不是nil，就直接关闭。然后递归关闭子 Context。</p>
<p>3.关闭子 Context 的时候，removeFromParent 参数传值是 false，这是因为当前 Context 在关闭的时候，把 child 置成了 nil，所以子 Context 就不用再执行一次从父 Context 移除自身的操作了</p>
<h4 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h4><p>WithCancel函数用来创建一个可取消的context，即cancelCtx类型的context。WithCancel返回一个context和一个CancelFunc，调用CancelFunc即可触发cancel操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type CancelFunc func()</span><br><span class="line"></span><br><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newCancelCtx returns an initialized cancelCtx.</span></span><br><span class="line">func newCancelCtx(parent Context) cancelCtx &#123;</span><br><span class="line">    <span class="comment">// 将parent作为父节点context生成一个新的子节点</span></span><br><span class="line">    <span class="keyword">return</span> cancelCtx&#123;<span class="attr">Context</span>: parent&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">propagateCancel</span>(<span class="params">parent Context, child canceler</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> parent.Done() == nil &#123;</span><br><span class="line">        <span class="comment">// parent.Done()返回nil表明父节点以上的路径上没有可取消的context</span></span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取最近的类型为cancelCtx的祖先节点</span></span><br><span class="line">    <span class="keyword">if</span> p, <span class="attr">ok</span> := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> p.err != nil &#123;</span><br><span class="line">            <span class="comment">// parent has already been canceled</span></span><br><span class="line">            child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> p.children == nil &#123;</span><br><span class="line">                p.children = make(map[canceler]struct&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前子节点加入最近cancelCtx祖先节点的children中</span></span><br><span class="line">            p.children[child] = struct&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        go <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="xml">&lt;-parent.Done():</span></span><br><span class="line"><span class="xml">                child.cancel(false, parent.Err())</span></span><br><span class="line">            case &lt;-child.Done():</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func parentCancelCtx(parent Context) (*cancelCtx, bool) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        switch c := parent.(type) &#123;</span><br><span class="line">        case *cancelCtx:</span><br><span class="line">            return c, true</span><br><span class="line">        case *timerCtx:</span><br><span class="line">            return &amp;c.cancelCtx, true</span><br><span class="line">        case *valueCtx:</span><br><span class="line">            parent = c.Context</span><br><span class="line">        default:</span><br><span class="line">            return nil, false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cancelCtx取消时，会将后代节点中所有的cancelCtx都取消</p>
<p>propagateCancel即用来建立当前节点与祖先节点这个取消关联逻辑</p>
<p>流程：</p>
<p>1.判断parent.Done() == nil，表明父节点以上的路径上没有可取消的context，不需要处理</p>
<p>2.如果在context链上找到到cancelCtx类型的祖先节点，则判断这个祖先节点是否已经取消，如果已经取消就取消当前节点；否则将当前节点加入到祖先节点的children列表</p>
<p>3.否则开启一个协程，监听parent.Done()和child.Done()，一旦parent.Done()返回的channel关闭，即context链中某个祖先节点context被取消，则将当前context也取消</p>
<h3 id="timerCtx"><a href="#timerCtx" class="headerlink" title="timerCtx"></a>timerCtx</h3><p>timerCtx是一种基于cancelCtx的context类型，可以定时取消</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type timerCtx struct &#123;</span><br><span class="line">    cancelCtx</span><br><span class="line">    timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">    deadline time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *timerCtx) Deadline() (deadline time.Time, ok bool) &#123;</span><br><span class="line">    <span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *timerCtx) <span class="function"><span class="title">cancel</span>(<span class="params">removeFromParent bool, err error</span>)</span> &#123;</span><br><span class="line">    将内部的cancelCtx取消</span><br><span class="line">    c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        <span class="comment">// Remove this timerCtx from its parent cancelCtx&#x27;s children.</span></span><br><span class="line">        removeChild(c.cancelCtx.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.timer != nil &#123;</span><br><span class="line">        取消计时器</span><br><span class="line">        c.timer.Stop()</span><br><span class="line">        c.timer = nil</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部使用 cancelCtx实现取消，定时器timer，和过期时间deadline实现定时取消功能</p>
<p>timerCtx取消时，也就是调用cancel方法，如上面注释所示<br>1.先将内部的cancelCtx取消，调用cancelCtx的cancel方法，</p>
<p>2.如果需要则将自己从cancelCtx祖先节点上移除</p>
<p>3.取消计时器</p>
<h4 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a>WithDeadline</h4><p>通过该方法，可以返回一个基于parent的可取消的context，过期时间设置为d</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) &#123;</span><br><span class="line">    <span class="keyword">if</span> cur, <span class="attr">ok</span> := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">        <span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line">        <span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">    &#125;</span><br><span class="line">    c := &amp;timerCtx&#123;</span><br><span class="line">        cancelCtx: newCancelCtx(parent),</span><br><span class="line">        deadline:  d,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立新建context与可取消context祖先节点的取消关联关系</span></span><br><span class="line">    propagateCancel(parent, c)</span><br><span class="line">    dur := time.Until(d)</span><br><span class="line">    <span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">        <span class="keyword">return</span> c, <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    defer c.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> c.err == nil &#123;</span><br><span class="line">        c.timer = time.AfterFunc(dur, <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c, <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.如果父节点parent有过期时间并且过期时间早于d，那么新建的子节点context无需设置过期时间，使用WithCancel创建一个可取消的context</p>
<p>2.不满足以上条件，用parent和过期时间d创建一个定时取消的timerCtx，并建立新建context与可取消context祖先节点的取消关联关系</p>
<p>3.判断当前时间距离过期时间d的时长dur</p>
<p>4.dur小于0，即当前已经过了过期时间，则直接取消新建的timerCtx，原因为DeadlineExceeded</p>
<p>5.为新建的timerCtx设置定时器，一旦到达过期时间即取消当前timerCtx</p>
<h4 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a>WithTimeout</h4><p>该方法最终也是withDeadline，只不过接收的不是一个时间点，而是一个时间时长timeout</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) &#123;</span><br><span class="line">    <span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h4 id="ctx控制goroutine生命周期"><a href="#ctx控制goroutine生命周期" class="headerlink" title="ctx控制goroutine生命周期"></a>ctx控制goroutine生命周期</h4><p>Context 可以被用来控制 goroutine 的生命周期，从而避免出现 goroutine 泄漏或者不必要的等待操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">users</span><span class="params">(ctx context.Context, req *Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 启动一个 goroutine 来处理请求</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 处理请求...</span></span><br><span class="line">    &#125;(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 Context 对象作为参数传递给了 goroutine 函数，这样在请求被取消时，goroutine 就可以及时退出。</p>
<h4 id="withValue传递数据"><a href="#withValue传递数据" class="headerlink" title="withValue传递数据"></a>withValue传递数据</h4><p>Context 还可以被用来在不同的 goroutine 之间传递请求域的相关数据。为了实现这个目的，我们可以使用Context 的 WithValue() 方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> key <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    userKey key = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">users</span><span class="params">(ctx context.Context, req *Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从请求中获取用户信息</span></span><br><span class="line">    user := req.GetUser</span><br><span class="line">    <span class="comment">// 将用户信息保存到 Context 中</span></span><br><span class="line">    ctx = context.WithValue(ctx, userKey, user)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动一个 goroutine 来处理请求</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 从 Context 中获取用户信息</span></span><br><span class="line">        user := ctx.Value(userKey).(*User)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 处理请求...</span></span><br><span class="line">    &#125;(ctx)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 goroutine 函数中，我们使用 <code>ctx.Value()</code>方法来获取 Context 中保存的用户信息。</p>
<p>Context 中保存的键值对数据应该是线程安全的，因为它们可能会在多个 goroutine 中同时访问</p>
<h4 id="withCancel取消操作"><a href="#withCancel取消操作" class="headerlink" title="withCancel取消操作"></a>withCancel取消操作</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">users</span><span class="params">(ctx context.Context, req *Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个可以取消的 Context 对象</span></span><br><span class="line">    ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个 goroutine 来处理请求</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 等待请求完成或者被取消</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">            <span class="comment">// 请求完成</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;Request finish&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="comment">// 请求被取消</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;Request canceled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(ctx)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待一段时间后取消请求</span></span><br><span class="line">    time.Sleep(time.Millisecond * <span class="number">800</span>)</span><br><span class="line">    cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用 WithCancel() 方法创建了一个可以取消的 Context 对象，并将取消操作封装在了一个 cancel() 函数中。然后我们启动了一个 goroutine 函数，使用 select 语句等待请求完成或者被取消，最后在主函数中等待一段时间后调用 cancel() 函数来取消请求。</p>
<h4 id="withDeadline设置截止时间"><a href="#withDeadline设置截止时间" class="headerlink" title="withDeadline设置截止时间"></a>withDeadline设置截止时间</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">users</span><span class="params">(ctx context.Context, req *Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置请求的截止时间为当前时间加上 1 秒钟</span></span><br><span class="line">    ctx, cancel := context.WithDeadline(ctx, time.Now().Add(time.Second))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个 goroutine 来处理请求</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 等待请求完成或者超时</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-time.After(time.Millisecond * <span class="number">500</span>):</span><br><span class="line">            <span class="comment">// 请求完成</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;Request finish&quot;</span>)</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="comment">// 请求超时或者被取消</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;Request canceled or timed out&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(ctx)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待一段时间后取消请求</span></span><br><span class="line">    time.Sleep(time.Millisecond * <span class="number">1500</span>)</span><br><span class="line">    cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用 WithDeadline() 方法设置了一个截止时间为当前时间加上 1 秒钟的 Context 对象，并将超时操作封装在了一个 cancel() 函数中。然后我们启动了一个 goroutine 函数，使用 select 语句等待请求完成或者超时，最后在主函数中等待一段时间后调用 cancel() 函数来取消请求。</p>
<p>在使用 WithDeadline() 方法设置截止时间的时候，如果截止时间已经过期，则 Context 对象将被立即取消。</p>
<h4 id="withTimeout设置超时时间"><a href="#withTimeout设置超时时间" class="headerlink" title="withTimeout设置超时时间"></a>withTimeout设置超时时间</h4><p>除了使用 WithDeadline() 方法进行截止时间设置之外，Context 还可以被用来设置超时时间</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">users</span><span class="params">(ctx context.Context, req *Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置请求的超时时间为 1 秒钟</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(ctx, time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个 goroutine 来处理请求</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 等待请求完成或者超时</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Millisecond * <span class="number">500</span>):</span><br><span class="line">            <span class="comment">// 请求完成</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;Request completed&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="comment">// 请求超时或者被取消</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;Request canceled or timed out&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(ctx)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待一段时间后取消请求</span></span><br><span class="line">    time.Sleep(time.Millisecond * <span class="number">1500</span>)</span><br><span class="line">    cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ctx传递"><a href="#ctx传递" class="headerlink" title="ctx传递"></a>ctx传递</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">users</span><span class="params">(ctx context.Context, req *Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在处理 HTTP 请求的函数中创建 Context 对象</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(ctx, time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用数据库查询函数并传递 Context 对象</span></span><br><span class="line">    result, err := findUserByName(ctx, req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 处理查询错误...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理查询结果...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUserByName</span><span class="params">(ctx context.Context, req *Request)</span> <span class="params">(*Result, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在数据库查询函数中使用传递的 Context 对象</span></span><br><span class="line">    rows, err := db.QueryContext(ctx, <span class="string">&quot;SELECT * FROM users WHERE name = ?&quot;</span>, req.Name)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">     <span class="comment">// 处理查询错误...</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> rows.Close()</span><br><span class="line">   <span class="comment">// 处理查询结果...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在处理 HTTP 请求的函数中创建了一个 Context 对象，并将它作为参数传递给了一个数据库查询函数 findUserByName()。在 findUserByName() 函数中，我们使用传递的 Context 对象来调用 db.QueryContext() 方法进行查询操作。由于传递的 Context 对象可能会在查询过程中被取消，因此我们需要在查询完成后检查查询操作的错误，以便进行相应的处理。</p>
<p>在进行 Context 的传递时，我们需要保证传递的 Context 对象是原始 Context 对象的子 Context，以便在需要取消操作时能够同时取消所有相关的 goroutine。如果传递的 Context 对象不是原始 Context 对象的子 Context，则取消操作只会影响到当前 goroutine，而无法取消其他相关的 goroutine。</p>
<h4 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h4><p>Context 可以用于管理 goroutine 的生命周期和取消操作，避免出现资源泄漏和死锁等问题，同时也可以提高应用程序的性能和可维护性。</p>
<ul>
<li>在创建 goroutine 时，需要将原始 Context 对象作为参数传递给它。</li>
<li>在 goroutine 中，需要使用传递的 Context 对象来进行取消操作，以便能够及时释放相关的资源。</li>
<li>Context 的传递时，需要保证传递的 Context 对象是原始 Context 对象的子 Context，以便在需要取消操作时能够同时取消所有相关的 goroutine。</li>
<li>在使用 WithCancel 和 WithTimeout 方法创建 Context 对象时，需要及时调用 cancel 函数，以便能够及时释放资源。</li>
<li>在一些场景下，可以使用 WithValue 方法将数据存储到 Context 中，以便在不同的 goroutine 之间共享数据。</li>
</ul>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO环境安装</title>
    <url>/2020/12/19/GO%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="安装包下载、安装"><a href="#安装包下载、安装" class="headerlink" title="安装包下载、安装"></a>安装包下载、安装</h2><p>去官网下载go安装包即可，根据自己的操作系统。</p>
<p>提取到 /usr/local 目录，在 /usr/local/go 中创建Go目录树</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz</span><br></pre></td></tr></table></figure>
<p>sudo运行，或者root用户</p>
<h2 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h2><p>要将 /usr/local/go/bin 添加到 PATH 环境变量， 你需要将此行添加到你的 /etc/profile（全系统安装）或 $HOME/.profile 文件中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> PATH=$PATH:<span class="regexp">/usr/</span>local/go/bin</span><br></pre></td></tr></table></figure>

<p>如果安装到其他位置，则需要设置GOROOT</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> GOROOT=$HOME/go</span><br><span class="line"><span class="keyword">export</span> PATH=$PATH:$GOROOT/bin</span><br></pre></td></tr></table></figure>

<h2 id="相关环境变量参数"><a href="#相关环境变量参数" class="headerlink" title="相关环境变量参数"></a>相关环境变量参数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">go env</span><br><span class="line">go version</span><br></pre></td></tr></table></figure>

<p>go env可查看go的环境变量参数，go version 可查看go的版本</p>
<h3 id="GO111Module"><a href="#GO111Module" class="headerlink" title="GO111Module"></a>GO111Module</h3><p>go 1.11才有的特性</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">export GO111MODULE=on # 开启GoModule特性</span><br></pre></td></tr></table></figure>
<p>GO111MODULE解释, 当为on时则使用Go Modules,go 会忽略 $GOPATH和 vendor文件夹,只根据go.mod下载依赖。</p>
<p>当为 off时则不适用新特性 Go Modules支持，它会查找 vendor目录和 $GOPATH来查找依赖关系，也就是继续使用“GOPATH模式”。</p>
<p>当为 auto时或未设置时则根据当前项目目录下是否存在 go.mod文件或 $GOPATH/src之外并且其本身包含go.mod文件时才会使用新特性 Go Modules模式，</p>
<p>并且auto为 GO111MODULE的默认值。</p>
<h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><p>表示go的工作目录，这个目录指定了需要从哪个地方寻找GO的包、可执行程序等，这个目录可以是多个目录表示</p>
<h3 id="GOROOT"><a href="#GOROOT" class="headerlink" title="GOROOT"></a>GOROOT</h3><p>表示的是go语言编译、工具、标准库等的安装路径。</p>
<p>在Linux下设置GOROOT目录：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> GOROOT=$HOME/go</span><br></pre></td></tr></table></figure>

<h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h3><p>简单来说就是一个代理，让我们更方便的下载哪些由于墙的原因而导致无法下载的第三方包，</p>
<p><a href="http://proxy.golang.org/">http://proxy.golang.org</a> 在中国无法访问，故而建议使用 <a href="http://goproxy.cn/">http://goproxy.cn</a> 作为替代</p>
<h2 id="GO-MOD"><a href="#GO-MOD" class="headerlink" title="GO MOD"></a>GO MOD</h2><h3 id="初始化模块"><a href="#初始化模块" class="headerlink" title="初始化模块"></a>初始化模块</h3><p>go mod init &lt;项目模块名称&gt;</p>
<h3 id="依赖关系处理-根据go-mod文件"><a href="#依赖关系处理-根据go-mod文件" class="headerlink" title="依赖关系处理 ,根据go.mod文件"></a>依赖关系处理 ,根据go.mod文件</h3><p>go mod tidy</p>
<h3 id="将依赖包复制到项目下的-vendor目录。"><a href="#将依赖包复制到项目下的-vendor目录。" class="headerlink" title="将依赖包复制到项目下的 vendor目录。"></a>将依赖包复制到项目下的 vendor目录。</h3><p>go mod vendor<br>如果包被屏蔽(墙),可以使用这个命令，随后使用go build -mod=vendor编译</p>
<h3 id="显示依赖关系"><a href="#显示依赖关系" class="headerlink" title="显示依赖关系"></a>显示依赖关系</h3><p>go list -m all</p>
<h3 id="显示详细依赖关系"><a href="#显示详细依赖关系" class="headerlink" title="显示详细依赖关系"></a>显示详细依赖关系</h3><p>go list -m -json all</p>
<h3 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h3><p>go mod download [path@version]<br>[path@version]是非必写的</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO的make和new的区别</title>
    <url>/2020/12/21/GO%E7%9A%84make%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>Go有两个数据结构创建函数：new和make。两者的区别在学习Go语言的初期是一个常见的混淆点。基本的区别是new(T)返回一个* T，返回的这个指针可以被隐式地消除引用（图中的黑色箭头）。而make(T, args)返回一个普通的T。通常情况下，T内部有一些隐式的指针（图中的灰色箭头）。一句话，new返回一个指向已清零内存的指针，而make返回一个复杂的结构。<br>二者都是内存的分配（堆上），但是make只用于slice、map以及channel的初始化（非零值）；而new用于类型的内存分配，并且内存置为零</p>
<p><img src="/2020/12/21/GO%E7%9A%84make%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" alt="1"></p>
<h2 id="new与make"><a href="#new与make" class="headerlink" title="new与make"></a>new与make</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new 可以开辟一个内存，然后返回这个内存的地址。</p>
<p>简单类型还可以初始化零值，int，string</p>
<p>复杂类型也可以开辟内存，初始化的是nil</p>
<p>nil的指针赋值会存在问题</p>
<p>声明一个大小为5的数组，go会自动为数组的item初始化为零值，数组可以通过索引读取和赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]int</span><br><span class="line">fmt.Printf(<span class="string">&quot;arr: %p %#v \n&quot;</span>, &amp;arr, arr) <span class="comment">// arr: 0xc420014180 [5]int&#123;0, 0, 0, 0, 0&#125; </span></span><br><span class="line">arr[<span class="number">0</span>], arr[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;arr: %p %#v \n&quot;</span>, &amp;arr, arr) <span class="comment">// arr: 0xc420014180 [5]int&#123;1, 2, 0, 0, 0&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果声明的是一个数组指针，即一个指针的类型是数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrPot *[<span class="number">5</span>]int</span><br><span class="line">fmt.Printf(<span class="string">&quot;arrPot: %p %#v \n&quot;</span>, &amp;arrPot, arrPot) <span class="comment">// arrPot: 0xc42000c040 (*[5]int)(nil)</span></span><br></pre></td></tr></table></figure>
<p>初始化的值是nil，nil是不能赋值的</p>
<p>我们可以new一块内存地址出来，赋给指针，这个指针取值就可以赋值了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrPot *[<span class="number">5</span>]int</span><br><span class="line">fmt.Printf(<span class="string">&quot;arrPot: %p %#v \n&quot;</span>, &amp;arrPot, arrPot) <span class="comment">// arrPot: 0xc42000c040 (*[5]int)(nil) </span></span><br><span class="line"></span><br><span class="line">arrPot = <span class="keyword">new</span>([<span class="number">5</span>]int)</span><br><span class="line">fmt.Printf(<span class="string">&quot;arrPot: %p %#v \n&quot;</span>, &amp;arrPot, arrPot) <span class="comment">// arrPot: 0xc42000c040 &amp;[5]int&#123;0, 0, 0, 0, 0&#125; </span></span><br><span class="line">(*arrPot)[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;arrPot: %p %#v \n&quot;</span>, &amp;arrPot, arrPot) <span class="comment">// arrPot: 0xc42000c040 &amp;[5]int&#123;11, 0, 0, 0, 0&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>array是虽然是复合类型，但不是引用类型。go中的引用类似是slice，map等</p>
<p>声明一个map类型的变量，map不像array那样声明之后可以初始化成零值。go会给引用类型初始化为nil，nil是不能直接赋值的</p>
<p>map不能用new去申请内存，用make，make不仅可以开辟一个内存，还能给这个内存的类型初始化其零值，同时返回这个内存实例</p>
<p>make 也可以申请slice，channel</p>
<p>申请slice： 三个参数，第一个基本结构类型，第二个长度，第三个容量<br>申请map：两个参数， 第一个基本结构，第二个容量、长度</p>
<p>初始化需要提前申请好，防止发生扩容</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO的内存分配</title>
    <url>/2021/01/06/GO%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">go tool compile -S main.go</span><br></pre></td></tr></table></figure>
<p>通过以上查看汇编代码可以看到内存申请情况，runtime.newobject是用于申请内存的内建函数，newobject是mallocgc的代理，mallocgc是管理堆内存的函数。Go分配内存有两种策略：小块内存申请和大块内存申请</p>
<h2 id="内存管理基本结构"><a href="#内存管理基本结构" class="headerlink" title="内存管理基本结构"></a>内存管理基本结构</h2><p>golang的内存管理如下：</p>
<p><img src="/2021/01/06/GO%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1.png" alt="1"></p>
<h3 id="MSpan"><a href="#MSpan" class="headerlink" title="MSpan"></a>MSpan</h3><p>内存管理的基本单位是MSpan。MSpan是一个表示若干连续内存页（8KB）的数据结构</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct MSpan</span><br><span class="line">&#123;</span><br><span class="line">    PageID    start;        <span class="comment">// starting page number</span></span><br><span class="line">    uintptr    npages;        <span class="comment">// number of pages in span</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>基地址+(页号* 页大小)，就可以定位到这个MSpan的实际的地址空间<br>PS：连续页，PageID是起始id，npages是数量</p>
<p>每个 mspan按照它自身的属性 SizeClass的大小分割成若干个 object，每个 object可存储一个对象</p>
<p>Size_Class = Span_Class / 2</p>
<p>这是因为其实每个 SizeClass有两个 mspan，也就是有两个 SpanClass。其中一个分配给含有指针的对象，另一个分配给不含有指针的对象，每个等级SizeClass会存在两份mspan链表：一个链表用于存储内部不包含指针的对象，另一个链表用于存储内部包含指针的对象。这么的好处是垃圾回收时更高效，因为不需要扫描不包含指针的那个mspan链表</p>
<p>mspan按大小被划分为大约67个等级的object，大小从8字节到32K字节不等，不同等级存储不同大小的object内存块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _NumSizeClasses = <span class="number">67</span></span><br><span class="line"><span class="keyword">var</span> class_to_size = [_NumSizeClasses]uint16&#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>, <span class="number">144</span>, <span class="number">160</span>, <span class="number">176</span>, <span class="number">192</span>, <span class="number">208</span>, <span class="number">224</span>, <span class="number">240</span>, <span class="number">256</span>, <span class="number">288</span>, <span class="number">320</span>, <span class="number">352</span>, <span class="number">384</span>, <span class="number">416</span>, <span class="number">448</span>, <span class="number">480</span>, <span class="number">512</span>, <span class="number">576</span>, <span class="number">640</span>, <span class="number">704</span>, <span class="number">768</span>, <span class="number">896</span>, <span class="number">1024</span>, <span class="number">1152</span>, <span class="number">1280</span>, <span class="number">1408</span>, <span class="number">1536</span>,<span class="number">1792</span>, <span class="number">2048</span>, <span class="number">2304</span>, <span class="number">2688</span>, <span class="number">3072</span>, <span class="number">3200</span>, <span class="number">3456</span>, <span class="number">4096</span>, <span class="number">4864</span>, <span class="number">5376</span>, <span class="number">6144</span>, <span class="number">6528</span>, <span class="number">6784</span>, <span class="number">6912</span>, <span class="number">8192</span>, <span class="number">9472</span>, <span class="number">9728</span>, <span class="number">10240</span>, <span class="number">10880</span>, <span class="number">12288</span>, <span class="number">13568</span>, <span class="number">14336</span>, <span class="number">16384</span>, <span class="number">18432</span>, <span class="number">19072</span>, <span class="number">20480</span>, <span class="number">21760</span>, <span class="number">24576</span>, <span class="number">27264</span>, <span class="number">28672</span>, <span class="number">32768</span>&#125;</span><br></pre></td></tr></table></figure>

<p>比如 SizeClass等于3， object大小就是32B。 32B大小的object可以存储对象大小范围在17B到32B的对象。而对于微小对象（小于16B），分配器会将其进行合并，将几个对象分配到同一个 object中</p>
<p>最大的数是32768，也就是32KB，超过此大小就是大对象了，要直接从mheap堆上分配</p>
<p>对于mspan来说，它的 SizeClass会决定它所能分到的页数，这也是写死在代码里的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path: /usr/local/go/src/runtime/sizeclasses.go</span></span><br><span class="line"><span class="keyword">const</span> _NumSizeClasses = <span class="number">67</span></span><br><span class="line"><span class="keyword">var</span> class_to_allocnpages = [_NumSizeClasses]uint8&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如当我们要申请一个 object大小为 32B的 mspan的时候，在classtosize里对应的索引是3，而索引3在 class_to_allocnpages数组里对应的页数就是1，即为8KB</p>
<p>一个 mspan的 SizeClass等于10，根据前面的 class_to_size数组，得出这个 msapn分割的 object大小是144B，算出可分配的对象个数是 8KB/144B=56.89个，取整56个，所以会有一些内存浪费掉了，Go的源码里有所有 SizeClass的 mspan浪费的内存的大小；再根据 class_to_allocnpages数组，得到这个 mspan只由1个 page组成；假设这个 mspan是分配给无指针对象的，那么 spanClass等于20</p>
<h3 id="MHeap分配堆"><a href="#MHeap分配堆" class="headerlink" title="MHeap分配堆"></a>MHeap分配堆</h3><p>代表Go程序持有的所有堆空间，Go程序使用一个 mheap的全局对象 mheap来管理堆内存</p>
<p>MHeap层次用于直接分配较大(&gt;32kB)的内存空间，以及给MCentral和MCache等下层提供空间</p>
<p>mheap主要用于大对象的内存分配，以及管理未切割的 mspan，用于给 mcentral切割成小对象</p>
<p>mheap中含有所有规格的 mcentral，所以，当一个 mcache从 mcentral申请 mspan时，只需要在独立的 mcentral中使用锁，并不会影响申请其他规格的 mspan</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//path: /usr/local/go/src/runtime/mheap.go</span></span><br><span class="line">type mheap struct &#123;</span><br><span class="line">	lock mutex</span><br><span class="line">	<span class="comment">// spans: 指向mspans区域，用于映射mspan和page的关系</span></span><br><span class="line">	spans []*mspan</span><br><span class="line">	<span class="comment">// 指向bitmap首地址，bitmap是从高地址向低地址增长的</span></span><br><span class="line">	bitmap uintptr</span><br><span class="line">	<span class="comment">// 指示arena区首地址</span></span><br><span class="line">	arena_start uintptr</span><br><span class="line">	<span class="comment">// 指示arena区已使用地址位置</span></span><br><span class="line">	arena_used uintptr</span><br><span class="line">	<span class="comment">// 指示arena区末地址</span></span><br><span class="line">	arena_end uintptr</span><br><span class="line">	central [<span class="number">67</span>*<span class="number">2</span>]struct &#123;</span><br><span class="line">		mcentral mcentral</span><br><span class="line">		pad [sys.CacheLineSize - unsafe.Sizeof(mcentral&#123;&#125;)%sys.CacheLineSize]byte</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MCentral"><a href="#MCentral" class="headerlink" title="MCentral"></a>MCentral</h3><p>为所有 mcache提供切分好的 mspan资源。每个 central保存一种特定大小的全局 mspan列表，包括已分配出去的和未分配出去的。 每个 mcentral对应一种 mspan，而 mspan的种类导致它分割的 object大小不同。当工作线程的 mcache中没有合适（也就是特定大小的）的 mspan时就会从 mcentral获取</p>
<p>MCentral被所有的工作线程共同享有，存在多个Goroutine竞争的情况，因此会消耗锁资源</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct MCentral</span><br><span class="line">&#123;</span><br><span class="line">    Lock;</span><br><span class="line">    int32 sizeclass;</span><br><span class="line">    MSpan nonempty;</span><br><span class="line">    MSpan empty;</span><br><span class="line">    int32 nfree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个维护了两张全局的mspan链表。一张链表为non-empty类型，包含了可供分配的mspan（由于一个span可能包含多个object，只要有一个或一个以上的object可供分配即表示该mspan可供分配），一张为empty类型，包含已分配完毕的mspan</p>
<p>1.获取 加锁；从 nonempty链表找到一个可用的 mspan；并将其从 nonempty链表删除；将取出的 mspan加入到 empty链表；将 mspan返回给工作线程；解锁。<br>2.归还 加锁；将 mspan从 empty链表删除；将 mspan加入到 nonempty链表；解锁</p>
<p>PS：当Go执行垃圾回收时，如果span中的内存块被标记为可供分配，span会重新加入到non-empty链表中</p>
<p><img src="/2021/01/06/GO%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/3.png" alt="3"></p>
<p>当mcentral中也没有可供分配的span时，Go会从堆上申请新的span并将其放入mcentral中进行切分</p>
<h3 id="MCache本地小块内存"><a href="#MCache本地小块内存" class="headerlink" title="MCache本地小块内存"></a>MCache本地小块内存</h3><p>对于32KB以下的小块内存申请，Go会从本地缓存mcache中获取内存。</p>
<p>每一个M都有一个自己的局部内存缓存MCache，这样分配小对象的时候直接从MCache中分配，就不用加锁了，这是Go能够在多线程环境中高效地进行内存分配的重要原因</p>
<p>MCache是mspan切分后的列表，包含object的列表，提供可使用的内存，2倍的object列表，上面mspan已经提到过</p>
<p><img src="/2021/01/06/GO%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/2.png" alt="2"></p>
<p>mcache在初始化的时候是没有任何 mspan资源的，在使用过程中会动态地从 mcentral申请，之后会缓存下来。当对象小于等于32KB大小时，使用 mcache的相应规格的 mspan进行分配。</p>
<p>如果mcache上没有空闲的内存块可供分配该怎么办，则进入下一级mcentral</p>
<h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><p>堆在必要时向操作系统申请内存。它会申请一块大内存，被称为arena，在64位系统下为64MB，其它大部分系统为4MB，申请的内存同样用span管理， 1M打底</p>
<p><img src="/2021/01/06/GO%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/4.png" alt="4"></p>
<p><img src="/2021/01/06/GO%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/5.png" alt="5"></p>
<p>arena：堆区，运行时该区域每8KB会被划分成一个页，存储了所有在堆上初始化的对象</p>
<p>bitmap：标识arena中哪些地址保存了对象，bitmap中一个字节的内存对应arena区域中4个指针大小的内存，并标记了是否包含指针和是否扫描的信息（一个指针大小为8B，因此bitmap的大小为512GB/(4* 8)=16GB）</p>
<p>spans：存放mspan的指针，其中每个mspan会包含多个页，spans中一个指针（8B）表示arena中某一个page（8KB），因此spans的大小为512GB/(1024)=512MB</p>
<h2 id="内存分配流程"><a href="#内存分配流程" class="headerlink" title="内存分配流程"></a>内存分配流程</h2><p>Go的内存分配器在分配对象时，根据对象的大小，分成三类：小对象（小于等于16B）、一般对象（大于16B，小于等于32KB）、大对象（大于32KB）</p>
<p>1.&gt;32KB 的对象，直接从mheap上分配</p>
<p>2.&lt;=16B 的对象使用mcache的tiny分配器分配</p>
<p>3.(16B,32KB] 的对象，首先计算对象的规格大小，然后使用mcache中相应规格大小的mspan分配</p>
<p>4.如果mcache没有相应规格大小的mspan，则向mcentral申请</p>
<p>5.如果mcentral没有相应规格大小的mspan，则向mheap申请</p>
<p>6.如果mheap中也没有合适大小的mspan，则向操作系统申请</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.Go在程序启动时，会向操作系统申请一大块内存，之后自行管理（仅仅是虚拟的地址空间，并不会真正分配内存）。</p>
<p>2.Go内存管理的基本单元是mspan，它由若干个页组成，每种mspan可以分配特定大小的object。</p>
<p>3.mcache, mcentral, mheap是Go内存管理的三大组件，层层递进。<br>mcache管理线程在本地缓存的mspan；<br>mcentral管理全局的mspan供所有线程使用；<br>mheap管理Go的所有动态分配内存。</p>
<p>4.极小对象会分配在一个object中，以节省资源，使用tiny分配器分配内存；一般小对象通过mspan分配内存；大对象则直接由mheap分配内存</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO的协程：goroutine</title>
    <url>/2021/01/04/GO%E7%9A%84%E5%8D%8F%E7%A8%8B%EF%BC%9Agoroutine/</url>
    <content><![CDATA[<p>线程其实并不是真正运行的实体, 线程只是代表一个执行流和其状态.真正运行驱动流程往前的其实是 CPU. CPU 在时钟的驱动下, 根据PC寄存器从程序中取指令和操作数,从RAM中取数据,进行计算,处理,跳转,驱动执行流往前.CPU并不关注处理的是线程还是协程, 只需要设置 PC 寄存器, 设置栈指针等(这些称为上下文), 那么 CPU 就可以运行这个线程或者这个协程了</p>
<p>线程的运行, 其实是被运行.其阻塞, 其实是切换出调度队列, 不再去调度执行这个执行流. 其他执行流满足其条件, 便会把被移出调度队列的执行流重新放回调度队列</p>
<p>协程其实也是一个数据结构,记录了要运行什么函数,运行到哪里了，go在用户态实现调度,所以go要有代表协程这种执行流的结构体, 也要有保存和恢复上下文的函数, 运行队列.</p>
<h2 id="调度相关数据结构"><a href="#调度相关数据结构" class="headerlink" title="调度相关数据结构"></a>调度相关数据结构</h2><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>每个go func都代表一个g，无限制数量，代表一个用户代码的执行流</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct G</span><br><span class="line">&#123;</span><br><span class="line">    uintptr    stackguard;    <span class="comment">// 分段栈的可用空间下界</span></span><br><span class="line">    uintptr    stackbase;    <span class="comment">// 分段栈的栈基址</span></span><br><span class="line">    Gobuf    sched;        <span class="comment">//进程切换时，利用sched域来保存上下文</span></span><br><span class="line">    uintptr    stack0;</span><br><span class="line">    FuncVal*    fnstart;        <span class="comment">// goroutine运行的函数</span></span><br><span class="line">    <span class="keyword">void</span>*    param;        <span class="comment">// 用于传递参数，睡眠时其它goroutine设置param，唤醒时此goroutine可以获取</span></span><br><span class="line">    int16    status;        <span class="comment">// 状态Gidle,Grunnable,Grunning,Gsyscall,Gwaiting,Gdead</span></span><br><span class="line">    int64    goid;        <span class="comment">// goroutine的id号</span></span><br><span class="line">    G*    schedlink;</span><br><span class="line">    M*    m;        <span class="comment">// for debuggers, but offset not hard-coded</span></span><br><span class="line">    M*    lockedm;    <span class="comment">// G被锁定只能在这个m上运行</span></span><br><span class="line">    uintptr    gopc;    <span class="comment">// 创建这个goroutine的go表达式的pc</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>真正代表协程的是 runtime.g 结构体. 每个 go func 都会编译成 runtime.newproc 函数, 最终有一个 runtime.g 对象放入调度队列，参数会在 newproc 函数里拷贝到 stack 中, sched 用于保存协程切换时的 pc 位置和栈位置</p>
<p>切换时并不必陷入到操作系统内核中，所以保存过程很轻量。看一下结构体G中的Gobuf，其实只保存了当前栈指针，程序计数器，以及goroutine自身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct Gobuf</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The offsets of these fields are known to (hard-coded in) libmach.</span></span><br><span class="line">    uintptr    sp;</span><br><span class="line">    byte*    pc;</span><br><span class="line">    G*    g;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>runtime.m,代表真正的OS线程, 每个m都是对应到一条操作系统的物理线程,最大一万个，代表执行者，底层线程</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct M</span><br><span class="line">&#123;</span><br><span class="line">    G*    g0;        <span class="comment">// 带有调度栈的goroutine</span></span><br><span class="line">    G*    gsignal;    <span class="comment">// signal-handling G 处理信号的goroutine</span></span><br><span class="line">    <span class="keyword">void</span>    (*mstartfn)(<span class="keyword">void</span>);</span><br><span class="line">    G*    curg;        <span class="comment">// M中当前运行的goroutine</span></span><br><span class="line">    P*    p;        <span class="comment">// 关联P以执行Go代码 (如果没有执行Go代码则P为nil)</span></span><br><span class="line">    P*    nextp;</span><br><span class="line">    int32    id;</span><br><span class="line">    int32    mallocing; <span class="comment">//状态</span></span><br><span class="line">    int32    throwing;</span><br><span class="line">    int32    gcing;</span><br><span class="line">    int32    locks;</span><br><span class="line">    int32    helpgc;        <span class="comment">//不为0表示此m在做帮忙gc。helpgc等于n只是一个编号</span></span><br><span class="line">    bool    blockingsyscall;</span><br><span class="line">    bool    spinning;</span><br><span class="line">    Note    park;</span><br><span class="line">    M*    alllink;    <span class="comment">// 这个域用于链接allm</span></span><br><span class="line">    M*    schedlink;</span><br><span class="line">    MCache    *mcache;</span><br><span class="line">    G*    lockedg;</span><br><span class="line">    M*    nextwaitm;    <span class="comment">// next M waiting for lock</span></span><br><span class="line">    GCStats    gcstats;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>M中还有一个MCache，是当前M的内存的缓存。M也和G一样有一个常驻寄存器变量，代表当前的M。同时存在多个M，表示同时存在多个物理线程。</p>
<p>结构体M中有两个G是需要关注一下的，一个是curg，代表结构体M当前绑定的结构体G。另一个是g0，是带有调度栈的goroutine，这是一个比较特殊的goroutine。普通的goroutine的栈是在堆上分配的可增长的栈，而g0的栈是M对应的线程的栈。所有调度相关的代码，会先切换到该goroutine的栈中再执行</p>
<h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>runtime.p,默认为机器核数，通过GOMAXPROCS环境变量设置，表示执行所需要的资源</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct P</span><br><span class="line">&#123;</span><br><span class="line">    Lock;</span><br><span class="line">    uint32    status;  <span class="comment">// Pidle或Prunning等</span></span><br><span class="line">    P*    link;</span><br><span class="line">    uint32    schedtick;   <span class="comment">// 每次调度时将它加一</span></span><br><span class="line">    M*    m;    <span class="comment">// 链接到它关联的M (nil if idle)</span></span><br><span class="line">    MCache*    mcache;</span><br><span class="line"></span><br><span class="line">    G*    runq[<span class="number">256</span>];</span><br><span class="line">    int32    runqhead;</span><br><span class="line">    int32    runqtail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Available G&#x27;s (status == Gdead)</span></span><br><span class="line">    G*    gfree;</span><br><span class="line">    int32    gfreecnt;</span><br><span class="line">    byte    pad[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在P中有一个Grunnable的goroutine队列，这是一个P的局部队列。当P执行Go代码时，它会优先从自己的这个局部队列中取，这时可以不用加锁，提高了并发度。如果发现这个队列空了，则去其它P的队列中拿一半过来，这样实现工作流窃取的调度。这种情况下是需要给调用器加锁的。</p>
<p>局部队列也就是本地队列</p>
<p>一个 P 可以与多个 M 对应，但同一时刻，这个 P 只能和其中一个 M 发生绑定关系</p>
<h3 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h3><p>在proc.c文件中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct Sched &#123;</span><br><span class="line">    Lock;</span><br><span class="line"></span><br><span class="line">    uint64    goidgen;</span><br><span class="line"></span><br><span class="line">    M*    midle;     <span class="comment">// idle m&#x27;s waiting for work</span></span><br><span class="line">    int32    nmidle;     <span class="comment">// number of idle m&#x27;s waiting for work</span></span><br><span class="line">    int32    nmidlelocked; <span class="comment">// number of locked m&#x27;s waiting for work</span></span><br><span class="line">    int3    mcount;     <span class="comment">// number of m&#x27;s that have been created</span></span><br><span class="line">    int32    maxmcount;    <span class="comment">// maximum number of m&#x27;s allowed (or die)</span></span><br><span class="line"></span><br><span class="line">    P*    pidle;  <span class="comment">// idle P&#x27;s</span></span><br><span class="line">    uint32    npidle;  <span class="comment">//idle P的数量</span></span><br><span class="line">    uint32    nmspinning;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Global runnable queue.</span></span><br><span class="line">    G*    runqhead;</span><br><span class="line">    G*    runqtail;</span><br><span class="line">    int32    runqsize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Global cache of dead G&#x27;s.</span></span><br><span class="line">    Lock    gflock;</span><br><span class="line">    G*    gfree;</span><br><span class="line"></span><br><span class="line">    int32    stopwait;</span><br><span class="line">    Note    stopnote;</span><br><span class="line">    uint32    sysmonwait;</span><br><span class="line">    Note    sysmonnote;</span><br><span class="line">    uint64    lastpoll;</span><br><span class="line"></span><br><span class="line">    int32    profilehz;    <span class="comment">// cpu profiling rate</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有M的idle队列，P的idle队列，以及一个全局的就绪的G队列。Sched结构体中的Lock是非常必须的，如果M或P等做一些非局部的操作，它们一般需要先锁住调度器。</p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="M-P-G-Sched"><a href="#M-P-G-Sched" class="headerlink" title="M,P,G,Sched"></a>M,P,G,Sched</h3><p>1.Sched结构就是调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。</p>
<p>2.M代表内核级线程，一个M就是一个线程，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息。</p>
<p>3.P全称是Processor，处理器，它的主要用途就是用来执行goroutine的，所以它也维护了一个goroutine队列，里面存储了所有需要它来执行的goroutine，这个P的角色可能有一点让人迷惑，一开始容易和M冲突，后面重点聊一下它们的关系。</p>
<p>4.G就是goroutine实现的核心结构了，G维护了goroutine需要的栈、程序计数器以及它所在的M等信息</p>
<p>类比 M:工人， G:砖， P：工具<br>M用P执行G（工人用工具搬砖）</p>
<p>G需要绑定M运行<br>M需要绑定P运行<br>多个M并不会同时处于执行状态，最多只有P的个数（GOMAXPROCS）<br>M:P:G=1:1:N</p>
<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>从启动过程开始说起：</p>
<p>1.调度器初始化runtime·schedinit<br>PS：根据用户设置的GOMAXPROCS值来创建一批P，不管GOMAXPROCS设置为多大，最多也只能创建256个P，为闲置状态<br>放置在调度器结构(Sched)的pidle字段维护的链表中存储起来，后续使用</p>
<p>2.runtime·newproc创建出第一个goroutine，这个goroutine将执行的函数是runtime·main<br>PS：runtime·main函数，创建了一个新的内核线程M，不过这个线程是一个特殊线程，它在整个运行期专门负责做特定的事情——系统监控(sysmon)</p>
<p>3.这第一个goroutine，也就是主goroutine</p>
<p>4.runtime·mstart执行这个主goroutine</p>
<h3 id="创建G"><a href="#创建G" class="headerlink" title="创建G"></a>创建G</h3><p>1.通过go关键字创建，对应到调度器的接口就是runtime·newproc，将G放入当前M的P中</p>
<h3 id="创建M"><a href="#创建M" class="headerlink" title="创建M"></a>创建M</h3><p>1.runtime根据实际情况去创建，G太多了，M少，有空闲的P</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> newm(<span class="keyword">void</span> (*fn)(<span class="keyword">void</span>), P *p)</span><br></pre></td></tr></table></figure>
<p>PS：newm函数的核心行为就是调用clone系统调用创建一个内核线程，每个内核线程的开始执行位置都是runtime·mstart函数</p>
<h3 id="创建P"><a href="#创建P" class="headerlink" title="创建P"></a>创建P</h3><p>1.runtime·schedinit创建一批P， 根据GOMAXPROCS设置，最多也只能创建256个P</p>
<h3 id="调度：窃取调度算法-work-stealing"><a href="#调度：窃取调度算法-work-stealing" class="headerlink" title="调度：窃取调度算法 work stealing"></a>调度：窃取调度算法 work stealing</h3><h4 id="M分配P"><a href="#M分配P" class="headerlink" title="M分配P"></a>M分配P</h4><p>newm接口给新建的M分配了一个P</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(m != &amp;runtime·m0) &#123;</span><br><span class="line">	acquirep(m-&gt;nextp);</span><br><span class="line">	m-&gt;nextp = nil;</span><br><span class="line">&#125;</span><br><span class="line">schedule();</span><br></pre></td></tr></table></figure>

<p>没有P，M是无法执行goroutine的，对应acquirep的动作是releasep，把M装配的P给载掉</p>
<h4 id="schedule调度"><a href="#schedule调度" class="headerlink" title="schedule调度"></a>schedule调度</h4><p>分配好P之后就是取G执行，也就是上面的schedule方法，简化后的代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">schedule(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	G *gp;</span><br><span class="line"></span><br><span class="line">	gp = runqget(m-&gt;p);</span><br><span class="line">	<span class="keyword">if</span>(gp == nil)</span><br><span class="line">		gp = findrunnable();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m-&gt;p-&gt;runqhead != m-&gt;p-&gt;runqtail &amp;&amp;</span><br><span class="line">		runtime·atomicload(&amp;runtime·sched.nmspinning) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">		runtime·atomicload(&amp;runtime·sched.npidle) &gt; <span class="number">0</span>)  <span class="comment">// <span class="doctag">TODO:</span> fast atomic</span></span><br><span class="line">		wakep();</span><br><span class="line"></span><br><span class="line">	execute(gp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.runqget方法，M从自己的P的G队列中取G运行，成功则运行，失败则自己的P的G队列是空的，gp=nil，与自己的队列都是无锁交互</p>
<p>2.自己的P的G队列是空的，findrunnable方法，从全局的G队列，取G，全局G队列也是空的话，从其他M的P的G队列，窃取一半的G运行，如果都没有G，则卸掉P，线程sleep状态</p>
<p>3.wakep，一个M，自己的P的G队列太长，执行不过来，发现有闲置的P，则用闲置的M或者创建新的M，继续执行</p>
<p>4.execute最后执行G</p>
<p><img src="/2021/01/04/GO%E7%9A%84%E5%8D%8F%E7%A8%8B%EF%BC%9Agoroutine/1.png" alt="1"></p>
<p>当M线程没有关联P来运行G时，就需要将G放入全局列表</p>
<h3 id="阻塞点，切换调用，调度点"><a href="#阻塞点，切换调用，调度点" class="headerlink" title="阻塞点，切换调用，调度点"></a>阻塞点，切换调用，调度点</h3><p>1.park goroutine: runtime·park函数。goroutine调用park后，这个goroutine就会被设置位waiting状态，放弃cpu,被park的goroutine处于waiting状态，并且这个goroutine不在P中，如果不对其调用runtime·ready，它是永远不会再被执行的<br>PS: channel操作，定时器中，网络poll等都有可能park goroutine</p>
<p>2.runtime·gosched:和park完全不同；gosched是将goroutine设置为runnable状态，然后放入到调度器全局等待队列</p>
<p>3.系统调用: 系统调用的时候执行entersyscall，退出后又执行exitsyscall函数。也只有封装了entersyscall的系统调用才有可能触发重新调度, 改变P的状态为syscall,通过sysmon线程监控抢占式调度，被抢P的M，只能把G放到全局队列，然后sleep<br>PS:sysmon线程:这个系统监控线程会扫描所有的P，发现一个P处于了syscall的状态，就知道这个P遇到了goroutine在做系统调用，于是系统监控线程就会创建一个新的M去把这个处于syscall的小车给抢过来</p>
<h3 id="sysmon协程系统监控与抢占式调度"><a href="#sysmon协程系统监控与抢占式调度" class="headerlink" title="sysmon协程系统监控与抢占式调度"></a>sysmon协程系统监控与抢占式调度</h3><p>1.sysmon协程是在go runtime初始化之后，执行用户编码之前，不与任何P绑定，直接由一个M执行的内核线程</p>
<p>2.每10ms执行一次，初始20us，运行1ms翻倍，最终10ms，发生过抢占，则恢复到20us</p>
<p>稳定之后，会在循环之中执行以下工作</p>
<h4 id="检查死锁"><a href="#检查死锁" class="headerlink" title="检查死锁"></a>检查死锁</h4><h5 id="检查是否存在正在运行的线程"><a href="#检查是否存在正在运行的线程" class="headerlink" title="检查是否存在正在运行的线程"></a>检查是否存在正在运行的线程</h5><p>如果线程数量大于 0，说明当前程序不存在死锁；如果线程数小于 0，说明当前程序的状态不一致；如果线程数等于 0，我们需要进一步检查程序的运行状态</p>
<h5 id="检查是否存在正在运行的-Goroutine"><a href="#检查是否存在正在运行的-Goroutine" class="headerlink" title="检查是否存在正在运行的 Goroutine"></a>检查是否存在正在运行的 Goroutine</h5><p>1.当存在 Goroutine 处于  Grunnable、Grunning 和 Gsyscall状态时，意味着程序发生了死锁<br>2.当所有的 Goroutine 都处于 Gidle、Gdead 和 Gcopystack 状态时，意味着主程序调用了 runtime.goexit </p>
<h5 id="检查处理器上是否存在计时器"><a href="#检查处理器上是否存在计时器" class="headerlink" title="检查处理器上是否存在计时器"></a>检查处理器上是否存在计时器</h5><p>当运行时存在等待的 Goroutine 并且不存在正在运行的 Goroutine 时，我们会检查处理器中存在的计时器</p>
<p>如果处理器中存在等待的计时器，那么所有的 Goroutine 陷入休眠状态是合理的，不过如果不存在等待的计时器，运行时就会直接报错并退出程序</p>
<h4 id="运行计时器"><a href="#运行计时器" class="headerlink" title="运行计时器"></a>运行计时器</h4><p>通过 runtime.nanotime 和 runtime.timeSleepUntil 获取当前时间和计时器下一次需要唤醒的时间，保证计时器时间不会有太大偏差，准确执行</p>
<h4 id="轮询网络"><a href="#轮询网络" class="headerlink" title="轮询网络"></a>轮询网络</h4><p>系统监控还会在循环中轮询网络，检查是否有待执行的文件描述符</p>
<p>非阻塞地调用 runtime.netpoll 检查待执行的文件描述符并通过 runtime.injectglist 将所有处于就绪状态的 Goroutine 加入全局运行队列中</p>
<p>将所有 Goroutine 的状态从 Gwaiting 切换至 Grunnable 并加入全局运行队列等待运行</p>
<h4 id="抢占处理器"><a href="#抢占处理器" class="headerlink" title="抢占处理器"></a>抢占处理器</h4><p>循环中调用 runtime.retake函数抢占处于运行或者系统调用中的处理器，该函数会遍历运行时的全局处理器，每个处理器都存储了一个 runtime.sysmontick 结构体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type sysmontick struct &#123;</span><br><span class="line">	schedtick   uint32 <span class="comment">// 处理器的调度次数</span></span><br><span class="line">	schedwhen   int64	<span class="comment">// 处理器上次调度时间</span></span><br><span class="line">	syscalltick uint32 <span class="comment">// 系统调用的次数</span></span><br><span class="line">	syscallwhen int64 <span class="comment">// 系统调用的时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>retake函数会有两种抢占逻辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func retake(now int64) uint32 &#123;</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(allp); i++ &#123;</span><br><span class="line">		_p_ := allp[i]</span><br><span class="line">		pd := &amp;_p_.sysmontick</span><br><span class="line">		s := _p_.status</span><br><span class="line">		<span class="keyword">if</span> s == _Prunning || s == _Psyscall &#123;</span><br><span class="line">			t := int64(_p_.schedtick)</span><br><span class="line">			<span class="keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now &#123;</span><br><span class="line">				preemptone(_p_)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> s == _Psyscall &#123;</span><br><span class="line">			<span class="keyword">if</span> runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; <span class="number">0</span> &amp;&amp; pd.syscallwhen+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &gt; now &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> atomic.Cas(&amp;_p_.status, s, _Pidle) &#123;</span><br><span class="line">				n++</span><br><span class="line">				_p_.syscalltick++</span><br><span class="line">				handoffp(_p_)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> uint32(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.当处理器处于 Prunning 或者 Psyscall 状态时，如果上一次触发调度的时间已经过去了 10ms，我们就会通过 runtime.preemptone 抢占当前处理器</p>
<p>2.当处理器处于 Psyscall 状态时，在满足以下两种情况下会调用 runtime.handoffp 让出处理器的使用权：<br>  1.当处理器的运行队列不为空或者不存在空闲处理器时<br>  2.当系统调用时间超过了 10ms 时</p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>系统监控还会决定是否需要触发强制垃圾回收，如果需要触发垃圾回收，我们会将用于垃圾回收的 Goroutine 加入全局队列，让调度器选择合适的处理器去执行</p>
<h3 id="上下文切换保存"><a href="#上下文切换保存" class="headerlink" title="上下文切换保存"></a>上下文切换保存</h3><p>goroutine放弃cpu的时候，调用runtime·mcall函数，此函数也是汇编实现，主要将goroutine的栈地址和程序计数器保存到G结构的sched字段中，将相关寄存器的值给保存到内存中；恢复现场就是在goroutine重新获得cpu的时候，runtime·gogocall，这个函数主要在execute中调用，需要从内存把之前的寄存器信息全部放回到相应寄存器中去</p>
<h2 id="goroutine与python-yield"><a href="#goroutine与python-yield" class="headerlink" title="goroutine与python yield"></a>goroutine与python yield</h2><p>1.创建成本：Go 原生支持协程，通过 go func() 就可以创建一个 goroutine。Python 可以通过 gevent.spawn 来新建一个 coroutine，需要第三方库来支持。</p>
<p>2.Goroutine 之间的通信更简单，通过 channel call 即可实现，上下文切换透明（只有少部分需要自己注意 Gosched）。Python 需要 yield 来传递数据和切换上下文（通过一些库封装后对调用者来说也是透明的，比如：gevent/tornado）。</p>
<p>3.Python coroutine 只会使用一个线程，所以只能利用单核。Goroutine 可以被多个线程调度，可以利用多核</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO的垃圾回收</title>
    <url>/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h2 id="垃圾回收GC"><a href="#垃圾回收GC" class="headerlink" title="垃圾回收GC"></a>垃圾回收GC</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>程序创建对象等引用类型实体时会在虚拟内存中分配给它们一块内存空间，如果该内存空间不再被任何引用变量引用时就成为需要被回收的垃圾</p>
<p>对于一个运行较长时间的程序，如果使用完内存资源后没有及时释放就会造成内存泄漏甚至系统错误</p>
<p>如果我们在不该释放内存的时候释放内存，那么仍然在使用这块内存的指针就会变成野指针wild pointer，使用该指针对内存进行读写是未定义的行为</p>
<h3 id="GC性能指标"><a href="#GC性能指标" class="headerlink" title="GC性能指标"></a>GC性能指标</h3><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>是指单位时间内是有多少时间是用来运行用户代码的。GC占用的时间过多，就会导致吞吐量较低</p>
<h4 id="最大暂停时间STW"><a href="#最大暂停时间STW" class="headerlink" title="最大暂停时间STW"></a>最大暂停时间STW</h4><p>STW stop the world 暂停所有赋值线程</p>
<p>基本上所有的垃圾回收算法，都会在执行GC的过程中，暂停用户代码。如果暂停时间过长，必然会影响用户体验，尤其是那些交互性较强的应用</p>
<h4 id="访问局部性"><a href="#访问局部性" class="headerlink" title="访问局部性"></a>访问局部性</h4><p>具有引用关系的对象之间很可能存在连续访问的情况。因此，把具有引用关系的对象安排在堆中较劲的位置，可以充分利用内存访问局部性。有的GC算法会根据引用关系重排对象，比如复制算法。</p>
<h4 id="堆使用效率"><a href="#堆使用效率" class="headerlink" title="堆使用效率"></a>堆使用效率</h4><p>影响堆使用效率的主要有两个因素，一个是对象头部大小，一个是堆的用法。</p>
<p>1.一般来说，堆的头部越大，存储的信息越多，那么GC的效率就会越高，吞吐量什么的也会有更佳的表现。但是，我们必须明白，对象头越小越好</p>
<p>2.不同的算法对于堆的不同用法，也会导致堆使用效率差距非常大。比如复制算法，用户应用只能使用一般的堆大小</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>1.无内存泄漏：垃圾回收器最基本的目标就是减少防止程序员未及时释放导致的内存泄漏，垃圾回收器会识别并清理内存中的垃圾</p>
<p>2.自动回收无用内存：垃圾回收器作为独立的子任务，不需要程序员显式调用即可自动清理内存垃圾</p>
<p>3.内存整理：如果只是简单回收无用内存，那么堆上的内存空间会存在较多碎片而无法满足分配较大对象的需求，因此垃圾回收器需要重整内存空间，提高内存利用率</p>
<h2 id="GC常见算法"><a href="#GC常见算法" class="headerlink" title="GC常见算法"></a>GC常见算法</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数Reference counting<br>会为每个对象维护一个计数器，当该对象被其他对象引用时加一，引用失效时减一，当引用次数归零后即可回收对象</p>
<p>python就是引用计数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">typedef struct_object &#123;</span><br><span class="line">    int ob_refcnt;</span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125;PyObject;</span><br></pre></td></tr></table></figure>

<p>ob_refcnt为引用计数器</p>
<p>优点：<br>1.原理和实现都比较简单</p>
<p>2.回收的即时性：当对象的引用计数为0时立即回收，不像其他GC机制需要等待特定时机再回收，提高了内存的利用率</p>
<p>3.不需要暂停应用即可完成回收</p>
<p>缺点：</p>
<p>1.无法解决循环引用的回收问题：当ObjA引用了ObjB，ObjB也引用ObjA时，这两个对象的引用次数使用大于0，从而占用的内存无法被回收</p>
<p>2.时间和空间成本较高：一方面是因为每个对象需要额外的空间存储引用计数器变量，另一方面是在栈上的赋值时修改引用次数时间成本较高（原本只需要修改寄存器中的值，现在计数器需要不断更新因此不是只读的，需要额外的原子操作来保证线程安全</p>
<p>3.引用计数是一种摊销算法，会将内存的回收分摊到整个程序的运行过程，但是当销毁一个很大的树形结构时无法保证响应时间</p>
<h4 id="改进：延迟引用计数"><a href="#改进：延迟引用计数" class="headerlink" title="改进：延迟引用计数"></a>改进：延迟引用计数</h4><p>在延迟引用计数法中使用ZCT（Zero Count Table）。ZCT 是一个表，它会事先<br>记录下计数器值在dec_ref_cnt() 函数的作用下变为0 的对象， 因为计数器值为0 的对象不一定都是垃圾，所以暂时先将这些对象保留</p>
<p>在延迟引用计数法中，程序延迟了根引用的计数，将垃圾一并回收。通过延迟，减轻了<br>因根引用频繁发生变化而导致的计数器增减所带来的额外负担。当然也失去量垃圾即可回收的特点</p>
<h3 id="追踪回收式"><a href="#追踪回收式" class="headerlink" title="追踪回收式"></a>追踪回收式</h3><p>判断哪些对象存活，然后将其余的所有对象作为垃圾进行回收。追踪回收本身包括<br>标记-清除 Mark-Sweep<br>标记-复制 Mark-Copy<br>标记-整理 Mark-Compact<br>三种回收算法</p>
<p>同引用计数法相比<br>优点：</p>
<p>1.解决了循环引用对象的回收问题</p>
<p>2.占用空间更少</p>
<p>缺点：</p>
<p>1.同引用计数相比无法立刻识别出垃圾对象，需要依赖GC线程</p>
<p>2.算法在标记时必须暂停整个程序，即Stop The World, STW，否则其他线程的代码会修改对象状态从而回收不该回收的对象</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>上面说的三种算法都是通过可达性分析算法，先进行可达性标记，标记对象是否可达</p>
<p>GC ROOT： 当前时刻存活的对象<br>GC会收集那些不是GC Roots且没有被GC Roots引用的对象<br>包括：</p>
<p>1.全局对象、栈上的对象（函数参数与内部变量）</p>
<p>2.与上面对象通过引用链相连的对象</p>
<p>对于“不可达”的对象，我们可以认为该对象为垃圾对象并回收对应的内存空间</p>
<p><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/1.png" alt="1"></p>
<h4 id="标记-清除-Mark-Sweep"><a href="#标记-清除-Mark-Sweep" class="headerlink" title="标记-清除 Mark-Sweep"></a>标记-清除 Mark-Sweep</h4><p>标记：记录需要回收的垃圾对象</p>
<p>清除：在标记完成后回收垃圾对象的内存空间</p>
<p><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2.png" alt="2"></p>
<p>优点：</p>
<p>1.算法吞吐量高：用户代码时间/总时间高</p>
<p>2.空间利用率：同标记-复制相比不需要额外空间复制对象，也不需要像引用计数算法为每个对象设置引用计数器</p>
<p>缺点：</p>
<p>1.清除后会产生大量的内存碎片空间，导致程序在运行时可能没法为较大的对象分配内存空间，导致提前GC</p>
<h4 id="标记-复制-Mark-Copy"><a href="#标记-复制-Mark-Copy" class="headerlink" title="标记-复制 Mark-Copy"></a>标记-复制 Mark-Copy</h4><p>将内存分成大小相同的两块，当某一块的内存使用完了之后就将使用中的对象挨个复制到另一块内存中，最后将当前内存恢复未使用的状态</p>
<p><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/3.png" alt="3"></p>
<p>优点：</p>
<p>1.标记-清除法需要在清除阶段对大量垃圾对象进行扫描，标记-复制则只需要从GC Root对象出发，将“可到达”的对象复制到另一块内存后直接清理当前这块的内存，因此提升了垃圾回收的效率</p>
<p>PS：清除，是扫描所有垃圾，标记垃圾，回收，复制是只扫描GC ROOT对象</p>
<p>2.解决了内存碎片化的问题，防止分配较大连续空间时的提前GC问题</p>
<p>缺点：</p>
<p>1.同标记-清除法相比，在“可达”对象占比较高的情况下有复制对象的开销</p>
<p>2.内存利用率较低，相当于可利用的内存仅有一半</p>
<h4 id="标记-整理-Mark-Compact"><a href="#标记-整理-Mark-Compact" class="headerlink" title="标记-整理 Mark-Compact"></a>标记-整理 Mark-Compact</h4><p>标记出所有“可达”的对象，然后将存活的对象移动到内存空间的一端，最后清理掉端边界以外的内存</p>
<p><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/4.png" alt="4"></p>
<p>优点：</p>
<p>1.避免了内存碎片化的问题</p>
<p>2.在对象存活率较高的情况下，标记-整理算法由于不需要复制对象效率更高，因此更加适合老年代算法</p>
<p>缺点：</p>
<p>1.整理过程较为复杂，需要多次遍历内存导致STW时间比标记-清除算法更长</p>
<h4 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h4><p>三色标记法是对“标记”阶段的改进，在不暂停程序的情况下即可完成对象的可达性分析。GC线程将所有对象分为三类</p>
<p>1.白色：未搜索对象，回收周期开始时，所有对象都是白色，回收周期结束后，所有白色都是垃圾对象</p>
<p>2.灰色：正在搜索的对象，对象身上还有一个或多个引用没有扫描</p>
<p>3.黑色：已搜索完的对象，所有引用已被扫描完</p>
<p>属于增量式GC算法，回收器将所有对象着白色，从GC ROOT出发，逐步把所有可达对象变成灰色再到黑色</p>
<p>最终所有的白色对象即是不可达对象</p>
<p>流程：</p>
<p>1.所有对象都是白色对象</p>
<p>2.从GC Root对象出发，扫描所有可达对象并标记为灰色，放入待处理队列</p>
<p>3.从队列取出一个灰色对象并标记为黑色，将其引用对象标记为灰色放入队列</p>
<p>4.重复上一步骤，直到灰色对象队列为空</p>
<p>5.此时所有剩下的白色对象就是垃圾对象</p>
<p>优点：</p>
<p>1.不需要暂停整个程序进行GC</p>
<p>缺点：</p>
<p>1.如果程序垃圾对象的产生速度大于垃圾对象的回收速度时，可能导致程序中的垃圾对象越来越多而无法及时收集</p>
<p>2.线程切换和上下文转换的消耗会使得垃圾回收的总体成本上升，从而降低系统吞吐量</p>
<h5 id="三色标记法的并发性问题"><a href="#三色标记法的并发性问题" class="headerlink" title="三色标记法的并发性问题"></a>三色标记法的并发性问题</h5><p><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/5.png" alt="5"></p>
<p>如图所示，三色标记法GC与用户程序同时并发执行，用户在标记执行过程中建立了从A对象到D对象的引用，A为黑色，D不会再被扫描为白色，会被错误回收，导致后续对D的访问出错。这种没有指向合法地址的指针一般被称为“野指针”，会造成严重的程序错误</p>
<h5 id="问题原因及解决"><a href="#问题原因及解决" class="headerlink" title="问题原因及解决"></a>问题原因及解决</h5><p>三色标记法和用户程序并发执行，那么下列两个条件同时满足就可能出现错误回收非垃圾对象的问题：</p>
<p>1.某一黑色对象引用白色对象</p>
<p>2.对于某个白色对象，所有和它存在可达关系的灰色对象丢失了访问它的可达路径</p>
<p>最简单解决三色标记并发问题的方法是停止所有的赋值器线程，保证标记过程不受干扰，即垃圾回收器中常提到的STW, stop the world方法。另外一种思路就是使用赋值器屏障技术使得赋值器在进行指针写操作时同步垃圾回收器</p>
<h3 id="读写屏障技术"><a href="#读写屏障技术" class="headerlink" title="读写屏障技术"></a>读写屏障技术</h3><p>使用屏障技术可以使得用户程序和三色标记过程并发执行，我们只需要达成下列任意一种三色不变性：</p>
<p>1.强三色不变性：黑色对象永远不会指向白色对象</p>
<p>2.弱三色不变性：黑色对象指向的白色对象至少包含一条由灰色对象经过白色对象的可达路径</p>
<p>GC中使用的内存读写屏障技术指的是编译器会在编译期间生成一段代码，该代码在运行期间用户读取、创建或更新对象指针时会拦截内存读写操作，相当于一个hook调用，</p>
<p>根据hook时机不同可分为不同的屏障技术。</p>
<p>由于读屏障Read barrier技术需要在读操作中插入代码片段从而影响用户程序性能，所以一般使用写屏障技术来保证三色标记的稳健性</p>
<p>内存屏障技术解决了三色标记法的STW缺点，并不是指消除了所有的赋值器挂起问题。</p>
<p>需要分清楚STW方法是全局性的赋值器挂起而内存屏障技术是局部的赋值器挂起</p>
<h4 id="Dijkstra插入写屏障"><a href="#Dijkstra插入写屏障" class="headerlink" title="Dijkstra插入写屏障"></a>Dijkstra插入写屏障</h4><p>Dijkstra插入写屏障避免了前面提到的条件1，即防止黑色对象指向白色对象</p>
<p>一个对象可以存储在内存中的“栈”或者“堆”，由于“栈”空间容量小且要求相应速度较高，因此“插入写屏障”不适合用于“栈”空间</p>
<p>流程：<br>1.垃圾回收之前将所有的对象标记为白色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/6.png" alt="6"></p>
<p>2.遍历GC Root Set，将可达对象标记为灰色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/7.png" alt="7"></p>
<p>3.遍历灰色对象列表，将可达的对象从白色标记为灰色；将遍历完的灰色对象标记为黑色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/8.png" alt="8"></p>
<p>4.在三色标记过程中用户程序令栈区对象A指向对象H，令堆区对象E指向对象I，由于对象E在堆区从而触发插入写屏障并将黑色对象E指向的白色对象I标记为灰色，栈区对象A不触发<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/9.png" alt="9"></p>
<p>5.继续三色标记直至灰色对象队列为空<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/10.png" alt="10"></p>
<p>6.垃圾回收之前将所有的对象标记为白色由于栈区对象没有启动插入写屏障，因此栈上可能存在白色对象被引用的情况（上图中对应对象H），因此在回收白色对象前在STW保护下重新扫描一次栈空间<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/11.png" alt="11"></p>
<p>7.在STW保护下对栈空间一次性进行三色标记，直到灰色对象队列为空<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/12.png" alt="12"></p>
<p>8.结束STW<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/13.png" alt="13"></p>
<p>9.最后将栈空间和堆空间的白色垃圾对象进行回收<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/14.png" alt="14"></p>
<p>缺点：</p>
<p>1.一方面它是一种比较保守的垃圾回收方法，把有可能存活的对象都标记成灰色了以满足“强三色不变性”，在修改用户修改引用的时候，会被修改后的本该回收的标记为灰色从而漏掉回收</p>
<p>2.在于栈上的对象也是根对象，Dijkstra插入写屏障要么在用户程序执行内存写操作时为栈上对象插入写屏障，要么在一轮三色标记完成后使用STW重新对栈上的对象进行三色标记。前者会降低栈空间的响应速度，后者会暂停用户程序</p>
<h4 id="Yuasa删除写屏障"><a href="#Yuasa删除写屏障" class="headerlink" title="Yuasa删除写屏障"></a>Yuasa删除写屏障</h4><p>Yuasa删除写屏障避免了前面提到的条件2，防止丢失灰色对象到白色对象的可达路径</p>
<p>流程：<br>1.将所有对象标记为白色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/15.png" alt="15"></p>
<p>2.遍历GC Root Set将可达对象设为灰色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/16.png" alt="16"></p>
<p>3.如果用户程序令灰色对象A删除了对白色对象D的引用，如果这时候不触发删除写屏障，那么对象D、B和C直到本轮垃圾回收结束都会是白色对象。因此需要触发删除写屏障，将对象D标记为灰色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/17.png" alt="17"></p>
<p>4.遍历灰色对象队列，将可达的白色对象标记为灰色，遍历完的灰色对象标记为黑色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/18.png" alt="18"></p>
<p>5.继续进行三色标记，直到灰色对象队列为空<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/19.png" alt="19"></p>
<p>6.清除所有的白色对象<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/20.png" alt="20"></p>
<p>优点：</p>
<p>1.不需要在一轮三色标记后对栈空间上的对象进行重新扫描</p>
<p>缺点：</p>
<p>1.Collector会悲观地认为所有被删除的对象都可能被黑色对象引用<br>比如上图中，删除了A到D的指针，D根据删除屏障，会被标记为灰色，如果此时还有一个单独的对象H指向D，那么本该被删除的对象H却可以在本轮垃圾回收中存活</p>
<h4 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h4><h5 id="使用混合写屏障的原因"><a href="#使用混合写屏障的原因" class="headerlink" title="使用混合写屏障的原因"></a>使用混合写屏障的原因</h5><p>go1.8引入混合写屏障</p>
<p>由于GC Root对象包括了栈对象，如果运行时在所有GC Root对象上开启插入写屏障意味着需要在数量庞大的Goroutine的栈上都开启Dijkstra写屏障从而严重影响用户程序的性能</p>
<p>之前的做法是是Mark阶段（golang垃圾回收使用的是标记-清除法）结束后暂停整个程序，对栈上对象重新进行三色标记法</p>
<p>PS：如果Goroutine较多的话，对栈对象re-scan这一步需要耗费10 ~ 100 ms </p>
<p>以上两种屏障的劣势：</p>
<p>Dijkstra插入写屏障：一轮标记结束后需要STW重新扫描栈上对象</p>
<p>Yuasa删除写屏障：回收精度低</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>混合写屏障也是仅在堆空间启动的，防止降低栈空间的运行效率</p>
<p>1.GC开始时将栈上所有对象标记为黑色，无须STW</p>
<p>2.GC期间在栈上创建的新对象均标记为黑色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/21.png" alt="21"></p>
<p>3.将被删除的下游对象标记为灰色</p>
<p>4.将被添加的下游对象标记为灰色</p>
<p>场景一：某个对象从堆对象的下游变成栈对象的下游，这种情况下标记该对象为灰色，该对象就不会被错误地回收<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/22.png" alt="22"></p>
<p>场景二：某个对象从一个栈对象的下游变成另一个对象的下游，由于对象全都在栈空间对象的可达对象中，因此混合写屏障不会对这些对象着色。<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/23.png" alt="23"></p>
<p>场景三：某个对象从一个堆对象的下游变成另一个堆对象的下游，比如下图中对象G从F的下游移动到Y的下游，为了避免对象G被错误回收，我们需要将其标记为灰色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/24.png" alt="24"></p>
<p>场景四：某个对象从栈对象的下游变成堆对象的下游，对于栈空间对象不触发写屏障，但是对于被删除的堆空间对象G需要标记成灰色以保护它和它的下游对象不被错误删除<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/25.png" alt="25"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>追踪式回收有一个问题是会频繁扫描生命周期较长的对象，大部分生命周期都很短，因此有必要将对象按照生命周期的长度划分到堆heap上的两个甚至多个区域。对于新生代区域的扫描频率应该高于老年代区域</p>
<h4 id="区域划分：新生代，老年代"><a href="#区域划分：新生代，老年代" class="headerlink" title="区域划分：新生代，老年代"></a>区域划分：新生代，老年代</h4><p>1.新生代，老年代分为young，old区域<br>2.新生代中的对象生命周期较短（每次回收约98%的对象是垃圾对象）<br>3.新生代采用标记-复制法需要两块内存交替使用<br>4.Young区为了节省复制算法的内存代价又划分成Eden、Survivor0和Survivor1三个分区（内存分配比例为8:1:1）。</p>
<p><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/26.png" alt="26"></p>
<p>新生代回收：Minor GC<br>老年代回收：Major GC</p>
<h4 id="分配策略与流程"><a href="#分配策略与流程" class="headerlink" title="分配策略与流程"></a>分配策略与流程</h4><p>1.对象优先在Yonug上的Eden区域分配（大对象直接进入Old区）</p>
<p>2.Eden区满了之后开始进行Minor GC，将Eden中存活的对象移动到Survivor0区，直接清空Eden区</p>
<p>3.Eden区第二次满了之后进行Minor GC，将Eden和Survivor0中存活的对象复制到Survivor1区，清空Eden和Survivor0区</p>
<p>4.若干轮Minor GC过后，此时新生代中生命周期较长的对象熬过了一定次数的Minor GC晋升成老年代移动到Old区，某轮Minor GC存活率较高Survivor区空间不足时也会将存活对象放到Old区</p>
<p>5.当Old区满了之后进行Major GC</p>
<h3 id="增量和并发式垃圾回收"><a href="#增量和并发式垃圾回收" class="headerlink" title="增量和并发式垃圾回收"></a>增量和并发式垃圾回收</h3><p>传统的垃圾回收算法都有STW的弊端，即需要在执行垃圾回收过程中需要抢占CPU，这会暂停所有的用户程序</p>
<p>1.通常GC任务都比较繁重，长时间暂停用户程序会影响程序的响应速度，这对于实时性要求较高的程序是致命的缺点<br>2.对于多核计算机而言，抢占CPU进行垃圾回收会造成计算资源浪费</p>
<p>增量式垃圾回收和并发式垃圾回收都是基于三色标记法和读写屏障技术的</p>
<h4 id="增量式"><a href="#增量式" class="headerlink" title="增量式"></a>增量式</h4><p><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/27.png" alt="27"></p>
<p>增量式垃圾回收过程图如上所示，同STW垃圾回收过程相比：</p>
<p>优点：</p>
<p>1.将垃圾回收时间分摊开，避免了程序的长时间暂停，防止影响程序的实时性<br>缺点：</p>
<p>1.一方面引入了内存写屏障技术，需要额外的计算开销；另一方面由于写屏障技术的保守性导致有一些垃圾对象没有被回收，会增加一轮垃圾回收的总时长</p>
<h4 id="并发式"><a href="#并发式" class="headerlink" title="并发式"></a>并发式</h4><p><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/28.png" alt="28"></p>
<p>同时执行</p>
<p>在一定程序上利用了多核计算机的优势并减少了对用户程序的干扰，不过依然无法摆脱读写屏障的额外计算开销和增加一轮垃圾回收总时长的问题</p>
<h2 id="GO的GC"><a href="#GO的GC" class="headerlink" title="GO的GC"></a>GO的GC</h2><h3 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h3><p>go v1.1：标记-清除法，整个过程都需要STW</p>
<p>go v1.3：标记-清除法，标记过程仍然需要STW但清除过程并行化，gc pause约几百ms</p>
<p>go v1.5：引入插入写屏障技术的三色标记法，仅在堆空间启动插入写屏障，全部扫描后需要STW重新扫描栈空间，gc pause耗时降到10ms以下</p>
<p>go v1.8：引入混合写屏障技术的三色标记法，仅在堆空间启动混合写屏障，不需要在GC结束后对栈空间重新扫描，gc pause时间降低至0.5ms以下</p>
<p>go v1.14：引入新的页分配器用于优化内存分配的速度</p>
<p>PS：gc pause时间的缩短也就意味着程序的响应速度更快</p>
<h3 id="GC扫描对象"><a href="#GC扫描对象" class="headerlink" title="GC扫描对象"></a>GC扫描对象</h3><h4 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h4><p>对静态类型做好标记准备</p>
<h5 id="GO的结构体对齐规则"><a href="#GO的结构体对齐规则" class="headerlink" title="GO的结构体对齐规则"></a>GO的结构体对齐规则</h5><h6 id="长度对齐"><a href="#长度对齐" class="headerlink" title="长度对齐"></a>长度对齐</h6><p>结构体的长度至少是内部最长的基础字段的整数倍</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   type TestStruct struct &#123;</span><br><span class="line">  ptr   uintptr  <span class="comment">// 8字节</span></span><br><span class="line">  int1  uint32   <span class="comment">// 4字节</span></span><br><span class="line">  int2  uint8    <span class="comment">// 1字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体内存占用为16个字节</p>
<h6 id="地址对齐"><a href="#地址对齐" class="headerlink" title="地址对齐"></a>地址对齐</h6><p>字段的地址偏移是自身长度的整数倍</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 假设new一个TestStruct结构体的地址是x, 则各字段的地址如下</span></span><br><span class="line"><span class="comment">// ptr: a + 0</span></span><br><span class="line"><span class="comment">// int1: a + 8</span></span><br><span class="line"><span class="comment">// int2: a + 8 + 4</span></span><br><span class="line">type TestStruct struct &#123;</span><br><span class="line">  ptr   uintptr  <span class="comment">// 8字节</span></span><br><span class="line">  int1  uint8    <span class="comment">// 1字节</span></span><br><span class="line">  int2  uint32   <span class="comment">// 4字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>int1和int2之间填充了一些没使用到的内存空间，进而实现了地址对齐</p>
<h5 id="指针位标记"><a href="#指针位标记" class="headerlink" title="指针位标记"></a>指针位标记</h5><p>GO的所有类型都对应一个_type结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type TestStruct struct &#123;</span><br><span class="line">  ptr   uintptr  <span class="comment">// 8</span></span><br><span class="line">  int1  uint8    <span class="comment">// 1</span></span><br><span class="line">  pint1 *uint8</span><br><span class="line">  int2  uint32   <span class="comment">// 4</span></span><br><span class="line">  pint2 *uint64</span><br><span class="line">  int3  uint64   <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如上面这个结构体：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Needs to be in sync with ../cmd/link/internal/ld/decodesym.go:/^func.commonsize,</span></span><br><span class="line"><span class="comment">// ../cmd/compile/internal/gc/reflect.go:/^func.dcommontype and</span></span><br><span class="line"><span class="comment">// ../reflect/type.go:/^type.rtype.</span></span><br><span class="line">type _type struct &#123;</span><br><span class="line">    size       uintptr  <span class="comment">// 类型长度，上面这个结构体的长度48个字节</span></span><br><span class="line">    ptrdata    uintptr <span class="comment">// 指针截止的长度位置，由于最后一个指针是pint2，因此包含指针的字段截止到40字节的位置</span></span><br><span class="line">    hash       uint32</span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      uint8</span><br><span class="line">    fieldalign uint8</span><br><span class="line">    kind       uint8  <span class="comment">// 类型，自定义struct类型的kind为25</span></span><br><span class="line">    alg        *typeAlg</span><br><span class="line">    <span class="comment">// gcdata stores the GC type data for the garbage collector.</span></span><br><span class="line">    <span class="comment">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span></span><br><span class="line">    <span class="comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></span><br><span class="line">    gcdata    *byte <span class="comment">// byte数组（*byte类型），表示指针的bitmap。比如当gcdata等于20（二进制00010100，从低位到高位就是00101000，其中每个bit表示一个指针大小（8字节）的内存，第3个bit和第5个bit为1表示第三个和第五个字段是指针类型）</span></span><br><span class="line">    str       nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h4><p>golang在运行分配完内存后会调用函数heapBitsSetType，主要逻辑是根据编译期间对每个struct生成的type结构，用一个bitmap记录下来分配的内存块中哪些位置是指针</p>
<h4 id="扫描阶段"><a href="#扫描阶段" class="headerlink" title="扫描阶段"></a>扫描阶段</h4><p>1.扫描阶段从markroot开始，以栈对象、全局变量和寄存器对象作为gc root，创建一个有向引用图并将根对象添加到队列中<br>2.新起一个异步goroutine执行gcDrain函数，从队列里消费并扫描对象</p>
<h3 id="GC实现"><a href="#GC实现" class="headerlink" title="GC实现"></a>GC实现</h3><p>基于三色标记法实现的垃圾回收机制，从而将长时间的STW分隔成多段较短时间的STW的并发式回收</p>
<p>1.GC开始前将所有对象标记为白色</p>
<p>2.将GC Root对象（golang中是栈对象和全局变量的指针）加入灰色对象队列</p>
<p>3.使用并发的goroutine扫描队列中的指针，如果指针还引用了其他指针，那么将被引用的加入灰色对象队列，被扫描的对象标记为黑色</p>
<h4 id="四个阶段"><a href="#四个阶段" class="headerlink" title="四个阶段"></a>四个阶段</h4><h5 id="清除终止Sweep-Termination"><a href="#清除终止Sweep-Termination" class="headerlink" title="清除终止Sweep Termination"></a>清除终止Sweep Termination</h5><p>1.暂停程序</p>
<p>2.清扫未被回收的内存管理单元span，当上一轮GC的清扫工作完成后才可以开始新一轮的GC</p>
<h5 id="标记Mark"><a href="#标记Mark" class="headerlink" title="标记Mark"></a>标记Mark</h5><p>1.切换至_GCmark，开启写屏障和用户程序协助Mutator Assiste并将根对象添加到三色标记法队列</p>
<p>2.恢复程序，标记进程和Mutator Assiste进程会开始并发标记内存中的对象，<br>混合写屏障将被删除的指针和新加入的指针都标记成灰色，新创建的对象标记成黑色</p>
<p>3.扫描根对象（包括所有goroutine的栈、全局对象以及不在堆中的运行时数据结构），扫描goroutine栈期间会暂停当前处理器<br>依次处理三色标记法队列，将扫描过的对象标记为黑色并将它们指向的对象标记成灰色</p>
<p>4.使用分布式终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段</p>
<h5 id="标记终止Mark-Termination"><a href="#标记终止Mark-Termination" class="headerlink" title="标记终止Mark Termination"></a>标记终止Mark Termination</h5><p>1.暂停程序，切换至_GCmarktermination并关闭辅助标记的用户程序</p>
<p>2.清理处理器上的线程缓存</p>
<h5 id="清除Sweep"><a href="#清除Sweep" class="headerlink" title="清除Sweep"></a>清除Sweep</h5><p>1.将状态切换至_GCoff，关闭混合写屏障</p>
<p>2.恢复用户程序，所有新创建的对象标记为白色</p>
<p>3.后台并发清理所有的内存管理单元span，当goroutine申请新的内存管理单元时就会触发清理</p>
<p>PS:在GC过程中会有两种后台任务，包括标记任务和清扫任务。可以同时执行的标记任务约是P数量的四分之一，即go所说的25%CPU用于GC的依据。清扫任务会在程序启动后运行，进入清扫阶段时唤醒</p>
<h4 id="辅助GC"><a href="#辅助GC" class="headerlink" title="辅助GC"></a>辅助GC</h4><p>由于Golang使用了并发式的垃圾回收，将原本需要STW较长时间的GC过程分散到多次小规模的GC</p>
<p>当用户分配内存的速度超过GC回收速度时，Golang会通过辅助GC暂停用户程序进行垃圾回收，防止内存因分配对象速度过快消耗殆尽的问题</p>
<h4 id="GC触发时机"><a href="#GC触发时机" class="headerlink" title="GC触发时机"></a>GC触发时机</h4><p>三个前提条件：</p>
<p>1.允许垃圾回收</p>
<p>2.没有panic</p>
<p>3.处于Gcoff阶段</p>
<p>触发机制：</p>
<p>1.gcTriggerHeap：堆内存大小达到阈值</p>
<p>2.gcTriggerTime：距离上一次垃圾回收超过一定阈值时</p>
<p>3.gcTriggerCycle：如果当前没有启动GC则开始新一轮的GC</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test reports whether the trigger condition is satisfied, meaning</span></span><br><span class="line"><span class="comment">// that the exit condition for the _GCoff phase has been met. The exit</span></span><br><span class="line"><span class="comment">// condition should be tested when allocating.</span></span><br><span class="line">func (t gcTrigger) test() bool &#123;</span><br><span class="line">	<span class="comment">// 前提条件</span></span><br><span class="line">    <span class="keyword">if</span> !memstats.enablegc || panicking != <span class="number">0</span> || gcphase != _GCoff &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发机制</span></span><br><span class="line">    <span class="keyword">switch</span> t.kind &#123;</span><br><span class="line">    <span class="keyword">case</span> gcTriggerHeap:</span><br><span class="line">        <span class="comment">// Non-atomic access to heap_live for performance. If</span></span><br><span class="line">        <span class="comment">// we are going to trigger on this, this thread just</span></span><br><span class="line">        <span class="comment">// atomically wrote heap_live anyway and we&#x27;ll see our</span></span><br><span class="line">        <span class="comment">// own write.</span></span><br><span class="line">        <span class="keyword">return</span> memstats.heap_live &gt;= memstats.gc_trigger</span><br><span class="line">    <span class="keyword">case</span> gcTriggerTime:</span><br><span class="line">        <span class="keyword">if</span> gcpercent &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        lastgc := int64(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line">        <span class="keyword">return</span> lastgc != <span class="number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class="line">    <span class="keyword">case</span> gcTriggerCycle:</span><br><span class="line">        <span class="comment">// t.n &gt; work.cycles, but accounting for wraparound.</span></span><br><span class="line">        <span class="keyword">return</span> int32(t.n-work.cycles) &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h3><p>1.尽量使用小数据类型，比如使用int8代替int</p>
<p>2.少使用+连接string：go语言中string是一个只读类型，针对string的每一个操作都会创建一个新的string。大量小文本拼接时优先使用strings.Join，大量大文本拼接时使用bytes.Buffer</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>GO的基本数据结构：channel</title>
    <url>/2021/01/14/GO%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Achannel/</url>
    <content><![CDATA[<h2 id="channel实现"><a href="#channel实现" class="headerlink" title="channel实现"></a>channel实现</h2><p>channel可以被存储到变量中，可以作为参数传递给函数，也可以作为函数的返回值返回。</p>
<p>作为Go语言的核心特征之一，虽然channel看上去很高端，但是其实channel仅仅就是一个数据结构</p>
<p>线程间有竞争条件，那么对共享数据的访问往往需要加锁来保证一致性，而针对不同的访问竞争，比如读/读、读/写、写/写，需要用不同的锁机制</p>
<p>Go语言采用的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong></p>
<h3 id="channel状态"><a href="#channel状态" class="headerlink" title="channel状态"></a>channel状态</h3><p>初始化channel</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = chan string <span class="comment">// A channel is in a nil state when it is declared to its zero value</span></span><br><span class="line">ch = nil <span class="comment">// A channel can be placed in a nil state</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* open channel */</span></span><br><span class="line">ch := make(chan string) <span class="comment">// A channel is in a open state when it’s made using the built-in function make.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* closed channel */</span></span><br><span class="line">close(ch) </span><br></pre></td></tr></table></figure>

<p>channel分为三种状态：</p>
<p>1.nil： 不允许读写，blocked状态，会阻塞</p>
<p>2.open： 允许读写， allowed状态</p>
<p>3.closed： 写会panic，可以读</p>
<p>在channel被close之后，goruntine仍然可以从channel取走数据，如果channel中没有数据可取时，receive操作会立刻返回nil</p>
<p>range循环可以直接在channel上迭代，当channel被关闭并且没有数据时可以直接跳出循环。</p>
<p>另外，对于nil和closed状态的channel执行close操作也会触发panic异常</p>
<h3 id="缓冲channel与非缓冲channel"><a href="#缓冲channel与非缓冲channel" class="headerlink" title="缓冲channel与非缓冲channel"></a>缓冲channel与非缓冲channel</h3><p>channel的读写操作可以不传递数据</p>
<p>场景：</p>
<p>一个goroutine可以同时给多个goroutine发送消息，只是这个消息不携带额外的数据，所以常被用于批量goruntine的退出</p>
<p>goroutine A对channel执行了close操作，而goruntine B得到channel已经被关闭这个信息后可以执行相应的处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ch := make(chan struct&#123;&#125;)</span><br><span class="line"><span class="comment">// 写入ch </span></span><br><span class="line">ch &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="comment">// 读取ch</span></span><br><span class="line">&lt;- ch</span><br></pre></td></tr></table></figure>

<p>也可以传递数据：</p>
<p>goroutine A执行send发送数据，而goroutine B执行receive接收数据。channel携带的数据只能被一个goruntine得到，一个goruntine取走数据后这份数据在channel里就不复存在了</p>
<p>携带数据的可以分为缓冲和非缓冲</p>
<h4 id="非缓冲channel"><a href="#非缓冲channel" class="headerlink" title="非缓冲channel"></a>非缓冲channel</h4><p>不存储数据，只传递数据</p>
<p>goroutine A在往channel发送数据完成之前，一定有goroutine B在等着从这个channel接收数据，否则发送就会导致发送的goruntine被block住，所以发送和接收的goruntine是耦合的</p>
<p>所以会有两个goroutine</p>
<p>死锁场景：</p>
<p>ch发送数据时就使main gouruntine被永久block住，导致程序死锁，因为没有goroutine等待接收数据，main还没执行完，会导致ch阻塞锁住<br>如果channel长度是1，则不会发生死锁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch = make(chan string)</span><br><span class="line">	ch &lt;- <span class="string">&quot;hello&quot;</span> <span class="comment">//fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]:</span></span><br><span class="line">	fmt.Println(<span class="xml">&lt;-ch)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面这种也会死锁，ch里没有数据，直接读也会锁住</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch = make(chan string)</span><br><span class="line">	fmt.Println(<span class="xml">&lt;-ch) //fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]:</span></span><br><span class="line">	ch &lt;- &quot;hello&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单起一个goroutine就可以正常工作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch = make(chan string)</span><br><span class="line">	go <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		fmt.Println(<span class="xml">&lt;-ch) //out: hello</span></span><br><span class="line"><span class="xml">	&#125;()</span></span><br><span class="line">	ch &lt;- &quot;hello&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>退出场景：<br>main goroutine会在go func执行前就退出了，无法打印1-10</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	go <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让两个goruntine之间有一些通信，让main goruntine收到sub goruntine通知后再退出。在这种场景中，channel并不携带任何数据，只是起到一个信号的作用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch = make(chan string)</span><br><span class="line">	go <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">		&#125;</span><br><span class="line">		ch &lt;- <span class="string">&quot;exit&quot;</span></span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	&lt;-ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓冲channel"><a href="#缓冲channel" class="headerlink" title="缓冲channel"></a>缓冲channel</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch = make(chan string, <span class="number">1</span>)</span><br><span class="line">	ch &lt;- <span class="string">&quot;hello&quot;</span> <span class="comment">//fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]:</span></span><br><span class="line">	fmt.Println(<span class="xml">&lt;-ch)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>以上场景，如果没有指定channel长度为1，则会发生死锁<br>同一个goroutine内，读，放到写前面会导致死锁<br>对比上面非缓冲channel</p>
<p>注意：长度不同，会有区别</p>
<p>对于长度为1的channel<br>第二个数据发送完成之前，之前发送的第一个数据一定被取走了，否则发送也会被block住，这其实说明了数据的交付得到了延迟保证</p>
<p>对于长度大于1的channel<br>发送数据时，之前发送的数据不能保证一定被取走了，并且buffer size越大，数据的交付得到的保证越少。也正是由于这种无保证交付，减少了goroutine之间通信时的阻塞延迟，根据发送数据、接收数据、数据处理的速度合理的设计buffer size，甚至可以在不浪费空间的情况下做到没有任何延迟</p>
<p>如果channel buffer已经塞满了数据，继续执行发送会导致当前goruntine被block住（阻塞），直到channel中的数据被取走一部分才可以继续向channel发送数据</p>
<p>PS：</p>
<p>1.channel主要用于多个goroutine之间通信，不要在单个goruotine中进行读写，容易导致死锁</p>
<p>2.合理设计goroutine数量，和channel的size</p>
<h3 id="goroutine泄露"><a href="#goroutine泄露" class="headerlink" title="goroutine泄露"></a>goroutine泄露</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	ch := make(chan string)</span><br><span class="line">	count := <span class="number">3</span></span><br><span class="line">	<span class="keyword">for</span> index := <span class="number">0</span>; index &lt; count; index++ &#123;</span><br><span class="line">		go <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">			time.Sleep(time.Duration(rand.Intn(<span class="number">200</span>)) * time.Millisecond)</span><br><span class="line">			ch &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="xml">&lt;-ch)</span></span><br><span class="line"><span class="xml">	time.Sleep(time.Duration(rand.Intn(5000)) * time.Millisecond)</span></span><br><span class="line"><span class="xml">	//other work</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子，3个goroutine发送数据，1个接收数据</p>
<p>所以只有最早执行完send的goruntine的数据能得到交付，另外两个慢一点的goruntine将会被永远block住直到整个程序退出。这种情况也是一个BUG，称为goruntine泄露，泄露的goruntine并不会被自动回收</p>
<p>确保每个不再需要的goruntine正常退出非常重要，尤其是常驻内存的后台程序。</p>
<p>最需要注意的场景就是负责接收的goruntine在永久退出（return）接收处理时，要确保发送的goruntine不会因为继续发送数据被block住</p>
<p>改进：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	ch := make(chan string)</span><br><span class="line">	count := <span class="number">3</span></span><br><span class="line">	<span class="keyword">for</span> index := <span class="number">0</span>; index &lt; count; index++ &#123;</span><br><span class="line">		go <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">			time.Sleep(time.Duration(rand.Intn(<span class="number">200</span>)) * time.Millisecond)</span><br><span class="line">			ch &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> index := <span class="number">0</span>; index &lt; count; index++ &#123;</span><br><span class="line">		fmt.Println(<span class="xml">&lt;-ch)</span></span><br><span class="line"><span class="xml">	&#125;</span></span><br><span class="line"><span class="xml">	time.Sleep(time.Duration(rand.Intn(5000)) * time.Millisecond)</span></span><br><span class="line"><span class="xml">	//other work</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="cap和len"><a href="#cap和len" class="headerlink" title="cap和len"></a>cap和len</h3><p>cap可获取channel的长度容量</p>
<p>len可获取channel的数据个数</p>
<h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>range可以对channel进行迭代，不断接收channel里的数据（没有数据时阻塞），直到channel被关闭后自动退出迭代</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch = make(chan string, <span class="number">2</span>)</span><br><span class="line">	go <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">			time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">			ch &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">		close(ch) <span class="comment">// 放入5条数据后关闭</span></span><br><span class="line">	&#125;()</span><br><span class="line"> 	<span class="comment">// 超过channel长度继续写数据会阻塞，主goroutine会进行取，另一个goroutine进行写</span></span><br><span class="line">	<span class="keyword">for</span> recv := range ch &#123;</span><br><span class="line">		fmt.Println(recv) <span class="comment">// 关闭可继续读取数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>go提供的select可以同时对多个channel进行监控，实现并发接收。当多个case里的channel同时有数据ready的时候，select会随机选择一个case进行处理。</p>
<p>PS：range操作可以在channel关闭后自动退出，而select不会。所以在用for循环搭配select实现轮询时，select的case语句中必须显示的判断channel是否已经关闭，并做相应的处理，否则select每次从处于closed状态的channel中取出空值，并且继续执行case语句包含的body，程序的运行就可能与期望不一致</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch = make(chan string, <span class="number">2</span>)</span><br><span class="line">	go <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">			time.Sleep(<span class="number">1000</span> * time.Millisecond)</span><br><span class="line">			ch &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">		close(ch)</span><br><span class="line">	&#125;()</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		<span class="keyword">case</span> recv, <span class="attr">ok</span> := <span class="xml">&lt;-ch:</span></span><br><span class="line"><span class="xml">			if !ok &#123; // 显示的判断，是否关闭</span></span><br><span class="line"><span class="xml">				os.Exit(0)</span></span><br><span class="line"><span class="xml">			&#125;</span></span><br><span class="line"><span class="xml">			fmt.Println(recv)</span></span><br><span class="line"><span class="xml">		&#125;</span></span><br><span class="line"><span class="xml">	&#125;</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="并发循环"><a href="#并发循环" class="headerlink" title="并发循环"></a>并发循环</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	list := []int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	sizes := make(chan int)</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> e := range list &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		go <span class="function"><span class="title">func</span>(<span class="params">e int</span>)</span> &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">			sizes &lt;- e</span><br><span class="line">		&#125;(e)</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	go <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		wg.Wait()</span><br><span class="line">		close(sizes)</span><br><span class="line">	&#125;()</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">var</span> total int</span><br><span class="line">	<span class="keyword">for</span> num := range sizes &#123;</span><br><span class="line">		total += num</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据list的长度启动多个goruntine，每个gouruntine的处理就是向非缓冲channel中写入一个数据，main goruntine取到所有数据后打印total退出</p>
<p>1.sync.WaitGroup来做计数，每启动一个goruntine计数器加1，每个goruntine完成时用wg.Done()将计数器减1，还有一个额外的goruntine在监控计数器的变化（阻塞直到计数器减到0</p>
<p>2.如果所有的goruntine都完成了数据发送并退出，额外的goruntine将会关闭channel</p>
<p>3.main goruntine对channel的range操作一旦检测到channel被关闭便会立即退出</p>
<p>场景：使用并发循环，但是不知道迭代次数时</p>
<p>1.监控计数器的处理必须放到一个单独的goruntine中，因为Wait()会阻塞当前goruntine直到计数器变为0。</p>
<p>2.Add()操作可以加负数。无论是Add()还是Done()，如果操作会使计数器变为负数则会出发panic异常</p>
<h3 id="关于-gorountine-退出"><a href="#关于-gorountine-退出" class="headerlink" title="关于 gorountine 退出"></a>关于 gorountine 退出</h3><p>扫描磁盘空间例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//限制同时打开的目录文件数，防止启动过多的goruntine</span></span><br><span class="line"><span class="keyword">var</span> sema = make(chan struct&#123;&#125;, <span class="number">20</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//用于取消整个磁盘扫描任务</span></span><br><span class="line"><span class="keyword">var</span> done = make(chan struct&#123;&#125;)</span><br><span class="line"> </span><br><span class="line">func <span class="function"><span class="title">walkDir</span>(<span class="params">dir string, n *sync.WaitGroup, fileSizes chan&lt;- int64</span>)</span> &#123;</span><br><span class="line">	defer n.Done()</span><br><span class="line">	<span class="comment">//收到cancel信号后，goruntine直接退出</span></span><br><span class="line">	<span class="keyword">if</span> <span class="function"><span class="title">cancelled</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, <span class="attr">entry</span> := range <span class="function"><span class="title">dirents</span>(<span class="params">dir</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> entry.IsDir() &#123;</span><br><span class="line">			n.Add(<span class="number">1</span>)</span><br><span class="line">			subdir := filepath.Join(dir, entry.Name())</span><br><span class="line">			go walkDir(subdir, n, fileSizes)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fileSizes &lt;- entry.Size()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func dirents(dir string) []os.FileInfo &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	<span class="keyword">case</span> sema &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class="line">	<span class="keyword">case</span> <span class="xml">&lt;-done:</span></span><br><span class="line"><span class="xml">		//发出cancel后，我们期望是这个工作能立即被终止，但是对于已经启动的goruntine，dirents会继续执行并耗费不少时间</span></span><br><span class="line"><span class="xml">		//所以这里添加对cancel信号的处理，可以减少cancel操作的时延</span></span><br><span class="line"><span class="xml">		return nil</span></span><br><span class="line"><span class="xml">	&#125;</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">	defer func() &#123;</span></span><br><span class="line">		&lt;-sema</span><br><span class="line">	&#125;()</span><br><span class="line"> </span><br><span class="line">	entries, err := ioutil.ReadDir(dir)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Fprintf(os.Stderr, &quot;du1: %v\n&quot;, err)</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">	return entries</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func inputDir() string &#123;</span><br><span class="line">	var (</span><br><span class="line">		inputReader *bufio.Reader</span><br><span class="line">		dir         string</span><br><span class="line">		err         error</span><br><span class="line">	)</span><br><span class="line"> 	// inputReader，获取用户输入</span><br><span class="line">	inputReader = bufio.NewReader(os.Stdin)</span><br><span class="line">	// 打印提示</span><br><span class="line">	fmt.Printf(&quot;Please input a directory:&quot;)</span><br><span class="line">	// 读取用户输入</span><br><span class="line">	dir, err = inputReader.ReadString(&#x27;\n&#x27;)</span><br><span class="line">	// 遇到错误退出</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">	// 处理文件路径</span><br><span class="line">	dir = strings.Replace(dir, &quot;\n&quot;, &quot;&quot;, -1)</span><br><span class="line">	//返回文件路径</span><br><span class="line">	return dir</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func printDiskUsage(nFiles int64, nBytes int64) &#123;</span><br><span class="line">	fmt.Printf(&quot;%d files %.1f GB\n&quot;, nFiles, float64(nBytes)/1e9)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func cancelled() bool &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case &lt;-done:</span><br><span class="line">		return true</span><br><span class="line">	default:</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">	// 开始执行工作，打印开始执行</span><br><span class="line">	fmt.Println(&quot;=========Enter, walk.Test.()==========&quot;)</span><br><span class="line">	// defer最后结束执行，打印结束工作</span><br><span class="line">	defer fmt.Println(&quot;=========Exit, walk.Test.()==========&quot;)</span><br><span class="line">	// 程序输入</span><br><span class="line">	dir := inputDir()</span><br><span class="line"> </span><br><span class="line">	//从标准输入读到任何内容后，关闭done这个channel</span><br><span class="line">	go func() &#123;</span><br><span class="line">		os.Stdin.Read(make([]byte, 1))</span><br><span class="line">		close(done)</span><br><span class="line">	&#125;()</span><br><span class="line"> </span><br><span class="line">	fileSizes := make(chan int64)</span><br><span class="line">	var n sync.WaitGroup</span><br><span class="line">	n.Add(1)</span><br><span class="line">	go walkDir(dir, &amp;n, fileSizes)</span><br><span class="line"> </span><br><span class="line">	go func() &#123;</span><br><span class="line">		n.Wait()</span><br><span class="line">		close(fileSizes)</span><br><span class="line">	&#125;()</span><br><span class="line"> </span><br><span class="line">	var nFiles, nBytes int64</span><br><span class="line">	var tick &lt;-chan time.Time</span><br><span class="line">	tick = time.Tick(100 * time.Millisecond)</span><br><span class="line"> </span><br><span class="line">loop:</span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-done:</span><br><span class="line">			for range fileSizes &#123;</span><br><span class="line">				//do nothing，这个for循环的意义在于：收到cancel信号后，统计工作马上结束，我们会退出对fileSizes这个channel的接收操作，但是整个程序未必退出</span><br><span class="line">				//这时将fileSizes排空可以防止还在运行walkDir的goruntine因为向fileSies发送数据被阻塞（没有buffer或者buffer已满），导致goruntine泄露</span><br><span class="line">			&#125;</span><br><span class="line">			return</span><br><span class="line">		case size, ok := &lt;-fileSizes:</span><br><span class="line">			if !ok &#123; //这里必须显示的判断fileSizes是否已经被close</span><br><span class="line">				break loop</span><br><span class="line">			&#125;</span><br><span class="line">			nFiles++</span><br><span class="line">			nBytes += size</span><br><span class="line">		case &lt;-tick: //每0.1S产生一次时钟信号，打印一次当前统计数字</span><br><span class="line">			printDiskUsage(nFiles, nBytes)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	printDiskUsage(nFiles, nBytes)</span><br><span class="line">	close(sema)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1.新建一个done channel用于取消整个磁盘扫描任务，新建一个sema channel， 限制20个，限制同时打开的目录文件数</p>
<p>2.打印开始，defer打印结束</p>
<p>3.输入文件路径inputDir：</p>
<p>根据 inputReader，获取用户输入， inputReader.ReadString(‘\n’)读取用户输入， 遇到错误退出，处理并返回文件路径</p>
<p>4.用于关闭done chanel 从标准输入读到任何内容后，关闭done这个channel，用于主任务监控，关闭说明任务结束</p>
<p>5.初始化file的channel</p>
<p>6.开始计数，计数+1，启动goroutine 对于文件work。传入输入的文件路径，传入计数指针，用于修改计数，传入file的chaannel</p>
<pre><code>工作的函数：
1.defer，进行计数，最后计数减一
2.判断主done channel是否要关闭，防止work goroutine在主任务结束后，继续执行
3.根据文件路径获取文件列表 []os.FileInfo， dirents
    1.select监控，一种是监控到 done里有信号要退出，收到信号直接return nil，结束后续运行
      一种是往sema里写入一个空值，用来代表有一个目录文件被打开
    2.函数最后取出sema的数据
    3.读取文件路径，返回当前路径的文件列表，最后第二步，取出sema的数据
4.遍历出来的文件，判断是不是文件夹，不是把大小放到file channel里，是的话，计数加1
5.再启一个goroutine 继续work子路径，传入新得到的路径，计数，filechannel
PS:外面计数+1，work执行结束，减一， 如果有子路径，加1，进入子路径，结束后减1，最后都没有文件夹了，则计数为0</code></pre>
<p>7.单启一个goroutine，看计数，Wait()会阻塞当前goruntine直到计数器变为0，最后关闭file channel</p>
<p>8.声明一个tick channel time.Time格式</p>
<p>9.loop循环开启， select监听多个channel：<br>    1.done channel收到信号，统计工作结束<br>    2.file channel取出数据，判断file channel是否被关闭，然后取出数据统计<br>    3.tick channel，打印当时数据<br>    4.for循环结束，打印最终数据</p>
<p>10.最后程序退出</p>
<h3 id="close关闭"><a href="#close关闭" class="headerlink" title="close关闭"></a>close关闭</h3><p>close 内置函数关闭一个通道，该通道必须是双向的或仅发送的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ch1 := make(chan int, <span class="number">10</span>)</span><br><span class="line">ch2 := make(chan&lt;- int, <span class="number">10</span>)</span><br><span class="line">ch3 := make(<span class="xml">&lt;-chan int, 10)</span></span><br><span class="line"><span class="xml">close(ch1)</span></span><br><span class="line"><span class="xml">close(ch2)</span></span><br><span class="line"><span class="xml">close(ch3)</span></span><br></pre></td></tr></table></figure>
<p>关闭 channel3将panic cannot close receive-only channel</p>
<p>channel 应该由发送的一方执行，由接收 channel 的一方关闭</p>
<h3 id="done-channel"><a href="#done-channel" class="headerlink" title="done channel"></a>done channel</h3><p>用于主协程通知子协程取消的需求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    messages := make(chan int, <span class="number">10</span>)</span><br><span class="line">    done := make(chan bool)</span><br><span class="line"></span><br><span class="line">    defer close(messages)</span><br><span class="line">    <span class="comment">// consumer</span></span><br><span class="line">    go <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">        <span class="keyword">for</span> _ = range ticker.C &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="xml">&lt;-done:</span></span><br><span class="line"><span class="xml">                fmt.Println(&quot;child process interrupt...&quot;)</span></span><br><span class="line"><span class="xml">                return</span></span><br><span class="line"><span class="xml">            default:</span></span><br><span class="line">                fmt.Printf(&quot;send message: %d\n&quot;, &lt;-messages)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    // producer</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        messages &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(5 * time.Second)</span><br><span class="line">    close(done)</span><br><span class="line">    time.Sleep(1 * time.Second)</span><br><span class="line">    fmt.Println(&quot;main process exit!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子中定义了一个buffer为0的channel done,子协程运行着定时任务。</p>
<p>如果主协程需要在某个时刻发送消息通知子协程中断任务退出，那么就可以让子协程监听这个done channel，一旦主协程关闭done channel，那么子协程就可以推出了，这样就实现了主协程通知子协程的需求</p>
<h2 id="channel原理"><a href="#channel原理" class="headerlink" title="channel原理"></a>channel原理</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>src/runtime/chan.go里</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type hchan struct &#123;</span><br><span class="line">    qcount   uint           <span class="comment">// total data in the queue</span></span><br><span class="line">    dataqsiz uint           <span class="comment">// size of the circular queue</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">    elemsize uint16</span><br><span class="line">    closed   uint32</span><br><span class="line">    elemtype *_type <span class="comment">// element type</span></span><br><span class="line">    sendx    uint   <span class="comment">// send index</span></span><br><span class="line">    recvx    uint   <span class="comment">// receive index</span></span><br><span class="line">    recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">    sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>make的时候，会申请一块内存，创建一个hchan结构体，返回执行该内存的指针，所以获取的的ch变量本身就是一个指针，在函数之间传递的时候是同一个channel</p>
<p>核心的部分是存放channel数据的环形队列，由qcount和elemsize分别指定了队列的容量和当前使用量</p>
<p>如果是带缓冲区的chan，则缓冲区数据实际上是紧接着Hchan结构体中分配的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">c = (Hchan*)runtime.mal(n + hint*elem-&gt;size);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用两个list保存像该chan发送和从该chan接收数据的goroutine，还有一个mutex来保证操作这些结构的安全</p>
<p>recvq和sendq两个链表，一个是因读这个通道而导致阻塞的goroutine，另一个是因为写这个通道而阻塞的goroutine。如果一个goroutine阻塞于channel了，那么它就被挂在recvq或sendq中</p>
<p>队列中的每个成员是一个SudoG结构体变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct    SudoG</span><br><span class="line">&#123;</span><br><span class="line">    G*    g;        <span class="comment">// g and selgen constitute</span></span><br><span class="line">    uint32    selgen;        <span class="comment">// a weak pointer to g</span></span><br><span class="line">    SudoG*    link;</span><br><span class="line">    int64    releasetime;</span><br><span class="line">    byte*    elem;        <span class="comment">// data element</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构中主要的就是一个g和一个elem</p>
<p>elem用于存储goroutine的数据</p>
<p>读通道时，数据会从Hchan的队列中拷贝到SudoG的elem域</p>
<p>写通道时，数据则是由SudoG的elem域拷贝到Hchan的队列中</p>
<h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">c &lt;- v</span><br><span class="line"><span class="keyword">void</span> runtime·chansend(ChanType *t, Hchan *c, byte *ep, bool *pres, <span class="keyword">void</span> *pc)</span><br></pre></td></tr></table></figure>
<p>c就是channel<br>ep是取变量v的地址<br>pres 用于select操作中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">G1： c &lt;- task</span><br><span class="line">G2： task := <span class="xml">&lt;- ch</span></span><br></pre></td></tr></table></figure>

<p>G1是写入,发送者<br>G2是读取，接收者</p>
<p>流程：</p>
<p>写：</p>
<p>1.初始的时候hchan结构体的buf为空，sendx和recvx都为0</p>
<p>2.G1向ch里发送数据的时候，会首先对buf加锁</p>
<p>3.将要发送的数据copy到buf里，并增加sendx的值</p>
<p>4.最后释放buf的锁</p>
<p>读：</p>
<p>1.G2消费的时候首先对buf加锁</p>
<p>2.然后将buf里的数据copy到task变量对应的内存里，增加recvx</p>
<p>3.最后释放锁</p>
<p>PS：整个过程，G1和G2没有共享的内存，底层通过hchan结构体的buf，使用copy内存的方式进行通信，最后达到了共享内存的目的</p>
<p>G2的消费速度应该是慢于G1的，所以buf的数据会越来越多，这个时候G1再向ch里发送数据，这个时候G1就会阻塞</p>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>channel会区分是同步还是异步。</p>
<p>同步是指chan是不带缓冲区的，因此可能写阻塞，而异步是指chan带缓冲区，只有缓冲区满才阻塞</p>
<p>写阻塞：</p>
<p>1.G1向buf已经满了的ch发送数据的时候，当runtine检测到对应的hchan的buf已经满</p>
<p>2.会通知调度器，调度器会将G1的状态设置为waiting</p>
<p>3.移除与线程M的联系，然后从P的runqueue中选择一个goroutine在线程M中执行</p>
<p>4.G1就是阻塞状态，但是不是操作系统的线程阻塞</p>
<p>5.G1变为waiting状态后，会创建一个代表自己的sudog的结构，然后放到sendq这个list中</p>
<p>6.sudog结构中保存了channel相关的变量的指针</p>
<p>PS： 如果该Goroutine是sender，那么保存的是待发送数据的变量的地址，如果是receiver则为接收数据的变量的地址，之所以是地址，前面我们提到在传输数据的时候使用的是copy的方式</p>
<p>7.G2从ch中接收一个数据时，会通知调度器，设置G1的状态为runnable，然后将加入P的runqueue里，等待线程执行</p>
<h3 id="空通道"><a href="#空通道" class="headerlink" title="空通道"></a>空通道</h3><p>G2先运行，读阻塞：</p>
<p>1.G2会从一个empty的channel里取数据，这个时候G2就会阻塞</p>
<p>2.G2也会创建一个sudog结构体，保存接收数据的变量的地址，但是该sudog结构体是放到了recvq列表里</p>
<p>3.当G1向ch发送数据的时候，runtime并没有对hchan结构体题的buf进行加锁，而是直接将G1里的发送到ch的数据copy到了G2 sudog里对应的elem指向的内存地址</p>
<p>PS：读一个关闭的通道，永远不会阻塞，会返回一个通道数据类型的零值。这个实现也很简单，将零值复制到调用函数的参数ep中。写一个关闭的通道，则会panic。关闭一个空通道，也会导致panic</p>
<h3 id="select实现"><a href="#select实现" class="headerlink" title="select实现"></a>select实现</h3><p>select-case中的chan操作编译成了if-else</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select &#123;</span><br><span class="line"><span class="keyword">case</span> v = <span class="xml">&lt;-c:</span></span><br><span class="line"><span class="xml">        ...foo</span></span><br><span class="line"><span class="xml">default:</span></span><br><span class="line"><span class="xml">        ...bar</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>会被编译为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="function"><span class="title">selectnbrecv</span>(<span class="params">&amp;v, c</span>)</span> &#123;</span><br><span class="line">        ...foo</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>selectnbrecv函数调用runtime.chanrecv函数，只不过设置了一个参数，告诉当runtime.chanrecv函数，当不能完成操作时不要阻塞，而是返回失败</p>
<p>select操作其实都仅仅是被换成了if-else判断，底层调用的不阻塞的通道操作函数</p>
<h4 id="select随机性"><a href="#select随机性" class="headerlink" title="select随机性"></a>select随机性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct    Scase</span><br><span class="line">&#123;</span><br><span class="line">    SudoG    sg;            <span class="comment">// must be first member (cast to Scase)</span></span><br><span class="line">    Hchan*    chan;        <span class="comment">// chan</span></span><br><span class="line">    byte*    pc;            <span class="comment">// return pc</span></span><br><span class="line">    uint16    kind;</span><br><span class="line">    uint16    so;            <span class="comment">// vararg of selected bool</span></span><br><span class="line">    bool*    receivedp;    <span class="comment">// pointer to received bool (recv2)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct    Select</span><br><span class="line">&#123;</span><br><span class="line">    uint16    tcase;            <span class="comment">// 总的scase[]数量</span></span><br><span class="line">    uint16    ncase;            <span class="comment">// 当前填充了的scase[]数量</span></span><br><span class="line">    uint16*    pollorder;        <span class="comment">// case的poll次序</span></span><br><span class="line">    Hchan**    lockorder;        <span class="comment">// channel的锁住的次序</span></span><br><span class="line">    Scase    scase[<span class="number">1</span>];        <span class="comment">// 每个case会在结构体里有一个Scase，顺序是按出现的次序</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1.每个select都对应一个Select结构体</p>
<p>2.在Select数据结构中有个Scase数组，记录下了每一个case，而Scase中包含了Hchan。</p>
<p>3.然后pollorder数组将元素随机排列，将Scase乱序</p>
<h2 id="CSP模型"><a href="#CSP模型" class="headerlink" title="CSP模型"></a>CSP模型</h2><p>用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型</p>
<p>golang 通过goroutine和channel实现</p>
<p>Goroutine 是实际并发执行的实体，底层是使用协程(coroutine)实现并发，coroutine是一种运行在用户态的用户线程</p>
<p>1.用户空间 避免了内核态和用户态的切换导致的成本</p>
<p>2.可以由语言和框架层进行调度</p>
<p>3.更小的栈空间允许创建大量的实例</p>
<p>channel 是被单独创建并且可以在进程之间传递，它的通信模式类似于 boss-worker 模式的</p>
<p>一个实体通过将消息发送到channel 中，然后又监听这个 channel 的实体处理，两个实体之间是匿名的，这个就实现实体中间的解耦</p>
<p>其中 channel 是同步的一个消息被发送到 channel 中，最终是一定要被另外的实体消费掉的，在实现原理上其实是一个阻塞的消息队列</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO的基本数据结构：int，字符串，结构体，指针</title>
    <url>/2020/12/22/GO%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Aint%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a>int类型</h2><p><img src="/2020/12/22/GO%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Aint%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E6%8C%87%E9%92%88/1.png" alt="1"></p>
<p>变量i属于类型int，在内存中用一个32位字长(word)表示</p>
<p>变量j由于做了精确的转换，属于int32类型。尽管i和j有着相同的内存布局，但是它们属于不同的类型</p>
<p>变量f属于float类型，Go语言当前使用32位浮点型值表示(float32)。它与int32很像，但是内部实现不同。</p>
<p>接下来，变量bytes的类型是[5]byte，一个由5个字节组成的数组。它的内存表示就是连起来的5个字节，就像C的数组。类似地，变量primes是4个int的数组。</p>
<h2 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h2><p>字符串在Go语言内存模型中用一个2字长的数据结构表示。它包含一个指向字符串存储数据的指针和一个长度数据</p>
<p><img src="/2020/12/22/GO%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Aint%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E6%8C%87%E9%92%88/2.png" alt="2"></p>
<p>因为string类型是不可变的，对于多字符串共享同一个存储数据是安全的。切分操作str[i:j]会得到一个新的2字长结构，一个可能不同的但仍指向同一个字节序列(即上文说的存储数据)的指针和长度数据。</p>
<p>这意味着字符串切分可以在不涉及内存分配或复制操作。这使得字符串切分的效率等同于传递下标</p>
<h3 id="string的遍历"><a href="#string的遍历" class="headerlink" title="string的遍历"></a>string的遍历</h3><p>要么string打印，要么fmt格式化输出，得到字符串，不然得到的是byte类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;方法一  格式化打印&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> _, <span class="attr">ch1</span> := range str &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;%q&quot;</span>,ch1) <span class="comment">//单引号围绕的字符字面值，由go语法安全的转义</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;方法二  转化输出格式&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> _, <span class="attr">ch2</span> := range str &#123;</span><br><span class="line">      fmt.Println(string(ch2))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="strings包常用操作"><a href="#strings包常用操作" class="headerlink" title="strings包常用操作"></a>strings包常用操作</h3><h4 id="Count-s-string-str-string-int"><a href="#Count-s-string-str-string-int" class="headerlink" title="Count(s string, str string) int"></a>Count(s string, str string) int</h4><p>计算字符串str在s中的非重叠个数。如果str为空串则返回s中的字符（非字节）个数+1。</p>
<h4 id="Index-s-string-str-string-int"><a href="#Index-s-string-str-string-int" class="headerlink" title="Index(s string, str string) int"></a>Index(s string, str string) int</h4><p>返回子串str在字符串s中第一次出现的位置。如果找不到则返回-1；如果str为空，则返回0。</p>
<h4 id="LastIndex-s-string-str-string-int"><a href="#LastIndex-s-string-str-string-int" class="headerlink" title="LastIndex(s string, str string) int"></a>LastIndex(s string, str string) int</h4><p>返回子串str在字符串s中最后一次出现的位置。如果找不到则返回-1；如果str为空则返回字符串s的长度。</p>
<h4 id="IndexRune-s-string-r-rune-int"><a href="#IndexRune-s-string-r-rune-int" class="headerlink" title="IndexRune(s string, r rune) int"></a>IndexRune(s string, r rune) int</h4><p>返回字符r在字符串s中第一次出现的位置。如果找不到则返回-1。</p>
<h4 id="IndexAny-s-string-str-string-int"><a href="#IndexAny-s-string-str-string-int" class="headerlink" title="IndexAny(s string, str string) int"></a>IndexAny(s string, str string) int</h4><p>返回字符串str中的任何一个字符在字符串s中第一次出现的位置。如果找不到或str为空则返回-1。</p>
<h4 id="LastIndexAny-s-string-str-string-int"><a href="#LastIndexAny-s-string-str-string-int" class="headerlink" title="LastIndexAny(s string, str string) int"></a>LastIndexAny(s string, str string) int</h4><p>返回字符串str中的任何一个字符在字符串s中最后一次出现的位置。如果找不到或str为空则返回-1。</p>
<h4 id="Contains-s-string-str-string-bool"><a href="#Contains-s-string-str-string-bool" class="headerlink" title="Contains(s string, str string) bool"></a>Contains(s string, str string) bool</h4><p>判断字符串s中是否包含个子串str。包含或者str为空则返回true。</p>
<h4 id="ContainsAny-s-string-str-string-bool"><a href="#ContainsAny-s-string-str-string-bool" class="headerlink" title="ContainsAny(s string, str string) bool"></a>ContainsAny(s string, str string) bool</h4><p>判断字符串s中是否包含个子串str中的任何一个字符。包含则返回true，如果str为空则返回false。</p>
<h4 id="ContainsRune-s-string-r-rune-bool"><a href="#ContainsRune-s-string-r-rune-bool" class="headerlink" title="ContainsRune(s string, r rune) bool"></a>ContainsRune(s string, r rune) bool</h4><p>判断字符串s中是否包含字符r。</p>
<h4 id="SplitN-s-str-string-n-int-string"><a href="#SplitN-s-str-string-n-int-string" class="headerlink" title="SplitN(s, str string, n int) []string"></a>SplitN(s, str string, n int) []string</h4><p>以str为分隔符，将s切分成多个子串，结果中<strong>不包含</strong>str本身。如果str为空则将s切分成Unicode字符列表。如果s中没有str子串，则将整个s作为[]string的第一个元素返回。参数n表示最多切分出几个子串，超出的部分将不再切分，最后一个n包含了所有剩下的不切分。如果n为0，则返回nil；如果n小于0，则不限制切分个数，全部切分。</p>
<h4 id="SplitAfterN-s-str-string-n-int-string"><a href="#SplitAfterN-s-str-string-n-int-string" class="headerlink" title="SplitAfterN(s, str string, n int) []string"></a>SplitAfterN(s, str string, n int) []string</h4><p>以str为分隔符，将s切分成多个子串，结果中<strong>包含</strong>str本身。如果str为空，则将s切分成Unicode字符列表。如果s 中没有str子串，则将整个s作为 []string 的第一个元素返回。参数n表示最多切分出几个子串，超出的部分将不再切分。如果n为0，则返回 nil；如果 n 小于 0，则不限制切分个数，全部切分。</p>
<h4 id="Split-s-str-string-string"><a href="#Split-s-str-string-string" class="headerlink" title="Split(s, str string) []string"></a>Split(s, str string) []string</h4><p>以str为分隔符，将s切分成多个子切片，结果中<strong>不包含</strong>str本身。如果str为空，则将s切分成Unicode字符列表。如果s中没有str子串，则将整个s作为[]string的第一个元素返回。</p>
<h4 id="SplitAfter-s-str-string-string"><a href="#SplitAfter-s-str-string-string" class="headerlink" title="SplitAfter(s, str string) []string"></a>SplitAfter(s, str string) []string</h4><p>以str为分隔符，将s切分成多个子切片，结果中<strong>包含</strong>str本身。如果 str 为空，则将 s 切分成Unicode字符列表。如果s中没有str子串，则将整个s作为[]string的第一个元素返回。</p>
<h4 id="Fields-s-string-string"><a href="#Fields-s-string-string" class="headerlink" title="Fields(s string) []string"></a>Fields(s string) []string</h4><p>以连续的空白字符为分隔符，将s切分成多个子串，结果中不包含空白字符本身。空白字符有：\t, \n, \v, \f, \r, ’ ‘, U+0085 (NEL), U+00A0 (NBSP) 。如果 s 中只包含空白字符，则返回一个空列表。</p>
<h4 id="FieldsFunc-s-string-f-func-rune-bool-string"><a href="#FieldsFunc-s-string-f-func-rune-bool-string" class="headerlink" title="FieldsFunc(s string, f func(rune) bool) []string"></a>FieldsFunc(s string, f func(rune) bool) []string</h4><p>以一个或多个满足f(rune)的字符为分隔符，将s切分成多个子串，结果中不包含分隔符本身。如果s中没有满足f(rune)的字符，则返回一个空列表。</p>
<h4 id="Join-s-string-str-string-string"><a href="#Join-s-string-str-string-string" class="headerlink" title="Join(s []string, str string) string"></a>Join(s []string, str string) string</h4><p>将s中的子串连接成一个单独的字符串，子串之间用str分隔。</p>
<h4 id="HasPrefix-s-string-prefix-string-bool"><a href="#HasPrefix-s-string-prefix-string-bool" class="headerlink" title="HasPrefix(s string, prefix string) bool"></a>HasPrefix(s string, prefix string) bool</h4><p>判断字符串s是否以prefix开头。</p>
<h4 id="HasSuffix-s-suffix-string-bool"><a href="#HasSuffix-s-suffix-string-bool" class="headerlink" title="HasSuffix(s, suffix string) bool"></a>HasSuffix(s, suffix string) bool</h4><p>判断字符串s是否以prefix结尾。</p>
<h4 id="Map-f-func-rune-rune-s-string-string"><a href="#Map-f-func-rune-rune-s-string-string" class="headerlink" title="Map(f func(rune) rune, s string) string"></a>Map(f func(rune) rune, s string) string</h4><p>将s中满足f(rune)的字符替换为f(rune)的返回值。如果f(rune)返回负数，则相应的字符将被删除。</p>
<h4 id="Repeat-s-string-n-int-string"><a href="#Repeat-s-string-n-int-string" class="headerlink" title="Repeat(s string, n int) string"></a>Repeat(s string, n int) string</h4><p>将n个字符串s连接成一个新的字符串。</p>
<h4 id="ToUpper-s-string-string"><a href="#ToUpper-s-string-string" class="headerlink" title="ToUpper(s string) string"></a>ToUpper(s string) string</h4><p>将s中的所有字符修改为其大写格式。对于非ASCII字符，它的大写格式需要查表转换。</p>
<h4 id="ToLower-s-string-string"><a href="#ToLower-s-string-string" class="headerlink" title="ToLower(s string) string"></a>ToLower(s string) string</h4><p>将s中的所有字符修改为其小写格式。对于非ASCII字符，它的小写格式需要查表转换。</p>
<h4 id="ToTitle-s-string-string"><a href="#ToTitle-s-string-string" class="headerlink" title="ToTitle(s string) string"></a>ToTitle(s string) string</h4><p>将s中的所有字符修改为其Title格式，大部分字符的Title格式就是Upper格式，只有少数字符的Title格式是特殊字符。这里的ToTitle主要给Title函数调用。</p>
<h4 id="TrimLeftFunc-s-string-f-func-rune-bool-string"><a href="#TrimLeftFunc-s-string-f-func-rune-bool-string" class="headerlink" title="TrimLeftFunc(s string, f func(rune) bool) string"></a>TrimLeftFunc(s string, f func(rune) bool) string</h4><p>删除s头部连续的满足f(rune)的字符。</p>
<h4 id="TrimRightFunc-s-string-f-func-rune-bool-string"><a href="#TrimRightFunc-s-string-f-func-rune-bool-string" class="headerlink" title="TrimRightFunc(s string, f func(rune) bool) string"></a>TrimRightFunc(s string, f func(rune) bool) string</h4><p>删除s尾部连续的满足f(rune)的字符。</p>
<h4 id="TrimFunc-s-string-f-func-rune-bool-string"><a href="#TrimFunc-s-string-f-func-rune-bool-string" class="headerlink" title="TrimFunc(s string, f func(rune) bool) string"></a>TrimFunc(s string, f func(rune) bool) string</h4><p>删除s首尾连续的满足f(rune)的字符。</p>
<h4 id="IndexFunc-s-string-f-func-rune-bool-int"><a href="#IndexFunc-s-string-f-func-rune-bool-int" class="headerlink" title="IndexFunc(s string, f func(rune) bool) int"></a>IndexFunc(s string, f func(rune) bool) int</h4><p>返回s中第一个满足f(rune) 的字符的字节位置。如果没有满足 f(rune) 的字符，则返回 -1。</p>
<h4 id="LastIndexFunc-s-string-f-func-rune-bool-int"><a href="#LastIndexFunc-s-string-f-func-rune-bool-int" class="headerlink" title="LastIndexFunc(s string, f func(rune) bool) int"></a>LastIndexFunc(s string, f func(rune) bool) int</h4><p>返回s中最后一个满足f(rune)的字符的字节位置。如果没有满足 f(rune) 的字符，则返回 -1。</p>
<h4 id="Trim-s-string-str-string-string"><a href="#Trim-s-string-str-string-string" class="headerlink" title="Trim(s string, str string) string"></a>Trim(s string, str string) string</h4><p>删除s首尾连续的包含在str中的字符。</p>
<h4 id="TrimLeft-s-string-str-string-string"><a href="#TrimLeft-s-string-str-string-string" class="headerlink" title="TrimLeft(s string, str string) string"></a>TrimLeft(s string, str string) string</h4><p>删除s头部连续的包含在str中的字符串。</p>
<h4 id="TrimRight-s-string-str-string-string"><a href="#TrimRight-s-string-str-string-string" class="headerlink" title="TrimRight(s string, str string) string"></a>TrimRight(s string, str string) string</h4><p>删除s尾部连续的包含在str中的字符串。</p>
<h4 id="TrimSpace-s-string-string"><a href="#TrimSpace-s-string-string" class="headerlink" title="TrimSpace(s string) string"></a>TrimSpace(s string) string</h4><p>删除s首尾连续的的空白字符。</p>
<h4 id="TrimPrefix-s-prefix-string-string"><a href="#TrimPrefix-s-prefix-string-string" class="headerlink" title="TrimPrefix(s, prefix string) string"></a>TrimPrefix(s, prefix string) string</h4><p>删除s头部的prefix字符串。如果s不是以prefix开头，则返回原始s。</p>
<h4 id="TrimSuffix-s-suffix-string-string"><a href="#TrimSuffix-s-suffix-string-string" class="headerlink" title="TrimSuffix(s, suffix string) string"></a>TrimSuffix(s, suffix string) string</h4><p>删除s尾部的suffix字符串。如果s不是以suffix结尾，则返回原始s。（只去掉一次，注意和TrimRight区别）</p>
<h4 id="Replace-s-old-new-string-n-int-string"><a href="#Replace-s-old-new-string-n-int-string" class="headerlink" title="Replace(s, old, new string, n int) string"></a>Replace(s, old, new string, n int) string</h4><p>返回s的副本，并将副本中的old字符串替换为new字符串，替换次数为n次，如果n为-1，则全部替换；如果 old 为空，则在副本的每个字符之间都插入一个new。</p>
<h4 id="EqualFold-s1-s2-string-bool"><a href="#EqualFold-s1-s2-string-bool" class="headerlink" title="EqualFold(s1, s2 string) bool"></a>EqualFold(s1, s2 string) bool</h4><p>比较UTF-8编码在小写的条件下是否相等，不区分大小写，同时它还会对特殊字符进行转换。比如将“ϕ”转换为“Φ”、将“Ǆ”转换为“ǅ”等，然后再进行比较。<br>“==”比较字符串是否相等，区分大小写，返回bool。</p>
<h4 id="Compare-s1-string-s2-string-int1"><a href="#Compare-s1-string-s2-string-int1" class="headerlink" title="Compare(s1 string, s2 string) int1"></a>Compare(s1 string, s2 string) int1</h4><p>比较字符串，区分大小写，比”==”速度快。相等为0，不相等为-1。</p>
<h2 id="结构体和指针"><a href="#结构体和指针" class="headerlink" title="结构体和指针"></a>结构体和指针</h2><p>type Point struct { X, Y int }<br><img src="/2020/12/22/GO%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Aint%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E6%8C%87%E9%92%88/3.png" alt="3"><br>Point{10,20}表示一个已初始化的Point类型。对它进行取地址表示一个指向刚刚分配和初始化的Point类型</p>
<p>结构体的域在内存中是紧挨着排列的。</p>
<p>出于效率的考虑，大型的结构体通常都使用结构体指针的方式，直接传递给函数，或者从函数中返回</p>
<p>1.当函数本意是修改原始数据，用指针传递<br>2.结构体很大，用指针传递<br>3.结构体很小，不打算修改内容，用值传递，值传递是传递实参的副本，对本身没有影响</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO基本数据结构：nil,指针,值,引用类型</title>
    <url>/2020/12/24/GO%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Anil,%E6%8C%87%E9%92%88,%E5%80%BC,%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="引用类型，值"><a href="#引用类型，值" class="headerlink" title="引用类型，值"></a>引用类型，值</h2><p>1.值类型：变量直接存储，内存通常在栈中分配。<br>2.引用类型：变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配。通过GC回收</p>
<p>PS : 通常在函数中转入指针效率比较高，因为方法中的参数是需要进行拷贝的，拷贝指针的效率比较高，要是一个大的结构体的话拷贝的效率就比较低</p>
<p>1.值类型 ： 基本数据类型int、float、bool、string以及数组和struct。<br>2.引用类型：指针、slice、map、chan等都是引用类型</p>
<h2 id="nil，初始化零值"><a href="#nil，初始化零值" class="headerlink" title="nil，初始化零值"></a>nil，初始化零值</h2><p>nil代表空值</p>
<p>布尔类型是false<br>整型是0<br>字符串是””<br>而指针，函数，interface，slice，channel和map的零值都是nil</p>
<p>PS：<br>string的空值是””，它是不能跟nil比较的。即使是空的string，它的大小也是两个机器字长的。<br>slice也类似，它的空值并不是一个空指针，而是结构体中的指针域为空，空的slice的大小也是三个机器字长的。</p>
<p>指针域为空，但是有长度域，所以不是nil</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针指的是内存地址，而指针本身也是有内存地址的</p>
<p>&amp;： 取址符<br>变量获取内存地址，需要在变量前加上一个符号&amp;</p>
<ul>
<li>：取值符<br>内存地址获取变量，需要在内存地址前加上一个符号*</li>
</ul>
<p>这俩做着相反的事</p>
<p>指针的值：指的是数据的内存地址<br>指针的地址：指的是指针本身的内存地址</p>
<p>变量赋值后，指针不变</p>
<p>一个值为nil的指针变量，直接赋值会出问题</p>
<p>如下所示，声明的是一个指向string的指针类型的变量<br>前面打印的&amp;a是取的指针本身的地址，后面打印的是指针的值，也就是空值nil，还没有被赋值成地址，跟空字符串不一样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个指针变量 a 其类型也是 string</span></span><br><span class="line">    <span class="keyword">var</span> a *string</span><br><span class="line">    fmt.Printf(<span class="string">&quot;aPot: %p %#v\n&quot;</span>, &amp;a, a) <span class="comment">// 输出 a: 0xc42000c030 (*string)(nil)</span></span><br><span class="line">    *a = <span class="string">&quot;This is a Pointer&quot;</span>  <span class="comment">// 报错：panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以不能这样赋值，读取也会报错。* a 做取值操作会panic</p>
<p>解决方法是初始化内存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b string</span><br><span class="line">a = &amp;b</span><br><span class="line">*a = <span class="string">&quot;This is a Pointer&quot;</span></span><br></pre></td></tr></table></figure>
<p>给a赋值一个b的内存地址，在通过取值* 相当于从这个内存地址取了一个空字符串，再赋值，就不会报错</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO基本数据结构：slice</title>
    <url>/2020/12/21/GO%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Aslice/</url>
    <content><![CDATA[<p>一个slice是一个数组某个部分的引用。在内存中，它是一个包含3个域的结构体，</p>
<p>分为3个部分：</p>
<p>1.指向slice的指针<br>2.slice的长度，长度是下标操作的上界，如x[i]中i必须小于长度<br>3.slice的容量，容量是分割操作的上界，如x[i:j]中j不能大于容量</p>
<p><img src="/2020/12/21/GO%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Aslice/1.png" alt="1"></p>
<p>数组的slice不是复制操作，而是一个新的数据结构，新的指针，x[1:3]它只是写了一个新的slice结构的属性来引用相同的存储数据</p>
<h3 id="slice的扩容"><a href="#slice的扩容" class="headerlink" title="slice的扩容"></a>slice的扩容</h3><p>其实slice在Go的运行时库中就是一个<br>C语言动态数组的实现，<br>在$GOROOT/src/pkg/runtime/runtime.h中可以看到它的定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct    Slice</span><br><span class="line">&#123;    <span class="comment">// must not move anything</span></span><br><span class="line">    byte*    array;        <span class="comment">// actual data</span></span><br><span class="line">    uintgo    len;        <span class="comment">// number of elements</span></span><br><span class="line">    uintgo    cap;        <span class="comment">// allocated number of elements</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对slice进行append的操作时，slice会自动扩容</p>
<p>规则：<br>1、扩容后的大小是当前大小的2倍以上，则是新大小</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> newSize &gt;= <span class="number">2</span>* oldSize &#123;</span><br><span class="line">	size = newSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>2、如果扩容后的大小小于当前大小的2倍，则循环以下操作：<br>    1.当前大小小于1024,则按2倍大小增长<br>    2.当前大小大于1024，则按1/4倍大小增长<br>增长后的大小超过新大小，则结束循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> newSize &gt;= <span class="number">2</span>* oldSize &#123;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> oldSize &gt; newSize &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> oldSize &lt; <span class="number">1024</span> &#123;</span><br><span class="line">				oldSize += <span class="number">2</span>* oldSize</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				oldSize += <span class="number">1</span>/<span class="number">4</span>* oldSize</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="go协程下的slice扩容append"><a href="#go协程下的slice扩容append" class="headerlink" title="go协程下的slice扩容append"></a>go协程下的slice扩容append</h3><p>问题：go协程下，进行append操作，append并不是协程安全，往一个slice下添加，并发高，会出现问题</p>
<h4 id="方法1，索引处理"><a href="#方法1，索引处理" class="headerlink" title="方法1，索引处理"></a>方法1，索引处理</h4><p>设置一个全局slice</p>
<p>go协程下，不进行append，而是对全局slice，利用局部索引赋值，在for循环，go协程结束后，对其进行处理</p>
<p>开销比较小</p>
<h4 id="方法2，channel"><a href="#方法2，channel" class="headerlink" title="方法2，channel"></a>方法2，channel</h4><h4 id="方法3，加锁"><a href="#方法3，加锁" class="headerlink" title="方法3，加锁"></a>方法3，加锁</h4><p>对append操作进行上锁，append完进行解锁</p>
<p>开销比较大</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> l sync.Mutex</span><br><span class="line"></span><br><span class="line">l.Lock() <span class="comment">// 加锁</span></span><br><span class="line">a = append(a, <span class="number">1</span>)</span><br><span class="line">l.Unlock() <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<h3 id="slice添加元素"><a href="#slice添加元素" class="headerlink" title="slice添加元素"></a>slice添加元素</h3><h4 id="追加元素"><a href="#追加元素" class="headerlink" title="追加元素"></a>追加元素</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = append(a, i)</span><br></pre></td></tr></table></figure>

<h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><h5 id="创建临时切片"><a href="#创建临时切片" class="headerlink" title="创建临时切片"></a>创建临时切片</h5><p>取前2位，然后插入3，再把后几位加上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []int&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b= a[<span class="number">2</span>:]</span><br><span class="line">b = append([]int&#123;<span class="number">3</span>&#125;,b[<span class="number">0</span>:]...)</span><br><span class="line">a=append(a[<span class="number">0</span>:<span class="number">2</span>],b...)</span><br></pre></td></tr></table></figure>
<h5 id="append链式操作"><a href="#append链式操作" class="headerlink" title="append链式操作"></a>append链式操作</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []int&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">a=append(a[:<span class="number">2</span>],append([]int&#123;<span class="number">3</span>&#125;,a[<span class="number">2</span>:]...)...)</span><br></pre></td></tr></table></figure>

<h5 id="copy操作"><a href="#copy操作" class="headerlink" title="copy操作"></a>copy操作</h5><p>新添加一个0，然后复制，不需要新开切片</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []int&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">a=append(a,<span class="number">0</span>)</span><br><span class="line"><span class="comment">// copy前a[3:]是[5,6,0]，a[2:]是[4,5,6,0]</span></span><br><span class="line"><span class="comment">// 两个长度不同进行copy，取最短长度，把后面那个值，放到前面去</span></span><br><span class="line"><span class="comment">// 则结果位a[3:]就是[4,5,6]</span></span><br><span class="line"><span class="comment">// a为[1,2,4,4,5,6]</span></span><br><span class="line"><span class="comment">// 最后再修改第三个值，完成插入</span></span><br><span class="line">copy(a[<span class="number">3</span>:],a[<span class="number">2</span>:])</span><br><span class="line">a[<span class="number">2</span>]=<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>这种方法比较高效</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">s = append(s, zero_value)</span><br><span class="line">copy(s[i+<span class="number">1</span>:], s[i:])</span><br><span class="line">s[i] = x</span><br></pre></td></tr></table></figure>

<h3 id="slice删除元素"><a href="#slice删除元素" class="headerlink" title="slice删除元素"></a>slice删除元素</h3><p>根据下标删除元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除元素 3 索引(下标) 3</span></span><br><span class="line">index := <span class="number">3</span></span><br><span class="line"><span class="comment">// 这里通过 append 方法 分成两个然后合并</span></span><br><span class="line"><span class="comment">// append(切片名,追加的元素) 切片名这里我们进行切割一个新的切片DelIndex[:index] 追加的元素将索引后面的元素追加</span></span><br><span class="line"><span class="comment">// DelIndex[index+1:]...) 为什么追加会有...三个点, 因为是一个切片 所以需要展开</span></span><br><span class="line">DelIndex = append(DelIndex[:index], DelIndex[index+<span class="number">1</span>:]...)</span><br></pre></td></tr></table></figure>

<h3 id="slice反转"><a href="#slice反转" class="headerlink" title="slice反转"></a>slice反转</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func reverse(s []byte) []byte &#123;</span><br><span class="line">	<span class="keyword">for</span> i, <span class="attr">j</span> := <span class="number">0</span>, len(s)-<span class="number">1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j-<span class="number">1</span> &#123;</span><br><span class="line">		s[i], s[j] = s[j], s[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func reverseSlice (arr []int) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(arr)/<span class="number">2</span>; i++ &#123;</span><br><span class="line">        arr[i], arr[len(arr)-<span class="number">1</span>-i] = arr[len(arr)-<span class="number">1</span>-i], arr[i] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO的基本数据结构：map</title>
    <url>/2020/12/23/GO%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Amap/</url>
    <content><![CDATA[<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>G基本结构如下，runtime/map.go go版本 v1.11</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line">type hmap struct &#123;</span><br><span class="line">        <span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span></span><br><span class="line">        <span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span></span><br><span class="line">        count     int <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">        flags     uint8</span><br><span class="line">        B         uint8  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">        noverflow uint16 <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">        hash0     uint32 <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">        buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">        oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">        nevacuate  uintptr        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">        extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1.这个hash结构使用的是一个可扩展哈希的算法，由hash值mod当前hash表大小决定某一个值属于哪个桶，而hash表大小是2的指数，即上面结构体中的2^B。</p>
<p>2.每次扩容，会增大到上次大小的两倍。结构体中有一个buckets和一个oldbuckets是用来实现增量扩容的。正常情况下直接使用buckets，而oldbuckets为空。如果当前哈希表正在扩容中，则oldbuckets不为空，并且buckets大小是oldbuckets大小的两倍</p>
<p>捅结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A bucket for a Go map.</span></span><br><span class="line">type bmap struct &#123;</span><br><span class="line">        <span class="comment">// tophash generally contains the top byte of the hash value</span></span><br><span class="line">        <span class="comment">// for each key in this bucket. If tophash[0] &lt; minTopHash,</span></span><br><span class="line">        <span class="comment">// tophash[0] is a bucket evacuation state instead.</span></span><br><span class="line">        tophash [bucketCnt]uint8</span><br><span class="line">        <span class="comment">// Followed by bucketCnt keys and then bucketCnt values.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> packing all the keys together and then all the values together makes the</span></span><br><span class="line">        <span class="comment">// code a bit more complicated than alternating key/value/key/value/... but it allows</span></span><br><span class="line">        <span class="comment">// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span></span><br><span class="line">        <span class="comment">// Followed by an overflow pointer.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个桶bucket最多存放8个kv对，多于8个，会申请一个新的bucket，并将它与之前的bucket链起来</p>
<p>当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。冲突的解决手段是用链表法：在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key</p>
<h2 id="map的增量扩容"><a href="#map的增量扩容" class="headerlink" title="map的增量扩容"></a>map的增量扩容</h2><p>扩容过程中会有两张表，oldtable 旧哈希表， newtable 新哈希表</p>
<p>1.根据结构设置，哈希表的大小是2^B，扩容之后的大小为2^(B+1)，每次扩容都变为原来大小的两倍</p>
<p>2.会建立一个新的2倍大小的hash表，将旧的buckets搬到新表</p>
<p>3.一般旧表hash值不等于新表hash，需要重新计算hash到新表，旧的表的buckets不会删除，加一个已删除标记</p>
<p>4.增量扩容，不会一次完成，每次搬移1-2个键值对，由于这个工作是逐渐完成的，这样就会导致一部分数据在old table中，一部分在new table中，所以对于hashmap的insert,remove,lookup操作的处理逻辑产生影响。只有当所有的bucket都从旧表移到新表之后，才会将oldbucket释放掉</p>
<p>PS： 为什么是增量， 为了缩短map容器的响应时间，元素很多的话，不增量就会卡住，响应时间过长</p>
<p>5.扩容因子：如果grow的太频繁，会造成空间的利用率很低，如果很久才grow，会形成很多的overflow buckets，查找的效率也会下降</p>
<p>作者测试：6.5适中，table中元素的个数大于table中能容纳的元素的个数</p>
<h2 id="map的查找过程"><a href="#map的查找过程" class="headerlink" title="map的查找过程"></a>map的查找过程</h2><p>1、将key的类型选用hash算法得到key的hash值</p>
<p>2、hash值的的低位，作为buckets数组的index索引，用于找到key所在的bucket数组</p>
<p>3.hash的高8位存储到tophash，tophash在bucket结构里</p>
<p>PS：存储过程中，key放在一起。value放在一起，方便字节对齐（底层cpu访问数据效率）避免浪费存储空间</p>
<p>部分代码： mapaccess1方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 不同类型 key 使用的 hash 算法在编译期确定</span></span><br><span class="line">    alg := t.key.alg</span><br><span class="line">    <span class="comment">// 计算哈希值，并且加入 hash0 引入随机性</span></span><br><span class="line">    hash := alg.hash(key, uintptr(h.hash0))</span><br><span class="line">    <span class="comment">// 比如 B=5，那 m 就是31，二进制是全 1</span></span><br><span class="line">    <span class="comment">// 求 bucket num 时，将 hash 与 m 相与，</span></span><br><span class="line">    <span class="comment">// 达到 bucket num 由 hash 的低 8 位决定的效果</span></span><br><span class="line">    m := bucketMask(h.B)</span><br><span class="line">    <span class="comment">// b 就是 bucket 的地址</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, (hash&amp;m)*uintptr(t.bucketsize)))</span><br><span class="line">    <span class="comment">// oldbuckets 不为 nil，说明发生了扩容</span></span><br><span class="line">    <span class="keyword">if</span> c := h.oldbuckets; c != nil &#123;</span><br><span class="line">        <span class="comment">// 如果不是同 size 扩容（看后面扩容的内容）</span></span><br><span class="line">        <span class="comment">// 对应条件 1 的解决方案</span></span><br><span class="line">        <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            <span class="comment">// 新 bucket 数量是老的 2 倍</span></span><br><span class="line">            m &gt;&gt;= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求出 key 在老的 map 中的 bucket 位置</span></span><br><span class="line">        oldb := (*bmap)(add(c, (hash&amp;m)*uintptr(t.bucketsize)))</span><br><span class="line">        <span class="comment">// 如果 oldb 没有搬迁到新的 bucket</span></span><br><span class="line">        <span class="comment">// 那就在老的 bucket 中寻找</span></span><br><span class="line">        <span class="keyword">if</span> !<span class="function"><span class="title">evacuated</span>(<span class="params">oldb</span>)</span> &#123;</span><br><span class="line">            b = oldb</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算出高 8 位的 hash</span></span><br><span class="line">    <span class="comment">// 相当于右移 56 位，只取高8位</span></span><br><span class="line">    top := tophash(hash)</span><br><span class="line">    <span class="comment">//开始寻找key</span></span><br><span class="line">    <span class="keyword">for</span> ; b != nil; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="comment">// 遍历 8 个 bucket</span></span><br><span class="line">        <span class="keyword">for</span> i := uintptr(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="comment">// tophash 不匹配，继续</span></span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// tophash 匹配，定位到 key 的位置</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))</span><br><span class="line">            <span class="comment">// key 是指针</span></span><br><span class="line">            <span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">                <span class="comment">// 解引用</span></span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 key 相等</span></span><br><span class="line">            <span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">                <span class="comment">// 定位到 value 的位置</span></span><br><span class="line">                v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))</span><br><span class="line">                <span class="comment">// value 解引用</span></span><br><span class="line">                <span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">                    v = *((*unsafe.Pointer)(v))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找流程：</p>
<p>1、先找oldtable，旧的hash表，如果hash表已经被添加删除标记，则去新的找</p>
<p>2.先比较key的hash值高8位在tophash[i]值是否相等，顺序比较，得到i</p>
<p>3.找到key的hash低位对应的bucket</p>
<p>4.如果相等则再比较bucket的第i个的key与所给的key是否相等</p>
<p>5.如果没有，则在overflow里继续寻找，桶溢出链表</p>
<p><img src="/2020/12/23/GO%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Amap/1.png" alt="1"></p>
<h2 id="map的插入过程"><a href="#map的插入过程" class="headerlink" title="map的插入过程"></a>map的插入过程</h2><p>1.初始化校验，根据key计算hash，根据低位找对对应的buckets数组</p>
<p>部分代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">//判断 hmap 是否已经初始化（是否为 nil）</span></span><br><span class="line">    <span class="keyword">if</span> h == nil &#123;</span><br><span class="line">        panic(plainError(<span class="string">&quot;assignment to entry in nil map&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//判断是否并发读写 map，若是则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span>(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据 key 的不同类型调用不同的 hash 方法计算得出 hash 值</span></span><br><span class="line">    alg := t.key.alg</span><br><span class="line">    hash := alg.hash(key, uintptr(h.hash0))</span><br><span class="line">    <span class="comment">//设置 flags 标志位，表示有一个 goroutine 正在写入数据。因为 alg.hash 有可能出现 panic 导致异常</span></span><br><span class="line">    h.flags |= hashWriting</span><br><span class="line">    <span class="comment">//判断 buckets 是否为 nil，若是则调用 newobject 根据当前 bucket 大小进行分配</span></span><br><span class="line">    <span class="comment">//初始化时没有初始 buckets，那么它在第一次赋值时就会对 buckets 分配</span></span><br><span class="line">    <span class="keyword">if</span> h.buckets == nil &#123;</span><br><span class="line">        h.buckets = newobject(t.bucket) <span class="comment">// newarray(t.bucket, 1)</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.根据table中元素的个数，判断是否正在扩容。</p>
<p>3.如果在扩容中：<br>    oldbucket是被冻结的，查找时会在oldbucket中查找，但不会在oldbucket中插入数据。如果在oldbucket是找到了相应的key，做法是将它迁移到新bucket后加入evalucated标记</p>
<p>4.在bucket中，查找空闲的位置，如果已经存在需要插入的key，更新其对应的value。</p>
<p>5.如果对应的bucket已经full，重新申请新的bucket作为overbucket。</p>
<p>6.将key/value pair插入到bucket中</p>
<p>部分代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据低八位计算得到 bucket 的内存地址</span></span><br><span class="line">    bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">    <span class="comment">//判断是否正在扩容，若正在扩容中则先迁移再接着处理</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        growWork(t, h, bucket)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算并得到 bucket 的 bmap 指针地址</span></span><br><span class="line">    b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))</span><br><span class="line">    <span class="comment">//计算 key hash 高八位用于查找 Key</span></span><br><span class="line">    top := tophash(hash)</span><br><span class="line">    <span class="keyword">var</span> inserti *uint8</span><br><span class="line">    <span class="keyword">var</span> insertk unsafe.Pointer</span><br><span class="line">    <span class="keyword">var</span> val unsafe.Pointer</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//迭代 buckets 中的每一个 bucket（共 8 个）</span></span><br><span class="line">        <span class="keyword">for</span> i := uintptr(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="comment">//对比 bucket.tophash 与 top（高八位）是否一致</span></span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="comment">//若不一致，判断是否为空槽</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == empty &amp;&amp; inserti == nil &#123;</span><br><span class="line">                    <span class="comment">//有两种情况，第一种是没有插入过。第二种是插入后被删除</span></span><br><span class="line">                    inserti = &amp;b.tophash[i]</span><br><span class="line">                    insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))</span><br><span class="line">                    <span class="comment">//把该位置标识为可插入 tophash 位置,这里就是第一个可以插入数据的地方</span></span><br><span class="line">                    val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若是匹配（也就是原本已经存在），则进行更新。最后跳出并返回 value 的内存地址</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))</span><br><span class="line">            <span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !alg.equal(key, k) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// already have a mapping for key. Update it.</span></span><br><span class="line">            <span class="keyword">if</span> t.needkeyupdate &#123;</span><br><span class="line">                typedmemmove(t.key, k, key)</span><br><span class="line">            &#125;</span><br><span class="line">            val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))</span><br><span class="line">            goto done</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否迭代完毕，若是则结束迭代 buckets 并更新当前桶位置</span></span><br><span class="line">        ovf := b.overflow(t)</span><br><span class="line">        <span class="keyword">if</span> ovf == nil &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        b = ovf</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若满足三个条件：触发最大 LoadFactor 、存在过多溢出桶 overflow buckets、没有正在进行扩容。就会进行扩容动作（以确保后续的动作）</span></span><br><span class="line">    <span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">        hashGrow(t, h)</span><br><span class="line">        goto again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>PS：<br>插入是数据追加方式：<br>1.先找到对应的key，则更新对应的value并结束遍历</p>
<p>2.先找到对应的空位，则直接在这个位置插入，后面的都会覆盖并结束遍历，因为是顺序遍历，buckets数组后面的会被覆盖掉</p>
<p>3.然后就是只要在某个bucket中找到第一个空位，就会将key/value插入到这个位置。也就是位置位于bucket前面的会覆盖后面的(类似于存储系统设计中做删除时的常用的技巧之一，直接用新数据追加方式写，新版本数据覆盖老版本数据)</p>
<p>不过这也意味着做删除时必须完全的遍历bucket所有溢出链，将所有的相同key数据都删除。</p>
<p>所以目前map的设计是为插入而优化的，删除效率会比插入低一些</p>
<h2 id="map的删除过程"><a href="#map的删除过程" class="headerlink" title="map的删除过程"></a>map的删除过程</h2><p>删除某个key的操作与分配类似，由于hashmap的存储结构是数组+链表，所以真正删除key仅仅是将对应的slot设置为empty，并没有减少内存</p>
<p>delete(intMap, 1)</p>
<p>所以过程给查找类似，把tophash值设成empty，并不是真正释放内存</p>
<h3 id="清空map"><a href="#清空map" class="headerlink" title="清空map"></a>清空map</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, <span class="attr">_</span> := range m &#123;</span><br><span class="line">	<span class="keyword">delete</span>(m, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.map 被清空。执行完之后调用len函数，结果肯定是0；<br>2.内存没有释放。清空只是修改了一个标记，底层内存还是被占用了；<br>3.循环遍历了len(m)次。上面的代码每一次遍历都会删除一个元素，而遍历的次数并不会因为之前每次删一个元素导致减少</p>
<p>真正的释放内存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">map = nil</span><br></pre></td></tr></table></figure>

<p>这之后坐等垃圾回收器回收就好了。</p>
<p>PS：用 map 做缓存，而每次更新只是部分更新，更新的 key 如果偏差比较大，有可能会有内存逐渐增长而不释放的问题</p>
<h2 id="map的性能思考，调优"><a href="#map的性能思考，调优" class="headerlink" title="map的性能思考，调优"></a>map的性能思考，调优</h2><p>1.hashmap中存的是buckets数组，而不是指针，存数组的好处：可以一次性分配更多内存，减少分配次数，避免多次gc<br>缺点就是，扩容时会对整个数组的值拷贝，而不是指针，代价相比指针较大</p>
<p>2.bucket的kv优化，如果kv小于128字节，则存的是kv值，否则kv就是指向真实kv数据的指针</p>
<h2 id="map的并发安全"><a href="#map的并发安全" class="headerlink" title="map的并发安全"></a>map的并发安全</h2><p>map的相关操作并不是协程安全的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">c := make(map[string]string)</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    go <span class="function"><span class="title">func</span>(<span class="params">n int</span>)</span> &#123;</span><br><span class="line">        k, <span class="attr">v</span> := strconv.Itoa(n), strconv.Itoa(n)</span><br><span class="line">        c[k] = v</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(c)</span><br></pre></td></tr></table></figure>

<p>以上操作会触发协程安全错误</p>
<p>加锁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">c := make(map[string]string)</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    go <span class="function"><span class="title">func</span>(<span class="params">n int</span>)</span> &#123;</span><br><span class="line">        k, <span class="attr">v</span> := strconv.Itoa(n), strconv.Itoa(n)</span><br><span class="line">        lock.Lock()</span><br><span class="line">        c[k] = v</span><br><span class="line">        lock.Unlock()</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(c)</span><br></pre></td></tr></table></figure>

<p>sync.Map官方包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m sync.Map</span><br><span class="line"></span><br><span class="line"><span class="comment">//写</span></span><br><span class="line">m.Store(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">m.Store(<span class="string">&quot;slice&quot;</span>, []int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;)</span><br><span class="line">m.Store(<span class="string">&quot;int&quot;</span>, <span class="number">123</span>)</span><br><span class="line"><span class="comment">//读</span></span><br><span class="line">m.Load(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">m.Load(<span class="string">&quot;slice&quot;</span>)</span><br><span class="line">m.Load(<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="comment">//删</span></span><br><span class="line">m.Delete(<span class="string">&quot;int&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO的接口interface和反射</title>
    <url>/2021/01/20/GO%E7%9A%84%E6%8E%A5%E5%8F%A3interface%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="interface定义"><a href="#interface定义" class="headerlink" title="interface定义"></a>interface定义</h2><p>接口是一组方法签名(声明的是一组方法的集合)。当一个类型为接口中的所有方法提供定义时，它被称为实现该接口</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">type Animal interface &#123;</span><br><span class="line">    Speak() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Dog struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (d Dog) Speak() string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">type Cat struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (c Cat) Speak() string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Meow!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    animals := []Animal&#123;Dog&#123;&#125;, Cat&#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, <span class="attr">animal</span> := range animals &#123;</span><br><span class="line">        fmt.Println(animal.Speak())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空interface"><a href="#空interface" class="headerlink" title="空interface{}"></a>空interface{}</h3><p>interface{} 类型，空接口，没有方法的接口，所有类型都至少实现了 0 个方法，所以 所有类型都实现了空接口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">DoSomething</span>(<span class="params">v interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>v是interface类型，其他类型需要转换断言</p>
<h3 id="指针和接口"><a href="#指针和接口" class="headerlink" title="指针和接口"></a>指针和接口</h3><p>上面的Cat的speak方法是值接收器，下面的改为指针接收器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func (c *Cat) Speak() string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Meow!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时访问需要指针类型定义才可以访问，不然会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">animals := []Animal&#123;<span class="keyword">new</span>(Dog), <span class="keyword">new</span>(Cat)&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式下Dog也可以正常工作，因为一个指针类型可以通过其相关的值类型来访问值类型的方法，但是反过来不行。即，一个 * Dog 类型的值可以使用定义在 Dog 类型上的 Speak() 方法，而 Cat 类型的值不能访问定义在 * Cat 类型上的方法</p>
<h2 id="interface实现"><a href="#interface实现" class="headerlink" title="interface实现"></a>interface实现</h2><p>interface实际上就是一个结构体，包含两个成员。其中一个成员是指向具体数据的指针，另一个成员中包含了类型信息。空接口和带方法的接口略有不同，eface 和 iface</p>
<h3 id="eface"><a href="#eface" class="headerlink" title="eface"></a>eface</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct Eface</span><br><span class="line">&#123;</span><br><span class="line">    Type*    type;</span><br><span class="line">    <span class="keyword">void</span>*    data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>eface 表示空的 interface{}，它用两个机器字长表示，第一个字 type 是指向实际类型描述的指针，第二个字 data 代表数据指针</p>
<h3 id="iface"><a href="#iface" class="headerlink" title="iface"></a>iface</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct Iface</span><br><span class="line">&#123;</span><br><span class="line">    Itab*    tab;</span><br><span class="line">    <span class="keyword">void</span>*    data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>iface 表示至少带有一个函数的 interface， 它也用两个机器字长表示，第一个字 tab 指向一个 itab 结构，第二个字 data 代表数据指针</p>
<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>data 用来保存实际变量的地址。</p>
<p>data 中的内容会根据实际情况变化，因为 golang 在函数传参和赋值时是 值传递 的，所以：</p>
<p>1.如果实际类型是一个值，那么 interface 会保存这个值的一份拷贝。interface 会在堆上为这个值分配一块内存，然后 data 指向它。</p>
<p>2.如果实际类型是一个指针，那么 interface 会保存这个指针的一份拷贝。由于 data 的长度恰好能保存这个指针的内容，所以 data 中存储的就是指针的值。它和实际数据指向的是同一个变量。</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type 类型结构如下，反射方法会涉及到type域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct Type</span><br><span class="line">&#123;</span><br><span class="line">    uintptr size; <span class="comment">// 为该类型所占用的字节数量</span></span><br><span class="line">    uint32 hash;</span><br><span class="line">    uint8 _unused;</span><br><span class="line">    uint8 align;</span><br><span class="line">    uint8 fieldAlign;</span><br><span class="line">    uint8 kind; <span class="comment">// 表示类型的种类，如 bool、int、float、string、struct、interface 等。</span></span><br><span class="line">    Alg *alg;</span><br><span class="line">    <span class="keyword">void</span> *gc; <span class="comment">// 精确的垃圾回收中，就是依赖Type结构体中的gc域的</span></span><br><span class="line">    UncommonType *x;</span><br><span class="line">    Type *ptrto;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Itab"><a href="#Itab" class="headerlink" title="Itab"></a>Itab</h3><p>Iface和Eface略有不同，它是带方法的interface底层使用的数据结构。data域同样是指向原始数据的，而Itab的结构如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct    Itab</span><br><span class="line">&#123;</span><br><span class="line">    InterfaceType*    inter;</span><br><span class="line">    Type*    type;</span><br><span class="line">    Itab*    link;</span><br><span class="line">    int32    bad;</span><br><span class="line">    int32    unused;</span><br><span class="line">    <span class="keyword">void</span>    (*fun[])(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1.inter 指向对应的 interface 的类型信息。</p>
<p>2.type 和 eface 中的一样，指向的是实际类型的描述信息 type</p>
<p>3.fun 为函数列表，表示对于该特定的实际类型而言，interface中所有函数的地址，一个Iface中的具体类型中实现的方法会被拷贝到Itab的fun数组中</p>
<h3 id="Itab函数生成"><a href="#Itab函数生成" class="headerlink" title="Itab函数生成"></a>Itab函数生成</h3><p>假设 interface 有 m 个函数， struct 有 n 个函数，那么 itab 中的函数表生成的时间复杂度为 O(m* n) </p>
<p>遍历 interface 的所有函数，对每次迭代都从 struct 中遍历找到匹配的函数</p>
<p>Type结构体中是有个UncommonType字段的，里面有张方法表，类型所实现的方法都在里面。而在Itab中有个InterfaceType字段，这个字段中也有一张方法表，就是这个接口所要求的方法。</p>
<p>这两处方法表都是排序过的，只需要一遍顺序扫描进行比较，应该可以知道Type中否实现了接口中声明的所有方法，所以实现了 O(m + n) 时间复杂度的算法</p>
<h3 id="interface参数传递与函数调用"><a href="#interface参数传递与函数调用" class="headerlink" title="interface参数传递与函数调用"></a>interface参数传递与函数调用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type Binary uint64</span><br><span class="line"></span><br><span class="line">func (i Binary) <span class="built_in">String</span>() string &#123;</span><br><span class="line">    <span class="keyword">return</span> strconv.FormatUint(uint64(i), <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Stringer interface &#123;</span><br><span class="line">    <span class="built_in">String</span>() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">test</span>(<span class="params">s Stringer</span>)</span> &#123;</span><br><span class="line">    s.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    a := Binary(<span class="number">0x123</span>)</span><br><span class="line">    test(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>1.分配一块内存 p， 并且将对象 a 的内容拷贝到 p 中</p>
<p>2.创建 iface 对象 i，将 i.tab 赋值为 itab&lt;Stringer, Binary&gt;。将 i.data 赋值为 p</p>
<p>3.使用 i 作为参数调用 test 函数。</p>
<p>4.当 test 函数执行 s.String 时，实际上就是在 s.tab 的 fun 中索引（索引由编译器在编译时生成）到 String 函数，并且调用它</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>不知道类型的情况下，可更新变量、运行时查看值、调用方法以及直接对他们的布局进行操作的机制，称为反射</p>
<p>比如需要一个函数处理各种类型的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> value := value.(type) &#123;</span><br><span class="line"><span class="keyword">case</span> string:</span><br><span class="line">	<span class="comment">// ...一些操作</span></span><br><span class="line"><span class="keyword">case</span> int:	</span><br><span class="line">	<span class="comment">// ...一些操作	</span></span><br><span class="line"><span class="keyword">case</span> cbsStruct: <span class="comment">// 自定义的结构体	</span></span><br><span class="line">	<span class="comment">// ...一些操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型很多，代码会很长，且不好维护</p>
<p>反射可以获取变量的内部信息，reflect包是用来实现运行反射的。通过reflect包能够完成对一个interface{}变量的具体类型以及值的获取</p>
<h3 id="reflect-Type和reflect-Value"><a href="#reflect-Type和reflect-Value" class="headerlink" title="reflect.Type和reflect.Value"></a>reflect.Type和reflect.Value</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reflect.ValueOf()</span><br></pre></td></tr></table></figure>
<p>获取输入参数接口中的数据的值，如果为空则返回0 &lt;- 注意是0</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reflect.TypeOf()</span><br></pre></td></tr></table></figure>
<p>动态获取输入参数接口中的值的类型，如果为空则返回nil &lt;- 注意是nil</p>
<p>输出了interface{}的真实类型以及真实值</p>
<h3 id="Kind"><a href="#Kind" class="headerlink" title="Kind"></a>Kind</h3><p>也是代表类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type order struct &#123;  </span><br><span class="line">    ordId      int</span><br><span class="line">    customerId int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o := order&#123;</span><br><span class="line">    ordId:      <span class="number">456</span>,</span><br><span class="line">    customerId: <span class="number">56</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := reflect.TypeOf(q)</span><br><span class="line">k := t.Kind(q)</span><br></pre></td></tr></table></figure>

<p>reflect.Type和reflect.Kind<br>Type代表interface{}实际类型main.order<br>而Kind代表具体类型struct</p>
<h3 id="NumField-和Field"><a href="#NumField-和Field" class="headerlink" title="NumField() 和Field()"></a>NumField() 和Field()</h3><p>NumField()方法获取一个struct所有的fields，Field(i int)获取指定第i个field的reflect.Value</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> v := reflect.ValueOf(q) <span class="comment">// TypeOf 也可以</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Field:%d type:%T value:%v\n&quot;</span>, i, v.Field(i), v.Field(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Int-和String"><a href="#Int-和String" class="headerlink" title="Int() 和String()"></a>Int() 和String()</h3><p>Int()和String()主要用于从reflect.Value提取对应值作为int64和string类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reflect.ValueOf(a).Int()</span><br><span class="line">reflect.ValueOf(b).String()</span><br></pre></td></tr></table></figure>

<h3 id="Name"><a href="#Name" class="headerlink" title="Name()"></a>Name()</h3><p>.Name()可以获取去这个类型的名称</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reflect.TypeOf(a).Name()</span><br></pre></td></tr></table></figure>

<h3 id="NumMethod-和Method"><a href="#NumMethod-和Method" class="headerlink" title="NumMethod()和Method()"></a>NumMethod()和Method()</h3><p>可以获取struct的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">t := reflect.TypeOf(s)</span><br><span class="line"> <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;t.NumMethod(); i++ &#123;</span><br><span class="line">	m := t.Method(i)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;第%d个方法是：%s:%v\n&quot;</span>, i+<span class="number">1</span>, m.Name, m.Type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射创建"><a href="#反射创建" class="headerlink" title="反射创建"></a>反射创建</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type People struct &#123;</span><br><span class="line">    Age   int</span><br><span class="line">    Name  string</span><br><span class="line">    Test1 string</span><br><span class="line">    Test2 string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewUseReflect() interface&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">var</span> p People</span><br><span class="line">    t := reflect.TypeOf(p)</span><br><span class="line">    v := reflect.New(t)</span><br><span class="line">    v.Elem().Field(<span class="number">0</span>).Set(reflect.ValueOf(<span class="number">18</span>))</span><br><span class="line">    v.Elem().Field(<span class="number">1</span>).Set(reflect.ValueOf(<span class="string">&quot;shiina&quot;</span>))</span><br><span class="line">    v.Elem().Field(<span class="number">2</span>).Set(reflect.ValueOf(<span class="string">&quot;test1&quot;</span>))</span><br><span class="line">    v.Elem().Field(<span class="number">3</span>).Set(reflect.ValueOf(<span class="string">&quot;test2&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> v.Interface()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>golang的反射性能很差</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO的程序启动</title>
    <url>/2020/12/29/GO%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>启动流程大致如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_rt0_amd64_darwin   # 通过参数argc和argv等，确定栈的位置，得到寄存器</span><br><span class="line"></span><br><span class="line">main  # 跳转到本文件main，继续执行</span><br><span class="line"></span><br><span class="line">_rt0_amd64  # 设置好m-&gt;g0的栈,将当前的SP设置为stackbase,将SP往下大约64K的地方设置为stackguard,然后会获取处理器信息,然后设置本地线程存储</span><br><span class="line"></span><br><span class="line">runtime.check # 检测像int8,int16,float等是否是预期的大小，检测cas操作是否正常</span><br><span class="line"></span><br><span class="line">runtime.args # 去 stack 里读取参数和环境变量，执行文件的绝对路径初始化</span><br><span class="line"></span><br><span class="line">runtime.osinit # 初始化OS:获取CPU数量和内存页大小初始化</span><br><span class="line"></span><br><span class="line">runtime.hashinit # 使用读/dev/urandom的方式从内核获得随机数种子</span><br><span class="line"></span><br><span class="line">runtime.schedinit # 初始化调度，命令行参数、环境变量、gc、栈空间、内存管理、所有P实例、HASH算法等初始化</span><br><span class="line"></span><br><span class="line">runtime.newproc # 创建一个goruntine并执行，执行函数为 runtime.main</span><br><span class="line"></span><br><span class="line">runtime.mstart # 启动这个m，即m0，里面会调用schedule函数进入调度状态</span><br><span class="line"></span><br><span class="line">main.main # 用户的main函数</span><br><span class="line"></span><br><span class="line">runtime.exit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="本地线程存储"><a href="#本地线程存储" class="headerlink" title="本地线程存储"></a>本地线程存储</h2><p>每个goroutine都有自己的控制信息，这些信息是存放在一个结构体G中</p>
<p>有一个全局变量g是结构体G的指针，我们希望只有唯一的全局变量g，保证全局唯一，而不是g0，g1，g2</p>
<p>每个线程访问它，得到自己线程的G，这种情况下就需要本地线程存储。</p>
<p>g确实是一个全局变量，却在不同线程有多份不同的副本。每个goroutine去访问g时，都是对应到自己线程的这一份副本</p>
<h2 id="调度器初始化"><a href="#调度器初始化" class="headerlink" title="调度器初始化"></a>调度器初始化</h2><p>注释写在代码里，大概流程如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">schedinit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="comment">// raceinit must be the first call to race detector.</span></span><br><span class="line">	<span class="comment">// In particular, it must be done before mallocinit below calls racemapshadow.</span></span><br><span class="line">	<span class="comment">// 从TLS中获取g实例</span></span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        _g_.racectx, raceprocctx0 = raceinit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置全局线程数上限</span></span><br><span class="line">    sched.maxmcount = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一系列函数所在的PC计数器，用于traceback</span></span><br><span class="line">    tracebackinit()</span><br><span class="line">    <span class="comment">// 貌似是验证链接器符号的正确性</span></span><br><span class="line">    moduledataverify()</span><br><span class="line">    <span class="comment">// 栈的初始化</span></span><br><span class="line">    stackinit()</span><br><span class="line">    <span class="comment">// 内存分配器初始化</span></span><br><span class="line">    mallocinit()</span><br><span class="line">    mcommoninit(_g_.m)</span><br><span class="line">    <span class="comment">// 初始化AES HASH算法</span></span><br><span class="line">    alginit()       <span class="comment">// maps must not be used before this call</span></span><br><span class="line">    modulesinit()   <span class="comment">// provides activeModules</span></span><br><span class="line">    typelinksinit() <span class="comment">// uses maps, activeModules</span></span><br><span class="line">    itabsinit()     <span class="comment">// uses activeModules</span></span><br><span class="line"></span><br><span class="line">    msigsave(_g_.m)</span><br><span class="line">    initSigmask = _g_.m.sigmask</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取命令行参数</span></span><br><span class="line">    <span class="comment">// 例如: ./$GOPATH/test/main test1 test2</span></span><br><span class="line">    <span class="comment">// 执行goargs得到runtime.argslice = []string len: 3, cap: 3, [&quot;main&quot;,&quot;test1&quot;,&quot;test2&quot;]</span></span><br><span class="line">    goargs()</span><br><span class="line">    <span class="comment">// 获取所有的环境变量</span></span><br><span class="line">    goenvs()</span><br><span class="line">    parsedebugvars()</span><br><span class="line">    <span class="comment">// gc初始化</span></span><br><span class="line">    gcinit()</span><br><span class="line"></span><br><span class="line">    sched.lastpoll = uint64(nanotime())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// P个数检查</span></span><br><span class="line">    procs := ncpu</span><br><span class="line">    <span class="keyword">if</span> n, <span class="attr">ok</span> := atoi32(gogetenv(<span class="string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        procs = n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> procs &gt; _MaxGomaxprocs &#123;</span><br><span class="line">        procs = _MaxGomaxprocs</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 所有P的初始化</span></span><br><span class="line">    <span class="keyword">if</span> procresize(procs) != nil &#123;</span><br><span class="line">        <span class="keyword">throw</span>(<span class="string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> buildVersion == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// Condition should never trigger. This code just serves</span></span><br><span class="line">        <span class="comment">// to ensure runtime·buildVersion is kept in the resulting binary.</span></span><br><span class="line">        buildVersion = <span class="string">&quot;unknown&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO的逃逸分析</title>
    <url>/2021/01/08/GO%E7%9A%84%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="关于堆栈及变量分配"><a href="#关于堆栈及变量分配" class="headerlink" title="关于堆栈及变量分配"></a>关于堆栈及变量分配</h2><p>在函数内部定义了一个局部变量，然后返回这个局部变量的地址（指针）。这些局部变量是在栈上分配的（静态内存分配），一旦函数执行完毕，变量占据的内存会被销毁，任何对这个返回值作的动作（如解引用），都将扰乱程序的运行，甚至导致程序直接崩溃</p>
<p>即时通过函数内部使用new函数构造一个变量（动态内存分配），然后返回此变量的地址。因为变量是在堆上创建的，所以函数退出时不会被销毁，但是new出来的对象不delete，也会发生内存泄漏</p>
<p>栈分配开销小，堆分配开销大。</p>
<p>栈空间会随着一个函数的结束自动释放，堆空间需要 GC 模块不断的跟踪扫描回收</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func stack() int &#123; </span><br><span class="line">    <span class="comment">// 变量 i 会在栈上分配</span></span><br><span class="line">     i := <span class="number">10</span></span><br><span class="line">     <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">func heap() *int &#123;</span><br><span class="line">    <span class="comment">// 变量 j 会在堆上分配</span></span><br><span class="line">    j := <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> &amp;j</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>stack 函数中的变量 i 在函数退出会自动释放；而 heap 函数返回的是对变量i的引用，也就是说 heap()退出后，表示变量 i 还要能被访问，它会自动被分配到堆空间上</p>
<p>汇编代码如下，可以查看汇编代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">go tool compile -S main.go</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">TEXT main.stack(SB) /tmp/test.go</span><br><span class="line">  test.go:<span class="number">7</span>     <span class="number">0x487240</span>        48c74424080a000000  MOVQ $<span class="number">0xa</span>, <span class="number">0x8</span>(SP)  </span><br><span class="line">  test.go:<span class="number">7</span>     <span class="number">0x487249</span>        c3          RET         </span><br><span class="line"> </span><br><span class="line">TEXT main.heap(SB) /tmp/test.go</span><br><span class="line">  test.go:<span class="number">9</span>     <span class="number">0x487250</span>        64488b0c25f8ffffff  MOVQ FS:<span class="number">0xfffffff8</span>, CX          </span><br><span class="line">  test.go:<span class="number">9</span>     <span class="number">0x487259</span>        483b6110        CMPQ <span class="number">0x10</span>(CX), SP           </span><br><span class="line">  test.go:<span class="number">9</span>     <span class="number">0x48725d</span>        <span class="number">7639</span>            JBE <span class="number">0x487298</span>                </span><br><span class="line">  test.go:<span class="number">9</span>     <span class="number">0x48725f</span>        4883ec18        SUBQ $<span class="number">0x18</span>, SP              </span><br><span class="line">  test.go:<span class="number">9</span>     <span class="number">0x487263</span>        48896c2410      MOVQ BP, <span class="number">0x10</span>(SP)           </span><br><span class="line">  test.go:<span class="number">9</span>     <span class="number">0x487268</span>        488d6c2410      LEAQ <span class="number">0x10</span>(SP), BP           </span><br><span class="line">  test.go:<span class="number">10</span>        <span class="number">0x48726d</span>        488d05ac090100      LEAQ <span class="number">0x109ac</span>(IP), AX            </span><br><span class="line">  test.go:<span class="number">10</span>        <span class="number">0x487274</span>        <span class="number">48890424</span>        MOVQ AX, <span class="number">0</span>(SP)              </span><br><span class="line">  test.go:<span class="number">10</span>        <span class="number">0x487278</span>        e8f33df8ff      CALL runtime.newobject(SB)      </span><br><span class="line">  test.go:<span class="number">10</span>        <span class="number">0x48727d</span>        488b442408      MOVQ <span class="number">0x8</span>(SP), AX            </span><br><span class="line">  test.go:<span class="number">10</span>        <span class="number">0x487282</span>        48c7000a000000      MOVQ $<span class="number">0xa</span>, <span class="number">0</span>(AX)            </span><br><span class="line">  test.go:<span class="number">11</span>        <span class="number">0x487289</span>        <span class="number">4889442420</span>      MOVQ AX, <span class="number">0x20</span>(SP)           </span><br><span class="line">  test.go:<span class="number">11</span>        <span class="number">0x48728e</span>        488b6c2410      MOVQ <span class="number">0x10</span>(SP), BP           </span><br><span class="line">  test.go:<span class="number">11</span>        <span class="number">0x487293</span>        4883c418        ADDQ $<span class="number">0x18</span>, SP              </span><br><span class="line">  test.go:<span class="number">11</span>        <span class="number">0x487297</span>        c3          RET                 </span><br><span class="line">  test.go:<span class="number">9</span>     <span class="number">0x487298</span>        e8a380fcff      CALL runtime.morestack_noctxt(SB)   </span><br><span class="line">  test.go:<span class="number">9</span>     <span class="number">0x48729d</span>        ebb1            JMP main.heap(SB)           </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">TEXT runtime.newobject(SB) /usr/share/go/src/runtime/malloc.go</span><br><span class="line">  malloc.go:<span class="number">1067</span>    <span class="number">0x40b070</span>        64488b0c25f8ffffff  MOVQ FS:<span class="number">0xfffffff8</span>, CX          </span><br><span class="line">  malloc.go:<span class="number">1067</span>    <span class="number">0x40b079</span>        483b6110        CMPQ <span class="number">0x10</span>(CX), SP           </span><br><span class="line">  malloc.go:<span class="number">1067</span>    <span class="number">0x40b07d</span>        763d            JBE <span class="number">0x40b0bc</span>                </span><br><span class="line">  malloc.go:<span class="number">1067</span>    <span class="number">0x40b07f</span>        4883ec28        SUBQ $<span class="number">0x28</span>, SP              </span><br><span class="line">  malloc.go:<span class="number">1067</span>    <span class="number">0x40b083</span>        48896c2420      MOVQ BP, <span class="number">0x20</span>(SP)           </span><br><span class="line">  malloc.go:<span class="number">1067</span>    <span class="number">0x40b088</span>        488d6c2420      LEAQ <span class="number">0x20</span>(SP), BP           </span><br><span class="line">  malloc.go:<span class="number">1068</span>    <span class="number">0x40b08d</span>        488b442430      MOVQ <span class="number">0x30</span>(SP), AX           </span><br><span class="line">  malloc.go:<span class="number">1068</span>    <span class="number">0x40b092</span>        488b08          MOVQ <span class="number">0</span>(AX), CX              </span><br><span class="line">  malloc.go:<span class="number">1068</span>    <span class="number">0x40b095</span>        48890c24        MOVQ CX, <span class="number">0</span>(SP)              </span><br><span class="line">  malloc.go:<span class="number">1068</span>    <span class="number">0x40b099</span>        <span class="number">4889442408</span>      MOVQ AX, <span class="number">0x8</span>(SP)            </span><br><span class="line">  malloc.go:<span class="number">1068</span>    <span class="number">0x40b09e</span>        c644241001      MOVB $<span class="number">0x1</span>, <span class="number">0x10</span>(SP)         </span><br><span class="line">  malloc.go:<span class="number">1068</span>    <span class="number">0x40b0a3</span>        e888f4ffff      CALL runtime.mallocgc(SB)       </span><br><span class="line">  malloc.go:<span class="number">1068</span>    <span class="number">0x40b0a8</span>        488b442418      MOVQ <span class="number">0x18</span>(SP), AX           </span><br><span class="line">  malloc.go:<span class="number">1068</span>    <span class="number">0x40b0ad</span>        <span class="number">4889442438</span>      MOVQ AX, <span class="number">0x38</span>(SP)           </span><br><span class="line">  malloc.go:<span class="number">1068</span>    <span class="number">0x40b0b2</span>        488b6c2420      MOVQ <span class="number">0x20</span>(SP), BP           </span><br><span class="line">  malloc.go:<span class="number">1068</span>    <span class="number">0x40b0b7</span>        4883c428        ADDQ $<span class="number">0x28</span>, SP              </span><br><span class="line">  malloc.go:<span class="number">1068</span>    <span class="number">0x40b0bb</span>        c3          RET                 </span><br><span class="line">  malloc.go:<span class="number">1067</span>    <span class="number">0x40b0bc</span>        e87f420400      CALL runtime.morestack_noctxt(SB)   </span><br><span class="line">  malloc.go:<span class="number">1067</span>    <span class="number">0x40b0c1</span>        ebad            JMP runtime.newobject(SB)</span><br></pre></td></tr></table></figure>

<p> 上面的汇编中可看到，heap() 函数调用了 runtime.newobject() 方法，它会调用 mallocgc 方法从 mcache 上申请内存。堆内存分配不仅分配上逻辑比栈空间分配复杂，它最致命的是会带来很大的管理成本，Go 语言要消耗很多的计算资源对其进行标记回收（也就是 GC 成本）</p>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><h3 id="什么是逃逸分析"><a href="#什么是逃逸分析" class="headerlink" title="什么是逃逸分析"></a>什么是逃逸分析</h3><p>在编译原理中，分析指针动态范围的方法称之为逃逸分析。通俗来讲，当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。</p>
<p>逃逸分析决定一个变量是分配在栈上，还是分配在堆上</p>
<p>golang即时用new分配的内存，函数返回后，没有用了，就丢到栈上</p>
<p>如果还有函数外部其他引用，就会分配到堆上，实现按需分配</p>
<h3 id="为什么要逃逸分析"><a href="#为什么要逃逸分析" class="headerlink" title="为什么要逃逸分析"></a>为什么要逃逸分析</h3><p>如果变量都分配到堆上，堆不像栈可以自动清理。它会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销（占用CPU容量的25%）。</p>
<p>堆和栈相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。栈内存分配则会非常快</p>
<p>通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上，堆上的变量少了，会减轻分配堆内存的开销，同时也会减少gc的压力，提高程序的运行速度</p>
<h3 id="如何逃逸分析"><a href="#如何逃逸分析" class="headerlink" title="如何逃逸分析"></a>如何逃逸分析</h3><p>以下命令可以查看逃逸分析</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">go build -gcflags=-m main.go</span><br></pre></td></tr></table></figure>

<p>Go逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。</p>
<p>Go 编辑器会自动帮我们找出需要进行动态分配的变量，它是在编译时追踪一个变量的生命周期，如果能确认一个数据只在函数空间内访问，不会被外部使用，则使用栈空间，否则就要使用堆空间</p>
<p>简单来说，编译器会根据变量是否被外部引用来决定是否逃逸：</p>
<p>1.如果函数外部没有引用，则优先放到栈中，定义了一个很大的数组，需要申请的内存过大，超过了栈的存储能力，也会分配到堆中<br>2.如果函数外部存在引用，则必定放到堆中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func foo() *int &#123;</span><br><span class="line">    t := <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> &amp;t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    x := foo()</span><br><span class="line">    fmt.Println(*x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">src/main.go:<span class="number">7</span>:<span class="number">9</span>: &amp;t escapes to heap</span><br><span class="line">src/main.go:<span class="number">6</span>:<span class="number">7</span>: moved to heap: t</span><br><span class="line">src/main.go:<span class="number">12</span>:<span class="number">14</span>: *x escapes to heap</span><br><span class="line">src/main.go:<span class="number">12</span>:<span class="number">13</span>: main ... argument does not <span class="built_in">escape</span></span><br></pre></td></tr></table></figure>
<p>x也发生了逃逸</p>
<p>PS：有些函数参数为interface类型，比如<br>fmt.Println(a…interface{})，编译期间很难确定其参数的具体类型，也会发生逃逸</p>
<h3 id="逃逸分析注意点"><a href="#逃逸分析注意点" class="headerlink" title="逃逸分析注意点"></a>逃逸分析注意点</h3><p>不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。</p>
<p>PS：不要以为使用了堆内存就一定会导致性能低下，使用栈内存会带来性能优势。因为实际项目中，系统的性能瓶颈一般都不会出现在内存分配上。千万不要盲目优化，找到系统瓶颈，用数据驱动优化。</p>
<h3 id="逃逸分析缺陷问题"><a href="#逃逸分析缺陷问题" class="headerlink" title="逃逸分析缺陷问题"></a>逃逸分析缺陷问题</h3><p>编译器有时会将不需要使用堆空间的变量，也逃逸掉。这里是容易出现性能问题的大坑</p>
<p>多级间接赋值容易导致逃逸</p>
<p>这里的多级间接指的是，对某个引用类对象中的引用类成员进行赋值。Go 语言中的引用类数据类型有 func, interface, slice, map, chan, * Type(指针)</p>
<p>公式 Data.Field = Value，<br>如果 Data, Field 都是引用类的数据类型，<br>则会导致 Value 逃逸。这里的等号 = 不单单只赋值，也表示参数传递</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[]interface&#123;&#125;: data[<span class="number">0</span>] = <span class="number">100</span> 会导致 <span class="number">100</span> 逃逸</span><br><span class="line"></span><br><span class="line">map[string]interface&#123;&#125;: data[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;value&quot;</span> 会导致 <span class="string">&quot;value&quot;</span> 逃逸</span><br><span class="line"></span><br><span class="line">map[interface&#123;&#125;]interface&#123;&#125;: data[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;value&quot;</span> 会导致 key 和 value 都逃逸</span><br><span class="line"></span><br><span class="line">map[string][]string: data[<span class="string">&quot;key&quot;</span>] = []string&#123;<span class="string">&quot;hello&quot;</span>&#125; 会导致切片逃逸</span><br><span class="line"></span><br><span class="line">map[string]*int: 赋值时 *int 会 逃逸</span><br><span class="line"></span><br><span class="line">[]*int: data[<span class="number">0</span>] = &amp;i 会使 i 逃逸</span><br><span class="line"></span><br><span class="line">func(*int): data(&amp;i) 会使 i 逃逸</span><br><span class="line"></span><br><span class="line">func([]string): data([]&#123;<span class="string">&quot;hello&quot;</span>&#125;) 会使 []string&#123;<span class="string">&quot;hello&quot;</span>&#125; 逃逸</span><br><span class="line"></span><br><span class="line">chan []string: data &lt;- []string&#123;<span class="string">&quot;hello&quot;</span>&#125; 会使 []string&#123;<span class="string">&quot;hello&quot;</span>&#125; 逃逸</span><br></pre></td></tr></table></figure>

<h4 id="函数变量逃逸"><a href="#函数变量逃逸" class="headerlink" title="函数变量逃逸"></a>函数变量逃逸</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func <span class="function"><span class="title">test</span>(<span class="params">i int</span>)</span>        &#123;&#125;</span><br><span class="line">func <span class="function"><span class="title">testEscape</span>(<span class="params">i *int</span>)</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    i, j, m, <span class="attr">n</span> := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    t, <span class="attr">te</span> := test, testEscape <span class="comment">// 函数变量</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 直接调用</span></span><br><span class="line">    test(m)        <span class="comment">// 不逃逸</span></span><br><span class="line">    testEscape(&amp;n) <span class="comment">// 不逃逸</span></span><br><span class="line">    <span class="comment">// 间接调用</span></span><br><span class="line">    t(i)   <span class="comment">// 不逃逸</span></span><br><span class="line">    te(&amp;j) <span class="comment">// 逃逸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="间接赋值"><a href="#间接赋值" class="headerlink" title="间接赋值"></a>间接赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">type Data struct &#123;</span><br><span class="line">    data  map[int]int</span><br><span class="line">    slice []int</span><br><span class="line">    ch    chan int</span><br><span class="line">    inf   interface&#123;&#125;</span><br><span class="line">    p     *int</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    d1 := Data&#123;&#125;</span><br><span class="line">    d1.data = make(map[int]int) <span class="comment">// GOOD: does not escape</span></span><br><span class="line">    d1.slice = make([]int, <span class="number">4</span>)   <span class="comment">// GOOD: does not escape</span></span><br><span class="line">    d1.ch = make(chan int, <span class="number">4</span>)   <span class="comment">// GOOD: does not escape</span></span><br><span class="line">    d1.inf = <span class="number">3</span>                  <span class="comment">// GOOD: does not escape</span></span><br><span class="line">    d1.p = <span class="keyword">new</span>(int)             <span class="comment">//  GOOD: does not escape</span></span><br><span class="line"> </span><br><span class="line">    d2 := <span class="keyword">new</span>(Data)             <span class="comment">// d2 是指针变量， 下面为该指针变量中的指针成员赋值</span></span><br><span class="line">    d2.data = make(map[int]int) <span class="comment">// BAD: escape to heap</span></span><br><span class="line">    d2.slice = make([]int, <span class="number">4</span>)   <span class="comment">// BAD:  escape to heap</span></span><br><span class="line">    d2.ch = make(chan int, <span class="number">4</span>)   <span class="comment">// BAD:  escape to heap</span></span><br><span class="line">    d2.inf = <span class="number">3</span>                  <span class="comment">// BAD:  escape to heap</span></span><br><span class="line">    d2.p = <span class="keyword">new</span>(int)             <span class="comment">// BAD:  escape to heap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h4><p>只要使用了 Interface 类型(不是 interafce{})，那么赋值给它的变量一定会逃逸</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">type Iface interface &#123;</span><br><span class="line">    Dummy()</span><br><span class="line">&#125;</span><br><span class="line">type Integer int</span><br><span class="line">func (i Integer) <span class="function"><span class="title">Dummy</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        iface Iface</span><br><span class="line">        i     Integer</span><br><span class="line">    )</span><br><span class="line">    iface = i</span><br><span class="line">    iface.Dummy() <span class="comment">//  make i escape to heap</span></span><br><span class="line">    <span class="comment">// 形成 iface.Dummy.i = i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        chInteger   = make(chan *int)</span><br><span class="line">        chMap       = make(chan map[int]int)</span><br><span class="line">        chSlice     = make(chan []int)</span><br><span class="line">        chInterface = make(chan interface&#123;&#125;)</span><br><span class="line">        a, b, c, d  = <span class="number">0</span>, map[int]int&#123;&#125;, []int&#123;&#125;, <span class="number">32</span></span><br><span class="line">    )</span><br><span class="line">    chInteger &lt;- &amp;a  <span class="comment">// 逃逸</span></span><br><span class="line">    chMap &lt;- b       <span class="comment">// 逃逸</span></span><br><span class="line">    chSlice &lt;- c     <span class="comment">// 逃逸</span></span><br><span class="line">    chInterface &lt;- d <span class="comment">// 逃逸</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>向 channel 中发送数据，本质上就是为 channel 内部的成员赋值，就像给一个 slice 中的某一项赋值一样。所以 chan * Type, chan map[Type]Type, chan []Type, chan interface{} 类型都会导致发送到 channel 中的数据逃逸。</p>
<p>这本来也是情理之中的，发送给 channel 的数据是要与其他函数分享的，为了保证发送过去的指针依然可用，只能使用堆分配。</p>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数如 func(arg …string) 实际与 func(arg []string) 是一样的，会增加一层访问路径。这也是 fmt.Sprintf 总是会使参数逃逸的原因</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func a (args ...interface&#123;&#125;) int &#123;</span><br><span class="line">	c := args[<span class="number">0</span>].(int)</span><br><span class="line">	d := args[<span class="number">1</span>].(int)</span><br><span class="line">	<span class="keyword">return</span> c + d</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    res := a(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1, 2逃逸</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="结构体方法"><a href="#结构体方法" class="headerlink" title="结构体方法"></a>结构体方法</h4><p>以下 2 种很常规的写法，但他们却有着很大的性能差距</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">    roles []string</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (u *User) <span class="function"><span class="title">SetRoles</span>(<span class="params">roles []string</span>)</span> &#123;</span><br><span class="line">    u.roles = roles</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func SetRoles(u User, roles []string) User &#123;</span><br><span class="line">    u.roles = roles</span><br><span class="line">    <span class="keyword">return</span> u</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b User</span><br><span class="line"></span><br><span class="line">	a := SetRoles(b, []string&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;) <span class="comment">// // 参数[]string&#123;&quot;1&quot;, &quot;2&quot;&#125; 不逃逸</span></span><br><span class="line"></span><br><span class="line">	b.SetRoles([]string&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;) <span class="comment">// 参数[]string&#123;&quot;1&quot;, &quot;2&quot;&#125; 逃逸</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>两种情况下</p>
<p>第一种没有逃逸</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">第一种 a := SetRoles(b, []string&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">main.go:<span class="number">8</span>:<span class="number">6</span>: can inline (*User).SetRoles</span><br><span class="line">main.go:<span class="number">12</span>:<span class="number">6</span>: can inline SetRoles</span><br><span class="line">main.go:<span class="number">17</span>:<span class="number">6</span>: can inline main</span><br><span class="line">main.go:<span class="number">20</span>:<span class="number">15</span>: inlining call to SetRoles</span><br><span class="line">main.go:<span class="number">8</span>:<span class="number">25</span>: leaking param: roles</span><br><span class="line">main.go:<span class="number">8</span>:<span class="number">7</span>: (*User).SetRoles u does not <span class="built_in">escape</span></span><br><span class="line">main.go:<span class="number">12</span>:<span class="number">15</span>: leaking param: u to result ~r2 level=<span class="number">0</span></span><br><span class="line">main.go:<span class="number">12</span>:<span class="number">23</span>: leaking param: roles to result ~r2 level=<span class="number">0</span></span><br><span class="line">main.go:<span class="number">20</span>:<span class="number">27</span>: main []string literal does not <span class="built_in">escape</span></span><br><span class="line">main.go:<span class="number">20</span>:<span class="number">2</span>: a declared and not used</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种逃逸，第二种开销会比较大</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">第二种 b.SetRoles([]string&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">main.go:<span class="number">8</span>:<span class="number">6</span>: can inline (*User).SetRoles</span><br><span class="line">main.go:<span class="number">12</span>:<span class="number">6</span>: can inline SetRoles</span><br><span class="line">main.go:<span class="number">17</span>:<span class="number">6</span>: can inline main</span><br><span class="line">main.go:<span class="number">22</span>:<span class="number">12</span>: inlining call to (*User).SetRoles</span><br><span class="line">main.go:<span class="number">8</span>:<span class="number">25</span>: leaking param: roles</span><br><span class="line">main.go:<span class="number">8</span>:<span class="number">7</span>: (*User).SetRoles u does not <span class="built_in">escape</span></span><br><span class="line">main.go:<span class="number">12</span>:<span class="number">15</span>: leaking param: u to result ~r2 level=<span class="number">0</span></span><br><span class="line">main.go:<span class="number">12</span>:<span class="number">23</span>: leaking param: roles to result ~r2 level=<span class="number">0</span></span><br><span class="line">main.go:<span class="number">22</span>:<span class="number">21</span>: []string literal escapes to heap</span><br><span class="line">main.go:<span class="number">22</span>:<span class="number">3</span>: main b does not <span class="built_in">escape</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO自定义Error方法</title>
    <url>/2020/12/27/GO%E8%87%AA%E5%AE%9A%E4%B9%89Error%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>通过interface定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    <span class="built_in">Error</span>() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义error</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type <span class="built_in">Error</span> struct &#123;</span><br><span class="line">    errCode uint8</span><br><span class="line">&#125;</span><br><span class="line">func (e *<span class="built_in">Error</span>) <span class="built_in">Error</span>() string &#123;</span><br><span class="line">        <span class="keyword">switch</span> e.errCode &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;file not found&quot;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;time out&quot;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;permission denied&quot;</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;unknown error&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO的闭包</title>
    <url>/2020/12/28/GO%E7%9A%84%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>闭包=函数+引用环境</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func f(i int) func() int &#123;</span><br><span class="line">    <span class="keyword">return</span> func() int &#123;</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数f返回了一个函数，返回的这个函数，返回的这个函数就是一个闭包。这个函数中本身是没有定义变量i的，而是引用了它所在的环境（函数f）中的变量i</p>
<p>将闭包函数表现为一个结构体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type Closure struct &#123;</span><br><span class="line">    F func()()  <span class="comment">// 函数</span></span><br><span class="line">    i *int      <span class="comment">// 参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层汇编上，确实闭包是一个结构体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func f(i int) func() int &#123;</span><br><span class="line">    <span class="keyword">return</span> func() int &#123;</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MOVQ    $type.int+<span class="number">0</span>(SB),(SP)</span><br><span class="line">PCDATA    $<span class="number">0</span>,$<span class="number">16</span></span><br><span class="line">PCDATA    $<span class="number">1</span>,$<span class="number">0</span></span><br><span class="line">CALL    ,runtime.new(SB)    <span class="comment">// 是不是很熟悉，这一段就是i = new(int)    </span></span><br><span class="line">...    </span><br><span class="line">MOVQ    $type.struct &#123; F uintptr; A0 *int &#125;+<span class="number">0</span>(SB),(SP)    <span class="comment">// 这个结构体就是闭包的类型</span></span><br><span class="line">...</span><br><span class="line">CALL    ,runtime.new(SB)    <span class="comment">// 接下来相当于 new(Closure)</span></span><br><span class="line">PCDATA    $<span class="number">0</span>,$-<span class="number">1</span></span><br><span class="line">MOVQ    <span class="number">8</span>(SP),AX</span><br><span class="line">NOP    ,</span><br><span class="line">MOVQ    $<span class="string">&quot;&quot;</span>.func·<span class="number">001</span>+<span class="number">0</span>(SB),BP</span><br><span class="line">MOVQ    BP,(AX)                <span class="comment">// 函数地址赋值给Closure的F部分</span></span><br><span class="line">NOP    ,</span><br><span class="line">MOVQ    <span class="string">&quot;&quot;</span>.&amp;i+<span class="number">16</span>(SP),BP        <span class="comment">// 将堆中new的变量i的地址赋值给Closure的值部分</span></span><br><span class="line">MOVQ    BP,<span class="number">8</span>(AX)</span><br><span class="line">MOVQ    AX,<span class="string">&quot;&quot;</span>.~r1+<span class="number">40</span>(FP)</span><br><span class="line">ADDQ    $<span class="number">24</span>,SP</span><br><span class="line">RET    ,</span><br></pre></td></tr></table></figure>

<p>返回闭包时并不是单纯返回一个函数，而是返回了一个结构体，记录下函数返回地址和引用的环境中的变量地址</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO里的defer关键字</title>
    <url>/2020/12/27/GO%E9%87%8C%E7%9A%84defer%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>defer用于资源的释放，会在函数返回之前进行调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> 	f,<span class="attr">err</span> := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line">   	panic(err)</span><br><span class="line">&#125;</span><br><span class="line">defer f.Close()</span><br></pre></td></tr></table></figure>

<p>如果有多个defer，调用顺序类似于栈，越后面的defer表达式越先被调用</p>
<h2 id="defer使用注意"><a href="#defer使用注意" class="headerlink" title="defer使用注意"></a>defer使用注意</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>例1：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> 	func f() (result int) &#123;</span><br><span class="line">    defer <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        result++</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确结果返回1，而不是0</p>
<p>可改写成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> 	func f() (result int) &#123;</span><br><span class="line">    result = <span class="number">0</span>  <span class="comment">//return语句不是一条原子调用，return xxx其实是赋值＋ret指令</span></span><br><span class="line">    <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123; <span class="comment">//defer被插入到return之前执行，也就是赋返回值和ret指令之间</span></span><br><span class="line">        result++</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以返回是1</p>
<p>例2：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> 	func f() (r int) &#123;</span><br><span class="line">     t := <span class="number">5</span></span><br><span class="line">     defer <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       t = t + <span class="number">5</span></span><br><span class="line">     &#125;()</span><br><span class="line">     <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果是5，不是10<br>可改写成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> 	func f() (r int) &#123;</span><br><span class="line">     t := <span class="number">5</span></span><br><span class="line">     r = t <span class="comment">//赋值指令</span></span><br><span class="line">     <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;        <span class="comment">//defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过</span></span><br><span class="line">         t = t + <span class="number">5</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span>        <span class="comment">//空的return指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以结果是5</p>
<p>例3：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> 	func f() (r int) &#123;</span><br><span class="line">  		defer <span class="function"><span class="title">func</span>(<span class="params">r int</span>)</span> &#123;</span><br><span class="line">          r = r + <span class="number">5</span></span><br><span class="line">    &#125;(r)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是1，不是6</p>
<p>可以改写成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> 	func f() (r int) &#123;</span><br><span class="line">     r = <span class="number">1</span>  <span class="comment">//给返回值赋值</span></span><br><span class="line">     <span class="function"><span class="title">func</span>(<span class="params">r int</span>)</span> &#123;        <span class="comment">//这里改的r是传值传进去的r，不会改变要返回的那个r值</span></span><br><span class="line">          r = r + <span class="number">5</span></span><br><span class="line">     &#125;(r)</span><br><span class="line">     <span class="keyword">return</span>        <span class="comment">//空的return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以结果是1</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>return xxx这一条语句并不是一条原子指令!</p>
<p>函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。</p>
<p>defer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。</p>
<h2 id="defer的实现"><a href="#defer的实现" class="headerlink" title="defer的实现"></a>defer的实现</h2><p>defer跟go类似</p>
<p>调用runtime.deferproc而不是runtime.newproc</p>
<p>在defer出现的地方，插入了指令call runtime.deferproc，然后在函数返回之前的地方，插入指令call runtime.deferreturn。</p>
<p>普通函数汇编</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> 	add xx SP</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>defer</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> 	call runtime.deferreturn，</span><br><span class="line">add xx SP</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>goroutine的控制结构中，有一张表记录defer，调用runtime.deferproc时会将需要defer的表达式记录在表中，而在调用runtime.deferreturn的时候，则会依次从defer表中出栈并执行</p>
<h2 id="for循环的defer"><a href="#for循环的defer" class="headerlink" title="for循环的defer"></a>for循环的defer</h2><p>不建议这么使用</p>
<p>defer 先进后出</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO的连续栈</title>
    <url>/2020/12/28/GO%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%A0%88/</url>
    <content><![CDATA[<p>Go语言支持goroutine，每个goroutine需要能够运行，所以它们都有自己的栈</p>
<p>所以栈的空间是随着需要自动增长的，每个goroutine开始只分配很小的栈空间</p>
<p>所以开了千万个goroutine也不会耗尽内存</p>
<p>continuous stack</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>1.调用栈默认大小是4K（1.7修改为2K），最大栈1G，超出将panic<br>2.每次执行函数调用时，runtime就会进行检测，当前栈的大小不够用，会触发中断<br>3.runtime会保存此时函数运行的上下文<br>4.分配一个新的足够大的栈空间，进行2倍指数扩容将旧栈的内容拷贝到新栈中，并做一些设置，使得当函数恢复运行时，函数会在新分配的栈中继续执行</p>
<h3 id="捕获栈空间不足，实行中断"><a href="#捕获栈空间不足，实行中断" class="headerlink" title="捕获栈空间不足，实行中断"></a>捕获栈空间不足，实行中断</h3><p>1.比较栈指针寄存器和G结构体的stackguard<br>2.SP大于g-&gt;stackguard，runtime.morestack(保存M，连接旧栈新栈)，runtime.newstack(新栈)</p>
<p>每个goroutine对应一个结构体G，大致相当于进程控制块的概念<br>结构体中存了stackbase和stackguard，用于确定这个goroutine使用的栈空间信息<br>如果栈指针寄存器(SP)值超越了stackguard就需要扩展栈空间</p>
<p>汇编如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">000000</span> <span class="number">00000</span> (test.go:<span class="number">3</span>)    TEXT    <span class="string">&quot;&quot;</span>.main+<span class="number">0</span>(SB),$<span class="number">0</span>-<span class="number">0</span></span><br><span class="line"><span class="number">000000</span> <span class="number">00000</span> (test.go:<span class="number">3</span>)    MOVQ    (TLS),CX</span><br><span class="line"><span class="number">0x0009</span> <span class="number">00009</span> (test.go:<span class="number">3</span>)    CMPQ    SP,(CX)</span><br><span class="line"><span class="number">0x000c</span> <span class="number">00012</span> (test.go:<span class="number">3</span>)    JHI    ,<span class="number">21</span></span><br><span class="line"><span class="number">0x000e</span> <span class="number">00014</span> (test.go:<span class="number">3</span>)    CALL    ,runtime.morestack00_noctxt(SB)</span><br><span class="line"><span class="number">0x0013</span> <span class="number">00019</span> (test.go:<span class="number">3</span>)    JMP    ,<span class="number">0</span></span><br><span class="line"><span class="number">0x0015</span> <span class="number">00021</span> (test.go:<span class="number">3</span>)    NOP    ,</span><br></pre></td></tr></table></figure>
<p>如果SP大于g-&gt;stackguard了，则会调用runtime.morestack函数.开始中断，新建栈空间</p>
<p>runtime.morestack是用汇编实现的，做的事情大致是将一些信息存在M结构体中，这些信息包括当前栈桢，参数，当前函数调用，函数返回地址（两个返回地址，一个是runtime.morestack的函数地址，一个是f的返回地址）。通过这些信息可以把新栈和旧栈链起来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> runtime.morestack() &#123;</span><br><span class="line">    <span class="keyword">if</span>(g == g0) &#123;</span><br><span class="line">        panic();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m-&gt;morebuf.gobuf_pc = getCallerCallerPC();</span><br><span class="line">        <span class="keyword">void</span> *SP = getCallerSP();</span><br><span class="line">        m-&gt;morebuf.gobuf_sp = SP;</span><br><span class="line">        m-&gt;moreargp = SP;</span><br><span class="line">        m-&gt;morebuf.gobuf_g = g;</span><br><span class="line">        m-&gt;morepc = getCallerPC();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> *g0 = m-&gt;g0;</span><br><span class="line">        g = g0;</span><br><span class="line">        setSP(g0-&gt;g_sched.gobuf_sp);</span><br><span class="line">        runtime.newstack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用runtime.newstack，建立新的栈空间</p>
<p>PS：newstack是切换到m-&gt;g0的栈中去调用的。m-&gt;g0是调度器栈，go的运行时库的调度器使用的都是m-&gt;g0。</p>
<h3 id="旧栈数据复制到新栈"><a href="#旧栈数据复制到新栈" class="headerlink" title="旧栈数据复制到新栈"></a>旧栈数据复制到新栈</h3><p>1.runtime.morestack会调用于runtime.newstack<br>2.newstack：分配一个足够大的新的空间，将旧的栈中的数据复制到新的栈中</p>
<p>复制数据的过程中要考虑指针失效问题</p>
<p>某个指针引用旧栈的地址，搬到新栈后，旧栈会被释放，指针失效</p>
<p>所以要修改指针地址：</p>
<p>1.当前栈帧之前的每一个栈帧，对其中的每一个指针，检测指针指向的地址<br>2.如果指向地址是落在旧栈范围内的，则将它加上一个偏移使它指向新栈的相应地址。这个偏移值等于新栈基地址减旧栈基地址。</p>
<p>恢复运行：<br>1.切换到当前g<br>2.runtime.oldstack从过去保存旧栈的信息拿到相关信息<br>3.runtime.gogo根据旧的信息恢复上下文，运行</p>
<p>整个过程就完成了。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>1.比较SP与g的stackguard，SP大于g-&gt;stackguard，开始连续栈扩容<br>2.调用runtime.morestack，主要功能是保存当前的栈的一些信息<br>3.调用runtime.newstack，函数的主要功能是分配空间，装饰此空间，复制数据到新空间，修改指针<br>4.gogocall的方式切换到新分配的栈，获取旧的信息，恢复上下文，继续运行</p>
<p>栈缩容：是在垃圾回收的里处理的，当检测到栈只使用了不到1/4时，栈缩小为原来的1/2</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>GO里的go关键字</title>
    <url>/2020/12/27/GO%E9%87%8C%E7%9A%84go%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>go f(x, y, z)会启动一个新的goroutine运行函数f(x, y, z)。函数f，变量x、y、z的值是在原goroutine计算的，只有函数f的执行是在新的goroutine中的</p>
<p>新的goroutine不能和当前go线程用同一个栈，否则会相互覆盖。</p>
<p>所以对go关键字的调用协议与普通函数调用是不同的</p>
<p>普通函数的调用协议</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MOVL    $<span class="number">1</span>, <span class="number">0</span>(SP)</span><br><span class="line"> MOVL    $<span class="number">2</span>, <span class="number">4</span>(SP)</span><br><span class="line"> MOVL    $<span class="number">3</span>, <span class="number">8</span>(SP)</span><br><span class="line"> CALL    f(SB)</span><br></pre></td></tr></table></figure>

<p>将参数 1，2，3进栈，然后调用函数f</p>
<p>go 关键字调用函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MOVL    $<span class="number">1</span>, <span class="number">0</span>(SP)</span><br><span class="line"> MOVL    $<span class="number">2</span>, <span class="number">4</span>(SP)</span><br><span class="line"> MOVL    $<span class="number">3</span>, <span class="number">8</span>(SP)</span><br><span class="line"> PUSHQ   $f(SB)</span><br><span class="line"> PUSHQ   $<span class="number">12</span></span><br><span class="line"> CALL    runtime.newproc(SB)</span><br><span class="line"> POPQ    AX</span><br><span class="line"> POPQ    AX</span><br></pre></td></tr></table></figure>
<p>前半部分一样，将参数1，2，3进栈，同时也将函数f进栈，12也进栈，12是函数参数的大小</p>
<p>调用runtime.newproc函数</p>
<p>runtime.newproc函数接受的参数分别是：参数大小，新的goroutine是要运行的函数，函数的n个参数</p>
<p>runtime.newproc函数中</p>
<p>1.新建一个栈空间，将栈参数的12个字节拷贝到新栈空间中并让栈指针指向参数<br>2.线程状态有点像当被调度器剥夺CPU后一样，寄存器PC、SP会被保存到类似于进程控制块的一个结构体struct G内<br>3.f被存放在了struct G的entry域，后面进行调度器恢复goroutine的运行，新线程将从f开始执行。</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Git rebase 理解及使用</title>
    <url>/2020/06/17/Git%20rebase%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="什么是git-rebase"><a href="#什么是git-rebase" class="headerlink" title="什么是git rebase"></a>什么是git rebase</h2><p>官方描述</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">“git-rebase: Forward-port local commits to the updated upstream head”— git doc</span><br></pre></td></tr></table></figure>
<p>翻译一下，主要用在从上游分支获取最新commit信息，并有机的将当前分支和上游分支进行合并</p>
<p>PS： gitrebase并不会删除老的提交，也就是说你在对某个分支执行了rebase操作之后，老的提交仍然会存放在.git文件夹的objects目录下</p>
<h2 id="使用rebase意义"><a href="#使用rebase意义" class="headerlink" title="使用rebase意义"></a>使用rebase意义</h2><p>1.使用git log时，可以看到一个更整洁commit 历史树；</p>
<p>2.对于git工作流，commit数要多而有意义，这样review 代码速度加快，而且commit 都是有意义的，而且利于回退；</p>
<p>3.很多人的分支提交历史经常是fix，fix, fix agian,好的commit应该反映出项目的一步步开发。</p>
<h2 id="工作流程及原理：变基"><a href="#工作流程及原理：变基" class="headerlink" title="工作流程及原理：变基"></a>工作流程及原理：变基</h2><p><img src="/2020/06/17/Git%20rebase%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/1.png" alt="1"></p>
<p> 如上图所示，C1是线上的版本，在C1的代码上线了之后我们发现了一个bug，于是我们checkout了一个叫做bugFix的分支。与此同时还有新的功能在开发，新的功能提交到了master之后形成了节点C2。这个时候我们在bugFix分支当然可以merge master这没有什么问题，但是也可以rebase master，rebase之后整棵git树会变成这样：</p>
<p><img src="/2020/06/17/Git%20rebase%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/2.png" alt="2"></p>
<p> 这个结果就好像是我们先到了C2然后checkout出了bugFix分支，然后在bugFix分支上将之前写过的代码重新写了一遍。这样的操作就是变基，当我们rebase了之后再提交合并请求我们的合并记录里面会非常干净，没有多余merge的信息。</p>
<p>操作命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">	git checkout bugFix</span><br><span class="line">git rebase master</span><br><span class="line">git checkout master</span><br><span class="line">git merge bugFix</span><br></pre></td></tr></table></figure>
<p>前两步也可以直接写，直接在master分支执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git rebase master bugFix</span><br></pre></td></tr></table></figure>
<p>它会先checkout到bugFix分支然后执行rebase master的操作，之后我们再checkout到master进行合并即可</p>
<p>更复杂一点<br><img src="/2020/06/17/Git%20rebase%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/3.png" alt="3"></p>
<p>master是正常的线上分支，在C2节点处代码上线。上线之后继续开发新的需求checkout了新的分支feature，与此同时master也经过了一些合并，合并了另外的一些改动到了C4节点。之后新的分支feature开发完成了一个重要性能提升的改动C5，这时，我们发现了线上代码的一个bug并且性能不佳，我们需要紧急修复。于是在C5处checkout了新的分支bugFix，我们在bugFix分支当中修复了bug，想要发布上线。<br>这时候feature分支继续开发到了C6节点，仍然没有开发完成，也没有经过系统测试。所以我们并不希望C6的代码发布上线，我们希望合并进入master的代码之后C5，C7和C8。我们只需要在bugFix分支rebase到master，然后修复冲突之后提交。提交完成了之后，我们再checkout到master把bugFix分支merge进来<br>结果如下：</p>
<p><img src="/2020/06/17/Git%20rebase%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/4.png" alt="4"></p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="远程代码同步使用-pull-–rebase"><a href="#远程代码同步使用-pull-–rebase" class="headerlink" title="远程代码同步使用 pull –rebase"></a>远程代码同步使用 pull –rebase</h3><p>当我们项目多人在同一个分支开发时，不可避免在你要提交代码之前有人已往远程仓库提交代码。当我们push时，提示你先pull，如果我们直接pull，有冲突的情况我们需要解决冲突，没有冲突的情况自动合并，不管哪种情况我们都会产生一条新的提交记录</p>
<p><img src="/2020/06/17/Git%20rebase%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/5.png" alt="5"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure>
<p> 可以避免这一条记录产生</p>
<p>如果是两人同时修改一个文件而产生了冲突，解决冲突后</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  git add .</span><br><span class="line">git rebase --<span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>通过git log查看，会发现修改会放到最新的修改之后，一条线顺延，不会有多余的commit记录</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   git pull --rebase 当需要进行pull代码时候，使用这个命令，可以不生成merge branch 的log</span><br><span class="line"></span><br><span class="line">git rebase --<span class="keyword">continue</span> 当冲突问题解决之后可以使用git add .再使用该命令继续完成</span><br><span class="line"></span><br><span class="line">git rebase --abort 当前的commit会回到rebase操作之前的状态。</span><br><span class="line"></span><br><span class="line">git rebase --skip 如果你想丢弃该条引起冲突的commits，可以使用该命令，慎用；</span><br></pre></td></tr></table></figure>

<p>git pull实际执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   git pull的默认行为是git fetch + git merge</span><br><span class="line">git pull --rebase则是git fetch + git rebase.</span><br></pre></td></tr></table></figure>

<h3 id="整合分支"><a href="#整合分支" class="headerlink" title="整合分支"></a>整合分支</h3><p>一般的merge工作流程是这样的：</p>
<p>在当前你的master分支切出一个新分支test,增加一个文件，而此时master上有个小东西需要直接改一下，你接下来切回master分支，你修改了一些提交commit 并push远程。之后回到test分支继续开发完成，之后commit提交”测试合并”,push远程。</p>
<p>接下来，test分支没问题了，你需要合并test分支到master。通常我们最多的是在master分支上使用git merge test 命令，这时master会产生一条新的commit记录，默认叫 Merge branch ‘test’.你可以修改它，之后push远程。</p>
<p>整合分支要显示整洁的代码提交记录</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   git checkout -b test    #在test 的 branch 上添加一个文件</span><br><span class="line">   git commit</span><br><span class="line">git rebase master  之后回master分支，</span><br><span class="line">git merge test进行一次快进合并.</span><br></pre></td></tr></table></figure>
<p>使用git log 查看test上的commit记录，和上面直接使用merge的方式不同，会少一条merge记录。</p>
<p>这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁</p>
<h3 id="合并多个commit"><a href="#合并多个commit" class="headerlink" title="合并多个commit"></a>合并多个commit</h3><p>在一个分支为了解决一个问题，进行了多次commit，则会有多条commit记录，显得杂而乱</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git rebase -i [startpoint] [endpoint]</span><br><span class="line">其中-i的意思是--interactive，即弹出交互式的界面让用户编辑完成合并操作，</span><br><span class="line">[startpoint] [endpoint]则指定了一个编辑区间，如果不指定[endpoint]，则该区间的终点默认是当前分支HEAD所指向的commit(注：该区间指定的是一个前开后闭的区间)</span><br><span class="line">git rebase -i f4c477^ （使用^表示从该commitid开始）</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>会有如下的交互提示，进入编辑页面</p>
<p><img src="/2020/06/17/Git%20rebase%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/6.png" alt="6"></p>
<p>pick：保留该commit（缩写:p）<br>reword：保留该commit，但我需要修改该commit的注释（缩写:r）<br>edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）<br>squash：将该commit和前一个commit合并（缩写:s）<br>fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）<br>exec：执行shell命令（缩写:x）<br>drop：我要丢弃该commit（缩写:d）</p>
<p>然后对commit内容进行修改，对需要合并的commit进行s操作合并，缩写即可</p>
<p>：wq保存后，会进入另一个编辑页面</p>
<p><img src="/2020/06/17/Git%20rebase%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/7.png" alt="7"></p>
<p>编辑commit信息，然后保存</p>
<h3 id="git-rebase-–onto-A-B-C-的用法"><a href="#git-rebase-–onto-A-B-C-的用法" class="headerlink" title="git rebase –onto A B C 的用法"></a>git rebase –onto A B C 的用法</h3><p>A : 是一个分支名称（代表此分支的 HEAD）或者是一个 commit_id (此 id 不在 C 上)<br>B : 一个分支名称（此分支与 C 有共同的祖先 commit）或者是一个 commit_id (此 id 在 C 上)<br>C : 一个分支名称</p>
<p>命令的作用：       </p>
<ol>
<li>首先会执行 git checkout 切换到 C       </li>
<li> 将 B 到 C(HEAD) 之间所标识范围内的提交写到一个临时文件中 ，若B 为分支名称，则找 B 与 C 共同的祖先 commit，则为此 commit 到 C(HEAD) 之间所标识范围内的提交。       </li>
<li> 将当前分支强制重置（git reset –hard）到 A       </li>
<li> 从2中临时文件的提交列表中，一个一个将提交按照顺序重新提交到重置之后的分支上<br>注：       </li>
<li>如果遇到提交已经在分支中包含，跳过该提交。       </li>
<li>如果在提交过程遇到冲突，衍合过程暂停。用户解决冲突后，执行 git rebase –continue 继续变基操作。或者执行 git rebase –skip 跳过此提交。或者执行 git rebase –abort 就此终止变基操作切换到变基前的分支上。       </li>
<li>衍合操作结束后，当前分支为 C</li>
</ol>
<h2 id="注意-使用法则"><a href="#注意-使用法则" class="headerlink" title="注意-使用法则"></a>注意-使用法则</h2><p>不要通过rebase对任何已经提交到公共仓库中的commit进行修改,自己一个人玩的分支除外.</p>
<p>只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，就不会有事。假如在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就麻烦了.</p>
]]></content>
      <categories>
        <category>Git代码管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git工作流</title>
    <url>/2020/01/09/Git%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<p>Git工作流：为工作中团队成员遵守的一种代码管理方案，在Git中有以下几种工作流方案作为方案指导。</p>
<h2 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h2><p>这种工作方式跟svn类似，它只有一个master分支，开发者会先把远程的仓库克隆到本地，之后的修 改和提交都在本地操作，直到在某个合适的时间点将本地的代码合入到远程master。这种工作流比 较适合小团队，因为小团队可能不会太多的协作和合流的动作。</p>
<h2 id="功能分支工作流"><a href="#功能分支工作流" class="headerlink" title="功能分支工作流"></a>功能分支工作流</h2><p>这种工作流关注功能开发，不直接往master提交代码保证它是稳定并且干净的，而是从master拉 取feature分支进行功能开发，团队成员根据分工拉取不同的功能分支来进行不同的功能开发，这样 就可以完全隔离开每个人的工作。当功能开发完成后，会向master分支发起Pull Request，只有审 核通过的代码才真正允许合入master，这样就加强了团队成员之间的代码交流。</p>
<h2 id="Gitflow工作流"><a href="#Gitflow工作流" class="headerlink" title="Gitflow工作流"></a>Gitflow工作流</h2><p>相对复杂一点，但它非常适合用来管理大型项目的发布和维护，贯穿整个开发周期，master和develop分支是一直存在的，master分支可以被视为稳定的分支， 而develop分支是相对稳定的分支，特性开发会在feature分支上进行，发布会在release分支上 进行，而bug修复则会在hotfix分支上进行</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h4 id="两个分支，master，develop分支"><a href="#两个分支，master，develop分支" class="headerlink" title="两个分支，master，develop分支"></a>两个分支，master，develop分支</h4><p>相对使用仅有的一个master分支，Gitflow工作流使用2个分支来记录项目的历史。 master分支存储了正式发布的历史，而develop分支作为功能的集成分支。 这样也方便master分支上的所有提交分配一个版本号。</p>
<p><img src="/2020/01/09/Git%E5%B7%A5%E4%BD%9C%E6%B5%81/1.png" alt="1"></p>
<h4 id="每个人开发的功能分支"><a href="#每个人开发的功能分支" class="headerlink" title="每个人开发的功能分支"></a>每个人开发的功能分支</h4><p>每个新功能位于一个自己的分支，这样可以push到中央仓库以备份和协作。 但功能分支不是从master分支上拉出新分支，而是使用develop分支作为父分支。 当新功能完成时，合并回develop分支。 新功能提交应该从不直接与master分支交互。 从各种含义和目的上来看，功能分支加上develop分支就是功能分支工作流的用法。但Gitflow工作流没有在这里止步。</p>
<p><img src="/2020/01/09/Git%E5%B7%A5%E4%BD%9C%E6%B5%81/2.png" alt="2"></p>
<h4 id="develop和master中间的发布分支"><a href="#develop和master中间的发布分支" class="headerlink" title="develop和master中间的发布分支"></a>develop和master中间的发布分支</h4><p>一旦develop分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从develop分支上checkout一个发布分支。 新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上—— 这个分支只应该做Bug修复、文档生成和其它面向发布任务。 一旦对外发布的工作都完成了， 发布分支合并到master分支并分配一个版本号打好Tag。 另外，这些从新建发布分支以来的做的修改要合并回develop分支。</p>
<p>使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。 这也打造定义良好的开发阶段。</p>
<p><img src="/2020/01/09/Git%E5%B7%A5%E4%BD%9C%E6%B5%81/3.png" alt="3"></p>
<h4 id="修复分支"><a href="#修复分支" class="headerlink" title="修复分支"></a>修复分支</h4><p>维护分支或说是热修复（hotfix）分支用于生成快速给产品发布版本（production releases）打补丁， 这是唯一可以直接从master分支fork出来的分支。 修复完成，修改应该马上合并回master分支和dev elop分支（当前的发布分支），master分支应该用新的版本号打好Tag。</p>
<p>为Bug修复使用专门分支，让团队可以处理掉问题而不用打断其它工作或是等待下一个发布循环。 你可以把维护分支想成是一个直接在master分支上处理的临时发布。</p>
<p><img src="/2020/01/09/Git%E5%B7%A5%E4%BD%9C%E6%B5%81/4.png" alt="4"></p>
<h2 id="Forking工作流"><a href="#Forking工作流" class="headerlink" title="Forking工作流"></a>Forking工作流</h2><p>Forking工作流对于开源项目贡献者一定不陌生了，它有一个公开的中央仓库，其他贡献 者可以Fork（克隆）这个仓库作为你自己的私有仓库，开源项目维护者可以直接往中央仓库 push代码，而代码贡献者只能将代码push到自己的私有仓库，只有项目维护者接受代码贡献 者往中央仓库发起的pull request才会真正合入。</p>
]]></content>
      <categories>
        <category>Git代码管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令及分支</title>
    <url>/2018/05/21/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<h2 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h2><p><img src="/2018/05/21/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%88%86%E6%94%AF/1.jpg" alt="1"><br>从上图可以看到主要包含下面几个分支：</p>
<p>master: 主分支，主要用来版本发布。<br>develop：日常开发分支，该分支正常保存了开发的最新代码。<br>feature：具体的功能开发分支，只与 develop 分支交互。<br>release：release 分支可以认为是 master 分支的未测试版。比如说某一期的功能全部开发完成，那么就将 develop 分支合并到 release 分支，测试没有问题并且到了发布日期就合并到 master 分支，进行发布。<br>hotfix：线上 bug 修复分支。</p>
<h3 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a>主分支</h3><p>主分支包括 master 分支和 develop 分支。master 分支用来发布，HEAD 就是当前线上的运行代码。develop 分支就是我们的日常开发。使用这两个分支就具有了最简单的开发模式：develop 分支用来开发功能，开发完成并且测试没有问题则将 develop 分支的代码合并到 master 分支并发布。</p>
<h3 id="辅助分支"><a href="#辅助分支" class="headerlink" title="辅助分支"></a>辅助分支</h3><p>feature 分支<br>release 分支<br>hotfix 分支<br>通过这些分支，我们可以做到：团队成员之间并行开发，feature track 更加容易，开发和发布并行以及线上问题修复。</p>
<h4 id="Feature-分支"><a href="#Feature-分支" class="headerlink" title="Feature 分支"></a>Feature 分支</h4><p>feature 分支用来开发具体的功能，一般 fork 自 develop 分支，最终可能会合并到 develop 分支。比如我们要在下一个版本增加功能1、功能2、功能3。那么我们就可以起三个feature 分支：feature1，feature2，feature3。（feature 分支命名最好能够自解释，这并不是一种好的命名。）随着我们开发，功能1和功能2都被完成了，而功能3因为某些原因完成不了，那么最终 feature1 和 feature2 分支将被合并到 develop 分支，而 feature3 分支将被干掉。</p>
<h4 id="Release-分支"><a href="#Release-分支" class="headerlink" title="Release 分支"></a>Release 分支</h4><p>我们最初所有的开发工作都在 develop 分支上，当我们这一期的功能开发完毕的时候，我们基于 develop 分支开一个新的 release 分支。这个时候我们就可以对 release 分支做统一的测试了，另外做一些发布准备工作：比如版本号之类的。如果测试有问题的话，我们将直接在 release 分支上修改，然后将修改合并到 develop 分支上。</p>
<h4 id="Hotfix-分支"><a href="#Hotfix-分支" class="headerlink" title="Hotfix 分支"></a>Hotfix 分支</h4><p>顾名思义，hotfix 分支用来修复线上 bug。当线上代码出现 bug 时，我们基于 master 分支开一个 hotfix 分支，修复 bug 之后再将 hotfix 分支合并到 master 分支并进行发布，同时 develop 分支作为最新最全的代码分支，hotfix 分支也需要合并到 develop 分支上去。仔细想一想，其实 hotfix 分支和 release 分支功能类似。hotfix 的好处是不打断 develop 分支正常进行，</p>
<h2 id="git基本命令"><a href="#git基本命令" class="headerlink" title="git基本命令"></a>git基本命令</h2><p>1）git add 将想要快照的内容写入缓存区<br>2）git status -s “AM” 状态的意思是，这个文件在我们将它添加到缓存之后又有改动<br>3）git commit -m ‘第一次版本提交’ -m选项添加备注信息<br>4）git clone url 使用 git clone 拷贝一个 Git 仓库到本地<br>5）git diff 查看执行 git status 的结果的详细信息<br>　　尚未缓存的改动：git diff<br>　　查看已缓存的改动： git diff –cached<br>　　查看已缓存的与未缓存的所有改动：git diff HEAD<br>　　显示摘要而非整个 diff：git diff –stat<br>6）git commit -a 跳过git add 提交缓存的流程<br>7）git reset HEAD 用于取消已缓存的内容<br>8）git rm file<br>　　git rm 会将条目从缓存区中移除。这与 git reset HEAD 将条目取消缓存是有区别的。<br>　　“取消缓存”的意思就是将缓存区恢复为我们做出修改之前的样子。<br>　　默认情况下，git rm file 会将文件从缓存区和你的硬盘中（工作目录）删除。<br>9）git mv 重命名磁盘上的文件 如 git mv README README.md</p>
<p>10）git push -u origin master 提交代码</p>
<h2 id="git分支管理"><a href="#git分支管理" class="headerlink" title="git分支管理"></a>git分支管理</h2><p>查看本地分支：$ git branch</p>
<p>查看远程分支：$ git branch -r</p>
<p>创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支</p>
<p>切换分支：$ git checkout [name]</p>
<p>创建新分支并立即切换到新分支：$ git checkout -b [name]</p>
<p>删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</p>
<p>合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并</p>
<p>创建远程分支(本地分支push到远程)：$ git push origin [name]</p>
<p>删除远程分支：$ git push origin :heads/[name] 或 $ gitpush origin :[name] </p>
<h2 id="git仓库相关命令"><a href="#git仓库相关命令" class="headerlink" title="git仓库相关命令"></a>git仓库相关命令</h2><p>检出仓库：        $ git clone git://github.com/jquery/jquery.git</p>
<p>查看远程仓库：$ git remote -v</p>
<p>添加远程仓库：$ git remote add [name] [url]</p>
<p>删除远程仓库：$ git remote rm [name]</p>
<p>修改远程仓库：$ git remote set-url –push [name] [newUrl]</p>
<p>拉取远程仓库：$ git pull [remoteName] [localBranchName]</p>
<p>推送远程仓库：$ git push [remoteName] [localBranchName]</p>
<p>如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：</p>
<p>$git push origin test:master         // 提交本地test分支作为远程的master分支</p>
<p>$git push origin test:test              // 提交本地test分支作为远程的test分支</p>
<h2 id="git版本相关操作命令"><a href="#git版本相关操作命令" class="headerlink" title="git版本相关操作命令"></a>git版本相关操作命令</h2><p>查看版本：$ git tag</p>
<p>创建版本：$ git tag [name]</p>
<p>删除版本：$ git tag -d [name]</p>
<p>查看远程版本：$ git tag -r</p>
<p>创建远程版本(本地版本push到远程)：$ git push origin [name]</p>
<p>删除远程版本：$ git push origin :refs/tags/[name]</p>
<p>合并远程仓库的tag到本地：$ git pull origin –tags</p>
<p>上传本地tag到远程仓库：$ git push origin –tags</p>
<p>创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’</p>
<h2 id="提取远程代码"><a href="#提取远程代码" class="headerlink" title="提取远程代码"></a>提取远程代码</h2><p>1）git fetch　　从远程仓库下载新分支与数据<br>2)）git pull　　从远端仓库提取数据并尝试合并到当前分支</p>
]]></content>
      <categories>
        <category>Git代码管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git撤销回滚</title>
    <url>/2019/11/05/Git%E6%92%A4%E9%94%80%E5%9B%9E%E6%BB%9A/</url>
    <content><![CDATA[<p>了解git如何撤销回滚，先了解git的工作流</p>
<h2 id="git工作流"><a href="#git工作流" class="headerlink" title="git工作流"></a>git工作流</h2><p>完成一次完整的本地分支git提交工作，分为三个区域</p>
<p>工作区：即自己当前分支所修改的代码，git add xx 之前的！不包括 git add xx 和 git commit xxx 之后的。</p>
<p>暂存区：已经 git add xxx 进去，且未 git commit xxx 的。</p>
<p>本地分支：已经git commit -m xxx 提交到本地分支的。</p>
<p> <img src="/2019/11/05/Git%E6%92%A4%E9%94%80%E5%9B%9E%E6%BB%9A/1.png" alt="1"></p>
<p>代码回滚</p>
<p>在上传代码到远程仓库的时候，不免会出现问题，任何过程都有可能要回滚代码</p>
<h2 id="如何回滚"><a href="#如何回滚" class="headerlink" title="如何回滚"></a>如何回滚</h2><p>分为以下几种场景</p>
<h3 id="工作区的代码"><a href="#工作区的代码" class="headerlink" title="工作区的代码"></a>工作区的代码</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">git checkout ./a.txt   # 丢弃某个文件，或者</span><br><span class="line">git checkout ./       # 丢弃全部</span><br></pre></td></tr></table></figure>
<p>注意：git checkout – . 丢弃全部，也包括：新增的文件会被删除、删除的文件会恢复回来、修改的文件会回去。这几个前提都说的是，回到暂存区之前的样子。对之前保存在暂存区里的代码不会有任何影响。对commit提交到本地分支的代码就更没影响了。当然，如果你之前压根都没有暂存或commit，那就是回到你上次pull下来的样子了</p>
<h3 id="代码git-add到缓存区，并未commit提交"><a href="#代码git-add到缓存区，并未commit提交" class="headerlink" title="代码git add到缓存区，并未commit提交"></a>代码git add到缓存区，并未commit提交</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git reset HEAD .  或者</span><br><span class="line">git reset HEAD a.txt</span><br></pre></td></tr></table></figure>

<p>这个命令仅改变暂存区，并不改变工作区，这意味着在无任何其他操作的情况下，工作区中的实际文件同该命令运行之前无任何变化</p>
<h3 id="git-commit到本地分支、但没有git-push到远程"><a href="#git-commit到本地分支、但没有git-push到远程" class="headerlink" title="git commit到本地分支、但没有git push到远程"></a>git commit到本地分支、但没有git push到远程</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">git log # 得到你需要回退一次提交的commit id</span><br><span class="line">git reset --hard &lt;commit_id&gt;  # 回到其中你想要的某个版</span><br><span class="line">或者</span><br><span class="line">git reset --hard HEAD^  # 回到最新的一次提交</span><br><span class="line">或者</span><br><span class="line">git reset HEAD^  # 此时代码保留，回到 git add 之前</span><br></pre></td></tr></table></figure>

<h3 id="git-push把修改提交到远程仓库"><a href="#git-push把修改提交到远程仓库" class="headerlink" title="git push把修改提交到远程仓库"></a>git push把修改提交到远程仓库</h3><p>reset和revert两种方式</p>
<h4 id="通过git-reset是直接删除指定的commit"><a href="#通过git-reset是直接删除指定的commit" class="headerlink" title="通过git reset是直接删除指定的commit"></a>通过git reset是直接删除指定的commit</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">git log # 得到你需要回退一次提交的commit id</span><br><span class="line">git reset --hard &lt;commit_id&gt;</span><br><span class="line">git push origin HEAD --force # 强制提交一次，之前错误的提交就从远程仓库删除</span><br></pre></td></tr></table></figure>
<h4 id="通过git-revert是用一次新的commit来回滚之前的commit"><a href="#通过git-revert是用一次新的commit来回滚之前的commit" class="headerlink" title="通过git revert是用一次新的commit来回滚之前的commit"></a>通过git revert是用一次新的commit来回滚之前的commit</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">git log # 得到你需要回退一次提交的commit id</span><br><span class="line">git revert &lt;commit_id&gt;  # 撤销指定的版本，撤销也会作为一次提交进行保存</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Git代码管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git查看文件历史</title>
    <url>/2019/03/04/Git%E6%9F%A5%E7%9C%8B%E8%AE%B0%E5%BD%95%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h4 id="显示commit历史，以及每次commit发生变更的文件"><a href="#显示commit历史，以及每次commit发生变更的文件" class="headerlink" title="显示commit历史，以及每次commit发生变更的文件"></a>显示commit历史，以及每次commit发生变更的文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure>

<h4 id="搜索提交历史，根据关键词"><a href="#搜索提交历史，根据关键词" class="headerlink" title="搜索提交历史，根据关键词"></a>搜索提交历史，根据关键词</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git log -S [keyword]</span><br></pre></td></tr></table></figure>

<h4 id="显示某个commit之后的所有变动，每个commit占据一行"><a href="#显示某个commit之后的所有变动，每个commit占据一行" class="headerlink" title="显示某个commit之后的所有变动，每个commit占据一行"></a>显示某个commit之后的所有变动，每个commit占据一行</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git log [tag] HEAD --pretty=format:%s</span><br></pre></td></tr></table></figure>

<h4 id="显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件"><a href="#显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件" class="headerlink" title="显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件"></a>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git log [tag] HEAD --grep feature</span><br></pre></td></tr></table></figure>

<h4 id="显示某个文件的版本历史，包括文件改名"><a href="#显示某个文件的版本历史，包括文件改名" class="headerlink" title="显示某个文件的版本历史，包括文件改名"></a>显示某个文件的版本历史，包括文件改名</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git log --follow [file]</span><br><span class="line">git whatchanged [file]</span><br></pre></td></tr></table></figure>

<h4 id="显示指定文件相关的每一次diff"><a href="#显示指定文件相关的每一次diff" class="headerlink" title="显示指定文件相关的每一次diff"></a>显示指定文件相关的每一次diff</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git log -p [file]</span><br></pre></td></tr></table></figure>

<h4 id="显示过去5次提交"><a href="#显示过去5次提交" class="headerlink" title="显示过去5次提交"></a>显示过去5次提交</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git log -<span class="number">5</span> --pretty --oneline</span><br></pre></td></tr></table></figure>

<h4 id="显示所有提交过的用户，按提交次数排序"><a href="#显示所有提交过的用户，按提交次数排序" class="headerlink" title="显示所有提交过的用户，按提交次数排序"></a>显示所有提交过的用户，按提交次数排序</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git shortlog -sn</span><br></pre></td></tr></table></figure>

<h4 id="显示指定文件是什么人在什么时间修改过"><a href="#显示指定文件是什么人在什么时间修改过" class="headerlink" title="显示指定文件是什么人在什么时间修改过"></a>显示指定文件是什么人在什么时间修改过</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git blame [file]</span><br></pre></td></tr></table></figure>

<h4 id="显示暂存区和工作区的代码差异"><a href="#显示暂存区和工作区的代码差异" class="headerlink" title="显示暂存区和工作区的代码差异"></a>显示暂存区和工作区的代码差异</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>

<h4 id="显示暂存区和上一个commit的差异"><a href="#显示暂存区和上一个commit的差异" class="headerlink" title="显示暂存区和上一个commit的差异"></a>显示暂存区和上一个commit的差异</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git diff --cached [file]</span><br></pre></td></tr></table></figure>

<h4 id="显示工作区与当前分支最新commit之间的差异"><a href="#显示工作区与当前分支最新commit之间的差异" class="headerlink" title="显示工作区与当前分支最新commit之间的差异"></a>显示工作区与当前分支最新commit之间的差异</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure>

<h4 id="显示两次提交之间的差异"><a href="#显示两次提交之间的差异" class="headerlink" title="显示两次提交之间的差异"></a>显示两次提交之间的差异</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git diff [first-branch]...[second-branch]</span><br></pre></td></tr></table></figure>

<h4 id="显示今天你写了多少行代码"><a href="#显示今天你写了多少行代码" class="headerlink" title="显示今天你写了多少行代码"></a>显示今天你写了多少行代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="显示某次提交的元数据和内容变化"><a href="#显示某次提交的元数据和内容变化" class="headerlink" title="显示某次提交的元数据和内容变化"></a>显示某次提交的元数据和内容变化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git show [commit]</span><br></pre></td></tr></table></figure>

<h4 id="显示某次提交发生变化的文件"><a href="#显示某次提交发生变化的文件" class="headerlink" title="显示某次提交发生变化的文件"></a>显示某次提交发生变化的文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git show --name-only [commit]</span><br></pre></td></tr></table></figure>

<h4 id="显示某次提交时，某个文件的内容"><a href="#显示某次提交时，某个文件的内容" class="headerlink" title="显示某次提交时，某个文件的内容"></a>显示某次提交时，某个文件的内容</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git show [commit]:[filename]</span><br></pre></td></tr></table></figure>

<h4 id="显示当前分支的最近几次提交"><a href="#显示当前分支的最近几次提交" class="headerlink" title="显示当前分支的最近几次提交"></a>显示当前分支的最近几次提交</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>

<h4 id="从本地master拉取代码更新当前分支：branch-一般为master"><a href="#从本地master拉取代码更新当前分支：branch-一般为master" class="headerlink" title="从本地master拉取代码更新当前分支：branch 一般为master"></a>从本地master拉取代码更新当前分支：branch 一般为master</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git rebase [branch]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git代码管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的reset与revert的区别</title>
    <url>/2019/12/12/Git%E7%9A%84reset%E4%B8%8Erevert%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="git的head理解"><a href="#git的head理解" class="headerlink" title="git的head理解"></a>git的head理解</h2><p>使用git的每次提交，Git都会自动把它们串成一条时间线，这条时间线就是一个分支。如果没有新建分支，那么只有一条时间线，即只有一个分支，在Git里，这个分支叫主分支，即master分支。有一个HEAD指针指向当前分支（只有一个分支的情况下会指向master，而master是指向最新提交）</p>
<h2 id="reset操作"><a href="#reset操作" class="headerlink" title="reset操作"></a>reset操作</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>git reset的作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本</p>
<p><img src="/2019/12/12/Git%E7%9A%84reset%E4%B8%8Erevert%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" alt="1"></p>
<p>reset之后，目标版本之后的版本会被删除，更新为reset的版本</p>
<p><img src="/2019/12/12/Git%E7%9A%84reset%E4%B8%8Erevert%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" alt="2"></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>如果想恢复到之前某个提交的版本，且那个版本之后提交的版本我们都不要了，就可以用这种方法</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>git log 查看当前分支版本号，commit ID</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure>

<p>如下图所示，选择要回退的commit ID</p>
<p><img src="/2019/12/12/Git%E7%9A%84reset%E4%B8%8Erevert%E7%9A%84%E5%8C%BA%E5%88%AB/3.png" alt="3"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure>

<p>然后提交更改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure>
<p>PS： “git push”会报错，因为我们本地库HEAD指向的版本比远程库的要旧</p>
<p>强推则回退成功</p>
<h2 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p> git revert是用于“反做”某一个版本，以达到撤销该版本的修改的目的。比如，我们commit了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西</p>
<p> <img src="/2019/12/12/Git%E7%9A%84reset%E4%B8%8Erevert%E7%9A%84%E5%8C%BA%E5%88%AB/4.png" alt="4"></p>
<p> <img src="/2019/12/12/Git%E7%9A%84reset%E4%B8%8Erevert%E7%9A%84%E5%8C%BA%E5%88%AB/5.png" alt="5"></p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>如果我们想撤销之前的某一版本，但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用这种方法。</p>
<h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><p>git log 查看当前分支版本号，commit ID</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure>

<p>选择要反做的版本号，撤销该版本的修改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git revert -n 版本号</span><br></pre></td></tr></table></figure>

<p>PS： 这里可能会出现冲突，那么需要手动修改冲突的文件。而且要git add 文件名。</p>
<p>提交反做的内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;新提交说明&quot;</span> </span><br></pre></td></tr></table></figure>

<p>这时可以git log查看本地的版本信息，会发现新增一个版本</p>
<p>git push推上去</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>反做成功</p>
<h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>reset： 回滚“到”某个版本</p>
<p>revert： 回滚某个版本</p>
]]></content>
      <categories>
        <category>Git代码管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>GO的常见小问题</title>
    <url>/2021/03/18/Go%E7%9A%84%E5%B8%B8%E8%A7%81%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="byte与int"><a href="#byte与int" class="headerlink" title="byte与int"></a>byte与int</h3><h3 id="byte与字符串"><a href="#byte与字符串" class="headerlink" title="byte与字符串"></a>byte与字符串</h3><h3 id="strings转换"><a href="#strings转换" class="headerlink" title="strings转换"></a>strings转换</h3><h3 id="for循环字符串"><a href="#for循环字符串" class="headerlink" title="for循环字符串"></a>for循环字符串</h3><h3 id="简短模式"><a href="#简短模式" class="headerlink" title="简短模式"></a>简短模式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> size := <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>这种是不对的，会报错</p>
<h3 id="常量内存分配"><a href="#常量内存分配" class="headerlink" title="常量内存分配"></a>常量内存分配</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"><span class="keyword">const</span> cl  = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bl    = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>  &#123;</span><br><span class="line">    println(&amp;bl,bl)</span><br><span class="line">    println(&amp;cl,cl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会报错<br>常量不同于变量的在运行期分配内存，常量通常会被编译器在预处理阶段直接展开，作为指令数据使用</p>
<h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++  &#123;</span><br><span class="line">    loop:</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">    goto loop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>goto不能跳转到其他函数或者内层代码</p>
<h3 id="新类型强转"><a href="#新类型强转" class="headerlink" title="新类型强转"></a>新类型强转</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>  &#123;</span><br><span class="line">     type MyInt1 int</span><br><span class="line">    type MyInt2 = int</span><br><span class="line">    <span class="keyword">var</span> i int =<span class="number">9</span></span><br><span class="line">    <span class="keyword">var</span> i1 MyInt1 = i</span><br><span class="line">    <span class="keyword">var</span> i2 MyInt2 = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">&#125;</span><br><span class="line">type MyUser1 User</span><br><span class="line">type MyUser2 = User</span><br><span class="line">func (i MyUser1) <span class="function"><span class="title">m1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;MyUser1.m1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">func (i User) <span class="function"><span class="title">m2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;User.m2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i1 MyUser1</span><br><span class="line">    <span class="keyword">var</span> i2 MyUser2</span><br><span class="line">    i1.m1()</span><br><span class="line">    i2.m2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会报错，myint的是新类型，得强转，不能直接赋值</p>
<p>第二个，user取了别名myuser1，myuser1没有m2方法，执行失败</p>
<h3 id="nil切片和空切片指向地址"><a href="#nil切片和空切片指向地址" class="headerlink" title="nil切片和空切片指向地址"></a>nil切片和空切片指向地址</h3><p>指向数组的引用地址不一样</p>
<p>nil切片是0，不存在<br>空切片是指向一个固定的地址，所有的空切片都指向这个地址</p>
<p>var slice []int 创建出来的 slice 其实是一个 nil slice。它的长度和容量都为0。和nil比较的结果为true。这里比较混淆的是empty slice，empty slice的长度和容量也都为0，但是所有的空切片的数据指针都指向同一个地址 0xc42003bda0。空切片和 nil 比较的结果为false</p>
<h3 id="字符串转换数组，内存拷贝问题"><a href="#字符串转换数组，内存拷贝问题" class="headerlink" title="字符串转换数组，内存拷贝问题"></a>字符串转换数组，内存拷贝问题</h3><p>会发生内存拷贝，只要发生类型强转，都会发生内存拷贝</p>
<p>go的unsafe包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">unsafe.Pointer(&amp;a)方法可以得到变量a的地址</span><br><span class="line">(*reflect.StringHeader)(unsafe.Pointer(&amp;a)) 可以把字符串a转成底层结构的形式</span><br><span class="line">(*[]byte)(unsafe.Pointer(&amp;ssh))可以把ssh底层结构体转成byte的切片的指针。</span><br><span class="line">再通过 *转为指针指向的实际内容</span><br></pre></td></tr></table></figure>

<h3 id="反转含有中文，数字，字符串的字符"><a href="#反转含有中文，数字，字符串的字符" class="headerlink" title="反转含有中文，数字，字符串的字符"></a>反转含有中文，数字，字符串的字符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span><span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> src := <span class="string">&quot;你好abc啊哈哈&quot;</span></span><br><span class="line"> dst := reverse([]rune(src))</span><br><span class="line"> fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, string(dst))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func reverse(s []rune) []rune &#123;</span><br><span class="line"> <span class="keyword">for</span> i, <span class="attr">j</span> := <span class="number">0</span>, len(s)-<span class="number">1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j-<span class="number">1</span> &#123;</span><br><span class="line">  s[i], s[j] = s[j], s[i]</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rune关键字，从golang源码中看出，它是int32的别名（-2^31 ~ 2^31-1），比起byte（-128～127），可表示更多的字符。<br>由于rune可表示的范围更大，所以能处理一切字符，当然也包括中文字符。在平时计算中文字符，可用rune。<br>因此将字符串转为rune的切片，再进行翻转，完美解决</p>
<h3 id="拷贝大切片，小切片的代价"><a href="#拷贝大切片，小切片的代价" class="headerlink" title="拷贝大切片，小切片的代价"></a>拷贝大切片，小切片的代价</h3><p>并不是，所有切片的大小相同；三个字段（一个uintptr，两个int）。切片中的第一个字是指向切片底层数组的指针，这是切片的存储空间，第二个字段是切片的长度，第三个字段是容量。将一个 slice 变量分配给另一个变量只会复制三个机器字。所以 拷贝大切片跟小切片的代价应该是一样的</p>
<p>大切片跟小切片的区别无非就是 Len 和 Cap的值比小切片的这两个值大一些，如果发生拷贝，本质上就是拷贝上面的三个字段</p>
<h3 id="uintptr和unsafe-Pointer的区别"><a href="#uintptr和unsafe-Pointer的区别" class="headerlink" title="uintptr和unsafe.Pointer的区别"></a>uintptr和unsafe.Pointer的区别</h3><p>unsafe.Pointer只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；<br>而uintptr是用于指针运算的，GC 不把 uintptr 当指针，也就是说 uintptr 无法持有对象， uintptr 类型的目标会被回收；<br>unsafe.Pointer 可以和 普通指针 进行相互转换；<br>unsafe.Pointer 可以和 uintptr 进行相互转换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type W struct &#123;</span><br><span class="line"> b int32</span><br><span class="line"> c int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">var</span> w *W = <span class="keyword">new</span>(W)</span><br><span class="line"> <span class="comment">//这时w的变量打印出来都是默认值0，0</span></span><br><span class="line"> fmt.Println(w.b,w.c)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//现在我们通过指针运算给b变量赋值为10</span></span><br><span class="line"> b := unsafe.Pointer(uintptr(unsafe.Pointer(w)) + unsafe.Offsetof(w.b))</span><br><span class="line"> *((*int)(b)) = <span class="number">10</span></span><br><span class="line"> <span class="comment">//此时结果就变成了10，0</span></span><br><span class="line"> fmt.Println(w.b,w.c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>uintptr(unsafe.Pointer(w)) 获取了 w 的指针起始值<br>unsafe.Offsetof(w.b) 获取 b 变量的偏移量<br>两个相加就得到了 b 的地址值，将通用指针 Pointer 转换成具体指针 ((*int)(b))，通过 * 符号取值，然后赋值。*((*int)(b)) 相当于把 (*int)(b) 转换成 int 了，最后对变量重新赋值成 10，这样指针运算就完成了</p>
<h3 id="map不初始化会怎么样"><a href="#map不初始化会怎么样" class="headerlink" title="map不初始化会怎么样"></a>map不初始化会怎么样</h3><p>map不初始化，可以取值，取出来的值是空</p>
<p>不能赋值，赋值会panic异常</p>
<p>空map和nil map结果是一样的，都是map[]， 判断是否为空， map==nil</p>
<p>delete一个nil map也不会panic</p>
<h3 id="map初始化和不初始化的区别"><a href="#map初始化和不初始化的区别" class="headerlink" title="map初始化和不初始化的区别"></a>map初始化和不初始化的区别</h3><p>初始化map是有长度的，可以赋值，操作，默认值。不初始化无法赋值</p>
<h3 id="map的遍历删除"><a href="#map的遍历删除" class="headerlink" title="map的遍历删除"></a>map的遍历删除</h3><p>map的range遍历删除是安全的，可以一边遍历一边删除，但是删除完后，占用的内存一直不释放，map = nil释放内存</p>
<h3 id="go的字符串修改"><a href="#go的字符串修改" class="headerlink" title="go的字符串修改"></a>go的字符串修改</h3><p>字符串是不能修改的，天生线程安全，大家使用的都是只读对象，无须加锁；再者，方便内存共享，而不必使用写时复制（Copy On Write）等技术；字符串 hash 值也只需要制作一份</p>
<p>怎么修改，转为byte数组进行替换，最后通过string强转</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">angleBytes := []byte(angel)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">5</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">    angleBytes[i] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="判断一个数组是否已经排序"><a href="#判断一个数组是否已经排序" class="headerlink" title="判断一个数组是否已经排序"></a>判断一个数组是否已经排序</h3><p>sort包的，isSorted方法</p>
<p>sort包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type Interface interface &#123;</span><br><span class="line">        <span class="comment">// 获取数据集合元素个数</span></span><br><span class="line">        Len() int</span><br><span class="line">        <span class="comment">// 如果 i 索引的数据小于 j 索引的数据，返回 true，且不会调用下面的 Swap()，即数据升序排序。</span></span><br><span class="line">        Less(i, j int) bool</span><br><span class="line">        <span class="comment">// 交换 i 和 j 索引的两个元素的位置</span></span><br><span class="line">        Swap(i, j int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="slice和map的并发安全处理"><a href="#slice和map的并发安全处理" class="headerlink" title="slice和map的并发安全处理"></a>slice和map的并发安全处理</h3><p>slice在并发执行中不会报错，但是数据会丢失</p>
<p>方法：1，索引处理，全局索引，2：加锁， 3：channel处理</p>
<p>map并发会报错</p>
<p>方法：1，加锁，2：sync.map</p>
<h3 id="数组与切片的区别"><a href="#数组与切片的区别" class="headerlink" title="数组与切片的区别"></a>数组与切片的区别</h3><p>1、切片是指针类型， 数组是值类型</p>
<p>2、数组的长度是固定的，切片不是，切片是动态数组</p>
<p>3、切片比数组多一个属性，cap容量</p>
<p>4、切片的底层是数组</p>
<h3 id="json包使用，结构体里tag问题"><a href="#json包使用，结构体里tag问题" class="headerlink" title="json包使用，结构体里tag问题"></a>json包使用，结构体里tag问题</h3><p>如果变量首字母小写，则为private。无论如何不能转，因为取不到反射信息</p>
<p>如果变量首字母大写，则为public。</p>
<p>不加tag，可以正常转为json里的字段，json内字段名跟结构体内字段原名一致。<br>加了tag，从struct转json的时候，json的字段名就是tag里的字段名，原字段名已经没用。</p>
<h3 id="slice的深拷贝和-浅拷贝"><a href="#slice的深拷贝和-浅拷贝" class="headerlink" title="slice的深拷贝和 浅拷贝"></a>slice的深拷贝和 浅拷贝</h3><p>浅拷贝对于值类型的话是完全拷贝一份，而对于引用类型是拷贝其地址。也就是拷贝的对象修改引用类型的变量同样会影响到源对象</p>
<p>P2 := P1就是浅拷贝，如何避免，重新给定地址，重新生成一个</p>
<p>深拷贝 deepCopy(dst, src interface{})</p>
<p>对于深拷贝就比较好了解了，任何对象都会被完完整整的拷贝一份，拷贝对象与被拷贝对象不存在如何联系，也就不会互相影响。如果你需要拷贝的对象中没有引用类型，那么对于Golang而言使用浅拷贝就可以</p>
<h3 id="for-range循环，for里append"><a href="#for-range循环，for里append" class="headerlink" title="for range循环，for里append"></a>for range循环，for里append</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">s := []int&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, <span class="attr">v</span>:=range s &#123;</span><br><span class="line"> s =append(s, v)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;len(s)=%v\n&quot;</span>,len(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不会死循环，for range其实是golang的语法糖，在循环开始前会获取切片的长度 len(切片)，然后再执行len(切片)次数的循环。</p>
<h3 id="读写已经关闭的channel会怎样"><a href="#读写已经关闭的channel会怎样" class="headerlink" title="读写已经关闭的channel会怎样"></a>读写已经关闭的channel会怎样</h3><p>读已经关闭的 chan 能一直读到东西，但是读到的内容根据通道内关闭前是否有元素而不同。<br>如果 chan 关闭前，buffer 内有元素还未读 , 会正确读到 chan 内的值，且返回的第二个 bool 值（是否读成功）为 true。<br>如果 chan 关闭前，buffer 内有元素已经被读完，chan 内无值，接下来所有接收的值都会非阻塞直接成功，返回 channel 元素的零值，但是第二个 bool 值一直为 false。<br>因为如果接收值的地址 ep 不为空<br>那接收值将获得是一个该类型的零值<br>typedmemclr 会根据类型清理相应地址的内存<br>这就解释了上面代码为什么关闭的 chan 会返回对应类型的零值</p>
<p>写已经关闭的 chan 会 panic，<br>因为源码当 c.closed != 0 则为通道关闭，此时执行写，源码提示直接 panic，输出的内容就是上面提到的 “send on closed channel”</p>
<h3 id="对未初始化的channel进行读写会怎样"><a href="#对未初始化的channel进行读写会怎样" class="headerlink" title="对未初始化的channel进行读写会怎样"></a>对未初始化的channel进行读写会怎样</h3><p>读写未初始化的 chan 都会阻塞</p>
<p>未初始化的 chan 此时是等于 nil，当它不能阻塞的情况下，直接返回 false，表示读写 chan 失败</p>
<p>当 chan 能阻塞的情况下，则直接阻塞 gopark方法，读写抛出错误</p>
<h3 id="for循环select"><a href="#for循环select" class="headerlink" title="for循环select"></a>for循环select</h3><p>如果通道已经关闭会怎么样？如果select中的case只有一个，又会怎么样？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">c := make(chan int)</span><br><span class="line">go func () &#123;</span><br><span class="line">	c &lt;- <span class="number">10</span></span><br><span class="line">	close(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	select&#123;</span><br><span class="line">	<span class="keyword">case</span> x, <span class="attr">ok</span> := <span class="xml">&lt;-c:</span></span><br><span class="line"><span class="xml">		if !ok &#123;</span></span><br><span class="line"><span class="xml">			c = nil</span></span><br><span class="line"><span class="xml">		&#125;</span></span><br><span class="line"><span class="xml">	default:</span></span><br><span class="line"></span><br><span class="line"><span class="xml">	&#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>


<p>for循环select时，如果其中一个case通道已经关闭，则每次都会执行到这个case。</p>
<p>怎样不读关闭的channel，根据channel读关闭的会返回false，根据false判断<br>x, ok := &lt;-c 返回的值里第一个x是通道内的值，ok是指通道是否关闭，当通道被关闭后，ok则返回false，因此可以根据这个进行操作x, ok := &lt;-c 返回的值里第一个x是通道内的值，ok是指通道是否关闭，当通道被关闭后，ok则返回false，因此可以根据这个进行操作</p>
<p>执行c = nil 将通道置为nil，相当于读一个未初始化的通道，则会一直阻塞， seleect会跳过这个阻塞</p>
<p>如果select里边只有一个case，而这个case被关闭了，则会出现死循环。</p>
<p>如果像上面置为nil去解决，则会引发别的问题</p>
<p>第一次读取case能读到通道里的10<br>第二次读取case能读到通道已经关闭的信息。此时将通道置为nil<br>第三次读取case时main协程会被阻塞，此时整个进程没有其他活动的协程了，进程deadlock</p>
<h3 id="goalng内存逃逸"><a href="#goalng内存逃逸" class="headerlink" title="goalng内存逃逸"></a>goalng内存逃逸</h3><p>golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配</p>
<p>在一个切片上存储指针或带指针的值。 一个典型的例子就是 []* string</p>
<p>在方法内把局部变量指针返回 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出</p>
<p>slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。 slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配 </p>
<h3 id="怎样避免内存逃逸"><a href="#怎样避免内存逃逸" class="headerlink" title="怎样避免内存逃逸"></a>怎样避免内存逃逸</h3><p>在runtime/stubs.go:133有个函数叫noescape。noescape可以在逃逸分析中隐藏一个指针。让这个指针在逃逸分析中不会被检测为逃逸</p>
<p>noescape() 函数的作用是遮蔽输入和输出的依赖关系。使编译器不认为 p 会通过 x 逃逸， 因为 uintptr() 产生的引用是编译器无法理解的。</p>
<h3 id="内存泄漏相关问题"><a href="#内存泄漏相关问题" class="headerlink" title="内存泄漏相关问题"></a>内存泄漏相关问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"> <span class="string">&quot;net/http&quot;</span></span><br><span class="line"> <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> num := <span class="number">6</span></span><br><span class="line"> <span class="keyword">for</span> index := <span class="number">0</span>; index &lt; num; index++ &#123;</span><br><span class="line">  resp, <span class="attr">_</span> := http.Get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">  _, _ = ioutil.ReadAll(resp.Body)</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;此时goroutine个数= %d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这道题在不执行resp.Body.Close()的情况下，泄漏了吗？如果泄漏，泄漏了多少个goroutine?</p>
<p>不进行resp.Body.Close()，泄漏是一定的，读写加main是13个，是不对的</p>
<p>因为http。Get的DefaultTransport </p>
<p>一次建立连接，就会启动一个读goroutine和写goroutine。这就是为什么一次http.Get()会泄漏两个goroutine的来源</p>
<p>虽然执行了 6 次循环，而且每次都没有执行 Body.Close() ,就是因为执行了ioutil.ReadAll()把内容都读出来了，连接得以复用，因此只泄漏了一个读goroutine和一个写goroutine，最后加上main goroutine，所以答案就是3个goroutine。<br>从另外一个角度说，正常情况下我们的代码都会执行 ioutil.ReadAll()，但如果此时忘了 resp.Body.Close()，确实会导致泄漏。但如果你调用的域名一直是同一个的话，那么只会泄漏一个 读goroutine 和一个写goroutine，这就是为什么代码明明不规范但却看不到明显内存泄漏的原因</p>
<h3 id="goroutine泄露问题"><a href="#goroutine泄露问题" class="headerlink" title="goroutine泄露问题"></a>goroutine泄露问题</h3><p>如果你启动了一个 goroutine，但并没有符合预期的退出，直到程序结束，此goroutine才退出，这种情况就是 goroutine 泄露。当 goroutine 泄露发生时，该 goroutine 的栈(一般 2k 内存空间起)一直被占用不能释放，goroutine 里的函数在堆上申请的空间也不能被 垃圾回收器 回收。这样，在程序运行期间，内存占用持续升高，可用内存越来也少，最终将导致系统崩溃</p>
<p>channel引起泄漏</p>
<p>1.从 channel 里读，但是没有写</p>
<p>2.向 unbuffered channel 写，但是没有读</p>
<p>3.向已满的 buffered channel 写，但是没有读<br>解决方法，2,3设定buffer size，分配值和接收值数量一样</p>
<p>4.select操作在所有case上阻塞<br>解决方法：<br>使用上述实现里的模式，传入一个 quit channel，配合 select，当不需要的时候，close 这个 quit channel，该 goroutine 就可以退出<br>或者使用ctx包</p>
<p>5.goroutine进入死循环中，导致资源一直无法释放</p>
<h3 id="interface类型可以比较吗"><a href="#interface类型可以比较吗" class="headerlink" title="interface类型可以比较吗"></a>interface类型可以比较吗</h3><p>interface类型可以比较，动态类型，动态值，两个一样就可以比较，只有slice，map无法比较，只能和nil比较，或者通过reflect包DeepEqual，或者cmp包比较</p>
<p>struct可以比较，但是必须是同一类型的实例值可以比较，都相等为true</p>
<h3 id="map如何顺序读取"><a href="#map如何顺序读取" class="headerlink" title="map如何顺序读取"></a>map如何顺序读取</h3><p>map不能顺序读取，是因为他是无序的，想要有序读取，首先的解决的问题就是，把ｋｅｙ变为有序，所以可以把key放入切片，对切片进行排序，遍历切片，通过key取值</p>
<h3 id="实现set"><a href="#实现set" class="headerlink" title="实现set"></a>实现set</h3><p>通过map实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type inter interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">type <span class="built_in">Set</span> struct &#123;</span><br><span class="line">    m map[inter]bool</span><br><span class="line">    sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func New() *<span class="built_in">Set</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;<span class="built_in">Set</span>&#123;</span><br><span class="line">        m: map[inter]bool&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func (s *<span class="built_in">Set</span>) <span class="function"><span class="title">Add</span>(<span class="params">item inter</span>)</span> &#123;</span><br><span class="line">    s.Lock()</span><br><span class="line">    defer s.Unlock()</span><br><span class="line">    s.m[item] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="switch-fullthrough"><a href="#switch-fullthrough" class="headerlink" title="switch fullthrough"></a>switch fullthrough</h3><p>switch的每个case最后都会break</p>
<p>用fullthrough关键字，可以继续执行下一个case</p>
<h3 id="go的几个命令"><a href="#go的几个命令" class="headerlink" title="go的几个命令"></a>go的几个命令</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">go env: #用于查看go的环境变量</span><br><span class="line">go run: #用于编译并运行go源码文件</span><br><span class="line">go build: #用于编译源码文件、代码包、依赖包</span><br><span class="line">go get: #用于动态获取远程代码包</span><br><span class="line">go install: #用于编译go文件，并将编译结构安装到bin、pkg目录</span><br><span class="line">go clean: #用于清理工作目录，删除编译和安装遗留的目标文件</span><br><span class="line">go version: #用于查看go的版本信息</span><br></pre></td></tr></table></figure>

<h3 id="go的log包线程安全"><a href="#go的log包线程安全" class="headerlink" title="go的log包线程安全"></a>go的log包线程安全</h3><p>Golang的标准库提供了log的机制，但是该模块的功能较为简单（看似简单，其实他有他的设计思路）。在输出的位置做了线程安全的保护。</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO和NIO</title>
    <url>/2023/01/24/Java%20IO%E5%92%8CNIO/</url>
    <content><![CDATA[<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h3><p>最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内<br>核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用<br>户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用<br>户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：data = socket.read();如果数据没有就<br>绪，就会一直阻塞在 read 方法。</p>
<h3 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h3><p>当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个<br>error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备<br>好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。<br>所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO<br>不会交出 CPU，而会一直占用 CPU，这样会导致 CPU 占用率非常高</p>
<h3 id="多路复用IO模型"><a href="#多路复用IO模型" class="headerlink" title="多路复用IO模型"></a>多路复用IO模型</h3><p>在多路复用 IO模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用</p>
<p>多路复用 IO 比非阻塞 IO 模型的效率高，是因为非阻塞 IO 中，不断地询问 socket 状态是通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多。</p>
<p>不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件<br>逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件<br>迟迟得不到处理，并且会影响新的事件轮询</p>
<h3 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h3><p>用户发起IO操作，会给对应的socket注册一个信号函数，当内核的用户数据准备就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作</p>
<h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了</p>
<p>IO的两个阶段都不需要阻塞用户线程，都是由内核完成的， 相比于信号驱动模型，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作</p>
<p>Java7: Asynchronous IO</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>NIO与传统IO的区别，IO 是面向流的，NIO 是面向缓冲区的</p>
<p>IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何<br>地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓<br>存到一个缓冲区</p>
<p>NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据</p>
<h3 id="NIO的非阻塞"><a href="#NIO的非阻塞" class="headerlink" title="NIO的非阻塞"></a>NIO的非阻塞</h3><p>NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel 和 IO 中的 Stream(流)是差不多一个等级的。只不过 Stream 是单向的，譬如：InputStream, OutputStream，而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作<br>NIO 中的 Channel 的主要实现有：</p>
<ol>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ol>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer<br><img src="/2023/01/24/Java%20IO%E5%92%8CNIO/1.jpg" alt="1"><br>上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送<br>数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必<br>须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理</p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事<br>件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可<br>以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用<br>函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护<br>多个线程，并且避免了多线程之间的上下文切换导致的开销</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO模型</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2023/01/09/JVM/</url>
    <content><![CDATA[<h2 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h2><p>JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互</p>
<h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p>Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码</p>
<p>Java 源文件—-&gt;编译器—-&gt;字节码文件</p>
<p>字节码文件—-&gt;JVM—-&gt;机器码</p>
<p>每一个平台的解释器是不同的，但虚拟机是相同的，所以java能够跨平台运行，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享</p>
<h3 id="执行线程"><a href="#执行线程" class="headerlink" title="执行线程"></a>执行线程</h3><p>Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。</p>
<p>Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源</p>
<h3 id="jvm系统线程"><a href="#jvm系统线程" class="headerlink" title="jvm系统线程"></a>jvm系统线程</h3><p><img src="/2023/01/09/JVM/1.jpg" alt="1"></p>
<h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><p><img src="/2023/01/09/JVM/2.jpg" alt="1"></p>
<p><img src="/2023/01/09/JVM/3.jpg" alt="1"></p>
<h3 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h3><p>线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot JVM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)</p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的<br>程序计数器，这类内存也称为“线程私有”的内存，唯一没有outofMemory的区域</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）<br>用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成<br>的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程</p>
<p>栈帧是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接、 方法返回值和异常分派。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束</p>
<h4 id="本地方法区"><a href="#本地方法区" class="headerlink" title="本地方法区"></a>本地方法区</h4><p>本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为<br>Native 方法服务, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个<br>C 栈，但 HotSpot JVM 直接就把本地方法栈和虚拟机栈合二为一</p>
<h3 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h3><p>线程共享区域随虚拟机的启动/关闭而创建/销毁</p>
<h4 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆 heap"></a>堆 heap</h4><p>是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行<br>垃圾收集的最重要的内存区域。由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以<br>细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年代</p>
<h4 id="方法区（永久代）"><a href="#方法区（永久代）" class="headerlink" title="方法区（永久代）"></a>方法区（永久代）</h4><p>用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据.<br> HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小)</p>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版<br>本、字段、方法、接口等描述等信息外，还有一项信息是常量池Constant Pool Table，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用。 在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用<br>DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能</p>
<p>Native方法：在 Java 代码中使用本地语言（如 C、C++）编写的方法。它允许 Java 程序直接调用和使用本地语言编写的函数库和操作系统功能</p>
<h2 id="运行时内存"><a href="#运行时内存" class="headerlink" title="运行时内存"></a>运行时内存</h2><p>Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年代</p>
<p><img src="/2023/01/09/JVM/4.jpg" alt="1"></p>
<h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发<br>MinorGC 进行垃圾回收</p>
<h4 id="Eden区"><a href="#Eden区" class="headerlink" title="Eden区"></a>Eden区</h4><p>Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收</p>
<h4 id="ServivorFrom"><a href="#ServivorFrom" class="headerlink" title="ServivorFrom"></a>ServivorFrom</h4><p>上一次 GC 的幸存者，作为这一次 GC 的被扫描者。</p>
<h4 id="ServivorTo"><a href="#ServivorTo" class="headerlink" title="ServivorTo"></a>ServivorTo</h4><p>保留了一次 MinorGC 过程中的幸存者</p>
<h4 id="MinorGC-的过程（复制-gt-清空-gt-互换）"><a href="#MinorGC-的过程（复制-gt-清空-gt-互换）" class="headerlink" title="MinorGC 的过程（复制-&gt;清空-&gt;互换）"></a>MinorGC 的过程（复制-&gt;清空-&gt;互换）</h4><p>1、把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年<br>龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不<br>够位置了就放到老年区）<br>2、清空 Eden 和 ServicorFrom 中的对象<br>3、ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区</p>
<h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>主要存放应用程序中生命周期长的内存对象，老年代的对象比较稳定，所以 MajorGC 不会频繁执行</p>
<p>在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间</p>
<h4 id="MajorGC的过程-（标记清除算法）"><a href="#MajorGC的过程-（标记清除算法）" class="headerlink" title="MajorGC的过程 （标记清除算法）"></a>MajorGC的过程 （标记清除算法）</h4><p>首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常</p>
<h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域，它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。</p>
<p>java8，永久代被移除，被一个称为“元数据区”（元空间）的区域所取代，元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native<br>memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java List以及扩容分析</title>
    <url>/2023/02/01/Java%20List%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%AE%B9%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="ArrayList（数组）"><a href="#ArrayList（数组）" class="headerlink" title="ArrayList（数组）"></a>ArrayList（数组）</h3><p>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除</p>
<h4 id="三种构造方式"><a href="#三种构造方式" class="headerlink" title="三种构造方式"></a>三种构造方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//默认初始容量大小</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1.创建时指定容量大小</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">	    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">	        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">	                                           initialCapacity);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.无参构造函数，使用初始容量 10 来构造一个空列表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.构造包含指定 collection 元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">	    elementData = c.toArray();</span><br><span class="line">	    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">	        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">	        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">	            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        <span class="comment">// replace with empty array.</span></span><br><span class="line">	        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</p>
<p>无参构造的 ArrayList 对象时，直接创建了长度是 10 的 Object[] 数组 elementData</p>
<h4 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h4><p>在添加元素的时候</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向列表末尾添加元素，添加成功时返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//调用了 ensureCapacityInternal 方法，确保数组下标不越界</span></span><br><span class="line">	ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">	<span class="comment">//添加元素</span></span><br><span class="line">	elementData[size++] = e;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当要向列表中添加第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 变为 10。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    	<span class="comment">//返回默认的容量和传入参数的较大值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    	<span class="comment">//调用 grow 方法进行扩容</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当添加第 1 个元素时，elementData.length 为 0，因为执行了 ensureCapacityInternal() 方法 ，所以 minCapacity 此时为 10。此时，minCapacity - elementData.length &gt; 0成立，所以会进入 grow(minCapacity) 方法；</p>
<p>当添加第 2 个元素时，minCapacity = 2，此时 elementData.length 在添加第一个元素后扩容成 10 了。此时，minCapacity - elementData.length &gt; 0 不成立，所以不会执行 grow(minCapacity) 方法，既不会进行扩容。添加第 3、4、···直到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10；</p>
<p>当添加第 11 个元素时，minCapacity = 11，此时 minCapacity - elementData.length = 11 - 10 &gt; 0 成立，因此便进行扩容操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要分配的最大数组大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容的核心代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity 为旧容量，newCapacity 为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将 oldCapacity 右移一位，即相当于 oldCapacity / 2，整句运算式的结果就是将新容量更新为旧容量的 1.5 倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//检查新容量 newCapacity 是否大于最小需要容量 minCapacity，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//如果 minCapacity 大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">		(1) Arrays.copyOf()方法返回的数组是新的数组对象，原数组对象仍是原数组对象不变;</span></span><br><span class="line"><span class="comment">		(2) 该拷贝不会影响原来的数组, copyOf()的第二个自变量指定要建立的新数组长度，如果新数组的长度超过原数组的长度，则保留数组默认值;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 如果新容量 newCapacity &gt; MAX_ARRAY_SIZE，则执行 hugeCapacity() 方法来比较 minCapacity 和 MAX_ARRAY_SIZE：</span></span><br><span class="line"><span class="comment">// 如果 minCapacity 大于最大容量，则新容量 newCapacity 则为 Integer.MAX_VALUE；</span></span><br><span class="line"><span class="comment">// 否则，新容量 newCapacity 则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8；</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当向 ArrayList 中添加一个新元素时，ArrayList 会先检查当前数组中是否还有剩余的空间可以存储元素；<br>如果有剩余空间，则将元素添加到数组 elementData 的尾部，然后更新数组 elementData 中的元素数量 size 即可。<br>如果没有剩余空间，则底层通过 ArrayList 扩容的核心方法 grow(int minCapacity) 来进行扩容，具体步骤如下：<br>将数组 elementData 的长度设置为旧容量 oldCapacity；<br>然后取 oldCapacity 的大约 1.5 倍作为新容量 newCapacity，具体的计算方法是 newCapacity = oldCapacity + (oldCapacity &lt;&lt; 1)，这里通过使用移位运算符来加快计算速度；<br>通过 Arrays.copyOf() 方法来创建一个长度为 newCapacity 的数组，并且将旧数组中的元素复制到新数组中，复制完成后，ArrayList 就会开始使用新数组来存储元素，并更新数组的大小和元素数量</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。</p>
<h4 id="三种构造方式-1"><a href="#三种构造方式-1" class="headerlink" title="三种构造方式"></a>三种构造方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Vector() &#123;</span><br><span class="line">  &#x2F;&#x2F; 当前是无参构造方法 Vector vector &#x3D; new Vector();</span><br><span class="line">  &#x2F;&#x2F; 其实你不给参数，它默认就是10，它会去调用一个有参方法</span><br><span class="line">     this(10);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> public Vector(int initialCapacity) &#123;</span><br><span class="line"> 	&#x2F;&#x2F; 这句话好比如 Vector vector &#x3D; new Vector(5);</span><br><span class="line"> 	&#x2F;&#x2F; 意思代表着如果你没有参数我默认就是10，如何调用有参方法</span><br><span class="line"> 	&#x2F;&#x2F; 如果构造方法有值的话，则直接走当前方法</span><br><span class="line">     this(initialCapacity, 0);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> public Vector(int initialCapacity, int capacityIncrement) &#123;</span><br><span class="line">     super();</span><br><span class="line">     &#x2F;&#x2F; 判断当前的值是否为负数，则会抛出异常</span><br><span class="line">     if (initialCapacity &lt; 0)</span><br><span class="line">         throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#x2F;**</span><br><span class="line">     * 第一个值代表当前数组初始化的大小</span><br><span class="line">     * 第二个值代表待会儿我们可以在扩容的那个地方说，它起到了关键</span><br><span class="line">     * 性作用</span><br><span class="line">     *&#x2F;</span><br><span class="line">     this.elementData &#x3D; new Object[initialCapacity];</span><br><span class="line">     &#x2F;&#x2F; 如果我们在刚刚开始构建Vector的时候你没有传入参数</span><br><span class="line">     &#x2F;&#x2F; 或者说你只传了一个参数，在调用当前方法的时候，它是</span><br><span class="line">     &#x2F;&#x2F; 默认传入0的</span><br><span class="line">     this.capacityIncrement &#x3D; capacityIncrement;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="扩容过程-1"><a href="#扩容过程-1" class="headerlink" title="扩容过程"></a>扩容过程</h4><p>在添加元素的时候</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以看见该方法synchronized修饰，则是线程安全的</span><br><span class="line">    public synchronized boolean add(E e) &#123;</span><br><span class="line">        modCount++;&#x2F;&#x2F; 修改次数 加加</span><br><span class="line">        &#x2F;&#x2F; protected int elementCount; 则记录当前，每次加1</span><br><span class="line">        ensureCapacityHelper(elementCount + 1);</span><br><span class="line">        elementData[elementCount++] &#x3D; e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    private void ensureCapacityHelper(int minCapacity) &#123;</span><br><span class="line">        &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">        &#x2F;&#x2F; 如果在无参构造方法在第一次进行添加的时候，</span><br><span class="line">        &#x2F;&#x2F; 此时的minCapacity 等于1 而elementDta.length等于10</span><br><span class="line">        &#x2F;&#x2F; 1-10 &#x3D; -9; -9不大于0 所以说不满足条件</span><br><span class="line">        if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>经过多次添加的时候，满足条件，会触发扩容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">    &#x2F;&#x2F; 此时我们的elementData.length是等于10 </span><br><span class="line">    int oldCapacity &#x3D; elementData.length;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 这边 运用了一个三元运算符就行判断</span><br><span class="line">    * capacityIncrement  就是前面说的起到关键性作用的变量</span><br><span class="line">    * 假设，我们在创建Vector的时候是一个无参的构造器，或者说只有一个</span><br><span class="line">    * 参数，那么此时的capacityIncrement 等于0，前面提到过 默认传给</span><br><span class="line">    * 它的就是0，0不大于0所以结果为 oldCapacity + oldCapacity </span><br><span class="line">    * 也就是10加上10 等于20，以2倍的速度进行增加</span><br><span class="line">    * 如果你是Vector vector &#x3D; new Vector(5,5);这样创建</span><br><span class="line">    * 结果明显而知，5肯定大于0的</span><br><span class="line">    *&#x2F;</span><br><span class="line">    int newCapacity &#x3D; oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    </span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity &#x3D; minCapacity;</span><br><span class="line">    &#x2F;&#x2F; private static final int MAX_ARRAY_SIZE &#x3D; Integer.MAX_VALUE - 8 &#x3D; 2147483639</span><br><span class="line">    &#x2F;&#x2F; 判断当前是否超出了一个最大值</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">    &#x2F;&#x2F; 调用了Arrays.copyOf方法，</span><br><span class="line">    &#x2F;&#x2F; 为什么调用Arrays.copyOf，为了就是保留原有的数据</span><br><span class="line">    &#x2F;&#x2F; 把新的newCapacity赋值给它后再copy给原来的elementData</span><br><span class="line">    &#x2F;&#x2F; 则当前扩容完成</span><br><span class="line">    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p>
<p>可以参考算法 <a href="https://zypuu.github.io/2021/02/01/%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8%E5%92%8C%E8%B7%B3%E8%A1%A8/">数组、链表和跳表</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Map源码分析</title>
    <url>/2023/03/22/Java%20Map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成，</p>
<p>根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)</p>
<p>源码分析详情见： <a href="https://zypuu.github.io/2023/02/06/Java%20Set%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Java Set源码分析</a> 的HashSet部分</p>
<p>HashMap并非线程安全：线程不安全主要体现在resize的死循环，和使用迭代器时的Fast-Fail机制上</p>
<p>Fast-Fail事件机制</p>
<p>fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。在使用迭代器的过程中如果HashMap被修改，那么ConcurrentModificationException将被抛出，也即Fast-fail策略。</p>
<p>当HashMap的iterator()方法被调用时，会构造并返回一个新的EntryIterator对象，并将EntryIterator的expectedModCount设置为HashMap的modCount（该变量记录了HashMap被修改的次数）。</p>
<p>在通过该Iterator的next方法访问下一个Entry时，它会先检查自己的expectedModCount与HashMap的modCount是否相等，如果不相等，说明HashMap被修改，直接抛出<code>ConcurrentModificationException</code>。该Iterator的remove方法也会做类似的检查</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>为了解决HashMap的并发安全问题，可以使用concurrentHashMap</p>
<h3 id="Java7实现"><a href="#Java7实现" class="headerlink" title="Java7实现"></a>Java7实现</h3><p>基于散列的Map，并不是将每个方法都在同一个锁上同步使得每次只能有一个线程访问线程，而使用一种更细粒度的加锁机制来实现更大程度的共享。这种机制称为分段锁（Lock Striping）。在这种机制中，任意数量的读取线程可以并发地访问map<strong>，</strong>执行读取操作的线程和执行写入操作的线程可以并发地访问map，并且一定数量的写入线程可以并发地修改map。ConcurrentHashMap带来的结果是，在并发访问的环境下将实现更高的吞吐量，而在单线程环境中只损失非常小的性能。</p>
<p>ConcurrentHashMap返回的迭代器具有<strong>弱一致性</strong>。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以（但是不保证）在迭代器被构造后将修改操作反应给容器</p>
<p>ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p>
<p>concurrencyLevel：并行级别（Segment 的数量），默认是 16。</p>
<p>也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。</p>
<p>这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的</p>
<p><img src="/2023/03/22/Java%20Map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.jpg" alt="1"></p>
<h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public V put(K key, V value) &#123;</span><br><span class="line">      Segment&lt;K,V&gt; s;</span><br><span class="line">      if (value &#x3D;&#x3D; null)</span><br><span class="line">          throw new NullPointerException();</span><br><span class="line">      &#x2F;&#x2F; 1. 计算 key 的 hash 值</span><br><span class="line">      int hash &#x3D; hash(key);</span><br><span class="line">      &#x2F;&#x2F; 2. 根据 hash 值找到 Segment 数组中的位置 j</span><br><span class="line">      &#x2F;&#x2F;    hash 是 32 位，无符号右移 segmentShift(28) 位</span><br><span class="line">      &#x2F;&#x2F;    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的最后 4 位，也就是槽的数组下标</span><br><span class="line">     int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">     &#x2F;&#x2F; 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，</span><br><span class="line">     &#x2F;&#x2F; ensureSegment(j) 对 segment[j] 进行初始化</span><br><span class="line">     if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObject          &#x2F;&#x2F; nonvolatile; recheck</span><br><span class="line">          (segments, (j &lt;&lt; SSHIFT) + SBASE)) &#x3D;&#x3D; null) &#x2F;&#x2F;  in ensureSegment</span><br><span class="line">         s &#x3D; ensureSegment(j);</span><br><span class="line">     &#x2F;&#x2F; 3. 插入新值到 槽 s 中</span><br><span class="line">     return s.put(key, hash, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用下面的put方法，put会将新的值放入链表头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line"> 2     &#x2F;&#x2F; 在往该 segment 写入前，需要先获取该 segment 的独占锁</span><br><span class="line"> 3     &#x2F;&#x2F;    先看主流程，后面还会具体介绍这部分内容</span><br><span class="line"> 4     HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null :</span><br><span class="line"> 5         scanAndLockForPut(key, hash, value);</span><br><span class="line"> 6     V oldValue;</span><br><span class="line"> 7     try &#123;</span><br><span class="line"> 8         &#x2F;&#x2F; 这个是 segment 内部的数组</span><br><span class="line"> 9         HashEntry&lt;K,V&gt;[] tab &#x3D; table;</span><br><span class="line">10         &#x2F;&#x2F; 再利用 hash 值，求应该放置的数组下标</span><br><span class="line">11         int index &#x3D; (tab.length - 1) &amp; hash;</span><br><span class="line">12         &#x2F;&#x2F; first 是数组该位置处的链表的表头</span><br><span class="line">13         HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);</span><br><span class="line">14  </span><br><span class="line">15         &#x2F;&#x2F; 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况</span><br><span class="line">16         for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;</span><br><span class="line">17             if (e !&#x3D; null) &#123;</span><br><span class="line">18                 K k;</span><br><span class="line">19                 if ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">20                     (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">21                     oldValue &#x3D; e.value;</span><br><span class="line">22                     if (!onlyIfAbsent) &#123;</span><br><span class="line">23                         &#x2F;&#x2F; 覆盖旧值</span><br><span class="line">24                         e.value &#x3D; value;</span><br><span class="line">25                         ++modCount;</span><br><span class="line">26                     &#125;</span><br><span class="line">27                     break;</span><br><span class="line">28                 &#125;</span><br><span class="line">29                 &#x2F;&#x2F; 继续顺着链表走</span><br><span class="line">30                 e &#x3D; e.next;</span><br><span class="line">31             &#125;</span><br><span class="line">32             else &#123;</span><br><span class="line">33                 &#x2F;&#x2F; node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。</span><br><span class="line">34                 &#x2F;&#x2F; 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。</span><br><span class="line">35                 if (node !&#x3D; null)</span><br><span class="line">36                     node.setNext(first);</span><br><span class="line">37                 else</span><br><span class="line">38                     node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">39  </span><br><span class="line">40                 int c &#x3D; count + 1;</span><br><span class="line">41                 &#x2F;&#x2F; 如果超过了该 segment 的阈值，这个 segment 需要扩容</span><br><span class="line">42                 if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">43                     rehash(node); &#x2F;&#x2F; 扩容后面也会具体分析</span><br><span class="line">44                 else</span><br><span class="line">45                     &#x2F;&#x2F; 没有达到阈值，将 node 放到数组 tab 的 index 位置，</span><br><span class="line">46                     &#x2F;&#x2F; 其实就是将新的节点设置成原链表的表头</span><br><span class="line">47                     setEntryAt(tab, index, node);</span><br><span class="line">48                 ++modCount;</span><br><span class="line">49                 count &#x3D; c;</span><br><span class="line">50                 oldValue &#x3D; null;</span><br><span class="line">51                 break;</span><br><span class="line">52             &#125;</span><br><span class="line">53         &#125;</span><br><span class="line">54     &#125; finally &#123;</span><br><span class="line">55         &#x2F;&#x2F; 解锁</span><br><span class="line">56         unlock();</span><br><span class="line">57     &#125;</span><br><span class="line">58     return oldValue;</span><br><span class="line">59 &#125;</span><br></pre></td></tr></table></figure>

<p>然后看一下其中的两个方法ensureSegment，scanAndLockForPut</p>
<h4 id="初始化ensureSegment"><a href="#初始化ensureSegment" class="headerlink" title="初始化ensureSegment"></a>初始化ensureSegment</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</span><br><span class="line"> 2     final Segment&lt;K,V&gt;[] ss &#x3D; this.segments;</span><br><span class="line"> 3     long u &#x3D; (k &lt;&lt; SSHIFT) + SBASE; &#x2F;&#x2F; raw offset</span><br><span class="line"> 4     Segment&lt;K,V&gt; seg;</span><br><span class="line"> 5     if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) &#x3D;&#x3D; null) &#123;</span><br><span class="line"> 6         &#x2F;&#x2F; 这里看到为什么之前要初始化 segment[0] 了，</span><br><span class="line"> 7         &#x2F;&#x2F; 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]</span><br><span class="line"> 8         &#x2F;&#x2F; 为什么要用“当前”，因为 segment[0] 可能早就扩容过了</span><br><span class="line"> 9         Segment&lt;K,V&gt; proto &#x3D; ss[0];</span><br><span class="line">10         int cap &#x3D; proto.table.length;</span><br><span class="line">11         float lf &#x3D; proto.loadFactor;</span><br><span class="line">12         int threshold &#x3D; (int)(cap * lf);</span><br><span class="line">13  </span><br><span class="line">14         &#x2F;&#x2F; 初始化 segment[k] 内部的数组</span><br><span class="line">15         HashEntry&lt;K,V&gt;[] tab &#x3D; (HashEntry&lt;K,V&gt;[])new HashEntry[cap];</span><br><span class="line">16         if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">17             &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 再次检查一遍该槽是否被其他线程初始化了。</span><br><span class="line">18  </span><br><span class="line">19             Segment&lt;K,V&gt; s &#x3D; new Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">20             &#x2F;&#x2F; 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出</span><br><span class="line">21             while ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">22                    &#x3D;&#x3D; null) &#123;</span><br><span class="line">23                 if (UNSAFE.compareAndSwapObject(ss, u, null, seg &#x3D; s))</span><br><span class="line">24                     break;</span><br><span class="line">25             &#125;</span><br><span class="line">26         &#125;</span><br><span class="line">27     &#125;</span><br><span class="line">28     return seg;</span><br><span class="line">29 &#125;</span><br></pre></td></tr></table></figure>



<h4 id="获取写入锁scanAndLockForPut"><a href="#获取写入锁scanAndLockForPut" class="headerlink" title="获取写入锁scanAndLockForPut"></a>获取写入锁scanAndLockForPut</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1     </span><br><span class="line"> 2 private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;</span><br><span class="line"> 3     HashEntry&lt;K,V&gt; first &#x3D; entryForHash(this, hash);</span><br><span class="line"> 4     HashEntry&lt;K,V&gt; e &#x3D; first;</span><br><span class="line"> 5     HashEntry&lt;K,V&gt; node &#x3D; null;</span><br><span class="line"> 6     int retries &#x3D; -1; &#x2F;&#x2F; negative while locating node</span><br><span class="line"> 7  </span><br><span class="line"> 8     &#x2F;&#x2F; 循环获取锁 失败则循环  成功则跳出循环</span><br><span class="line"> 9     while (!tryLock()) &#123;</span><br><span class="line">10         HashEntry&lt;K,V&gt; f; &#x2F;&#x2F; to recheck first below</span><br><span class="line">11         if (retries &lt; 0) &#123;</span><br><span class="line">12             if (e &#x3D;&#x3D; null) &#123;</span><br><span class="line">13                 if (node &#x3D;&#x3D; null) &#x2F;&#x2F; speculatively create node</span><br><span class="line">14                     &#x2F;&#x2F; 进到这里说明数组该位置的链表是空的，没有任何元素</span><br><span class="line">15                     &#x2F;&#x2F; 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置</span><br><span class="line">16                     node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">17                 retries &#x3D; 0;</span><br><span class="line">18             &#125;</span><br><span class="line">19             else if (key.equals(e.key))</span><br><span class="line">20                 retries &#x3D; 0;</span><br><span class="line">21             else</span><br><span class="line">22                 &#x2F;&#x2F; 顺着链表往下走</span><br><span class="line">23                 e &#x3D; e.next;</span><br><span class="line">24         &#125;</span><br><span class="line">25         &#x2F;&#x2F; 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁</span><br><span class="line">26         &#x2F;&#x2F;    lock() 是阻塞方法，直到获取锁后返回</span><br><span class="line">27         else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">28             lock();</span><br><span class="line">29             break;</span><br><span class="line">30         &#125;</span><br><span class="line">31         else if ((retries &amp; 1) &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">32                  &#x2F;&#x2F; 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头</span><br><span class="line">33                  &#x2F;&#x2F;     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法</span><br><span class="line">34                  (f &#x3D; entryForHash(this, hash)) !&#x3D; first) &#123;</span><br><span class="line">35             e &#x3D; first &#x3D; f; &#x2F;&#x2F; re-traverse if entry changed</span><br><span class="line">36             retries &#x3D; -1;</span><br><span class="line">37         &#125;</span><br><span class="line">38     &#125;</span><br><span class="line">39     return node;</span><br><span class="line">40 &#125;</span><br></pre></td></tr></table></figure>

<p>获取锁时，并不直接使用lock来获取，因为该方法获取锁失败时会挂起。</p>
<p>如果tryLock获取锁失败，说明锁被其它线程占用，此时通过循环再次以tryLock的方式申请锁。</p>
<p>如果在循环过程中该Key所对应的链表头被修改，则重置retry次数。如果retry次数超过一定值，则使用lock方法申请锁。</p>
<h4 id="扩容rehash"><a href="#扩容rehash" class="headerlink" title="扩容rehash"></a>扩容rehash</h4><p>put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值。扩容后，容量为原来的 2 倍。</p>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>get 过程中是没有加锁的,除非读到的值是空的才会加锁重读.ConcurrentHashMap使用如下方法保证可见性，取得最新的Segment：Segment&lt;K,V&gt; s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)get方法里将要使用的共享变量都定义成volatile,能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值之所以不会读到过期的值，是根据java内存模型的happen before原则，对volatile字段的写入操作先于读操作</p>
<h4 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h4><p>ConcurrentHashMap会在不上锁的前提逐个Segment计算3次size，如果某相邻两次计算，所有Segment的更新次数之和相等，说明这两次计算过程中无更新操作，则这两次计算出的总size相等，可直接作为最终结果返回。如果这三次计算过程中Map有更新，则对所有Segment加锁重新计算Size。</p>
<h3 id="Java8实现"><a href="#Java8实现" class="headerlink" title="Java8实现"></a>Java8实现</h3><p>Java 8为进一步提高并发性，摒弃了分段锁的方案，而是直接使用一个大的数组，基于CAS的ConcurrentHashMap</p>
<h4 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a>put方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 public V put(K key, V value) &#123;</span><br><span class="line"> 2     return putVal(key, value, false);</span><br><span class="line"> 3 &#125;</span><br><span class="line"> 4 final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line"> 5     if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line"> 6     &#x2F;&#x2F; 得到 hash 值</span><br><span class="line"> 7     int hash &#x3D; spread(key.hashCode());</span><br><span class="line"> 8     &#x2F;&#x2F; 用于记录相应链表的长度</span><br><span class="line"> 9     int binCount &#x3D; 0;</span><br><span class="line">10     for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class="line">11         Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">12         &#x2F;&#x2F; 如果数组&quot;空&quot;，进行数组初始化</span><br><span class="line">13         if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">14             &#x2F;&#x2F; 初始化数组，后面会详细介绍</span><br><span class="line">15             tab &#x3D; initTable();</span><br><span class="line">16  </span><br><span class="line">17         &#x2F;&#x2F; 找该 hash 值对应的数组下标，得到第一个节点 f</span><br><span class="line">18         else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">19             &#x2F;&#x2F; 如果数组该位置为空，</span><br><span class="line">20             &#x2F;&#x2F;    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span><br><span class="line">21             &#x2F;&#x2F;          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span><br><span class="line">22             if (casTabAt(tab, i, null,</span><br><span class="line">23                          new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">24                 break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">25         &#125;</span><br><span class="line">26         &#x2F;&#x2F; hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容</span><br><span class="line">27         else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)</span><br><span class="line">28             &#x2F;&#x2F; 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了</span><br><span class="line">29             tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">30  </span><br><span class="line">31         else &#123; &#x2F;&#x2F; 到这里就是说，f 是该位置的头结点，而且不为空</span><br><span class="line">32  </span><br><span class="line">33             V oldVal &#x3D; null;</span><br><span class="line">34             &#x2F;&#x2F; 获取数组该位置的头结点的监视器锁</span><br><span class="line">35             synchronized (f) &#123;</span><br><span class="line">36                 if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class="line">37                     if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 头结点的 hash 值大于 0，说明是链表</span><br><span class="line">38                         &#x2F;&#x2F; 用于累加，记录链表的长度</span><br><span class="line">39                         binCount &#x3D; 1;</span><br><span class="line">40                         &#x2F;&#x2F; 遍历链表</span><br><span class="line">41                         for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class="line">42                             K ek;</span><br><span class="line">43                             &#x2F;&#x2F; 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了</span><br><span class="line">44                             if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">45                                 ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">46                                  (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">47                                 oldVal &#x3D; e.val;</span><br><span class="line">48                                 if (!onlyIfAbsent)</span><br><span class="line">49                                     e.val &#x3D; value;</span><br><span class="line">50                                 break;</span><br><span class="line">51                             &#125;</span><br><span class="line">52                             &#x2F;&#x2F; 到了链表的最末端，将这个新值放到链表的最后面</span><br><span class="line">53                             Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">54                             if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">55                                 pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">56                                                           value, null);</span><br><span class="line">57                                 break;</span><br><span class="line">58                             &#125;</span><br><span class="line">59                         &#125;</span><br><span class="line">60                     &#125;</span><br><span class="line">61                     else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 红黑树</span><br><span class="line">62                         Node&lt;K,V&gt; p;</span><br><span class="line">63                         binCount &#x3D; 2;</span><br><span class="line">64                         &#x2F;&#x2F; 调用红黑树的插值方法插入新节点</span><br><span class="line">65                         if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">66                                                        value)) !&#x3D; null) &#123;</span><br><span class="line">67                             oldVal &#x3D; p.val;</span><br><span class="line">68                             if (!onlyIfAbsent)</span><br><span class="line">69                                 p.val &#x3D; value;</span><br><span class="line">70                         &#125;</span><br><span class="line">71                     &#125;</span><br><span class="line">72                 &#125;</span><br><span class="line">73             &#125;</span><br><span class="line">74             &#x2F;&#x2F; binCount !&#x3D; 0 说明上面在做链表操作</span><br><span class="line">75             if (binCount !&#x3D; 0) &#123;</span><br><span class="line">76                 &#x2F;&#x2F; 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span><br><span class="line">77                 if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)</span><br><span class="line">78                     &#x2F;&#x2F; 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span><br><span class="line">79                     &#x2F;&#x2F; 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span><br><span class="line">80                     &#x2F;&#x2F;    具体源码我们就不看了，扩容部分后面说</span><br><span class="line">81                     treeifyBin(tab, i);</span><br><span class="line">82                 if (oldVal !&#x3D; null)</span><br><span class="line">83                     return oldVal;</span><br><span class="line">84                 break;</span><br><span class="line">85             &#125;</span><br><span class="line">86         &#125;</span><br><span class="line">87     &#125;</span><br><span class="line">88     &#x2F;&#x2F; </span><br><span class="line">89     addCount(1L, binCount);</span><br><span class="line">90     return null;</span><br><span class="line">91 &#125;</span><br></pre></td></tr></table></figure>

<p>对于put操作，如果Key对应的数组元素为null，则通过CAS操作将其设置为当前值。</p>
<p>如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用synchronized关键字申请锁，然后进行操作。</p>
<p>如果该put操作使得当前链表长度超过一定阈值，则将该链表转换为树，从而提高寻址效率。</p>
<h4 id="get方法-1"><a href="#get方法-1" class="headerlink" title="get方法"></a>get方法</h4><p>对于读操作，由于数组被volatile关键字修饰，因此不用担心数组的可见性问题。</p>
<p>同时每个元素是一个Node实例（Java 7中每个元素是一个HashEntry），它的Key值和hash值都由final修饰，不可变更，无须关心它们被修改后的可见性问题。而其Value及对下一个元素的引用由volatile修饰，可见性也有保障。</p>
<h4 id="size方法-1"><a href="#size方法-1" class="headerlink" title="size方法"></a>size方法</h4><p>put方法和remove方法都会通过addCount方法维护Map的size。size方法通过sumCount获取由addCount方法维护的Map的size。</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。</p>
<p>如果使用排序的映射，建议使用 TreeMap。</p>
<p>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常</p>
<h2 id="LinkHashMap"><a href="#LinkHashMap" class="headerlink" title="LinkHashMap"></a>LinkHashMap</h2><p>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历</p>
<p>LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序</p>
<p>linkedhashmap继承了hashmap的所有方法和属性，在hashmap数据结构，数组+单项链表+红黑树的原理上加上了双向链表，通过双向链表保证输出的时候按照插入顺序或者自己指定的顺序进行输出</p>
<h3 id="成员变量参数"><a href="#成员变量参数" class="headerlink" title="成员变量参数"></a>成员变量参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 序列化唯一表示 UID</span><br><span class="line">    private static final long serialVersionUID &#x3D; 3801124242820219131L;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 双向链表的头节点</span><br><span class="line">    transient LinkedHashMapEntry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 双向链表的尾节点</span><br><span class="line">    transient LinkedHashMapEntry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 默认是 false，则迭代时输出的顺序是插入节点的顺序。</span><br><span class="line">    &#x2F;&#x2F; 若为 true，则输出的顺序是按照访问节点的顺序（最近最少使用原则）。</span><br><span class="line">    &#x2F;&#x2F; accessOrder 为 true 时，可以在这基础之上构建一个 LruCache。</span><br><span class="line">    final boolean accessOrder;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 无参构造函数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public LinkedHashMap() &#123;</span><br><span class="line">        super();</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 有参构造函数</span><br><span class="line">     *</span><br><span class="line">     * @param initialCapacity 初始化时的容量</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public LinkedHashMap(int initialCapacity) &#123;</span><br><span class="line">        super(initialCapacity);</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 有参构造函数</span><br><span class="line">     *</span><br><span class="line">     * @param initialCapacity 初始化时的容量</span><br><span class="line">     * @param loadFactor      扩容的加载因子</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public LinkedHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor);</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 有参构造函数</span><br><span class="line">     *</span><br><span class="line">     * @param initialCapacity 初始化时的容量</span><br><span class="line">     * @param loadFactor      扩容的加载因子</span><br><span class="line">     * @param accessOrder     迭代输出节点的顺序</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor);</span><br><span class="line">        this.accessOrder &#x3D; accessOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 有参构造函数</span><br><span class="line">     *</span><br><span class="line">     * @param m 利用另一个Map 来构建</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        super();</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F; 批量插入一个 map 中的所有数据到本集合中。</span><br><span class="line">        putMapEntries(m, false);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="put方法-2"><a href="#put方法-2" class="headerlink" title="put方法"></a>put方法</h3><p>当前方法重写了hashmap中的Node方法，当创建的时候会调用当前方法中的类进行创建，根据添加顺序为双向链表添加位置。在hashmap的put()调用中会生成前后项指针。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">       LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">           new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">       linkNodeLast(p);</span><br><span class="line">       return p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">       TreeNode&lt;K,V&gt; p &#x3D; new TreeNode&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">       linkNodeLast(p);</span><br><span class="line">       return p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">       LinkedHashMap.Entry&lt;K,V&gt; last &#x3D; tail;</span><br><span class="line">       tail &#x3D; p;</span><br><span class="line">       if (last &#x3D;&#x3D; null)</span><br><span class="line">           head &#x3D; p;</span><br><span class="line">       else &#123;</span><br><span class="line">           p.before &#x3D; last;</span><br><span class="line">           last.after &#x3D; p;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">       Entry&lt;K,V&gt; before, after;</span><br><span class="line">       Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           super(hash, key, value, next);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>然后调用putVal方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;</span><br><span class="line">            ...</span><br><span class="line">            if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">                V oldValue &#x3D; e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                    e.value &#x3D; value;</span><br><span class="line">                afterNodeAccess(e); &#x2F;&#x2F;</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>linkedhashmap直接使用了hashmap的put()方法，因为继承了hashmap并且重写了afterNodeInsertion()方法,在accessOrder为true的时候调用，会破坏原先的顺序存储，会把最近访问的放到链表的最后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 此方法的作用是将刚刚访问的节点e放到链表的尾端</span><br><span class="line"> *&#x2F;</span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    &#x2F;&#x2F; accessOrder &#x3D; true 时 访问节点后才需要置于尾端</span><br><span class="line">    &#x2F;&#x2F; 如果e本身就在尾端，那就不需要操作</span><br><span class="line">    if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;</span><br><span class="line">        &#x2F;&#x2F; 记录节点e、e的前驱、e的后继</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p &#x3D; (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">        &#x2F;&#x2F;   b&lt;-&gt;p  &lt;--&gt; a</span><br><span class="line">        &#x2F;&#x2F; 第一步：现将p.after置空</span><br><span class="line">        &#x2F;&#x2F;断开p的后节点</span><br><span class="line">        p.after &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 第二步：将e的前驱.after 连接上e的后继</span><br><span class="line">        if (b &#x3D;&#x3D; null)</span><br><span class="line">          &#x2F;&#x2F;如果没有头节点      b&lt;---&gt; p  </span><br><span class="line">          直接把head指向a</span><br><span class="line">            head &#x3D; a;</span><br><span class="line">        else</span><br><span class="line">          &#x2F;&#x2F;如果有前驱的话，把b&lt;  ---&gt; a</span><br><span class="line">            b.after &#x3D; a;</span><br><span class="line">        if (a !&#x3D; null)</span><br><span class="line">              &#x2F;&#x2F; 如果a不等于空的话，把a指向b</span><br><span class="line">            a.before &#x3D; b;</span><br><span class="line">        else</span><br><span class="line">            &#x2F;&#x2F;如果a等于空的话，把last指向b.</span><br><span class="line">            last &#x3D; b;</span><br><span class="line">        if (last &#x3D;&#x3D; null)</span><br><span class="line">          &#x2F;&#x2F;如果last 空把p插入到head节点。</span><br><span class="line">            head &#x3D; p;</span><br><span class="line">        else &#123;</span><br><span class="line">          &#x2F;&#x2F;把p插入到最后节点。</span><br><span class="line">            p.before &#x3D; last;</span><br><span class="line">            last.after &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">      &#x2F;&#x2F;更新节点为尾节点。</span><br><span class="line">        tail &#x3D; p;</span><br><span class="line">        &#x2F;&#x2F; 链表结构性调整，修改次数自增</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get方法-2"><a href="#get方法-2" class="headerlink" title="get方法"></a>get方法</h3><p>与hashmap的区别在于，当accessOrder为true的话，会把当前访问的节点插入到双向链表的最后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder)</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; unlink</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after; &#x2F;&#x2F; b是当前节点的前一个节点，a是后一个节点</span><br><span class="line">        p.before &#x3D; p.after &#x3D; null; &#x2F;&#x2F;先断开当前节点，把当前节点对上一个和下一个节点的引用置为空</span><br><span class="line">        if (b &#x3D;&#x3D; null) &#x2F;&#x2F;当前节点的前一个节点是null，说明当前节点是头节点，那去掉当前节点之后，当前节点的后一个节点成为了链第一个，</span><br><span class="line">            &#x2F;&#x2F; 也就是头节点，当然有可能a也是null，那整个链就是空链，这种写法兼容了a也是null的情况</span><br><span class="line">            head &#x3D; a;</span><br><span class="line">        else </span><br><span class="line">            b.after &#x3D; a; &#x2F;&#x2F;如果当前节点不是头节点，直接去掉当前节点，当前节点的前一个和后一个连起来</span><br><span class="line">        if (a &#x3D;&#x3D; null) &#x2F;&#x2F;如果当前节点的后一个节点是null，说明当前节点是尾节点，那把当前节点去掉后，当前节点的前一个节点成为了链的最后一个节点尾节点。</span><br><span class="line">            tail &#x3D; b;</span><br><span class="line">        else</span><br><span class="line">            a.before &#x3D; b;&#x2F;&#x2F;如果当前节点不是尾节点，直接去掉当前节点，当前节点的前一个和后一个连起来</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Set源码分析</title>
    <url>/2023/02/06/Java%20Set%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法。</p>
<h3 id="HashSet-Hash表"><a href="#HashSet-Hash表" class="headerlink" title="HashSet (Hash表)"></a>HashSet (Hash表)</h3><p>1、HashSet ：无序、不重复、无索引<br>2、HashSet 底层是采用HashMap存储数据的，在JDK8之前是由数组+链表组成的，在JDK8之后是由数组+链表+红黑树组成的，数组的每个索引位置默认存放的是单向链表，如果链表的长度到达了一个临界值就会转为红黑树<br>3、在哈希表中，最重要的是哈希值，哈希值就是对象的整数表现形式，HashSet 在存数据的时候，会根据数组长度和哈希值计算出要存入的位置，哈希值是根据hashCode()方法计算出来的int型的整数，hashCode()方法定义在Object类中，所有对象都可以调用，默认使用地址值进行计算，一般情况下，自定义的对象都要重写hashCode()方法，利用对象内部的属性值计算哈希值。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public HashSet() &#123;</span><br><span class="line">    map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义</span><br><span class="line">private transient HashMap&lt;E,Object&gt; map;</span><br></pre></td></tr></table></figure>

<p>可以看到底层就是HashMap</p>
<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>PRESENT 主要起到占位作用，是一个空对象，用来代替 HashMap 中的 value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">private static final Object PRESENT &#x3D; new Object();</span><br></pre></td></tr></table></figure>

<h5 id="调用HashMap底层"><a href="#调用HashMap底层" class="headerlink" title="调用HashMap底层"></a>调用HashMap底层</h5><p>然后实际调用到了HashMap的底层</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 先调用一个hash方法，这是一个hash算法，并不是计算hash值</span><br><span class="line">&#x2F;&#x2F; 如果 key 的 hash 值 &lt; 216 - 1，那么得到就是 key 的 hash 值，否则就不是</span><br><span class="line">&#x2F;&#x2F; 用来后面寻找索引位置</span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义辅助变量</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    &#x2F;&#x2F; table 其实就是数组，定义：</span><br><span class="line">    &#x2F;&#x2F; transient Node&lt;K,V&gt;[] table;</span><br><span class="line">    &#x2F;&#x2F; 判断数组是否为空，如果为空调用 resize() 方法进行第一次扩容</span><br><span class="line">    &#x2F;&#x2F; 并将扩容后的数组大小返回给 n</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第一次初始化扩容"><a href="#第一次初始化扩容" class="headerlink" title="第一次初始化扩容"></a>第一次初始化扩容</h5><p>初始化 HashSet(或者是 HashMap)后，数组是空值(null)，需要进行数组的扩容,后面会详解扩容机制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义辅助变量</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">    &#x2F;&#x2F; 旧数组长度 0</span><br><span class="line">    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">    &#x2F;&#x2F; 旧临界值</span><br><span class="line">    int oldThr &#x3D; threshold;</span><br><span class="line">    &#x2F;&#x2F; 新的数组长度和临界值</span><br><span class="line">    int newCap, newThr &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 不满足条件</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">    &#125;</span><br><span class="line">	  &#x2F;&#x2F; 不满足条件</span><br><span class="line">    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line">    &#x2F;&#x2F; 第一次扩容</span><br><span class="line">    else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">        &#x2F;&#x2F; 新的数组长度默认为 16</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        &#x2F;&#x2F; 新的临界值默认为 12</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 不满足条件</span><br><span class="line">    if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 改变为新的临界值</span><br><span class="line">    threshold &#x3D; newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">	  &#x2F;&#x2F; 定义新的数组</span><br><span class="line">    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    &#x2F;&#x2F; 改变数组</span><br><span class="line">    table &#x3D; newTab;</span><br><span class="line">    &#x2F;&#x2F; 旧数组为空，不满足条件</span><br><span class="line">    if (oldTab !&#x3D; null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回新的数组</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="索引位置计算"><a href="#索引位置计算" class="headerlink" title="索引位置计算"></a>索引位置计算</h5><p>第一次扩容后，继续putVal，会计算索引位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">    &#x2F;&#x2F; 从这里开始</span><br><span class="line">    &#x2F;&#x2F; 计算应该存放的数组索引</span><br><span class="line">    &#x2F;&#x2F; 判断该索引位置是否为空，</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">        &#x2F;&#x2F; 如果为空，直接将结点加到该索引位置</span><br><span class="line">        tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">    &#x2F;&#x2F; 如果不为空，则该位置有可能是链表或红黑树，目前不会执行这一步</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; 此处省略一大堆代码</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount; &#x2F;&#x2F; 修改次数 +1</span><br><span class="line">    &#x2F;&#x2F; 判断添加后的节点数是否大于临界值</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        &#x2F;&#x2F; 如果大于，再次扩容</span><br><span class="line">        resize();</span><br><span class="line">    &#x2F;&#x2F; 一个空方法，供继承 HashMap 的类去实现</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(n - 1) &amp; hash 是计算索引的算法，计算后可以得到一个 0 ~ n -1 范围的值</p>
<p>这里的 n 也就是数组的长度是始终是 2 的 m 次幂，初始是16.扩容后就是32</p>
<p>那么 n -1 用二进制表示就是 0000 1111(高位省略)，二进制与运算(&amp;)可以用来隐藏和显示某些位。这里的 0000 1111 &amp; hash 就是指显示 hash 值的后 4 位，最终就会得到 0 ~ 15 之间的数，作为数组的索引</p>
<h5 id="重复判断"><a href="#重复判断" class="headerlink" title="重复判断"></a>重复判断</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">        tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">    &#x2F;&#x2F; 上面讲过注释省略，从这里开始分析</span><br><span class="line">	&#x2F;&#x2F; 如果当前索引位置不为空(是链表或红黑树)</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; 定义辅助变量</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        &#x2F;&#x2F; 判断当前索引位置的结点的 hash 值是否和新结点的 hash 值相同</span><br><span class="line">        &#x2F;&#x2F; 并且 key 对象相同或者 key 值相等(equlas)</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            &#x2F;&#x2F; 将当前索引位置的结点赋值给 e</span><br><span class="line">            e &#x3D; p;</span><br><span class="line">        &#x2F;&#x2F; 判断当前索引位置是否是红黑树</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        &#x2F;&#x2F; 当前索引位置是链表</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 代码省略</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 用 e 是否为空来判断是否存在重复结点</span><br><span class="line">        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            &#x2F;&#x2F; 判断是否更新 value</span><br><span class="line">            &#x2F;&#x2F; 这里 value 始终是一个 object 对象，用来占位，所以不需要更新</span><br><span class="line">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">            &#x2F;&#x2F; 一个空方法，供 HashMap 的子类实现</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            &#x2F;&#x2F; 返回旧的 value</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 下面讲过注释省略</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="链表转红黑树"><a href="#链表转红黑树" class="headerlink" title="链表转红黑树"></a>链表转红黑树</h5><p>添加元素时，当元素长度到达一定阈值，是如何从链表转为红黑树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">        tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            e &#x3D; p;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        &#x2F;&#x2F; 上面讲过注释省略，从这里开始分析</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历链表</span><br><span class="line">            for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                &#x2F;&#x2F; 判断是否到达链表的末尾</span><br><span class="line">                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 直接将结点添加到链表的末尾</span><br><span class="line">                    p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                    &#x2F;&#x2F; 判断链表的结点数是否到达转为红黑树的临界值(8)</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                        &#x2F;&#x2F; bin 可以理解为链表的结点</span><br><span class="line">                        &#x2F;&#x2F; 当 binCount 为 7 时，此时的位置是第 8 个结点</span><br><span class="line">                        &#x2F;&#x2F; 但由于刚刚又加入了一个结点，所以实际链表上已经有 9 个结点了</span><br><span class="line">                        &#x2F;&#x2F; 所以准确的说应该是超过临界值后会转为红黑树，不是到达</span><br><span class="line">                        &#x2F;&#x2F; 只不过 binCount 是从 0 开始数的，导致结点数少了一个</span><br><span class="line">                        &#x2F;&#x2F; 转为红黑树</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 判断当前结点的 hash 是否和新结点的 hash 相同</span><br><span class="line">                &#x2F;&#x2F; 并且 key 对象相同或者 key 值相同</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    &#x2F;&#x2F; 直接退出循环，不做任何添加操作</span><br><span class="line">                    break;</span><br><span class="line">                &#x2F;&#x2F; 继续下一个结点</span><br><span class="line">                p &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 下面讲过注释省略</span><br><span class="line">        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后进入treeifyBin函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义辅助变量</span><br><span class="line">    int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    &#x2F;&#x2F; 判断数组是否为空，或者数组长度小于一个临界值(64)</span><br><span class="line">    if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        &#x2F;&#x2F; 进行数组扩容，而不是转成红黑树</span><br><span class="line">        resize();</span><br><span class="line">    else if ((e &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 转红黑树的代码省略</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>链表上的结点到达了 8 个，但此时数组长度小于 64，是不会将其转为红黑树的，而是进行一次扩容</p>
<p>所以链表转为红黑树的临界条件是结点超过8个，且数组长度超过64</p>
<h5 id="数组达到临界值扩容机制"><a href="#数组达到临界值扩容机制" class="headerlink" title="数组达到临界值扩容机制"></a>数组达到临界值扩容机制</h5><ol>
<li>数组长度（Capacity）：数组长度表示 HashSet 内部数组的大小。在 Java 8 的 HashSet 实现中，默认的初始数组长度是 16。当 HashSet 中的元素数量超过数组长度时，就可能会发生冲突（碰撞），即多个元素哈希值相同但放置在数组同一个位置上。</li>
<li>临界值（Load Factor）：临界值是一个比例值，用于表示 HashSet 中元素数量和数组长度的比例。在 Java 8 的 HashSet 实现中，默认的临界值是 0.75，即当元素数量达到数组长度的 0.75 倍时，就会触发数组的扩容操作。</li>
<li>扩容之后，将旧数组的链表数据移动到新数组，移动链表时并不是把整个链表直接移动到新数组上，而是一个一个结点的移动。因为随着数组扩容后数组长度的变大，每个结点计算出的索引会和之前的不一样</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义辅助变量</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">    &#x2F;&#x2F; 旧数组长度 0</span><br><span class="line">    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">    &#x2F;&#x2F; 旧临界值</span><br><span class="line">    int oldThr &#x3D; threshold;</span><br><span class="line">    &#x2F;&#x2F; 新的数组长度和临界值</span><br><span class="line">    int newCap, newThr &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 第 n 此扩容，n &gt; 1</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断旧数组长度是否大于最大值</span><br><span class="line">        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 新数组长度扩大两倍</span><br><span class="line">    	&#x2F;&#x2F; 并判断新数组长度是否 &lt; 最大值，同时旧数组长度是否 &gt;&#x3D; 初始长度(16)</span><br><span class="line">        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            &#x2F;&#x2F; 新数组长度临界值扩大两倍</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F; 判断旧数组长度临界值是否 &gt; 0</span><br><span class="line">    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line">        &#x2F;&#x2F; 新数组长度为旧数组长度临界值</span><br><span class="line">        &#x2F;&#x2F; oldCap 为 0，因为如果 &gt; 0 就走第一个条件了</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line">    &#x2F;&#x2F; 第一次扩容</span><br><span class="line">    else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">        &#x2F;&#x2F; 新的数组长度默认为 16</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        &#x2F;&#x2F; 新的临界值默认为 12</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 判断是否新临界值为 0</span><br><span class="line">    if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将新数组大小的 0.75 倍赋值给 ft</span><br><span class="line">        &#x2F;&#x2F; 初始化 HashMap 时就指定了 loadFactor 为默认临界因子(0.75f)</span><br><span class="line">        float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        &#x2F;&#x2F; 如果新的数组大小 &lt; 最大长度，并且 ft &lt; 最大长度，新的数组长度临界值就为 ft</span><br><span class="line">        &#x2F;&#x2F; 否则为整数的最大值</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 改变为新的临界值</span><br><span class="line">    threshold &#x3D; newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">	&#x2F;&#x2F; 定义新的数组</span><br><span class="line">    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    &#x2F;&#x2F; 改变数组</span><br><span class="line">    table &#x3D; newTab;</span><br><span class="line">    &#x2F;&#x2F; 判断旧数组是否为空</span><br><span class="line">    if (oldTab !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 按照新的数组长度创建新的数组</span><br><span class="line">        &#x2F;&#x2F; 并遍历旧数组，将旧数组上的结点一个一个移动到新数组上</span><br><span class="line">        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; &#x2F;&#x2F; 定义辅助变量</span><br><span class="line">            &#x2F;&#x2F; 判断当前索引位置是否为空</span><br><span class="line">            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; 设置旧数组该索引处为空</span><br><span class="line">                oldTab[j] &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F; 判断是否有下一个结点</span><br><span class="line">                if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                    &#x2F;&#x2F; 没有下一个结点就直接将该结点移动到新数组上</span><br><span class="line">                    &#x2F;&#x2F; 注意：索引是由数组长度和 hash 值共同决定的</span><br><span class="line">                    &#x2F;&#x2F; 此时计算索引用的是新数组的长度，结果可能会与旧数组的索引不同</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                &#x2F;&#x2F; 判断该索引位置是不是一个红黑树</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    &#x2F;&#x2F; 移动树上的结点</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                &#x2F;&#x2F; 该索引位置是一个链表</span><br><span class="line">                else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                    &#x2F;&#x2F; 定义 lowHead，lowTail，表示低位链表的头结点和尾节点</span><br><span class="line">                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                    &#x2F;&#x2F; 定义 hightHead，hightTail，表示高位链表的头结点和尾节点</span><br><span class="line">                    &#x2F;&#x2F; 低位链表和高位链表里的位，表示的是数组索引位</span><br><span class="line">                    &#x2F;&#x2F; 由于数组长度的增加，新数组的索引位置可能不变，也可能变大</span><br><span class="line">                    &#x2F;&#x2F; 如果不变，就用低位链表；如果变大，就用高位链表</span><br><span class="line">                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; next; &#x2F;&#x2F; 定义下一个结点</span><br><span class="line">                    do &#123;</span><br><span class="line">                        &#x2F;&#x2F; 获取下一个结点</span><br><span class="line">                        next &#x3D; e.next;</span><br><span class="line">                        &#x2F;&#x2F; 计算新新数组的索引位是否不变</span><br><span class="line">                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            &#x2F;&#x2F; 判断当前结点是否是头结点</span><br><span class="line">                            &#x2F;&#x2F; 因为最开始定义 loTail 为 null</span><br><span class="line">                            &#x2F;&#x2F; 而如果添加了一个结点后，loTail 就会指新的结点，不为 null</span><br><span class="line">                            if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                &#x2F;&#x2F; 将当前结点赋值给头结点</span><br><span class="line">                                loHead &#x3D; e;</span><br><span class="line">                        	&#x2F;&#x2F; 当前结点不是头结点</span><br><span class="line">                            else</span><br><span class="line">                                &#x2F;&#x2F; 将当前结点添加到最后</span><br><span class="line">                                loTail.next &#x3D; e;</span><br><span class="line">                            &#x2F;&#x2F; 尾节点指向最后的新结点</span><br><span class="line">                            loTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 新数组的索引位变大，使用高位链表</span><br><span class="line">                        else &#123;</span><br><span class="line">                            &#x2F;&#x2F; 和上面的低位链表一样的操作</span><br><span class="line">                            if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                hiHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next &#x3D; e;</span><br><span class="line">                            hiTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#x2F;&#x2F; 继续下一个结点</span><br><span class="line">                    &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                    &#x2F;&#x2F; 判断低位链表是否为非空链表</span><br><span class="line">                    if (loTail !&#x3D; null) &#123;</span><br><span class="line">                        loTail.next &#x3D; null;</span><br><span class="line">                        &#x2F;&#x2F; 移动到新数组上的索引不变</span><br><span class="line">                        newTab[j] &#x3D; loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 判断高位链表是否为非空链表</span><br><span class="line">                    if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                        hiTail.next &#x3D; null;</span><br><span class="line">                        &#x2F;&#x2F; 移动到新数组上的索引变大，相差一个旧数组的长度</span><br><span class="line">                        newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回新的数组</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="TreeSet（二叉树）"><a href="#TreeSet（二叉树）" class="headerlink" title="TreeSet（二叉树）"></a>TreeSet（二叉树）</h3><ol>
<li><p>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</p>
</li>
<li><p>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。</p>
</li>
<li><p>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序</p>
</li>
<li><p>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负数、零或正整数。</p>
</li>
</ol>
<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><p>TreeSet秉承了HashSet的一贯做法，内部通过Map来保存key/value数据，由于Set只保存key，所以内部的Map的value公用了一个定义的Object对象PRESENT。 TreeSet由于维持有序性，所以内部通过TreeMap存储数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 用于保存TreeMap的对象，会在构造函数当中赋值TreeMap对象</span><br><span class="line">    private transient NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TreeMap当中所有的value都是保存的PRESENT对象</span><br><span class="line">    private static final Object PRESENT &#x3D; new Object();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line"> 			this.m &#x3D; m;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>几种构造方式：</p>
<p>通过创建TreeMap对象赋值给TreeSet当中NavigableMap&lt;E,Object&gt; m变量；</p>
<p>通过创建NavigableMap&lt;E,Object&gt; m变量并通过addAll方法方法添加到TreeMap当中。</p>
<p>在TreeSet的addAll()方法通过super.addAll()方法调用AbstractCollection的addAll()方法，在该方法内部最后又调用TreeSet的add()方法添加到TreeMap m当中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public TreeSet() &#123;</span><br><span class="line">        this(new TreeMap&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public TreeSet(Comparator&lt;? super E&gt; comparator) &#123;</span><br><span class="line">        this(new TreeMap&lt;&gt;(comparator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public TreeSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        this();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public TreeSet(SortedSet&lt;E&gt; s) &#123;</span><br><span class="line">        this(s.comparator());</span><br><span class="line">        addAll(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>add方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public  boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        &#x2F;&#x2F; Use linear-time version if applicable</span><br><span class="line">        if (m.size()&#x3D;&#x3D;0 &amp;&amp; c.size() &gt; 0 &amp;&amp;</span><br><span class="line">            c instanceof SortedSet &amp;&amp;</span><br><span class="line">            m instanceof TreeMap) &#123;</span><br><span class="line">            SortedSet&lt;? extends E&gt; set &#x3D; (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">            TreeMap&lt;E,Object&gt; map &#x3D; (TreeMap&lt;E, Object&gt;) m;</span><br><span class="line">            Comparator&lt;?&gt; cc &#x3D; set.comparator();</span><br><span class="line">            Comparator&lt;? super E&gt; mc &#x3D; map.comparator();</span><br><span class="line">            if (cc&#x3D;&#x3D;mc || (cc !&#x3D; null &amp;&amp; cc.equals(mc))) &#123;</span><br><span class="line">                map.addAllForTreeSet(set, PRESENT);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        return m.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">----------AbstractCollection.java中代码-----------</span><br><span class="line"></span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        boolean modified &#x3D; false;</span><br><span class="line">        for (E e : c)</span><br><span class="line">            if (add(e))</span><br><span class="line">                modified &#x3D; true;</span><br><span class="line">        return modified;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>详情见TreeMap的底层实现方法</p>
<h3 id="LinkHashSet（HashSet-LinkedHashMap）"><a href="#LinkHashSet（HashSet-LinkedHashMap）" class="headerlink" title="LinkHashSet（HashSet+LinkedHashMap）"></a>LinkHashSet（HashSet+LinkedHashMap）</h3><p> 对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public LinkedHashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    super(initialCapacity, loadFactor, true);</span><br><span class="line">&#125;</span><br><span class="line">public LinkedHashSet(int initialCapacity) &#123;</span><br><span class="line">    super(initialCapacity, .75f, true);</span><br><span class="line">&#125;</span><br><span class="line">public LinkedHashSet() &#123;</span><br><span class="line">    super(16, .75f, true);</span><br><span class="line">&#125;</span><br><span class="line">public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    super(Math.max(2*c.size(), 11), .75f, true);</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line">public LinkedHashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    super(initialCapacity, loadFactor, true);</span><br><span class="line">&#125;</span><br><span class="line">public LinkedHashSet(int initialCapacity) &#123;</span><br><span class="line">    super(initialCapacity, .75f, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LinkedHashSet() &#123;</span><br><span class="line">    super(16, .75f, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    super(Math.max(2*c.size(), 11), .75f, true);</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line"> HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">     map &#x3D; new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详情见LinkedHashMap的底层实现方法</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java关键字native和volatile</title>
    <url>/2023/04/22/Java%E5%85%B3%E9%94%AE%E5%AD%97native%E5%92%8Cvolatile/</url>
    <content><![CDATA[<h2 id="native"><a href="#native" class="headerlink" title="native"></a>native</h2><p>1.java 中的 native 修饰符表示被修饰的方法由本地语言实现。</p>
<p>2.有时java应用需要与java外面的环境交互。这是本地方法存在的主要原因，你可以想想java需要与一些底层系统如操作系统或某些硬件交换信息时的情况。</p>
<p>3.JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的，还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法</p>
<p>比如：Thread.start()方法，CAS里面调用的操作系统的CAS</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>关键字volatile在Java中本质上是一种修饰符，它用来修饰变量。</p>
<p>volatile关键字在多线程编程中非常重要，它保证了多个线程之间变量的可见性和有序性。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>被volatile修饰的变量对于所有线程都是可见的，即当一个线程修改volatile变量的值后，其他线程立即可见修改后的值。写完后立即刷新回主内存并及时发出通知，大家可以去主内存拿最新版，前面的修改对后面所有线程可见</p>
<h3 id="有序性（禁止指令重排序）"><a href="#有序性（禁止指令重排序）" class="headerlink" title="有序性（禁止指令重排序）"></a>有序性（禁止指令重排序）</h3><p>JVM会对代码进行优化，其中包括指令重排序，编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序，如果一个操作的结果并不影响程序的正确性，那么JVM很有可能会将此操作与其后面的操作交换执行顺序。而在多线程环境中，这种指令重排序可能会导致程序输出不正确的结果，因此使用volatile关键字可以禁止指令重排序优化。</p>
<h3 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h3><p>并不保证操作具有原子性</p>
<h3 id="如何实现volatile的可见性和有序性"><a href="#如何实现volatile的可见性和有序性" class="headerlink" title="如何实现volatile的可见性和有序性"></a>如何实现volatile的可见性和有序性</h3><p>当写一个volatile变量时，JVM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中。.<br>当读一个volatile变量时，JVM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量</p>
<p>所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取</p>
<p>引入内存屏障的定义</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>内存屏障是一种机制，用于保障程序在多线程环境中的数据一致性。它可以保证指令的执行顺序，避免出现线程安全问题</p>
<p>内存屏障(也称内存栅栏，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作)，避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性(禁重排)</p>
<p>可见性实现：</p>
<p>内存屏障之前的所有写操作都要回写到主内存。<br>内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果</p>
<p>实现了可见性</p>
<p>内存屏障分类：</p>
<table>
<thead>
<tr>
<th>Load Barrier（读屏障）</th>
<th>确保前面的读操作必须在它之前的写操作完成之后才执行</th>
</tr>
</thead>
<tbody><tr>
<td>Store Barrier（写屏障）</td>
<td>确保后面的写操作必须在它之前的读操作完成之后才执行。</td>
</tr>
<tr>
<td>Full Fence（全屏障）</td>
<td>保证所有前面的操作都完成后再执行后面的操作。</td>
</tr>
<tr>
<td>StoreLoad Barrier（写-读屏障）</td>
<td>保证后面的读操作必须在前面的写操作完成后执行</td>
</tr>
</tbody></table>
<p>内存屏障指令：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>屏障指令</th>
<th>指令效果</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad屏障</td>
<td>读1；LoadLoad屏障；读2</td>
<td>保证读1在读2以及后续读取操作之前执行</td>
</tr>
<tr>
<td>StoreStore屏障</td>
<td>写1；StoreStore屏障；写2</td>
<td>写2及其后续写操作执行前，保证写1的操作已经刷新到主内存</td>
</tr>
<tr>
<td>LoadStore屏障</td>
<td>读1；LoadStore屏障；写2</td>
<td>写2及其后续的写操作执行前，保证读1的操作已经结束</td>
</tr>
<tr>
<td>StoreLoad屏障</td>
<td>写1；StoreLoad屏障；读2</td>
<td>保证写1的操作已经刷新到主内存之后，才会执行后续的读2操作</td>
</tr>
</tbody></table>
<p>内存屏障刷内存数据：</p>
<p>读屏障(LoadBarrier)：在读指令之前插入读屏障，让工作内存或CPU高速缓存当中的缓存数据失效，重新回到主内存中获取最新数据<br>写屏障(StoreBarrier)：在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中</p>
<h4 id="volatile读操作"><a href="#volatile读操作" class="headerlink" title="volatile读操作"></a>volatile读操作</h4><p>在每个volatile读操作的后面插入一个LoadLoad屏障<br>在每个volatile读操作的后面插入一个LoadStore屏障</p>
<p><img src="/2023/04/22/Java%E5%85%B3%E9%94%AE%E5%AD%97native%E5%92%8Cvolatile/1.jpg" alt="1"></p>
<h4 id="volatile写操作"><a href="#volatile写操作" class="headerlink" title="volatile写操作"></a>volatile写操作</h4><p>在每个volatile写操作的前面插入一个StoreStore屏障<br>在每个volatile写操作的后面插入一个StoreLoad屏障</p>
<p><img src="/2023/04/22/Java%E5%85%B3%E9%94%AE%E5%AD%97native%E5%92%8Cvolatile/2.jpg" alt="1"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Java中的volatile关键字会告诉Java虚拟机，在访问该变量时总是从主内存中读取数据，在修改该变量时总是将数据写回主内存中。这个特性可以保证在多线程环境下，不同线程访问该变量时不会出现数据不一致的问题。</p>
<p>为了实现这个特性，Java虚拟机会在volatile变量的读写操作前后加上内存屏障（Memory Barriers），它会强制将写缓冲区/高速缓存中的数据刷新到主内存中，或强制从主内存中读取最新的数据到写缓冲区/高速缓存中。内存屏障是一种CPU指令，在不同的CPU体系结构下实现方式可能不同。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾回收</title>
    <url>/2023/01/18/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h2 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象添加一个引用计数器,当对象增加一个引用时计数器加 1,引用失效时计数器减 1。引用计数为 0 的对象可被回收，但是会出现问题，如果出现循环引用的话，引用计数永远不可能为0，所以，该对象永远不会被回收</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记<br>过程。两次标记后仍然是可回收对象，则将面临回收。</p>
<h3 id="Java-引用类型"><a href="#Java-引用类型" class="headerlink" title="Java 引用类型"></a>Java 引用类型</h3><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>（更多详情可以看 Go的垃圾回收算法，进行比对 <a href="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">GO的垃圾回收</a>）</p>
<h3 id="标记清除Mark-Sweep"><a href="#标记清除Mark-Sweep" class="headerlink" title="标记清除Mark-Sweep"></a>标记清除Mark-Sweep</h3><p>最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间<br><img src="/2023/01/18/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/1.jpg" alt="1"><br>该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题</p>
<h3 id="标记复制Mark-Copying"><a href="#标记复制Mark-Copying" class="headerlink" title="标记复制Mark-Copying"></a>标记复制Mark-Copying</h3><p>为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小<br>的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用<br>的内存清掉<br><img src="/2023/01/18/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2.jpg" alt="1"><br>算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原<br>本的一半。且存活对象增多的话，Copying 算法的效率会大大降低</p>
<h3 id="标记整理Mark-Copying"><a href="#标记整理Mark-Copying" class="headerlink" title="标记整理Mark-Copying"></a>标记整理Mark-Copying</h3><p>结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清<br>理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象</p>
<p><img src="/2023/01/18/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/3.jpg" alt="1"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代和新生代。<br>老生代的特点是每次垃圾回收时只有少量对象需要被回收<br>新生代的特点是每次垃圾回收时都有大量垃圾需要被回收<br>因此可以根据不同区域选择不同的算法</p>
<h4 id="新生代标记复制"><a href="#新生代标记复制" class="headerlink" title="新生代标记复制"></a>新生代标记复制</h4><p>因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</p>
<p>每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量<br>存活对象的复制成本就可以完成收集</p>
<h4 id="老年代标记整理"><a href="#老年代标记整理" class="headerlink" title="老年代标记整理"></a>老年代标记整理</h4><p>因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标<br>记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存</p>
<ol>
<li>JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储 class 类，<br>常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。</li>
<li>对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目<br>前存放对象的那一块)，少数情况会直接分配到老生代。</li>
<li>当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，Eden<br>Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From<br>Space 进行清理。</li>
<li>如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。</li>
<li>在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。</li>
<li>当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被<br>移到老生代中</li>
</ol>
<h3 id="分区收集算法"><a href="#分区收集算法" class="headerlink" title="分区收集算法"></a>分区收集算法</h3><p>分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是<br>整个堆), 从而减少一次 GC 所产生的停顿。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="新生代垃圾回收器"><a href="#新生代垃圾回收器" class="headerlink" title="新生代垃圾回收器"></a>新生代垃圾回收器</h3><h4 id="Serial-垃圾收集器（单线程、复制算法）"><a href="#Serial-垃圾收集器（单线程、复制算法）" class="headerlink" title="Serial 垃圾收集器（单线程、复制算法）"></a>Serial 垃圾收集器（单线程、复制算法）</h4><p>最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1 之前新生代唯一的垃圾收集器。Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。<br>Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限<br>定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial<br>垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器</p>
<h4 id="ParNew-垃圾收集器（Serial-多线程）"><a href="#ParNew-垃圾收集器（Serial-多线程）" class="headerlink" title="ParNew 垃圾收集器（Serial+多线程）"></a>ParNew 垃圾收集器（Serial+多线程）</h4><p>收集器默认开启和 CPU 数目相同的线程数，ParNew虽然是除了多线程外和Serial 收集器几乎完全一样，但是ParNew垃圾收集器是很多 java<br>虚拟机运行在 Server 模式下新生代的默认垃圾收集器</p>
<h4 id="Parallel-Scavenge-收集器（多线程复制算法、高效）"><a href="#Parallel-Scavenge-收集器（多线程复制算法、高效）" class="headerlink" title="Parallel Scavenge 收集器（多线程复制算法、高效）"></a>Parallel Scavenge 收集器（多线程复制算法、高效）</h4><p>自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量（吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)）高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务</p>
<h3 id="老年代垃圾回收器"><a href="#老年代垃圾回收器" class="headerlink" title="老年代垃圾回收器"></a>老年代垃圾回收器</h3><h4 id="Serial-Old-收集器（单线程标记整理算法-）"><a href="#Serial-Old-收集器（单线程标记整理算法-）" class="headerlink" title="Serial Old 收集器（单线程标记整理算法 ）"></a>Serial Old 收集器（单线程标记整理算法 ）</h4><p>Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，<br>这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器</p>
<h4 id="Parallel-Old-收集器（多线程标记整理算法）"><a href="#Parallel-Old-收集器（多线程标记整理算法）" class="headerlink" title="Parallel Old 收集器（多线程标记整理算法）"></a>Parallel Old 收集器（多线程标记整理算法）</h4><p>Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6<br>才开始提供</p>
<h4 id="CMS-收集器（多线程标记清除算法）"><a href="#CMS-收集器（多线程标记清除算法）" class="headerlink" title="CMS 收集器（多线程标记清除算法）"></a>CMS 收集器（多线程标记清除算法）</h4><p>Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验</p>
<h5 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h5><p>只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</p>
<h5 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h5><p>进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</p>
<h5 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a>重新标记</h5><p>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记<br>记录，仍然需要暂停所有的工作线程</p>
<h5 id="并发清除"><a href="#并发清除" class="headerlink" title="并发清除"></a>并发清除</h5><p>清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并<br>发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看<br>CMS 收集器的内存回收和用户线程是一起并发地执行</p>
<h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><p>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收<br>集器两个最突出的改进是：</p>
<ol>
<li>基于标记-整理算法，不产生内存碎片。</li>
<li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。<br>G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域<br>的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾<br>最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收<br>集效率</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发CAS</title>
    <url>/2023/04/15/Java%E5%B9%B6%E5%8F%91CAS/</url>
    <content><![CDATA[<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>Compare And Swap，比较并交换，是一条CPU的并发原语，CAS操作对应的CPU指令是CMPXCHG（Compare and Exchange）指令。CMPXCHG指令是一种原子指令，用于比较内存中的值与一个寄存器中的值，如果相等，则将新的值存入内存中；如果不相等，则不执行任何操作。这个操作是原子的，即在执行过程中不会被中断，由操作系统保证。</p>
<p>CAS是一种无锁的原子算法</p>
<h2 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h2><p>主内存中存放的共享变量的值：V（一般情况下这个V是内存的地址值，通过这个地址可以获得内存中的值）</p>
<p>工作内存中共享变量的副本值，也叫预期值：A</p>
<p>需要将共享变量更新到的最新值：B</p>
<p><img src="/2023/04/15/Java%E5%B9%B6%E5%8F%91CAS/1.jpg" alt="1"></p>
<p>步骤：</p>
<ol>
<li>获取当前共享变量的值和期望值：<br>CAS操作的第一步是获取共享变量的当前值V，同时也需要提供一个期望值A，这个期望值是用来比较共享变量的当前值是否与之相等的基准。</li>
<li>比较共享变量的当前值V和期望值A是否相等：<br>在这一步，CAS会比较共享变量的当前值和之前提供的期望值是否相等。如果相等，说明共享变量的值符合预期，可以进行下一步操作。</li>
<li>更新共享变量的值B：<br>如果共享变量的当前值与期望值相等，CAS会将共享变量的值更新为要写入的新值。这个操作是原子性的，即在这个过程中不会有其他线程对该共享变量进行干扰。</li>
<li>处理失败的情况：<br>如果共享变量的当前值V与期望值A不相等，说明此时有其他线程已经修改了共享变量的值BV。在这种情况下，当前线程需要重新获取共享变量的最新值，并重新执行步骤2和3，直至操作成功。</li>
</ol>
<h2 id="乐观锁的典型实现"><a href="#乐观锁的典型实现" class="headerlink" title="乐观锁的典型实现"></a>乐观锁的典型实现</h2><p>悲观锁更新的方式认为：在更新数据的时候大概率会有其他线程去争夺共享资源，所以悲观锁的做法是：第一个获取资源的线程会将资源锁定起来，其他没争夺到资源的线程只能进入阻塞队列，等第一个获取资源的线程释放锁之后，这些线程才能有机会重新争夺资源。synchronized就是java中悲观锁的典型实现，synchronized使用起来非常简单方便，但是会使没争抢到资源的线程进入阻塞状态，线程在阻塞状态和Runnable状态之间切换效率较低（比较慢）。比如你的更新操作其实是非常快的，这种情况下你还用synchronized将其他线程都锁住了，线程从Blocked状态切换回Runnable华的时间可能比你的更新操作的时间还要长。</p>
<p>乐观锁更新方式认为:在更新数据的时候其他线程争抢这个共享变量的概率非常小，所以更新数据的时候不会对共享数据加锁。但是在正式更新数据之前会检查数据是否被其他线程改变过，如果未被其他线程改变过就将共享变量更新成最新值，如果发现共享变量已经被其他线程更新过了，就重试，直到成功为止。CAS机制就是乐观锁的典型实现</p>
<h2 id="Java-Unsafe类底层实现"><a href="#Java-Unsafe类底层实现" class="headerlink" title="Java Unsafe类底层实现"></a>Java Unsafe类底层实现</h2><p>底层依靠Unsafe的CAS实现，以AtomicInteger为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * Atomically adds the given value to the current value. </span><br><span class="line"> * </span><br><span class="line"> * @param delta the value to add </span><br><span class="line"> * @return the previous value </span><br><span class="line"> *&#x2F; </span><br><span class="line">public final int getAndAdd(int delta) &#123; </span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, delta); </span><br><span class="line">&#125; </span><br><span class="line">public final int incrementAndGet() &#123; </span><br><span class="line">    for (;;) &#123; </span><br><span class="line">        int current &#x3D; get(); </span><br><span class="line">        int next &#x3D; current + 1; </span><br><span class="line">        if (compareAndSet(current, next)) </span><br><span class="line">            return next; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">private volatile int value; </span><br><span class="line">public final int get() &#123; </span><br><span class="line">    return value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码是一个无限循环，也就是CAS的自旋。循环体当中做了三件事：</p>
<p>获取当前值;</p>
<p>当前值+1，计算出目标值;</p>
<p>进行CAS操作，如果成功则跳出循环(当前值和目标值相等)，如果失败则重复上述步骤;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123; </span><br><span class="line">    int var5; </span><br><span class="line">    do &#123; </span><br><span class="line">        var5 &#x3D; this.getIntVolatile(var1, var2); </span><br><span class="line">    &#125; while (!this.compareAndSwapInt(var1, var2, var5, var5 + var4));&#x2F;&#x2F;native方法 </span><br><span class="line">    return var5; </span><br><span class="line">&#125;    </span><br><span class="line">******** </span><br><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);&#x2F;&#x2F;底层c++实现 </span><br></pre></td></tr></table></figure>



<p>可以看到compareAndSwapInt为native方法，对应底层hotspot虚拟机unsage.cpp，最终调用了Atomic::cmpxchg来保证原子性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) </span><br><span class="line">  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;); </span><br><span class="line">  oop p &#x3D; JNIHandles::resolve(obj); </span><br><span class="line">  jint* addr &#x3D; (jint *) index_oop_from_field_offset_long(p, offset); </span><br><span class="line">  return (jint)(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e; </span><br><span class="line">UNSAFE_END </span><br><span class="line">*** </span><br></pre></td></tr></table></figure>

<p>Atomic::cmpxchg针对不同平台有不同的实现方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*** </span><br><span class="line">&#x2F;&#x2F; Adding a lock prefix to an instruction on MP machine </span><br><span class="line">#define LOCK_IF_MP(mp) &quot;cmp $0, &quot; #mp &quot;; je 1f; lock; 1: &quot; </span><br><span class="line">*** </span><br><span class="line">inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) &#123; </span><br><span class="line">  int mp &#x3D; os::is_MP(); </span><br><span class="line">  __asm__ volatile (LOCK_IF_MP(%4) &quot;cmpxchgl %1,(%3)&quot; </span><br><span class="line">                    : &quot;&#x3D;a&quot; (exchange_value) </span><br><span class="line">                    : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp) </span><br><span class="line">                    : &quot;cc&quot;, &quot;memory&quot;); </span><br><span class="line">  return exchange_value; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>最重要的指令为 LOCK_IF_MP ， MP是指多CPU(multi processors)，最终意义为多CPU的情况下需要lock，通过lock的方式来保证原子;</p>
<p>lock解释：</p>
<p>1、确保后续指令执行的原子性;</p>
<p>2、在Pentium及之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其它处理器暂时无法通过总线访问内存，很显然，这个开销很大。在新的处理器中，Intel使用缓存锁定来保证指令执行的原子性，缓存锁定将大大降低lock前缀指令的执行开销;</p>
<p>3、禁止该指令与前面和后面的读写指令重排序;</p>
<p>4、把写缓冲区的所有数据刷新到内存中;</p>
<p>总之：JAVA中我们使用到涉及到CAS操作的底层实现为对应平台虚拟机中的c++代码(lock指令)实现来保证原子性;</p>
<h2 id="问题及缺点"><a href="#问题及缺点" class="headerlink" title="问题及缺点"></a>问题及缺点</h2><h3 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A， 那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了</p>
<p>对于基本类型的值来说，这种把数字改变了在改回原来的值是没有太大影响的，但如果是对于引用类型的话，就会产生很大的影响了</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>为了解决这个 ABA 的问题，我们可以引入版本控制，例如，每次有线程修改了引用的值，就会进行版本的更新，虽然两个线程持有相同的引用，但他们的版本不同，这样，我们就可以预防 ABA 问题了。Java 中提供了 AtomicStampedReference 这个类，就可以进行版本控制了。</p>
<h3 id="循环时间长，开销大"><a href="#循环时间长，开销大" class="headerlink" title="循环时间长，开销大"></a>循环时间长，开销大</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，即自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销;</p>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><p>如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。</p>
<p>pause指令有两个作用，第一它可以延迟流水线执行指令(de-pipeline),使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</p>
<p>第二它可以避免在退出循环的时候因内存顺序冲突(memory order violation)而引起CPU流水线被清空(CPU pipeline flush)，从而提高CPU的执行效率;</p>
<p>代码层面，破坏掉for死循环，当自旋超过一定时间或者一定次数时，return退出;</p>
<p>使用类似ConcurrentHashMap的方法。当多个线程竞争时，将粒度变小，将一个变量拆分为多个变量，达到多个线程访问多个资源的效果，最后再调用sum把它合起来，能降低CPU消耗，但是治标不治本;</p>
<h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p>只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性;</p>
<h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><p>1、合并变量</p>
<p>2、AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>可以保证变量操作的原子性；</p>
<p>并发量不是很高的情况下，使用CAS机制比使用锁机制效率更高；</p>
<p>在线程对共享资源占用时间较短的情况下，使用CAS机制效率也会较高</p>
<h2 id="Java8对-CAS-的优化"><a href="#Java8对-CAS-的优化" class="headerlink" title="Java8对 CAS 的优化"></a>Java8对 CAS 的优化</h2><p>为了解决上面的第二个问题，线程较多时候，大量线程的自旋浪费CPU资源</p>
<p>Java8 引入了一个 cell[] 数组，它的工作机制是这样的：假如有 5 个线程要对 i 进行自增操作，由于 5 个线程的话，不是很多，起冲突的几率较小，那就让他们按照以往正常的那样，采用 CAS 来自增吧。</p>
<p>但是，如果有 100 个线程要对 i 进行自增操作的话，这个时候，冲突就会大大增加，系统就会把这些线程分配到不同的 cell 数组元素去，假如 cell[10] 有 10 个元素吧，且元素的初始化值为 0，那么系统就会把 100 个线程分成 10 组，每一组对 cell 数组其中的一个元素做自增操作，这样到最后，cell 数组 10 个元素的值都为 10，系统在把这 10 个元素的值进行汇总，进而得到 100，二这，就等价于 100 个线程对 i 进行了 100 次自增操作</p>
<p>原理就是：采用了分段 CAS + 自动分段迁移机制优化了线程较多且竞争激烈的 CAS 并发性能。如上述所讲，比如 LongAdder ，内部包含了一个数组，数组中每个元素都是一个独立的子计数器。当多个线程同时操作时，线程会随机落在数组中的子计数器上进行 CAS 操作，避免了大量线程同时操作一个计数器的尴尬局面！最后获取的最终值，是通过自动分段合并计算出主计数器的值</p>
<h2 id="使用时机"><a href="#使用时机" class="headerlink" title="使用时机"></a>使用时机</h2><p>线程数较少、等待时间短可以采用自旋锁进行CAS尝试拿锁，较于synchronized高效;</p>
<p>线程数较大、等待时间长，不建议使用自旋锁，占用CPU较高;</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程和线程池</title>
    <url>/2023/05/14/Java%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><p>Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法</p>
<h4 id="Runable接口"><a href="#Runable接口" class="headerlink" title="Runable接口"></a>Runable接口</h4><p>无法直接 extends Thread， implements Runnable，需要首先实例化一个 Thread，并传入自己的 MyThread 实例</p>
<h4 id="ExecutorService、Callable、Future有返回值线程"><a href="#ExecutorService、Callable、Future有返回值线程" class="headerlink" title="ExecutorService、Callable、Future有返回值线程"></a>ExecutorService、Callable、Future有返回值线程</h4><p>有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。执行Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>通过线程池创建的线程</p>
<h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p><img src="/2023/05/14/Java%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/1.jpg" alt="1"></p>
<p>在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5 种状态。尤其是当线程启动以后，它不可能一直”霸占”着 CPU 独自运行，所以 CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换</p>
<h4 id="新建New"><a href="#新建New" class="headerlink" title="新建New"></a>新建New</h4><p>当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值</p>
<h4 id="就绪Runable"><a href="#就绪Runable" class="headerlink" title="就绪Runable"></a>就绪Runable</h4><p>当线程对象调用了 start()方法之后，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p>
<h4 id="运行Running"><a href="#运行Running" class="headerlink" title="运行Running"></a>运行Running</h4><p>如果处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体，则该线程处于运行状态</p>
<h4 id="阻塞Blocked（Waiting，-TimeWaiting）"><a href="#阻塞Blocked（Waiting，-TimeWaiting）" class="headerlink" title="阻塞Blocked（Waiting， TimeWaiting）"></a>阻塞Blocked（Waiting， TimeWaiting）</h4><p>阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状态。阻塞的情况分三种：</p>
<p>1、等待阻塞</p>
<p>运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列(waitting queue)中</p>
<p>2、同步阻塞</p>
<p>运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池(lock pool)中</p>
<p>3、其他阻塞</p>
<p>运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O处理完毕时，线程重新转入可运(runnable)状态。</p>
<h4 id="死亡Dead（Terminated）"><a href="#死亡Dead（Terminated）" class="headerlink" title="死亡Dead（Terminated）"></a>死亡Dead（Terminated）</h4><p>1、正常结束：run()或 call()方法执行完成，线程正常结束。</p>
<p>2、异常结束：线程抛出一个未捕获的 Exception 或 Error。</p>
<p>3、调用stop：直接调用该线程的 stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用。</p>
<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><p>1、线程自动结束，正常运行结束</p>
<p>2、使用退出标志，退出线程，常常有些线程是伺服线程。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程使用一个变量来控制循环，例如：最直接的方法就是设一个 boolean 类型的标志，并通过设置这个标志为 true 或 false 来控制 while循环是否退出</p>
<p>3、Interrupt方法结束线程</p>
<p>线程处于阻塞状态：如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时，会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的， 一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法</p>
<p>线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理</p>
<p>4、stop方法线程不安全</p>
<p>程序中可以直接使用 thread.stop()来强行终止线程，但是 stop 方法是很危险的，突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用 stop 方法来终止线程。</p>
<h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><p>1、对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于Object 类中的。</p>
<p>2、sleep()方法导致了程序暂停执行指定的时间，让出 cpu 给其他线程，但是他的监控状态依然保持，当指定的时间到了又会自动恢复运行状态。</p>
<p>3、在调用 sleep()方法的过程中，线程不会释放对象锁。</p>
<p>4、而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</p>
<h3 id="start和run的区别"><a href="#start和run的区别" class="headerlink" title="start和run的区别"></a>start和run的区别</h3><p>1、 start方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。</p>
<p>2、通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。</p>
<p>3、方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>1、守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务</p>
<p>2、通过 setDaemon(true)来设置线程为守护线程</p>
<p>3、在 Daemon 线程中产生的新线程也是 Daemon 的</p>
<p>4、线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程依旧是活跃的</p>
<p>5、独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或以上的非守护线程则 JVM 不会退出</p>
<h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><h4 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h4><p>调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用 wait()方法后，会释放对象的锁。因此，wait 方法一般用在同步方法或同步代码块中</p>
<h4 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h4><p>sleep 导致当前线程休眠，与 wait 方法不同的是 sleep 不会释放当前占有的锁,sleep(long)会导致线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态</p>
<h4 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h4><p>yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感</p>
<h4 id="interrupt方法"><a href="#interrupt方法" class="headerlink" title="interrupt方法"></a>interrupt方法</h4><p>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这</p>
<p>个线程本身并不会因此而改变状态(如阻塞，终止等)。</p>
<ol>
<li><p>调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。</p>
</li>
<li><p>若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛InterruptedException,从而使线程提前结束 TIMED-WATING 状态。</p>
</li>
<li><p>许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。</p>
</li>
<li><p>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程。</p>
</li>
</ol>
<h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><p>join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要在子线程结束后再结束，这时候就要用到 join() 方法</p>
<h4 id="notify方法"><a href="#notify方法" class="headerlink" title="notify方法"></a>notify方法</h4><p>Object 类中的 notify() 方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。</p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p> CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做上下文切换。时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能</p>
<p>上下文：是指某一时间点 CPU 寄存器和程序计数器的内容。</p>
<p>寄存器：是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。</p>
<p>程序计数器：是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统</p>
<p>PCB切换桢：上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行切换，上下文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB 还经常被称作“切换桢”（switchframe）。信息会一直保存到 CPU 的内存中，直到他们被再次使用</p>
<h4 id="上下文切换流程"><a href="#上下文切换流程" class="headerlink" title="上下文切换流程"></a>上下文切换流程</h4><ol>
<li><p>挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。</p>
</li>
<li><p>在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。</p>
</li>
<li><p>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序中。</p>
</li>
</ol>
<h4 id="切换原因"><a href="#切换原因" class="headerlink" title="切换原因"></a>切换原因</h4><ol>
<li><p>当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务；</p>
</li>
<li><p>当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务；</p>
</li>
<li><p>多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；</p>
</li>
<li><p>用户代码挂起当前任务，让出 CPU 时间；</p>
</li>
<li><p>硬件中断；</p>
</li>
</ol>
<h2 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h2><p>Java 里面线程池的顶级接口是 Executor，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 ExecutorService</p>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。</p>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p>
<h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载</title>
    <url>/2023/01/22/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化</p>
<p><img src="/2023/01/22/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/1.jpg" alt="1"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并<br>且不会危害虚拟机自身的安全</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使<br>用的内存空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int v &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>实际上变量 v 在准备阶段过后的初始值为 0 而不是 1，将 v 赋值为 1 的 put static 指令是程序被编译后，存放于类构造器client方法之中。</p>
<p>但是注意如果声明为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final int v &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 1</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程</p>
<h4 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h4><p>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中</p>
<p>符号引用就是 class 文件中的：</p>
<ol>
<li><p>CONSTANT_Class_info</p>
</li>
<li><p>CONSTANT_Field_info</p>
</li>
<li><p>CONSTANT_Method_info</p>
</li>
</ol>
<p>等类型的常量</p>
<h4 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h4><p>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码</p>
<h4 id="类构造器"><a href="#类构造器" class="headerlink" title="类构造器"></a>类构造器</h4><p>初始化阶段是执行类构造器client方法的过程。client方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子client方法执行之前，父类的client方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成client()方法</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类，</p>
<p> <img src="/2023/01/22/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/2.jpg" alt="1"></p>
<h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p>负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被虚拟机认可（按文件名识别，如 rt.jar）的类</p>
<h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库</p>
<h3 id="应用类加载器"><a href="#应用类加载器" class="headerlink" title="应用类加载器"></a>应用类加载器</h3><p>负责加载用户路径（classpath）上的类库。JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader实现自定义的类加载器</p>
<h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object 对象</p>
<p><img src="/2023/01/22/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/3.jpg" alt="1"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka原理探究</title>
    <url>/2023/07/27/Kafka%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="Kafka索引"><a href="#Kafka索引" class="headerlink" title="Kafka索引"></a>Kafka索引</h2><p>Kafka的索引是稀疏索引，这样可以避免索引文件占用过多的内存，从而可以在内存中保存更多的<br>索引。对应的就是Broker 端参数 log.index.interval.bytes 值，默认4KB，即4KB的消息建一条索引。</p>
<p>Kafka中有三大类索引：位移索引、时间戳索引和已中止事务索引。分别对应了.index  .timeIndex<br>.txnindex文件。</p>
<p><img src="/2023/07/27/Kafka%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/1.jpg" alt="1"></p>
<p>与之相关的源码如下：<br>1、AbstractIndex.scala：抽象类，封装了所有索引的公共操作<br>2、OffsetIndex.scala：位移索引，保存了位移值和对应磁盘物理位置的关系<br>3、TimeIndex.scala：时间戳索引，保存了时间戳和对应位移值的关系<br>4、TransactionIndex.scala：事务索引，启用Kafka事务之后才会出现这个索引</p>
<p><img src="/2023/07/27/Kafka%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/2.jpg" alt="1"></p>
<p>成员变量里面还有个 entrySize 。这个变量其实是每个索引项的大小，每个索引项的大小是固定的。</p>
<h3 id="entrySize"><a href="#entrySize" class="headerlink" title="entrySize"></a>entrySize</h3><p>在 OffsetIndex 中是 override def entrySize = 8 ，8个字节。<br>在 TimeIndex 中是 override def entrySize = 12 ,12个字节。</p>
<p>在 OffsetIndex 中，每个索引项存储了位移值和对应的磁盘物理位置，因此4+4=8，但是不对啊，磁盘物理位置是整型没问题，但是 AbstractIndex 的定义baseOffset来看，位移值是长整型，不是应该8个字节么</p>
<p>实际存储的位移值实际上是相对位移值，即真实位移值-baseOffset的值。<br>相对位移用整型存储够么？够，因为一个日志段文件大小的参数 log.segment.bytes 是整型，因此同<br>一个日志段对应的index文件上的位移值-baseOffset的值的差值肯定在整型的范围内</p>
<p>这样做有几个好处：<br>1、为了节省空间，一个索引项节省了4字节，想想那些日消息处理数万亿的公司<br>2、因为内存资源是很宝贵的，索引项越短，内存中能存储的索引项就越多，索引项多了直接命中的概率就高了。这其实和MySQL InnoDB 为何建议主键不宜过长一样。每个辅助索引都会存储主键的值，主键越长，每条索引项占用的内存就越大，缓存页一次从磁盘获取的索引数就越少，一次查询需要访问磁盘次数就可能变多。而磁盘访问我们都知道，很慢</p>
<p><img src="/2023/07/27/Kafka%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/3.jpg" alt="1"></p>
<h3 id="warmEntries"><a href="#warmEntries" class="headerlink" title="_warmEntries"></a>_warmEntries</h3><p>这个属性的用处就涉及到了索引的查找</p>
<p>kafka 无论是消息还是索引都是单调递增的，并且都是追加写入，因此数据都是有序的，在有序的集合中快速查询，就是二分查找<br><img src="/2023/07/27/Kafka%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/4.jpg" alt="1"></p>
<p>索引是在文件末尾追加的写入的，并且一般写入的数据立马就会被读取。所以数据的热点集中在尾部。并且操作系统基本上都是用页为单位缓存和管理内存的，内存又是有限的，因此会通过类LRU机制淘汰内存。</p>
<p>看起来LRU非常适合Kafka的场景，但是使用标准的二分查找会有缺页中断的情况，毕竟二分是跳着访问的</p>
<p>kafka官方注释：当我们查找索引的时候，标准的二分查找对缓存不友好，可能会造成不必要的缺页中断(线程被阻塞等待从磁盘加载没有被缓存到page cache 的数据)</p>
<p><img src="/2023/07/27/Kafka%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/5.jpg" alt="1"></p>
<p>简单的来讲，假设某索引占page cache 13页，此时数据已经写到了12页。按照kafka访问的特性，此时访问的数据都在第12页，因此二分查找的特性，此时缓存页的访问顺序依次是0，6，9，11，12。因为频繁被访问，所以这几页一定存在page cache中。</p>
<p>当第12页不断被填充，满了之后会申请新页第13页保存索引项，而按照二分查找的特性，此时缓存页的访问顺序依次是：0，7，10，12。这7和10很久没被访问到了，很可能已经不再缓存中了，然后需要从磁盘上读取数据。注释说：在他们的测试中，这会导致至少会产生从几毫秒跳到1秒的延迟。</p>
<p>基于以上问题，Kafka使用了改进版的二分查找，改的不是二分查找的内部，而且把所有索引项分为热区和冷区这个改进可以让查询热数据部分时，遍历的Page永远是固定的，这样能避免缺页中断。</p>
<p>看到这里其实我想到了一致性hash，一致性hash相对于普通的hash不就是在node新增的时候缓存的<br>访问固定，或者只需要迁移少部分数据。</p>
<p><img src="/2023/07/27/Kafka%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/6.jpg" alt="1"></p>
<p>现在处理器一般缓存页大小是4096，那么8192可以保证页数小于等3，用于二分查<br>找的页面都能命中</p>
<h3 id="联想到mysql的缓冲池管理"><a href="#联想到mysql的缓冲池管理" class="headerlink" title="联想到mysql的缓冲池管理"></a>联想到mysql的缓冲池管理</h3><p>从上面这波冷热分区我又想到了MySQL的buffer pool管理。MySQL的将缓冲池分为了新生代和老年<br>代。默认是37分，即老年代占3，新生代占7。即看作一个链表的尾部30%为老年代，前面的70%为新生代。替换了标准的LRU淘汰机制。<br>MySQL的缓冲池分区是为了解决预读失效和缓存污染问题。</p>
<p>1、预读失效：因为会预读页，假设预读的页不会用到，那么就白白预读了，因此让预读的页插入的是老年代头部，淘汰也是从老年代尾部淘汰。不会影响新生代数据。</p>
<p>2、缓存污染：在类似like全表扫描的时候，会读取很多冷数据。并且有些查询频率其实很少，因此让这些数据仅仅存在老年代，然后快速淘汰才是正确的选择，MySQL为了解决这种问题，仅仅分代是不够的，还设置了一个时间窗口，默认是1s，即在老年代被再次访问并且存在超过1s，才会晋升到新生代，这样就不会污染新生代的热数据</p>
<h2 id="Kafka日志段读写"><a href="#Kafka日志段读写" class="headerlink" title="Kafka日志段读写"></a>Kafka日志段读写</h2><h3 id="Kafka存储结构"><a href="#Kafka存储结构" class="headerlink" title="Kafka存储结构"></a>Kafka存储结构</h3><p>Kafka的Topic可以有多个分区，分区其实就是最小的读取和存储结构，即Consumer看似订<br>阅的是Topic，实则是从Topic下的某个分区获得消息，Producer也是发送消息也是如此。、<br><img src="/2023/07/27/Kafka%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/7.jpg" alt="1"><br><img src="/2023/07/27/Kafka%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/8.jpg" alt="1"><br>每个分区对应一个Log对象，在磁盘中就是一个子目录，子目录下面会有多组日志段即多Log<br>Segment，每组日志段包含：消息日志文件(以log结尾)、位移索引文件(以index结尾)、时间戳索引文件(以timeindex结尾)。其实还有其它后缀的文件</p>
<h3 id="日志段的定义"><a href="#日志段的定义" class="headerlink" title="日志段的定义"></a>日志段的定义</h3><p>日志的定义：<br><img src="/2023/07/27/Kafka%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/9.jpg" alt="1"><br>日志段的定义：<br><img src="/2023/07/27/Kafka%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/10.jpg" alt="1"></p>
<p>indexIntervalBytes 可以理解为插了多少消息之后再建一个索引，由此可以看出Kafka的索引其实是<br>稀疏索引，这样可以避免索引文件占用过多的内存，从而可以在内存中保存更多的索引。对应的就是Broker 端参数 log.index.interval.bytes 值，默认4KB。</p>
<p>实际的通过索引查找消息过程是先通过offset找到索引所在的文件，然后通过二分法找到离目标最近的索引，再顺序遍历消息文件找到目标文件。这波操作时间复杂度为 O(log2n)+O(m) ,n是索引文件里索引的个数，m为稀疏程度。</p>
<p>再说下 rollJitterMs ,这其实是个扰动值，对应的参数是 log.roll.jitter.ms ,这其实就要说到日志<br>段的切分了， log.segment.bytes ,这个参数控制着日志段文件的大小，默认是1G，即当文件存储超过1G之后就新起一个文件写入。这是以大小为维度的，还有一个参数是 log.segment.ms ,以时间为维度切分。</p>
<p>那配置了这个参数之后如果有很多很多分区，然后因为这个参数是全局的，因此同一时刻需要做很多文件的切分，这磁盘IO就顶不住了啊，因此需要设置个 rollJitterMs ，来岔开它们。</p>
<h3 id="日志段写入"><a href="#日志段写入" class="headerlink" title="日志段写入"></a>日志段写入</h3><p><img src="/2023/07/27/Kafka%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/11.jpg" alt="1"></p>
<p>1、判断下当前日志段是否为空，空的话记录下时间，来作为之后日志段的切分依据<br>2、确保位移值合法，最终调用的是 AbstractIndex.toRelative(..) 方法，即使判断offset是否小于<br>0，是否大于int最大值。<br>3、append消息，实际上就是通过 FileChannel 将消息写入，当然只是写入内存中及页缓存，是否刷<br>盘看配置。<br>4、更新日志段最大时间戳和最大时间戳对应的位移值。这个时间戳其实用来作为定期删除日志的依据<br>5、更新索引项，如果需要的话 (bytesSinceLastIndexEntry &gt; indexIntervalBytes)<br>流程图：<br><img src="/2023/07/27/Kafka%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/12.jpg" alt="1"></p>
<h3 id="日志段读取"><a href="#日志段读取" class="headerlink" title="日志段读取"></a>日志段读取</h3><p><img src="/2023/07/27/Kafka%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/13.jpg" alt="1"></p>
<p>1、根据第一条消息的offset，通过 OffsetIndex 找到对应的消息所在的物理位置和大小。<br>2、获取 LogOffsetMetadata ,元数据包含消息的offset、消息所在segment的起始offset和物理位置<br>3、判断 minOneMessage 是否为 true ,若是则调整为必定返回一条消息大小，其实就是在单条消息大于maxSize 的情况下得以返回，防止消费者饿死<br>4、再计算最大的 fetchSize ,即（最大物理位移-此消息起始物理位移）和 adjustedMaxSize 的最小值(这波我不是很懂，因为以上一波操作 adjustedMaxSize 已经最小为一条消息的大小了)<br>5、调用 FileRecords 的 slice 方法从指定位置读取指定大小的消息集合，并且构造FetchDataInfo 返回</p>
<p>流程图：<br><img src="/2023/07/27/Kafka%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/14.jpg" alt="1"></p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU cache</title>
    <url>/2021/01/27/LRU%20CACHE/</url>
    <content><![CDATA[<p>Lru Cache算法就是LeastRecentlyUsed，意思就是最近最少使用，当缓存满了的时候，不经常使用的就直接删除，挪出空间来缓存新的对象</p>
<p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p>
<p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p>
<p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置</p>
<p>首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1) 的时间内完成 get 或者 put 操作</p>
<p>本质是一个map集合，然后把map集合里的元素，放到了一个双向链表里，常用的放前面，不常用放后面</p>
<p>golang实现LRU cache</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体</span></span><br><span class="line">type LRUCache struct &#123;</span><br><span class="line">    size int 		<span class="comment">// 大小</span></span><br><span class="line">    capacity int 	<span class="comment">// 容量</span></span><br><span class="line">    cache map[int]*DLinkedNode 	<span class="comment">//	hashmap，双向链表，根据key值查找node</span></span><br><span class="line">    head, tail *DLinkedNode 	<span class="comment">// 头指针， 尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line">type DLinkedNode struct &#123;</span><br><span class="line">    key, value int <span class="comment">// key值，value值</span></span><br><span class="line">    prev, next *DLinkedNode <span class="comment">// 先前指针，后序指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line">func initDLinkedNode(key, value int) *DLinkedNode &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;DLinkedNode&#123;</span><br><span class="line">        key: key,</span><br><span class="line">        value: value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化一个lru cache</span></span><br><span class="line">func Constructor(capacity int) LRUCache &#123;</span><br><span class="line">	<span class="comment">// 初始化结构体</span></span><br><span class="line">    l := LRUCache&#123;</span><br><span class="line">        cache: map[int]*DLinkedNode&#123;&#125;,</span><br><span class="line">        head: initDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        tail: initDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        capacity: capacity,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头指针指向尾指针</span></span><br><span class="line">    l.head.next = l.tail</span><br><span class="line">    <span class="comment">// 尾指针指向头指针</span></span><br><span class="line">    l.tail.prev = l.head</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="built_in">this</span> *LRUCache) Get(key int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> _, <span class="attr">ok</span> := <span class="built_in">this</span>.cache[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据key取出值</span></span><br><span class="line">    node := <span class="built_in">this</span>.cache[key]</span><br><span class="line">    <span class="comment">// 放入头部</span></span><br><span class="line">    <span class="built_in">this</span>.moveToHead(node)</span><br><span class="line">    <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放入元素</span></span><br><span class="line">func (<span class="built_in">this</span> *LRUCache) <span class="function"><span class="title">Put</span>(<span class="params">key int, value int</span>)</span>  &#123;</span><br><span class="line">	<span class="comment">// 如果key不是在cache里</span></span><br><span class="line">    <span class="keyword">if</span> _, <span class="attr">ok</span> := <span class="built_in">this</span>.cache[key]; !ok &#123;</span><br><span class="line">    	<span class="comment">// 创建一个新的节点</span></span><br><span class="line">        node := initDLinkedNode(key, value)</span><br><span class="line">        <span class="comment">// 将新的节点放到head</span></span><br><span class="line">        <span class="built_in">this</span>.cache[key] = node</span><br><span class="line">        <span class="built_in">this</span>.addToHead(node)</span><br><span class="line">        <span class="comment">// 大小加1</span></span><br><span class="line">        <span class="built_in">this</span>.size++</span><br><span class="line">        <span class="comment">// 如果数量大于容量</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">this</span>.size &gt; <span class="built_in">this</span>.capacity &#123;</span><br><span class="line">        	<span class="comment">// 删除尾指针的node&#x27;</span></span><br><span class="line">            removed := <span class="built_in">this</span>.removeTail()</span><br><span class="line">            <span class="comment">// 删除字典中的key数据</span></span><br><span class="line">            <span class="keyword">delete</span>(<span class="built_in">this</span>.cache, removed.key)</span><br><span class="line">            <span class="built_in">this</span>.size--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 如果在字典里，则再次放入的话提高了了频次，移动到头部</span></span><br><span class="line">        node := <span class="built_in">this</span>.cache[key]</span><br><span class="line">        node.value = value</span><br><span class="line">        <span class="built_in">this</span>.moveToHead(node)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="built_in">this</span> *LRUCache) <span class="function"><span class="title">addToHead</span>(<span class="params">node *DLinkedNode</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 头部添加，node的前面指向head</span></span><br><span class="line">    node.prev = <span class="built_in">this</span>.head</span><br><span class="line">    <span class="comment">// node的next指向原先head的next</span></span><br><span class="line">    node.next = <span class="built_in">this</span>.head.next</span><br><span class="line">    <span class="comment">// head的next的前面指向node</span></span><br><span class="line">    <span class="built_in">this</span>.head.next.prev = node</span><br><span class="line">    <span class="comment">// head的next指向node</span></span><br><span class="line">    <span class="built_in">this</span>.head.next = node</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除node节点</span></span><br><span class="line">func (<span class="built_in">this</span> *LRUCache) <span class="function"><span class="title">removeNode</span>(<span class="params">node *DLinkedNode</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// node前面的节点的next指向node的next</span></span><br><span class="line">    node.prev.next = node.next</span><br><span class="line">    <span class="comment">// node的next的前面指向node的前面</span></span><br><span class="line">    node.next.prev = node.prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="built_in">this</span> *LRUCache) <span class="function"><span class="title">moveToHead</span>(<span class="params">node *DLinkedNode</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 先删除node</span></span><br><span class="line">    <span class="built_in">this</span>.removeNode(node)</span><br><span class="line">    <span class="comment">// 再把node加入到前面</span></span><br><span class="line">    <span class="built_in">this</span>.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="built_in">this</span> *LRUCache) removeTail() *DLinkedNode &#123;</span><br><span class="line">	<span class="comment">// 这个时候新的node已经加到前面了，所以要删除的是tail前面的prev</span></span><br><span class="line">    node := <span class="built_in">this</span>.tail.prev</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="built_in">this</span>.removeNode(node)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql的常用命令</title>
    <url>/2018/04/03/Mysql%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Mysql两种引擎的区别"><a href="#Mysql两种引擎的区别" class="headerlink" title="Mysql两种引擎的区别"></a>Mysql两种引擎的区别</h2><h3 id="Innodb引擎"><a href="#Innodb引擎" class="headerlink" title="Innodb引擎"></a>Innodb引擎</h3><p>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p>
<h3 id="MyIASM引擎"><a href="#MyIASM引擎" class="headerlink" title="MyIASM引擎"></a>MyIASM引擎</h3><p>MyIASM引擎没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。</p>
<h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><p>1、MyIASM是非事务安全的，而InnoDB是事务安全的</p>
<p>2、MyIASM锁的粒度是表级的，而InnoDB支持行级锁</p>
<p>3、MyIASM支持全文类型索引，而InnoDB不支持全文索引</p>
<p>4、MyIASM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyIASM</p>
<p>5、MyIASM表保存成文件形式，跨平台使用更加方便</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、MyIASM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyIASM<br>2、InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h3><p>1.整数：<code>int</code><br>2.小数：<code>decinal（总位数，小数位数）</code><br>3.字符串：<code>varchar（可变长度），char（固定长度）</code><br>4.日期时间：<code>datetime</code><br>5.枚举类型：<code>（enum）‘选择’</code></p>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>

<h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">quit/exit</span><br></pre></td></tr></table></figure>

<h4 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select version()；</span><br></pre></td></tr></table></figure>

<h4 id="显示时间"><a href="#显示时间" class="headerlink" title="显示时间"></a>显示时间</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select now()；</span><br></pre></td></tr></table></figure>

<h4 id="查看当前使用数据库"><a href="#查看当前使用数据库" class="headerlink" title="查看当前使用数据库"></a>查看当前使用数据库</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select datebase（）；</span><br></pre></td></tr></table></figure>

<h4 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select databases();</span><br></pre></td></tr></table></figure>

<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">create database 数据库名；</span><br></pre></td></tr></table></figure>

<h4 id="查看字符集"><a href="#查看字符集" class="headerlink" title="查看字符集"></a>查看字符集</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">show create database 数据库名；</span><br></pre></td></tr></table></figure>

<h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">drop database 数据库名；</span><br></pre></td></tr></table></figure>

<h4 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">use 数据库名；</span><br></pre></td></tr></table></figure>

<h4 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mysql dump -uroot -p 数据库名 &gt; 文件名.sql</span><br></pre></td></tr></table></figure>

<h4 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mysql dump -uroot -p 数据库名 &lt; 文件名.sql</span><br></pre></td></tr></table></figure>

<h4 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">source 文件名.sql</span><br></pre></td></tr></table></figure>

<h3 id="数据表的操作"><a href="#数据表的操作" class="headerlink" title="数据表的操作"></a>数据表的操作</h3><h4 id="查看所有表"><a href="#查看所有表" class="headerlink" title="查看所有表"></a>查看所有表</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>

<h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">create table 表名(id int unsigned...)</span><br></pre></td></tr></table></figure>

<h4 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">desc 表名</span><br></pre></td></tr></table></figure>

<h4 id="查看字符集-1"><a href="#查看字符集-1" class="headerlink" title="查看字符集"></a>查看字符集</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">show create table 表名;</span><br></pre></td></tr></table></figure>

<h4 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alter table 表名 add 字段名 数据类型;</span><br></pre></td></tr></table></figure>

<h4 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alter table 表名 modify 字段名 约束;</span><br><span class="line">alter table 表名 change 原名 新名 约束；</span><br></pre></td></tr></table></figure>

<h4 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop 字段名;</span><br></pre></td></tr></table></figure>

<h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">drop table 表名;</span><br></pre></td></tr></table></figure>

<h3 id="数据的操作"><a href="#数据的操作" class="headerlink" title="数据的操作"></a>数据的操作</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">insert into 表名 values (),(); # 数据，()按字段位置写入(),()是多行插入</span><br></pre></td></tr></table></figure>

<h4 id="部分插入"><a href="#部分插入" class="headerlink" title="部分插入"></a>部分插入</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">insert into 表名（字段名） values ();</span><br></pre></td></tr></table></figure>

<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">update 表名 set 字段名=‘’ where 条件；</span><br></pre></td></tr></table></figure>

<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 where 条件；</span><br></pre></td></tr></table></figure>

<h3 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h3><h4 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select * <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure>

<h4 id="查看字段数据，起名"><a href="#查看字段数据，起名" class="headerlink" title="查看字段数据，起名"></a>查看字段数据，起名</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select 表名.字段名 <span class="keyword">as</span> <span class="string">&#x27;别名&#x27;</span> <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure>

<h4 id="去重复"><a href="#去重复" class="headerlink" title="去重复"></a>去重复</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select distinct 字段 <span class="keyword">from</span> 表名；</span><br><span class="line">select key <span class="keyword">from</span> 表 group by key having count (*)&gt;<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>并不会修改数据。</p>
<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">select * <span class="keyword">from</span> 表名 where 字段名 &gt; &lt; &gt;= &lt;= != 或&lt;&gt;</span><br><span class="line"># 也可以在条件里加逻辑 and 、or、  not（条件）、</span><br></pre></td></tr></table></figure>

<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">where like ‘小%’ # 以小字为开头的</span><br><span class="line">% 替换任意个</span><br><span class="line">_ 替换一个</span><br></pre></td></tr></table></figure>

<h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">where  字段名 in （）；# 具体值</span><br><span class="line">not <span class="keyword">in</span></span><br><span class="line">（not）between and # 区间查询</span><br></pre></td></tr></table></figure>

<h4 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">where 字段 is <span class="literal">null</span> （not <span class="literal">null</span>）；</span><br></pre></td></tr></table></figure>

<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select * <span class="keyword">from</span> 表名 order by 字段 asc；升序 （desc 降序）；</span><br></pre></td></tr></table></figure>

<h4 id="分组（按字段分组）"><a href="#分组（按字段分组）" class="headerlink" title="分组（按字段分组）"></a>分组（按字段分组）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select 字段 <span class="keyword">from</span> 表名 group by 字段；</span><br></pre></td></tr></table></figure>

<h4 id="各个小组数据"><a href="#各个小组数据" class="headerlink" title="各个小组数据"></a>各个小组数据</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select count（*）.字段一 【group_concat(字段二)】.字段一 <span class="keyword">from</span> 表名 group by 字段一 having 条件；</span><br></pre></td></tr></table></figure>
<p>按这个字段一分组，该组的统计，该组的字段二数据<br>注意： 这里的条件用having 不用where</p>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">select * from 表名 limit 0,5；# 第一个参数从第几页开始（显示个数*（第几页-1）），第二个参数显示数量</span><br></pre></td></tr></table></figure>
<p>分页是为了限制查询，防止数据过大，limit放最后</p>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><h4 id="统计个数"><a href="#统计个数" class="headerlink" title="统计个数"></a>统计个数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select count（*） <span class="keyword">from</span> 表名 where 条件；</span><br></pre></td></tr></table></figure>

<h4 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select max（字段）<span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>

<h4 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select min（字段）<span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>

<h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select sum（字段） <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>

<h4 id="平均"><a href="#平均" class="headerlink" title="平均"></a>平均</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">select round（avg（字段）） from 表名；# 保留小数</span><br></pre></td></tr></table></figure>

<h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><h4 id="关联查询-1"><a href="#关联查询-1" class="headerlink" title="关联查询"></a>关联查询</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select * <span class="keyword">from</span> 表一 inner join 表二 on 表一.字段=表二.字段；</span><br></pre></td></tr></table></figure>
<p>将表一的字段按表二的字段对应，合成一个表查询<br>后面的表是大表</p>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select * <span class="keyword">from</span>表 where 字段 &gt; (上一个表的查询结果)；</span><br></pre></td></tr></table></figure>

<h4 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select * <span class="keyword">from</span> 表名 <span class="keyword">as</span> 别名一 inner join 表名 <span class="keyword">as</span> 别名二 on 别名一.字段 =别名二.字段</span><br></pre></td></tr></table></figure>

<h4 id="外键关联"><a href="#外键关联" class="headerlink" title="外键关联"></a>外键关联</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alter table 表一 addforeignkey（字段） references 表二（字段）；</span><br></pre></td></tr></table></figure>




<h3 id="拆表"><a href="#拆表" class="headerlink" title="拆表"></a>拆表</h3><p>已知表一</p>
<h4 id="创建表二"><a href="#创建表二" class="headerlink" title="创建表二"></a>创建表二</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">create table <span class="keyword">if</span> not exists （字段属性）</span><br></pre></td></tr></table></figure>
<p>if not exists 如果不存在</p>
<h4 id="将表一的数据分组"><a href="#将表一的数据分组" class="headerlink" title="将表一的数据分组"></a>将表一的数据分组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">select 字段<span class="keyword">from</span> 表一 group by 字段</span><br></pre></td></tr></table></figure>

<h4 id="插入新表二"><a href="#插入新表二" class="headerlink" title="插入新表二"></a>插入新表二</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">insert into 表二（字段） （第二步查询语句）</span><br></pre></td></tr></table></figure>
<p>用子查询</p>
<h4 id="连接两个表，更新表一字段为表二的连接字段"><a href="#连接两个表，更新表一字段为表二的连接字段" class="headerlink" title="连接两个表，更新表一字段为表二的连接字段"></a>连接两个表，更新表一字段为表二的连接字段</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">update（select * <span class="keyword">from</span> 表一 inner join 表二 on 表二.字段 = 表一.字段） set 表一.字段= 表二.字段</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql相关问题</title>
    <url>/2021/01/06/Mysql%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="为什么-B-树比-B-树更适合应用于数据库索引"><a href="#为什么-B-树比-B-树更适合应用于数据库索引" class="headerlink" title="为什么 B+ 树比 B 树更适合应用于数据库索引"></a>为什么 B+ 树比 B 树更适合应用于数据库索引</h3><p>查找一步步优化</p>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>自适应哈希索引就是用哈希表实现的，用哈希表实现索引的好处是非常明显的，查找单个指定数据只需要 O(1) 的时间复杂度</p>
<p>但是哈希表本身是无序的，不利于范围查询</p>
<h4 id="二分查找优化"><a href="#二分查找优化" class="headerlink" title="二分查找优化"></a>二分查找优化</h4><p>数据存有序数组，基于二分查找</p>
<p>二分查找o(logn),范围查询可以通过二分查找实现，但是不利于插入删除</p>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>为了优化插入删除，引入二叉搜索树</p>
<p>1.若任意结点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值。</p>
<p>2.若任意结点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值。</p>
<p>3.任意结点的左、右子树也分别为二叉搜索树</p>
<p>但是当树退化，高度差过大，会导致查询变慢，二叉搜索平衡树，AVL树</p>
<h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>自平衡二叉搜索树</p>
<p>维护AVL 树也是需要一定开销的，即当树插入/更新/删除新的数据时假设破坏了树的平衡性，那么需要通过左旋和右旋来维护树的平衡</p>
<p>AVL 树的查找效率为 O(log n)，也就是说，当树过高时，查找效率会下降</p>
<p>索引文件并不小，所以是存储在磁盘上的。</p>
<p>文件系统需要从磁盘读取数据时，一般以页为单位进行读取，假设一个页内的数据过少，<br>那么操作系统就需要读取更多的页，涉及磁盘随机 I/O 访问的次数就更多。</p>
<p>树越高，每一页读取的数据就越少</p>
<p>将数据从磁盘读入内存涉及随机 I/O 的访问，是数据库里面成本最高的操作之一</p>
<p>AVL树既有链表的快速插入与删除操作的特点，又有数组快速查找的优势，但是这并不是最符合磁盘读写特征的数据结构</p>
<h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>为了优化树高，将AVL树变为B树，二叉树变为m叉树，B树，多路平衡查找树</p>
<p>1.排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</p>
<p>2.子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</p>
<p>3.关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</p>
<p>4.所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</p>
<p>关键字数量大于等于ceil(m/2)-1个且小于等于M-1个</p>
<p>二叉树变成 m 叉树，这个 m 的大小可以根据单个页的大小做对应调整，从而使得一个页可以存储更多的数据，从磁盘中读取一个页可以读到的数据就更多，随机 IO 次数变少，大大提升效率</p>
<p>B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;</p>
<p>但是只能通过中序遍历查询全表，当进行范围查询时，可能会需要中序回溯</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+树在B树的基础上加了以下优化：</p>
<p>1.叶子结点增加了指针进行连接，即叶子结点间形成了链表；</p>
<p>2.非叶子结点只存关键字 key，不再存储数据，只在叶子结点存储数据；</p>
<p>说明：叶子之间用双向链表连接比单向链表连接多出的好处是通过链表中任一结点都可以通过往前或者往后遍历找到链表中指定的其他结点。</p>
<p>范围查询时可以通过访问叶子节点的链表进行有序遍历，而不再需要中序回溯访问结点。</p>
<p>非叶子结点只存储关键字key，一方面这种结构相当于划分出了更多的范围，加快了查询速度，另一方面相当于单个索引值大小变小，同一个页可以存储更多的关键字，读取单个页就可以得到更多的关键字，可检索的范围变大了，相对 IO 读写次数就降低了。</p>
<p>由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</p>
<h4 id="B树与B-树区别"><a href="#B树与B-树区别" class="headerlink" title="B树与B+树区别"></a>B树与B+树区别</h4><p>1、B 树非叶子结点和叶子结点都存储数据,因此查询数据时，时间复杂度最好为 O(1),最坏为 O(log n)，B+树只在叶子结点存储数据，非叶子结点存储关键字，且不同非叶子结点的关键字可能重复，因此查询数据时，时间复杂度固定为 O(log n)</p>
<p>2、B+ 树叶子结点之间用链表相互连接，因而只需扫描叶子结点的链表就可以完成一次遍历操作，B树只能通过中序遍历</p>
<h4 id="为什么更适合B-树"><a href="#为什么更适合B-树" class="headerlink" title="为什么更适合B+树"></a>为什么更适合B+树</h4><p>1、B+ 树相比 B 树减少了 磁盘I/O 读写的次数。由于索引文件很大因此索引文件存储在磁盘上，B+ 树的非叶子结点只存关键字不存数据，因而单个页可以存储更多的关键字，即一次性读入内存的需要查找的关键字也就越多，磁盘的随机 I/O 读取次数相对就减少了</p>
<p>2、B+树查询效率更加稳定，只查叶子节点，稳定ologn</p>
<p>3、范围查询，扫表，因为叶子节点是双向链表连接，方便范围查询，B树只能中序遍历</p>
<h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B* 树"></a>B* 树</h4><p>优化了B+树的子节点关键字个数，2/3m</p>
<p>B+树节点满的时候会分裂，B* 树，存有兄弟节点的指针，B* 树节点满时会检查兄弟节点是否满， 不满就放到兄弟节点，都满了，就各拿出1/3得到新的节点</p>
<p>从平衡二叉树、B树、B+树、B* 树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度</p>
<p>不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的</p>
<h3 id="索引相关"><a href="#索引相关" class="headerlink" title="索引相关"></a>索引相关</h3><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>快速访问数据表中的特定信息，提高检索速度<br>创建唯一性索引，保证数据库表中每一行数据的唯一性</p>
<p>创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度</p>
<p>在最频繁使用的、用以缩小查询范围的字段上建立索引。</p>
<p>在频繁使用的、需要排序的字段上建立索引</p>
<p>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引</p>
<p>特殊字段text，不宜建立索引</p>
<h4 id="索引优点"><a href="#索引优点" class="headerlink" title="索引优点"></a>索引优点</h4><p>大大减少了服务器需要扫描的数据行数。</p>
<p>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</p>
<p>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）</p>
<p>索引虽然会提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件</p>
<h4 id="聚集索引，非聚集索引，覆盖索引"><a href="#聚集索引，非聚集索引，覆盖索引" class="headerlink" title="聚集索引，非聚集索引，覆盖索引"></a>聚集索引，非聚集索引，覆盖索引</h4><p>索引创建的辅助索引，非主键索引，辅助索引的索引树存储的是主键ID，key是该字段，辅助索引（也成二级索引）存储的数据是主键值，称为非聚集索引</p>
<p>主键索引，存储的是一整行的数据，key是主键ID，叫做聚集索引，即叶子节点中，存储的是整行数据</p>
<p>如果通过辅助索引查询的数据不是主键值，要查的是整行数据，就需要通过辅助索引查到主键，再根据主键去主键索引查整行数据</p>
<p>这个回到主键索引树上去查找的过程，叫做回表</p>
<p>需要经过再一次的逻辑IO访问</p>
<p>减少回表，覆盖索引</p>
<p>不一定,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.</p>
<p>再辅助索引树上完成查询就是覆盖索引，不需要回表</p>
<p>覆盖索引不需要回表，查询操作在辅助索引树上就可以完成，减少了回表次数，因此可以减少大量的IO次数</p>
<p>对于统计而言，假设操作在覆盖索引上可以完成，也可以减少大量的IO操作</p>
<h4 id="联合索引，最左匹配原则"><a href="#联合索引，最左匹配原则" class="headerlink" title="联合索引，最左匹配原则"></a>联合索引，最左匹配原则</h4><p>创建了一个联合索引indext(a,b,c)，实际上是创建了三个索引</p>
<p>MySQL建立联合索引时会遵循最左前缀匹配的原则，在检索数据时从联合索引的最左边开始匹配 </p>
<h4 id="索引生效，失效条件"><a href="#索引生效，失效条件" class="headerlink" title="索引生效，失效条件"></a>索引生效，失效条件</h4><p>Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index （a,b,c）。 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效</p>
<p>创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处</p>
<p>(1)    select * from myTest  where a=3 and b=5 and c=4;   —-  abc顺序<br>abc三个索引都在where条件里面用到了，而且都发挥了作用</p>
<p>(2)    select * from myTest  where  c=4 and b=6 and a=3;<br>where里面的条件顺序在查询之前会被mysql自动优化，效果跟上一句一样</p>
<p>(3)    select * from myTest  where a=3 and c=7;<br>a用到索引，b没有用，所以c是没有用到索引效果的</p>
<p>(4)    select * from myTest  where a=3 and b&gt;7 and c=3;     —- b范围值，断点，阻塞了c的索引<br>a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引</p>
<p>(5)    select * from myTest  where b=3 and c=4;   — 联合索引必须按照顺序使用，并且需要全部使用<br>因为a索引没有使用，所以这里 bc都没有用上索引效果</p>
<p>(6)    select * from myTest  where a&gt;4 and b=7 and c=9;<br>a用到了  b没有使用，c没有使用</p>
<p>(7)    select * from myTest  where a=3 order by b;<br>a用到了索引，b在结果排序中也用到了索引的效果，a下面任意一段的b是排好序的</p>
<p>(8)    select * from myTest  where a=3 order by c;<br>a用到了索引，但是这个地方c没有发挥排序效果，因为中间断点了，使用 explain 可以看到 filesort</p>
<p>(9)    select * from mytable where b=3 order by a;<br>b没有用到索引，排序中a也没有发挥索引效果</p>
<p>不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</p>
<p>存储引擎不能使用索引范围条件右边的列</p>
<p>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *</p>
<p>mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</p>
<p>is null,is not null也无法使用索引   —-  此处存在疑问，经测试确实可以使用，ref和const等级，并不是all</p>
<p>like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操作。</p>
<p>所以设计索引，范围查询要放在最后面，列过滤的频繁程度越高，越放在前面</p>
<h3 id="大库DDL操作"><a href="#大库DDL操作" class="headerlink" title="大库DDL操作"></a>大库DDL操作</h3><p>修改表结构，字段，创建表等</p>
<p>1、不要在业务高峰期执行</p>
<p>2、执行DDL前，先看一下库中是否有未提交的事务，注意查看事务information_schema.innodb_trx表</p>
<p>3、随时关注服务器日志状况，已有问题要先行解决。show processlist也可以发现一些问题</p>
<p>4、特别危险的操作一定先在预生产环境或测试环境先行模拟，评估风险。</p>
<p>5、尽量避免 kill 会话进程，可能会在某些情况造成数据问题。</p>
<p>6、研发时，预计表就会比较大的时候，要多评审几次，多留一些预置字段，避免DDL操作。</p>
<h3 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h3><p>1、分库分表，能不分就不分</p>
<p>MySQL 是关系数据库，数据库表之间的关系从一定的角度上映射了业务逻辑。任何分库分表的行为都会在某种程度上提升业务逻辑的复杂度</p>
<p>分库分表会带来数据的合并，查询或者更新条件的分离，事务的分离等等多种后果，业务实现的复杂程度往往会翻倍或者指数级上升。所以，在分库分表之前，不要为分而分，去做其他力所能及的事情吧，例如升级硬件，升级，升级网络，升级数据库版本，读写分离，负载均衡等等。所有分库分表的前提是，这些你已经尽力了</p>
<p>2、某些字段垂直拆分</p>
<p>频繁更新的字段，拆分出去，减少update压力</p>
<p>3、日志表，大增长表，水平拆分</p>
<p>4、慢sql调优，慢sql记录，然后区分子服务拆分</p>
<h3 id="超大分页问题"><a href="#超大分页问题" class="headerlink" title="超大分页问题"></a>超大分页问题</h3><p>offset并不是跳过N行，而是都查出来，舍弃前面的跳过行，当跳过很大时，就会比较慢，效率比较低</p>
<p>先锁定id，然后关联根据id查，或者先预估数据，缓存</p>
<h3 id="纵向分表与横向分表"><a href="#纵向分表与横向分表" class="headerlink" title="纵向分表与横向分表"></a>纵向分表与横向分表</h3><p>纵向分表：把不经常使用的，按列拆分出去，单独查询</p>
<p>横向分表：按行分表</p>
<h4 id="分布式解决"><a href="#分布式解决" class="headerlink" title="分布式解决"></a>分布式解决</h4><p>1、单数据库可以用本地事务搞定，使用多数据库就只能通过分布式事务解决了。</p>
<p>常用解决方案有：基于可靠消息（MQ）的解决方案、两阶段事务提交、柔性事务</p>
<p>2、在使用 SQL 时 order by， limit 等关键字需要特殊处理，一般来说采用分片的思路：</p>
<p>先在每个分片上执行相应的函数，然后将各个分片的结果集进行汇总和再次计算，最终得到结果</p>
<p>3、分库分表id问题：UUid, 号段模式</p>
<h3 id="mysql隔离级别"><a href="#mysql隔离级别" class="headerlink" title="mysql隔离级别"></a>mysql隔离级别</h3><p>mysql事务的隔离性</p>
<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，读到了最终不一定存在的数据</p>
<h4 id="可重复度、不可重复读"><a href="#可重复度、不可重复读" class="headerlink" title="可重复度、不可重复读"></a>可重复度、不可重复读</h4><p>可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的</p>
<p>不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响</p>
<p>针对更新</p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>幻读是针对数据插入（INSERT）操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>读未提交（READ UNCOMMITTED）<br>读提交 （READ COMMITTED）<br>可重复读 （REPEATABLE READ）<br>串行化 （SERIALIZABLE）</p>
<p>隔离强度逐渐增强，性能逐渐变差</p>
<p><img src="/2021/01/06/Mysql%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/1.jpg" alt="1"></p>
<p>查看隔离级别<br>show variables like ‘tx_isolation’</p>
<p>设置隔离级别<br>SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}</p>
<p>MySQL事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。而读未提交隔离级别是不加锁的，所以它的性能是最好的，但同时也是安全系数最低的</p>
<p>mysql默认可重复读</p>
<h5 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h5><p>不加锁，没有隔离</p>
<p>可以读到其他事务未提交的数据，但没有办法保证你读到的数据最终一定是提交后的数据，如果中间发生回滚，那就会出现脏数据问题</p>
<h5 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h5><p>读提交就是一个事务只能读到其他事务已经提交过的数据，也就是其他事务调用 commit 命令之后的数据。但是在同一事务中，事务的不同时刻同样的查询条件，查询出来的记录内容是不一样的，事务A的提交影响了事务B的查询结果，这就是不可重复读</p>
<h5 id="可重复度"><a href="#可重复度" class="headerlink" title="可重复度"></a>可重复度</h5><p>实现可重复度：MVVC版本控制</p>
<p>一行记录可能实际上有多个版本，每个版本的记录除了有数据本身外，还要有一个表示版本的字段，记为 row trx_id，也就是事务id</p>
<p>可重复读是在事务开始的时候生成一个当前事务全局性的快照，而读提交则是每次执行语句的时候都重新生成一次快照，并符合以下规则：</p>
<p>1、当前事务内的更新，可以读到<br>2、版本未提交，不能读到<br>3、版本已提交，但是却在快照创建后提交的，不能读到<br>4、版本已提交，且是在快照创建前提交的，可以读到</p>
<p>并发写问题：</p>
<p>事务A执行 update 操作， update 的时候要对所修改的行加行锁，这个行锁会在提交之后才释放。而在事务A提交之前，事务B也想 update 这行数据，于是申请行锁，但是由于已经被事务A占有，事务B是申请不到的，此时，事务B就会一直处于等待状态，直到事务A提交，事务B才能继续执行，如果事务A的时间太长，那么事务B很有可能出现超时异常</p>
<p>加锁分为有索引和无索引：有索引可以直接拿到id对该行加锁，无索引，mysql会把所有行都加锁，然后再逐一比对释放锁，开销极大，所以要合理设计索引</p>
<p>解决幻读：</p>
<p>使用间隙锁，mysql的底层是b+树，叶子节点是双向链表，会把索引拆分几个区间，对于操作的记录加行锁，操作记录的两边加间隙锁（Next-Key），防止其他事务插入</p>
<p>事务不会读到其他事务对已有数据的修改，及时其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是，对于其他事务新插入的数据是可以读到的，这也就引发了幻读问题</p>
<h5 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h5><p>读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读</p>
<p>串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就相当于单线程，后一个事务的执行必须等待前一个事务结束</p>
<h3 id="一条sql语句是如何执行的"><a href="#一条sql语句是如何执行的" class="headerlink" title="一条sql语句是如何执行的"></a>一条sql语句是如何执行的</h3><p>查询语句：</p>
<p>1、检查该语句是否有权限，没有权限直接返回错误</p>
<p>2、有权限直接查询缓存，有缓存直接返回</p>
<p>3、分析器提取语句的关键词，确认是什么操作</p>
<p>4、选择优化方案</p>
<p>5、权限校验，通过则调引擎接口查询结果</p>
<p>更新语句：</p>
<p>先查询，然后更新，记录日志，会有两阶段记录日志，redolog， binlog两个日志 模块，解决数据一致性问题</p>
<p>判断redo log 是否完整，如果判断是完整的，就立即提交。<br>如果redo log 只是预提交但不是commit状态，这个时候就会去判断binlog是否完整，如果完整就提交 redo log, 不完整就回滚事务</p>
<h3 id="主从复制与一致性问题"><a href="#主从复制与一致性问题" class="headerlink" title="主从复制与一致性问题"></a>主从复制与一致性问题</h3><p>异步复制，不关心从库，直接返回</p>
<p>同步复制，等待从库同步完毕，事务执行时间会延长，强一致性</p>
<p>半同步复制：等待从库同步一个，写到redolog后，然后主的应答，从库剩余的写入</p>
<h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><p>1、mysql主库事件记录在binlog</p>
<p>2、主库将日志推到从库relog</p>
<p>3、从库根据relog做变更操作</p>
<h3 id="乐观锁，悲观锁"><a href="#乐观锁，悲观锁" class="headerlink" title="乐观锁，悲观锁"></a>乐观锁，悲观锁</h3><p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量</p>
<p>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</p>
<h3 id="explain分析查询语句"><a href="#explain分析查询语句" class="headerlink" title="explain分析查询语句"></a>explain分析查询语句</h3><p>explain是否使用索引，是否使用子查询，可选择索引 ，实际使用索引，扫描的行数</p>
<p>索引查询类型：<br>system 表只有一行</p>
<p>const 主键，索引查询 只有一行匹配</p>
<p>eq_ref 连接查询，只有一行</p>
<p>ref 使用非唯一索引</p>
<p>range 范围查询</p>
<p>index 只扫描索引树</p>
<p>all全表扫描</p>
<h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><p>不要select * ，只返回需要的数据</p>
<p>只返回需要的行 limit</p>
<p>切分大查询 </p>
<h3 id="查询缓存的问题QC"><a href="#查询缓存的问题QC" class="headerlink" title="查询缓存的问题QC"></a>查询缓存的问题QC</h3><p>同样的sql语句可以缓存，频繁更新的那种不适合缓存</p>
<p>缓存失效比较频繁的原因就是，只要我们一对表进行更新，那这个表所有的缓存都会被清空</p>
<h3 id="优化like查询"><a href="#优化like查询" class="headerlink" title="优化like查询"></a>优化like查询</h3><h4 id="优化1：icp"><a href="#优化1：icp" class="headerlink" title="优化1：icp"></a>优化1：icp</h4><p>like查询不能使用索引，优化：mysql ICP特性，5.6开启了</p>
<p>关闭ICP特性情况下：</p>
<p>storage层：只将满足index key条件的索引记录对应的整行记录取出，返回给server层</p>
<p>server 层：对返回的数据，使用后面的where条件过滤，直至返回</p>
<p>打开情况下：<br>storage层：</p>
<p>首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤</p>
<p>将满足的index filter条件的索引记录才去回表取出整行记录返回server层</p>
<p>不满足index filter条件的索引记录丢弃，不回表、也不会返回server层</p>
<p>server 层：对返回的数据，使用table filter条件做最后的过滤。</p>
<p>使用ICP后，直接就去掉了不满足index filter条件的记录，</p>
<p>省去了他们回表和传递到server层的成本</p>
<p>优化：配合复合索引使用，利用icp特性，减少不必要的数据扫描。然而对于单列like，无法利用icp特性，但是可以覆盖索引减少回表</p>
<h4 id="优化2：全文索引"><a href="#优化2：全文索引" class="headerlink" title="优化2：全文索引"></a>优化2：全文索引</h4><p>MySQL 5.6开始支持全文索引，可以在变长的字符串类型上创建全文索引，来加速模糊匹配业务场景的DML操作</p>
<p>优化查找字符串的方式</p>
<p>改写为全文索引的匹配方式：写SQL为全文索引匹配的方式：match(nickname) against(‘123’)</p>
<h4 id="优化3：生成列"><a href="#优化3：生成列" class="headerlink" title="优化3：生成列"></a>优化3：生成列</h4><p>利用MySQL 5.7的生成列模拟函数索引的方式解决，具体步骤如下：</p>
<p>虚拟列：当行记录被访问的时候自动计算得到，不占用存储空间。支持此列上创建二级索引。</p>
<p>物理列：当行记录被插入或更新时候自动计算并保存起来，占用存储空间。支持此列上创建主键和二级索引</p>
<p>利用内置reverse函数将like ‘%风云’反转为like ‘云风%’，基于此函数添加虚拟生成列。<br>在虚拟生成列上创建索引。<br>将SQL改写成通过生成列like reverse(‘%风云’)去过滤，走生成列上的索引</p>
<h3 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h3><p>客户端 - 连接器 - 查询缓存 - 分析器 - 优化器 - 执行器 - 引擎</p>
<p>查询空闲链接 show processlist</p>
<p>Command列显示为Sleep的这一行，就表示现在系统里面有一个空闲连接，超过超时时间，连接会断开</p>
<h3 id="不要delete删除数据"><a href="#不要delete删除数据" class="headerlink" title="不要delete删除数据"></a>不要delete删除数据</h3><p>尤其是大表，delete物理删除数据会产生空间碎片，最好采用逻辑删除</p>
<p>elete物理删除既不能释放磁盘空间，而且会产生大量的碎片，聚集索引非线性增加，导致索引频繁分裂，影响SQL执行计划的稳定性；</p>
<p>同时在碎片回收时，会耗用大量的CPU，磁盘空间，影响表上正常的DML操作</p>
<p>比较耗时，也会阻塞表上正常的DML运行，同时需要占用额外更多的磁盘空间，对于RDS来说，可能会导致磁盘空间瞬间爆满，实例瞬间被锁定，应用无法做DML操作，所以禁止在线上环境去执行</p>
<h3 id="主键达到上限"><a href="#主键达到上限" class="headerlink" title="主键达到上限"></a>主键达到上限</h3><p>自增ID达到上限用完了之后，分为两种情况：</p>
<p>如果设置了主键，那么将会报错主键冲突，改为bigint。<br>如果没有设置主键，数据库则会帮我们自动生成一个全局的row_id，新数据会覆盖老数据<br>解决方案：</p>
<p>表尽可能都要设置主键，主键尽量使用bigint类型，21亿的上限还是有可能达到的，比如魔兽，虽然说row_id上限高达281万亿，但是覆盖数据显然是不可接受的</p>
<h3 id="count-和count-1不是全表扫描"><a href="#count-和count-1不是全表扫描" class="headerlink" title="count * 和count 1不是全表扫描"></a>count * 和count 1不是全表扫描</h3><p>MySQL 都会用成本最小的辅助索引查询方式来计数</p>
<h3 id="binlog-redolog-undolog"><a href="#binlog-redolog-undolog" class="headerlink" title="binlog redolog undolog"></a>binlog redolog undolog</h3><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>快照读与当前读</p>
<p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作</p>
<p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作</p>
<p>undo日志</p>
<p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>N叉树的前序遍历</title>
    <url>/2020/12/16/N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><p>类似二叉树，子节点for循环遍历一下就好</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Definition for a Node.</span><br><span class="line"># class Node:</span><br><span class="line">#    def __init__(self, val=None, children=None):</span><br><span class="line">#        self.val = val</span><br><span class="line">#        self.children = children</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def preorder(self, <span class="attr">root</span>: <span class="string">&#x27;Node&#x27;</span>) -&gt; List[int]:</span><br><span class="line">        res = []</span><br><span class="line">        def handle(root):</span><br><span class="line">            <span class="keyword">if</span> not root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> root.children:</span><br><span class="line">                handle(i)</span><br><span class="line">        handle(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>按子节点顺序即可</p>
<h4 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def preorder(self, root):</span><br><span class="line">        <span class="keyword">if</span> root is None:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack, output = [root, ], []            </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">        	# 移除最后一个元素</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            output.append(root.val)</span><br><span class="line">            # 反转数组 </span><br><span class="line">            stack.extend(root.children[::-<span class="number">1</span>])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度：时间复杂度：O(M)，其中 MM 是 N 叉树中的节点个数。每个节点只会入栈和出栈各一次。</p>
<p>空间复杂度：O(M)。在最坏的情况下，这棵 N 叉树只有 2 层，所有第 2 层的节点都是根节点的孩子。将根节点推出栈后，需要将这些节点都放入栈，共有 M−1 个节点，因此栈的大小为 O(M)</p>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的单例模式</title>
    <url>/2018/05/28/Python%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>顾名思义：就是单个模式</p>
<p>单例模式是一种常见的软件设置模式，在它的核心结构中只包含一个被称为单例类的特殊类，通过单例模式可以保证系统中的一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个对象只能存在一个，单例模式是最好的解决方案。</p>
<p>比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个 AppConfig 的类来读取配置文件的信息。如果在程序运行期间，有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig 对象的实例，这就导致系统中存在多个 AppConfig 的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似 AppConfig 这样的类，我们希望在程序运行期间只存在一个实例对象。</p>
<p>单例模式的要点有三类</p>
<p>某个类只能有一个实例<br>它必须创建这个实例<br>它必须自行向整个系统提供这个实例</p>
<h2 id="实现单例的方法"><a href="#实现单例的方法" class="headerlink" title="实现单例的方法"></a>实现单例的方法</h2><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>其实，Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。</p>
<h3 id="使用装饰器"><a href="#使用装饰器" class="headerlink" title="使用装饰器"></a>使用装饰器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def Singleton(cls):</span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def _singleton(*args, **kargs):</span><br><span class="line">        <span class="keyword">if</span> cls not <span class="keyword">in</span> _instance:</span><br><span class="line">            _instance[cls] = cls(*args, **kargs)</span><br><span class="line">        <span class="keyword">return</span> _instance[cls]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _singleton</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Singleton</span><br><span class="line">class A(object):</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, x=<span class="number">0</span>):</span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A(<span class="number">2</span>)</span><br><span class="line">a2 = A(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="使用类"><a href="#使用类" class="headerlink" title="使用类"></a>使用类</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def instance(cls, *args, **kwargs):</span><br><span class="line">        <span class="keyword">if</span> not hasattr(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br></pre></td></tr></table></figure>
<p>但是这种情况下，多线程是无法使用的，存在问题</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def instance(cls, *args, **kwargs):</span><br><span class="line">        <span class="keyword">if</span> not hasattr(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">def task(arg):</span><br><span class="line">    obj = Singleton.instance()</span><br><span class="line">    print(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=task,args=[i,])</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;__main__.Singleton object at <span class="number">0x02C933D0</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x02C933D0</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x02C933D0</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x02C933D0</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x02C933D0</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x02C933D0</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x02C933D0</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x02C933D0</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x02C933D0</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x02C933D0</span>&gt;</span><br></pre></td></tr></table></figure>
<p>看起来也没有问题，那是因为执行速度过快，如果在init方法中有一些IO操作，就会发现问题了，下面我们通过time.sleep模拟</p>
<p>我们在上面__init__方法中加入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def __init__(self):</span><br><span class="line">       <span class="keyword">import</span> time</span><br><span class="line">       time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;__main__.Singleton object at <span class="number">0x034A3410</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x034BB990</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x034BB910</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x034ADED0</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x034E6BD0</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x034E6C10</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x034E6B90</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x034BBA30</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x034F6B90</span>&gt;</span><br><span class="line">&lt;__main__.Singleton object at <span class="number">0x034E6A90</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这时就发现问题，按照以上方式创建的单例，无法支持多线程</p>
<p>解决办法：加锁！未加锁部分并发执行,加锁部分串行执行,速度降低,但是保证了数据安全</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">class Singleton(object):</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def instance(cls, *args, **kwargs):</span><br><span class="line">        <span class="keyword">with</span> Singleton._instance_lock:</span><br><span class="line">            <span class="keyword">if</span> not hasattr(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">                Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task(arg):</span><br><span class="line">    obj = Singleton.instance()</span><br><span class="line">    print(obj)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=task,args=[i,])</span><br><span class="line">    t.start()</span><br><span class="line">time.sleep(<span class="number">20</span>)</span><br><span class="line">obj = Singleton.instance()</span><br><span class="line">print(obj)</span><br></pre></td></tr></table></figure>
<p>这样就差不多了，但是还是有一点小问题，就是当程序执行时，执行了time.sleep(20)后，下面实例化对象时，此时已经是单例模式了，但我们还是加了锁，这样不太好，再进行一些优化，把intance方法，改成下面的这样就行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@classmethod</span><br><span class="line">   def instance(cls, *args, **kwargs):</span><br><span class="line">       <span class="keyword">if</span> not hasattr(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">           <span class="keyword">with</span> Singleton._instance_lock:</span><br><span class="line">               <span class="keyword">if</span> not hasattr(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">                   Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">       <span class="keyword">return</span> Singleton._instance</span><br></pre></td></tr></table></figure>
<p>这样，一个可以支持多线程的单例模式就完成了</p>
<h3 id="new-方法实现单例"><a href="#new-方法实现单例" class="headerlink" title="__new__方法实现单例"></a>__new__方法实现单例</h3><p>我们知道，当我们实例化一个对象时，是先执行了类的__new__方法（我们没写时，默认调用object.__new__），实例化对象；然后再执行类的__init__方法，对这个对象进行初始化，所有我们可以基于这个，实现单例模式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">class Singleton(object):</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        <span class="keyword">if</span> not hasattr(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            <span class="keyword">with</span> Singleton._instance_lock:</span><br><span class="line">                <span class="keyword">if</span> not hasattr(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">                    Singleton._instance = object.__new__(cls)  </span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line">obj1 = Singleton()</span><br><span class="line">obj2 = Singleton()</span><br><span class="line">print(obj1,obj2)</span><br><span class="line"></span><br><span class="line">def task(arg):</span><br><span class="line">    obj = Singleton()</span><br><span class="line">    print(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=task,args=[i,])</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;__main__.Singleton object at <span class="number">0x038B33D0</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">__main__.Singleton</span> <span class="attr">object</span> <span class="attr">at</span> <span class="attr">0x038B33D0</span>&gt;</span></span></span><br><span class="line">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class="line">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class="line">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class="line">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class="line">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class="line">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class="line">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class="line">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class="line">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class="line">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br></pre></td></tr></table></figure>
<p>采用这种方式的单例模式，以后实例化对象时，和平时实例化对象的方法一样 obj = Singleton() </p>
<h3 id="元类创建单例"><a href="#元类创建单例" class="headerlink" title="元类创建单例"></a>元类创建单例</h3><p>1.类由type创建，创建类时，type的<strong>init__方法自动执行，类() 执行type的 __call__方法(类的__new__方法,类的__init__方法)<br>2.对象由类创建，创建对象时，类的__init__方法自动执行，对象()执行类的 __call</strong> 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">class SingletonType(type):</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line">    def __call__(cls, *args, **kwargs):</span><br><span class="line">        <span class="keyword">if</span> not hasattr(cls, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            <span class="keyword">with</span> SingletonType._instance_lock:</span><br><span class="line">                <span class="keyword">if</span> not hasattr(cls, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">                    cls._instance = <span class="built_in">super</span>(SingletonType,cls).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="title">metaclass</span></span>=SingletonType):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj1 = Foo(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">obj2 = Foo(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">print(obj1,obj2)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的垃圾回收机制</title>
    <url>/2018/07/09/Python%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>Python中的垃圾回收是以引用计数为主，分代收集为辅。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>python中一切皆为对象，对象的核心就是一个结构体PyObject，里面包含引用计数器ob_refcnt，当对象增加一个引用时，ob_refcnt+1；当引用它的对象被删除时，ob_refcnt-1；当引用计数ob_refcnt==0时，对象的生命结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> typedef struct_object &#123;</span><br><span class="line"> int ob_refcnt;</span><br><span class="line"> struct_typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
<p>导致引用计数+1的情况<br> 对象被创建，例如a=23<br>对象被引用，例如b=a<br>对象被作为参数，传入到一个函数中，例如func(a)<br>对象作为一个元素，存储在容器中，例如list1=[a,a]<br>导致引用计数-1的情况<br> 对象的别名被显式销毁，例如del a<br>对象的别名被赋予新的对象，例如a=24<br>一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）<br> 对象所在的容器被销毁，或从容器中删除对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">查看一个对象的引用计数</span><br><span class="line">sys.getrefcount(a)可以查看a对象的引用计数，但是比正常计数大<span class="number">1</span>，因为调用函数的时候传入a，这会让a的引用计数+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>简单<br>实时性：当某个对象的引用计数为0时，内存马上就会被回收；不像其他需要等待特定的时机来进行垃圾回收。这样也带来了另一个好处：垃圾回收的时间也分摊到了平时。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>维护引用计数，消耗资源<br>致命的缺陷： 循环引用</p>
<h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#循环引用的例子</span><br><span class="line">   list1 = []</span><br><span class="line">   list2 = []</span><br><span class="line">   list1.append(list2) #list1引用list2</span><br><span class="line">   list2.append(list1) #list2引用list1</span><br></pre></td></tr></table></figure>
<p>list1与list2相互引用，如果不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。</p>
<p>对于如今的强大硬件，缺点1尚可接受，但是循环引用导致内存泄露，注定python还将引入新的回收机制。</p>
<h3 id="标记-清楚算法"><a href="#标记-清楚算法" class="headerlink" title="标记-清楚算法"></a>标记-清楚算法</h3><p>面向会出现循环引用的数据类型，eg：list、dict、class等，而int、String等不是。<br>寻找Root objects（根节点）：<br>使用计数器副本，去除循环引用环后，引用计数不为0的节点就是根节点。<br>从root object（一般指全局引用或函数栈上的引用）出发，通过引用可以链接到的为可达对象，放入根节点链表；不能链接到的为不可达unreacherable对象，放入不可达节点链表，上面这个过程称为垃圾收集，后面垃圾回收是对不可达链表进行回收。</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>1、标记-清除机制</p>
<p>标记-清除机制，顾名思义，首先标记对象(垃圾检测)，然后清除垃圾(垃圾回收)。</p>
<p>首先初始所有对象标记为白色，并确定根节点对象(这些对象是不会被删除)，标记它们为黑色(表示对象有效)。将有效对象引用的对象标记为灰色(表示对象可达，但它们所引用的对象还没检查)，检查完灰色对象引用的对象后，将灰色标记为黑色。重复直到不存在灰色节点为止。最后白色结点都是需要清除的对象。</p>
<p>2、回收对象的组织</p>
<p>这里所采用的高级机制作为引用计数的辅助机制，用于解决产生的循环引用问题。而循环引用只会出现在“内部存在可以对其他对象引用的对象”，比如：list，class等。</p>
<p>为了要将这些回收对象组织起来，需要建立一个链表。自然，每个被收集的对象内就需要多提供一些信息。</p>
<p>通过PyGC_Head的指针将每个回收对象连接起来，形成了一个链表，也就是在1里提到的初始化的所有对象。</p>
<h3 id="分代技术"><a href="#分代技术" class="headerlink" title="分代技术"></a>分代技术</h3><p>分代技术是一种典型的以空间换时间的技术，这也正是java里的关键技术。这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。</p>
<p>这样的思想，可以减少标记-清除机制所带来的额外操作。分代就是将回收对象分成数个代，每个代就是一个链表(集合)，代进行标记-清除的时间与代内对象存活时间成正比例关系。</p>
<p>基于“对象存活的时间越长，越可能不是垃圾，应该越少进行垃圾收集”的思想。<br>对象等级共分为0、1、2三代，每代对应一个链表，每代有一个代表各代最多允许的对象数量：threshold（默认情况下，generation 0 超过700，或generation 1、generation2超过10，会触发垃圾回收机制）<br>所有的新建对象都是0代，当一个对象经历过垃圾回收，依然存活，就会被归入下一代对象<br>generation 0触发，会将generation 0 、1、2依次链接起来再清理<br>generation 1触发，会将generation 1、 2依次链接起来再清理<br>generation 2触发，只会清理自己</p>
<h3 id="GC模块（Garbage-Collector-interface）"><a href="#GC模块（Garbage-Collector-interface）" class="headerlink" title="GC模块（Garbage Collector interface）"></a>GC模块（Garbage Collector interface）</h3><h4 id="gc模块常用解析"><a href="#gc模块常用解析" class="headerlink" title="gc模块常用解析"></a>gc模块常用解析</h4><p>gc模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。</p>
<p>常用函数：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">gc</span><span class="selector-class">.set_debug</span>(<span class="selector-tag">flags</span>)</span><br></pre></td></tr></table></figure>

<p>设置gc的debug日志，一般设置为gc.DEBUG_LEAK</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">gc</span><span class="selector-class">.collect</span>(<span class="selector-attr">[generation]</span>)</span><br></pre></td></tr></table></figure>

<p>显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。<br> 返回不可达（unreachable objects）对象的数目</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">gc</span><span class="selector-class">.set_threshold</span>(<span class="selector-tag">threshold0</span><span class="selector-attr">[, threshold1[, threshold2]</span>)</span><br></pre></td></tr></table></figure>

<p>设置自动执行垃圾回收的频率。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">gc</span><span class="selector-class">.get_count</span>()</span><br></pre></td></tr></table></figure>

<p>获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表</p>
<h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><p>这个机制的主要作用就是发现并处理不可达的垃圾对象。<br> 垃圾回收=垃圾检查+垃圾回收<br> 把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，改对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。</p>
<p>gc模块里面会有一个长度为3的列表的计数器，可以通过gc.get_count()获取。<br>例如(488,3,0)，其中488是指距离上一次一代垃圾检查，Python分配内存的数目减去释放内存的数目，注意是内存分配，而不是引用计数的增加。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">print gc.get_count() # (590, 8, 0)</span><br><span class="line">a = ClassA()</span><br><span class="line">print gc.get_count() # (591, 8, 0)</span><br><span class="line">del a</span><br><span class="line">print gc.get_count() # (590, 8, 0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>gc模快有一个自动垃圾回收的阀值，即通过gc.get_threshold函数获取到的长度为3的元组，例如(700,10,10)<br>每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器<br>当计数器从(699,3,0)增加到(700,3,0)，gc模块就会执行gc.collect(0),即检查一代对象的垃圾，并重置计数器为(0,4,0)<br>当计数器从(699,9,0)增加到(700,9,0)，gc模块就会执行gc.collect(1),即检查一、二代对象的垃圾，并重置计数器为(0,0,1)<br>当计数器从(699,9,9)增加到(700,9,9)，gc模块就会执行gc.collect(2),即检查一、二、三代对象的垃圾，并重置计数器为(0,0,0)</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>如果循环引用中，两个对象都定义了__del__方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的__del__方法，所以为了安全起见，gc模块会把对象放到gc.garbage中，但是不会销毁对象。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>Python连接Mysql</title>
    <url>/2018/05/07/Python%E8%BF%9E%E6%8E%A5Mysql/</url>
    <content><![CDATA[<p>通过python操作mysql，面向对象的编程思想</p>
<h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<h2 id="面向对象封装"><a href="#面向对象封装" class="headerlink" title="面向对象封装"></a>面向对象封装</h2><h3 id="init初始化方法"><a href="#init初始化方法" class="headerlink" title="init初始化方法"></a>init初始化方法</h3><p>创建连接，建立游标对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class JD(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 　1创建链接对象</span><br><span class="line">        self.conn = connect(host=<span class="string">&#x27;主机名&#x27;</span>, port=<span class="number">3306</span>, database=<span class="string">&#x27;数据库名&#x27;</span>, user=<span class="string">&#x27;账户名&#x27;</span>, password=<span class="string">&#x27;密码&#x27;</span>,charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        # 2 创建游标对象</span><br><span class="line">        self.cs = self.conn.cursor()</span><br></pre></td></tr></table></figure>

<h3 id="del方法"><a href="#del方法" class="headerlink" title="del方法"></a>del方法</h3><p>关闭游标，关闭连接</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def __del__(self):</span><br><span class="line">        # 5 关闭</span><br><span class="line">        self.cs.close()</span><br><span class="line">        self.conn.close()</span><br></pre></td></tr></table></figure>

<h3 id="sql语句执行方法"><a href="#sql语句执行方法" class="headerlink" title="sql语句执行方法"></a>sql语句执行方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def my_execute_sql(self,sql):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;执行ｓｑｌ语句&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        self.cs.execute(sql)</span><br><span class="line"></span><br><span class="line">        # 4 获取数据</span><br><span class="line">        content = self.cs.fetchall()</span><br></pre></td></tr></table></figure>

<h3 id="写sql语句"><a href="#写sql语句" class="headerlink" title="写sql语句"></a>写sql语句</h3><p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def show_all_goods(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;显示所有的商品信息&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        sql = <span class="string">&quot;select * from goods;&quot;</span></span><br><span class="line"></span><br><span class="line">        self.my_execute_sql(sql)</span><br></pre></td></tr></table></figure>

<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def run(self):</span><br><span class="line">      self.show_all_goods()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ与RedisMQ</title>
    <url>/2020/09/18/RabbitMQ%E4%B8%8EReidsMQ/</url>
    <content><![CDATA[<h2 id="Redis队列"><a href="#Redis队列" class="headerlink" title="Redis队列"></a>Redis队列</h2><p>rpush，消息类型定义，不同业务定义不同消息类型，while true，一直循环等待取lpop，取不到time。sleep</p>
<h2 id="两个队列对比"><a href="#两个队列对比" class="headerlink" title="两个队列对比"></a>两个队列对比</h2><p>redis ：没有相应的机制保证消息的可靠消费，如果发布者发布一条消息，而没有对应的订阅者的话，或者消费失败的话，这条消息将丢失，不会存在内存中</p>
<p>rabbitmq：具有消息消费确认机制，如果发布一条消息，还没有消费者消费该队列，那么这条消息将一直存放在队列中，直到有消费者消费了该条消息，以此可以保证消息的可靠消费</p>
<p>redis:实时性高，redis作为高效的缓存服务器，所有数据都存在内存中，所以它具有更高的实时性消费者负载均衡</p>
<p>rabbitmq：可以被多个消费者同时监控消费，但是每一条消息只能被消费一次，由于rabbitmq的消费确认机制，因此它能够根据消费者的消费能力而调整它的负载</p>
<p>redis：发布订阅模式，一个队列可以被多个消费者同时订阅，当有消息到达时，会将该消息依次发送给每个订阅者，她是一种消息的广播形式，redis本身不做消费者的负载均衡，因此消费效率存在瓶颈；</p>
<p>rabbitmq：队列，每条消息都可以选择性持久化，持久化粒度更小，更灵活</p>
<p>rabbitmq实现了后台监控平台，可以在该平台上看到所有创建的队列的详细情况，良好的后台管理平台可以方面我们更好的使用</p>
<p>redis没有所谓的监控平台</p>
<p>redis：轻量级，低延迟，高并发，低可靠性；<br>rabbitmq：重量级，高可靠，异步，不保证实时</p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>原生支持AMQP协议，还支持STOMP， MQTT等多种消</p>
<h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>三层协议：高中底层</p>
<p>交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。<br>队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。<br>绑定 (Binding)： 一套规则，告知交换器消息应该将消息投递给哪个队列</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Publisher 生产者-&gt;exchange交换机发送消息</p>
<p>Consumer 消费者-&gt;从消息队列中取得消息</p>
<p>Broker 客户端连接，实体服务</p>
<p>Virtual host 一个Virtual Host里面可以有若干个Exchange和Queue，同一个Virtual Host里面不能有相同名称的Exchange和Queue</p>
<p>Message 消息 由Properties和Body组成（消息头和消息体）。Properties可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body这就是消息体内容</p>
<p>Exchange 交换机，接收生产者发送的消息，根据路由键转发消息到绑定的队列。</p>
<pre><code>三种常见的交换机类型：

1、direct（发布与订阅，完全匹配）

2、fanout（广播）

3、topic（主题，规则匹配）</code></pre>
<p>Routing key：路由键。一个路由规则，虚拟机可用它来确定如何路由一个特定消息<br>消息发送到MQ服务器时，消息将拥有一个路由键，即便是空的。RabbitMQ也会将其和绑定使用的路由键进行匹配。<br>如果匹配，消息将投递到该队列；如果不匹配，消息将会进入黑洞</p>
<p>Binding：绑定。Exchange和Queue之间的虚拟连接，binding中可以包含routing key</p>
<p>Channel：网络信道，是TCP里面的虚拟连接。几乎所有的操作都在Channel中进行， Channel是进行消息读写的通道</p>
<p>TCP一旦打开，就会创建AMQP信道。</p>
<p>无论是发布消息、接收消息、订阅队列，这些动作都是通过信道完成的。</p>
<p>为什么不直接通信：<br>1、TCP的创建和销毁开销特别大。创建需要3次握手，销毁需要4次分手<br>2、如果不用信道，那应用程序就会以TCP连接RabbitMQ，高峰时每秒成千上万条连接会造成资源巨大浪费，而且操作系统每秒处理TCP连接数也是有限制的，必定造成性能瓶颈<br>3、信道的原理是一条线程一条通道，多条线程多条通道同用一条TCP连接。一条TCP连接可以容纳无限的信道，即使每秒成千上万的请求也不会成为性能瓶颈</p>
<p>Queue：一个消息可以投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列上将其取走</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>发消息的时候需要指定发往哪个Exchange，然后借助routing key发送到对应的消息队列queue，消费者从订阅的消息队列上取消息</p>
<h3 id="exchange模式"><a href="#exchange模式" class="headerlink" title="exchange模式"></a>exchange模式</h3><p>direc：完全匹配RouteKey</p>
<p>topic：通配符模糊匹配RouteKey</p>
<p>Fanout：群发，不关心routekey</p>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><h4 id="如何保证可靠性"><a href="#如何保证可靠性" class="headerlink" title="如何保证可靠性"></a>如何保证可靠性</h4><p>1、消息落库，消息持久化，消息标记， 在高并发场景下，数据库IO压力大，不适用</p>
<p>2、延迟投递：</p>
<p>发送first——send消息</p>
<p>同时发送一个延迟的检查消息（检查第一次发送消息消费情况）</p>
<p>消费端消费消息，消费后发送一个确认ack给broker</p>
<p>回调服务检测到消费端的确认消息，进行数据库的状态持久化（这样相当于数据库一次操作，异步持久化）回调服务检测到消费端的确认消息，进行数据库的状态持久化（这样相当于数据库一次操作，异步持久化）</p>
<p>回调服务响应第二个延时消息，确认消息成功消费，如果出现异常，回调服务调用RPC给生产者，再次发送</p>
<h4 id="消息幂等性，避免重复消费"><a href="#消息幂等性，避免重复消费" class="headerlink" title="消息幂等性，避免重复消费"></a>消息幂等性，避免重复消费</h4><p>幂等性即对数据进行若干次操作，仍然保证正确</p>
<p>消息不会消费多次，只消费一次</p>
<p>唯一ID加上时间戳</p>
<p>MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据</p>
<h4 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h4><p>消息的确认，是指生产者投递消息后，如果Broker收到消息，则会给我们生产者一个应答。</p>
<p>生产者进行接收应答，用来确定这个消息是否正常的发送到Broker，这种方式也是消息的可靠性</p>
<p>Return Listener用于处理一些不可路由的消息！</p>
<h4 id="消息限流"><a href="#消息限流" class="headerlink" title="消息限流"></a>消息限流</h4><p>RabbitMQ提供了一种QOS（服务质量保证）功能，即在非自动确认消息的前提下，如果一定数目的消息（通过基于consumer或者channel设置Qos的值）未被确认前，不进行消费新的消息</p>
<h4 id="ACK机制"><a href="#ACK机制" class="headerlink" title="ACK机制"></a>ACK机制</h4><p>消费端进行消费的时候，如果由于业务异常我们可以进行日志的记录，然后进行补偿。如果由于服务器宕机等严重问题，那我们就需要手工进行ACK保障消费端消费成功。</p>
<p>消息确认ACK：如果在处理消息的过程中，消费者的服务器在处理消息时出现异常，那可能这条正在处理的消息就没有完成消息消费，数据就会丢失。为了确保数据不会丢失，RabbitMQ支持消息确认ACK。</p>
<p>ACK的消息确认机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除。</p>
<p>1、如果一个消费者在处理消息出现了网络不稳定、服务器异常等现象，那么就不会有ACK反馈，RabbitMQ会认为这个消息没有正常消费，会将消息重新放入队列中。</p>
<p>2、如果在集群的情况下：RabbitMQ会立即将这个消息推送给这个在线的其他消费者。这种机制保证了不丢失任何消息和任务。</p>
<p>3、消息永远不会从RabbitMQ中删除：只有当消费者正确发送ACK反馈，RabbitMQ确认收到后，消息才会删除</p>
<p>4、消息的ACK确认机制默认开</p>
<h4 id="重回队列"><a href="#重回队列" class="headerlink" title="重回队列"></a>重回队列</h4><p>消费失败的消息都会放回队列，一般都会关闭</p>
<h4 id="TTL队列"><a href="#TTL队列" class="headerlink" title="TTL队列"></a>TTL队列</h4><p>消息过期机制</p>
<p>第一种通过对队列进行设置，这种设置后，该队列中所有的消息都存在相同的过期时间，第二种通过对消息本身进行设置，那么每条消息的过期时间都不一样。如果同时使用这2种方法，那么以过期时间小的那个数值为准</p>
<h4 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h4><p>当消息在一个队列中变成死信（dead message）之后，它能被重新publish到另一个Exchange，这个Exchange就是DLX</p>
<p>消息变成死信：</p>
<p>1、 消息被拒绝（basic.reject/basic.nack）并且request=false；<br>2、 消息TTL过期；<br>3、 队列达到最大长度</p>
<p>可以监听这个队列进行处理</p>
<h4 id="生产消息流程"><a href="#生产消息流程" class="headerlink" title="生产消息流程"></a>生产消息流程</h4><p>1.Producer先连接到Broker,建立连接Connection,开启一个信道(Channel)</p>
<p>2.Producer声明一个交换器并设置好相关属性</p>
<p>3.Producer声明一个队列并设置好相关属性</p>
<p>4.Producer通过路由键将交换器和队列绑定起来</p>
<p>5.Producer发送消息到Broker,其中包含路由键、交换器等信息</p>
<p>6.相应的交换器根据接收到的路由键查找匹配的队列</p>
<p>7.如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者（两种处理方式）</p>
<p>8.关闭信道</p>
<p>9.管理连接</p>
<h4 id="消费者接收消息过程"><a href="#消费者接收消息过程" class="headerlink" title="消费者接收消息过程"></a>消费者接收消息过程</h4><p>1.Producer先连接到Broker,建立连接Connection,开启一个信道(Channel)</p>
<p>2.向Broker请求消费响应的队列中消息，可能会设置响应的回调函数</p>
<p>3.等待Broker回应并投递相应队列中的消息，接收消息</p>
<p>4.消费者确认收到的消息,ack</p>
<p>5.RabbitMq从队列中删除已经确定的消息</p>
<p>6.关闭信道</p>
<p>7.关闭连接</p>
<h4 id="事务，拒绝消息，延迟，优先处理"><a href="#事务，拒绝消息，延迟，优先处理" class="headerlink" title="事务，拒绝消息，延迟，优先处理"></a>事务，拒绝消息，延迟，优先处理</h4><h4 id="保证层级"><a href="#保证层级" class="headerlink" title="保证层级"></a>保证层级</h4><p>最多一次，最少一次，恰好一次</p>
<h4 id="队列结构"><a href="#队列结构" class="headerlink" title="队列结构"></a>队列结构</h4><p>rabbit_amqqueue_process :负责协议相关的消息处理，即接收生产者发布的消息、向消费者交付消息、处理消息的确认(包括生产端的 confirm 和消费端的 ack) 等。<br>backing_queue:是消息存储的具体形式和引擎，并向 rabbit amqqueue process 提供相关的接口以供调用。</p>
<h4 id="消息四种状态"><a href="#消息四种状态" class="headerlink" title="消息四种状态"></a>消息四种状态</h4><p>alpha: 消息内容(包括消息体、属性和 headers) 和消息索引都存储在内存中 。<br>beta: 消息内容保存在磁盘中，消息索引保存在内存中。<br>gamma: 消息内容保存在磁盘中，消息索引在磁盘和内存中都有 。<br>delta: 消息内容和索引都在磁盘中 。</p>
<h4 id="消息如何分发"><a href="#消息如何分发" class="headerlink" title="消息如何分发"></a>消息如何分发</h4><p>若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）</p>
<h4 id="如何确保消息正确发送"><a href="#如何确保消息正确发送" class="headerlink" title="如何确保消息正确发送"></a>如何确保消息正确发送</h4><p>将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一ID）</p>
<h4 id="消费方确认接收消息"><a href="#消费方确认接收消息" class="headerlink" title="消费方确认接收消息"></a>消费方确认接收消息</h4><p>消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。这里并没有用到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ给了Consumer足够长的时间来处理消息</p>
<p>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要根据bizId去重）<br>如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息</p>
<h4 id="丢数据问题"><a href="#丢数据问题" class="headerlink" title="丢数据问题"></a>丢数据问题</h4><p>生产者丢数据：</p>
<p>1、开启事务，但会降低吞吐量</p>
<p>2、 开启confirm模式，丢了可以进行重试</p>
<p>消费队列丢数据：</p>
<p>1、磁盘db持久化，持久化成功，返回个ack，将queue的持久化标识durable设置为true,则代表是一个持久的队列，deliveryMode=2</p>
<p>消费者丢数据：</p>
<p>自动确认，手动确认，不确认模式</p>
<h4 id="实现延时队列"><a href="#实现延时队列" class="headerlink" title="实现延时队列"></a>实现延时队列</h4><p>在rabbitmq中不存在延时队列，但是我们可以通过设置消息的过期时间和死信队列来模拟出延时队列。消费者监听死信交换器绑定的队列，而不要监听消息发送的队列</p>
<p>场景：用户在系统中创建一个订单，如果超过时间用户没有进行支付，那么自动取消订单</p>
<h4 id="消息如何被优先消费"><a href="#消息如何被优先消费" class="headerlink" title="消息如何被优先消费"></a>消息如何被优先消费</h4><p>可以设置消息优先级</p>
<h4 id="如何保证消息顺序性"><a href="#如何保证消息顺序性" class="headerlink" title="如何保证消息顺序性"></a>如何保证消息顺序性</h4><p>每个队列有一个消费者</p>
<p>否则只能通过全局ID实现（每条消息都一个msgId，关联的消息拥有一个parentMsgId。可以在消费端实现前一条消息未消费，不处理下一条消息；也可以在生产端实现前一条消息未处理完毕，不发布下一条消息）</p>
<h4 id="多个消费者监听一个队列"><a href="#多个消费者监听一个队列" class="headerlink" title="多个消费者监听一个队列"></a>多个消费者监听一个队列</h4><p>轮询: 默认的策略，消费者轮流，平均地接收消息<br>公平分发: 根据消费者的能力来分发消息，给空闲的消费者发送更多消息</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis， Codis与Mc</title>
    <url>/2021/03/12/Redis%E4%B8%8EMc/</url>
    <content><![CDATA[<h2 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>用的是LRU cache算法+超时过期机制</p>
<p>当查询数据时，客户端首先参考节点列表计算出key的哈希值（阶段一哈希），进而选中一个节点；客户端将请求发送给选中的节点，然后memcached节点通过一个内部的哈希算法（阶段二哈希），查找真正的数据（item）</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>Mc特点：</p>
<p>MC 处理请求时使用多线程异步 IO 的方式，可以合理利用 CPU 多核的优势，性能非常优秀；<br>MC 功能简单，使用内存存储数据；<br>MC 的内存结构以及钙化问题我就不细说了，大家可以查看官网了解下；<br>MC 对缓存的数据可以设置失效期，过期后的数据会被清除；<br>失效的策略采用延迟失效，就是当再次使用数据时检查是否失效；<br>当容量存满时，会对缓存中的数据进行剔除，剔除时除了会对过期 key 进行清理，还会按 LRU 策略对数据进行剔除</p>
<p>限制：<br>key 不能超过 250 个字节；<br>value 不能超过 1M 字节；<br>key 的最大失效时间是 30 天；<br>只支持 K-V 结构，不提供持久化和主从同步功能</p>
<h3 id="钙化问题"><a href="#钙化问题" class="headerlink" title="钙化问题"></a>钙化问题</h3><p>没有空余的内存分配新的slab的时候， 写入新的数据，会淘汰最新的，LRU只会淘汰同一级别的Slab数据</p>
<p>重启实例，采取随机过期策略</p>
<h2 id="Reids"><a href="#Reids" class="headerlink" title="Reids"></a>Reids</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>本地缓存(内存交互)，分布式缓存（远程请求，良好的扩展能力），多级缓存（两者结合）</p>
<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>内部的实现是通过 SDS（Simple Dynamic String ）来存储的。SDS 类似于 Java 中的 ArrayList，可以通过预分配冗余空间的方式来减少内存的频繁分配</p>
<p>场景：缓存，计数器，session</p>
<p>动态字符串SDS</p>
<p>会存储长度信息，取出来的就是o1，还预分配了一个冗余长度，有多余的1byte空间（这1byte也是为了存空字</p>
<p>惰性空间释放：我们执行完一个字符串缩减的操作，redis并不会马上收回我们的空间，因为可以预防你继续添加的操作，这样可以减少分配空间带来的消耗，但是当你再次操作还是没用到多余空间的时候，Redis也还是会收回对于的空间，防止内存的浪费的</p>
<p>两次，第一次不会缩减回收多余空间，再次操作发现还没有使用，就会回收，删减的话也不会马上释放free空间</p>
<p>同时保存了长度还会处理二进制的数据，进行长度对比</p>
<h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p>map结构，kv使用，扩容，渐进式rehash，新旧两个hash，扩大到原来的2倍，缩容是元素数量到达数组的1/10</p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>List 存储一些列表型的数据结构，底层是链表结构</p>
<p>lrange 命令，读取某个闭区间内的元素，可以基于 List 实现分页查询</p>
<p>Redis的链表结构，可以轻松实现阻塞队列，数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的“抢”列表尾部的数据</p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>无序集合，自动去重</p>
<h4 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h4><p>有序集合，根据分数自动排序</p>
<h4 id="pub-sub-订阅发布"><a href="#pub-sub-订阅发布" class="headerlink" title="pub/sub 订阅发布"></a>pub/sub 订阅发布</h4><h4 id="bitmap-布隆过滤器"><a href="#bitmap-布隆过滤器" class="headerlink" title="bitmap 布隆过滤器"></a>bitmap 布隆过滤器</h4><h4 id="pipeline-管道命令"><a href="#pipeline-管道命令" class="headerlink" title="pipeline 管道命令"></a>pipeline 管道命令</h4><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去</p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>解决链表查找问题，链表的插入删除都是o1，但是查找是on，只能一个一个查找</p>
<p>将链表升维，多层链表，类似二分查找的思想，是查找时间复杂度可以降低到O(log n)</p>
<p>但是会对插入，删除造成影响，需要调整层级链表之间的对应关系</p>
<p>如何调整，不要求每层的对应关系，插入的节点产生随即层数，还是O1操作，比如随机 层数是3，则1到3层都有这个节点，不需要调整会优于平衡树</p>
<p>查找时会逐层查找，降低查找的时间复杂度</p>
<p>如何产生这个随机层数，会影响到跳表的查找效率</p>
<p>redis中的概率是p，1/4</p>
<p>第1层链表固定有n个节点；<br>第2层链表平均有n<em>p个节点；<br>第3层链表平均有n</em>p2个节点</p>
<p>从第1层到最高层，各层链表的平均节点数是一个指数递减的等比数列。容易推算出，而最高层的平均节点数为1/p</p>
<p>相比于平衡树，hash：</p>
<p>1、跳表，平衡树是有序的，hash是无序的，查找是O1，但是无法范围查找</p>
<p>2、范围查找时，平衡树比跳表复杂，平衡树需要中序遍历</p>
<p>3、平衡树插入删除会引起子树调整，保证平衡，跳表只需要修改指针</p>
<p>4、内存占用，平衡树每层两个指针，跳表每层1/（1-p）， redis是1/4，每层1.33个指针</p>
<p>5、查找都是ologn，实现跳表更简单</p>
<h4 id="redis中的跳表"><a href="#redis中的跳表" class="headerlink" title="redis中的跳表"></a>redis中的跳表</h4><p>sorted set底层不仅仅使用了skiplist，还使用了ziplist和dict</p>
<p>sorted set中的每个元素主要表现出3个属性：</p>
<p>数据本身（在前面的例子中我们把名字存成了数据）。<br>每个数据对应一个分数(score)。<br>根据分数大小和数据本身的字典排序rank排名</p>
<p>zrevrank由数据查询它对应的排名，这在前面介绍的skiplist中并不支持。<br>zscore由数据查询它对应的分数，这也不是skiplist所支持的。<br>zrevrange根据一个排名范围，查询排名在这个范围内的数据。这在前面介绍的skiplist中也不支持。<br>zrevrangebyscore根据分数区间查询数据集合，是一个skiplist所支持的典型的范围查找（score相当于key）。</p>
<p>zscore的查询，不是由skiplist来提供的，而是由那个dict来提供的。 时间复杂度o1<br>为了支持排名(rank)，Redis里对skiplist做了扩展，使得根据排名能够快速查到数据，或者根据分数查到数据之后，也同时很容易获得排名。而且，根据排名的查找，时间复杂度也为O(log n)。<br>zrevrange的查询，是根据排名查数据，由扩展后的skiplist来提供。O(log(n)+M)<br>zrevrank是先在dict中由数据查到分数，再拿分数到skiplist中去查找，查到后也同时获得了排名。O(log n)</p>
<p>分数(score)允许重复，即skiplist的key允许重复。这在最开始介绍的经典skiplist中是不允许的。<br>在比较时，不仅比较分数（相当于skiplist的key），还比较数据本身。在Redis的skiplist实现中，数据本身的内容唯一标识这份数据，而不是由key来唯一标识。另外，当多个元素分数相同的时候，还需要根据数据内容来进字典排序。<br>第1层链表不是一个单向链表，而是一个双向链表。这是为了方便以倒序方式获取一个范围内的元素。</p>
<p>当数据较少时，sorted set是由一个ziplist来实现的。超过128个就会转skiplist，或者单独插入长度超过了64<br>当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。简单来讲，dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）</p>
<p>ziplist双向链表</p>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><h4 id="大量的key同一时间过期"><a href="#大量的key同一时间过期" class="headerlink" title="大量的key同一时间过期"></a>大量的key同一时间过期</h4><p>大量的key过期时间设置的过于集中，到过期的那个时间点，Redis可能会出现短暂的卡顿现象。严重的话会出现缓存雪崩</p>
<p>过期时间加上随机值</p>
<h4 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h4><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放</p>
<p>如果set后，设置expire之前意外crash，setnx和expire合成一条指令来用</p>
<h4 id="查找指定前缀的key"><a href="#查找指定前缀的key" class="headerlink" title="查找指定前缀的key"></a>查找指定前缀的key</h4><p>keys指令可以扫出指定模式的key列表，如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p>
<p>Redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长</p>
<p>增量式的，但是期间被更改，不能完全保证</p>
<h4 id="redis做异步队列"><a href="#redis做异步队列" class="headerlink" title="redis做异步队列"></a>redis做异步队列</h4><p>rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试</p>
<p>list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来</p>
<p>使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列，但有缺点在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如RocketMQ等</p>
<p>实现延时队列：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理</p>
<h4 id="redis持久化，主从数据交互"><a href="#redis持久化，主从数据交互" class="headerlink" title="redis持久化，主从数据交互"></a>redis持久化，主从数据交互</h4><p>RDB：RDB 持久化机制，是对 Redis 中的数据执行周期性的持久化。<br>AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的binlog。</p>
<p>RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态</p>
<p>AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF/RDB文件城后，Redis启动成功</p>
<p>RDB更适合做冷备，AOF更适合做热备</p>
<p>两种方式的优缺点：</p>
<p>1、RDB对Redis的性能影响非常小，是因为在同步数据的时候他只是fork了一个子进程去做持久化的，而且他在数据恢复的时候速度比AOF来的快</p>
<p>2、RDB都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，这意味着你这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉。AOF则最多丢一秒，数据完整性不一样</p>
<p>3、RDB在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒</p>
<p>4、AOF是一秒一次去通过一个后台的线程fsync操作，那最多丢这一秒的数据，写入的方式是追加，减少磁盘开销</p>
<p>5、AOF开启后，Redis支持写的QPS会比RDB支持写的要低</p>
<p>第一时间用RDB恢复，然后AOF做数据补全</p>
<p>RDB快照的数据生成的时候，缓存区也必须同时开始接受新请求，不然你旧的数据过去了，你在同步期间的增量数据咋办</p>
<p>aof重写：原理 就是 开辟一个子进程 对内存进行 遍历 转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件 中。序列化完毕后再将操作期间发生的 增量 AOF 日志 追加到这个新的 AOF 日志文件中</p>
<h4 id="Pipelibne"><a href="#Pipelibne" class="headerlink" title="Pipelibne"></a>Pipelibne</h4><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性</p>
<h4 id="redis同步机制"><a href="#redis同步机制" class="headerlink" title="redis同步机制"></a>redis同步机制</h4><p>第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可</p>
<p>传输过程中有什么网络问题啥的，会自动重连的，并且连接之后会把缺少的数据补上的</p>
<h4 id="为啥redis快"><a href="#为啥redis快" class="headerlink" title="为啥redis快"></a>为啥redis快</h4><p>Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS</p>
<p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速</p>
<p>2、数据结构简单，数据操作简单</p>
<p>3、采用了单线程，避免了上下文切换，和竞争，也不存在多线程多进程的cpu消耗</p>
<p>4、多路io复用模型，非阻塞io</p>
<p>5、底层实现，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</p>
<h4 id="单线程多核"><a href="#单线程多核" class="headerlink" title="单线程多核"></a>单线程多核</h4><p>开多个实例</p>
<h4 id="哨兵集群sentinel监控"><a href="#哨兵集群sentinel监控" class="headerlink" title="哨兵集群sentinel监控"></a>哨兵集群sentinel监控</h4><p>集群监控：负责监控 Redis master 和 slave 进程是否正常工作。<br>消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。<br>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。<br>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址</p>
<h4 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h4><p>Redis的过期策略，是有定期删除+惰性删除两种</p>
<p>从设置过期时间的key里随机选取 检查，达到过期时间的就删除，全扫描量太大</p>
<p>惰性删除：定期没删的，查询的时候来检查是否过期</p>
<p>既没定期删，也没访问，lru解决</p>
<h4 id="缓存击穿，穿透，雪崩"><a href="#缓存击穿，穿透，雪崩" class="headerlink" title="缓存击穿，穿透，雪崩"></a>缓存击穿，穿透，雪崩</h4><p>击穿：热点数据不过期设置</p>
<p>穿透：加校验，布隆过滤器反向校验</p>
<p>雪崩：重启，过期随机时间</p>
<h4 id="主从之间数据同步"><a href="#主从之间数据同步" class="headerlink" title="主从之间数据同步"></a>主从之间数据同步</h4><p>单机QPS是有上限的，而且Redis的特性就是必须支撑读高并发的，master机器去写，数据同步给别的slave机器</p>
<h4 id="redis线程模型"><a href="#redis线程模型" class="headerlink" title="redis线程模型"></a>redis线程模型</h4><p>文件事件处理器是单线程的，采用 IO 多路复用机制同时监听多个 Socket，根据 Socket 上的事件来选择对应的事件处理器进行处理</p>
<p>多个socket，io多路复用，文件事件分派器，文件处理器</p>
<p>多个 Socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 Socket，会将 Socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理</p>
<h4 id="redis慢的原因"><a href="#redis慢的原因" class="headerlink" title="redis慢的原因"></a>redis慢的原因</h4><p>1、实例内存达到上限：max值，达到max值会踢出一些数据，内存维持在max下，lru淘汰，扩充内存</p>
<p>2、大key问题，操作大key，就会消耗比较多的时间与内存，业务分解</p>
<p>3、复杂的操作：CONFIG SET slowlog-log-slower-than 5000，On操作，N比较大，或者组装数据，网络问题</p>
<p>4、集中过期：redis定时任务检查主动过期时，大量的key都过期</p>
<p>5、fork子进程，持久化，拷贝数据量大，在这个时间段内操作就会耗时比较严重</p>
<p>6、申请内存大页，内存页4kb，linux2.6。38支持2mb内存申请，Redis 在申请内存时也会以 2MB 为单位向操作系统申请，申请内存的耗时变长，进而导致每个写请求的延迟增加，影响到 Redis 性能</p>
<p>7、AOF阻塞：刷磁盘的时候，磁盘负载过高，导致子进程阻塞，不能返回，再次aofwrite的时候就会影响redis性能</p>
<h2 id="Codis"><a href="#Codis" class="headerlink" title="Codis"></a>Codis</h2><p>Codis就是起着一个中间代理的作用，能够把所有的Redis实例当成一个来使用，在客户端操作着SDK的时候和操作Redis的时候是一样的，没有差别。</p>
<p>因为Codis是一个无状态的，所以可以增加多个Codis来提升QPS,同时也可以起着容灾的作用。</p>
<h3 id="codis分片"><a href="#codis分片" class="headerlink" title="codis分片"></a>codis分片</h3><p>Codis会把所有的key分成1024个槽，这1024个槽对应着的就是Redis的集群，这个在Codis中是会在内存中维护着这1024个槽与Redis实例的映射关系</p>
<h3 id="槽位同步"><a href="#槽位同步" class="headerlink" title="槽位同步"></a>槽位同步</h3><p>ZooKeeper监听槽位变化，会及时同步</p>
<h3 id="codis扩容"><a href="#codis扩容" class="headerlink" title="codis扩容"></a>codis扩容</h3><p>在迁移的时候，会在原来的Redis节点和新的Redis里都保存着迁移的槽位信息，在迁移的过程中，如果有key打进将要迁移或者正在迁移的旧槽位的时候，这个时候Codis的处理机制是，先是将这个key强制迁移到新的Redis节点中，然后再告诉Codis,下次如果有新的key的打在这个槽位中的话，那么转发到新的节点。</p>
<p>最后自动均衡</p>
<h3 id="codis不支持事务，不支持MSETNX"><a href="#codis不支持事务，不支持MSETNX" class="headerlink" title="codis不支持事务，不支持MSETNX"></a>codis不支持事务，不支持MSETNX</h3><p>因为key可能存在在多个Redis的实例中，如果某个实例的设值成功，而另一个实例的设值不成功，从本质上讲这是不成功的，但是分布在多个实例中的Redis是没有回滚机制的，所以会产生脏数据</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>RestFul设计规则</title>
    <url>/2018/06/02/RestFul%E8%AE%BE%E8%AE%A1%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h2 id="restful"><a href="#restful" class="headerlink" title="restful"></a>restful</h2><p>REST全称是Representational State Transfer，REST本身并没有创造新的技术、组件或服务，而隐藏在RESTful背后的理念就是使用Web的现有特征和能力， 更好地使用现有Web标准中的一些准则和约束。虽然REST本身受Web技术的影响很深， 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。 所以我们这里描述的REST也是通过HTTP实现的REST。</p>
<h2 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h2><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>应该尽量将API部署在专用域名之下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//api.example.com</span></span><br></pre></td></tr></table></figure>

<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>应该将API的版本号放入url</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//www.example.com/app/1.0/foo</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//www.example.com/app/1.1/foo</span></span><br></pre></td></tr></table></figure>

<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>路径又称”终点”（endpoint），表示API的具体网址，每个网址代表一种资源（resource）<br>(1) 资源作为网址，只能有名词，不能有动词，而且所用的名词往往与数据库的表名对应。<br>(2) API中的名词应该使用复数。无论子资源或者所有资源。</p>
<h3 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h3><p>常用的HTTP动词有下面四个（括号里是对应的SQL命令）。</p>
<p>GET（SELECT）：从服务器取出资源（一项或多项）。<br>POST（CREATE）：在服务器新建一个资源。<br>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。<br>DELETE（DELETE）：从服务器删除资源。<br>还有三个不常用的HTTP动词。</p>
<p>PATCH（UPDATE）：在服务器更新(更新)资源（客户端提供改变的属性）。<br>HEAD：获取资源的元数据。<br>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</p>
<h3 id="过滤信息"><a href="#过滤信息" class="headerlink" title="过滤信息"></a>过滤信息</h3><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">?limit=<span class="number">10</span>：指定返回记录的数量</span><br><span class="line">?offset=<span class="number">10</span>：指定返回记录的开始位置。</span><br><span class="line">?page=<span class="number">2</span>&amp;per_page=<span class="number">100</span>：指定第几页，以及每页的记录数。</span><br><span class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?animal_type_id=<span class="number">1</span>：指定筛选条件</span><br></pre></td></tr></table></figure>

<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoos/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">200</span> OK - [GET]：服务器成功返回用户请求的数据</span><br><span class="line"><span class="number">201</span> CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</span><br><span class="line"><span class="number">202</span> Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</span><br><span class="line"><span class="number">204</span> NO CONTENT - [DELETE]：用户删除数据成功。</span><br><span class="line"><span class="number">400</span> INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作</span><br><span class="line"><span class="number">401</span> Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</span><br><span class="line"><span class="number">403</span> Forbidden - [*] 表示用户得到授权（与<span class="number">401</span>错误相对），但是访问是被禁止的。</span><br><span class="line"><span class="number">404</span> NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line"><span class="number">406</span> Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求<span class="built_in">JSON</span>格式，但是只有XML格式）。</span><br><span class="line"><span class="number">410</span> Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line"><span class="number">422</span> Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</span><br><span class="line"><span class="number">500</span> INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</span><br></pre></td></tr></table></figure>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果状态码是4xx，服务器就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    error: <span class="string">&quot;Invalid API key&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /collection：返回资源对象的列表（数组）</span><br><span class="line">GET /collection/resource：返回单个资源对象</span><br><span class="line">POST /collection：返回新生成的资源对象</span><br><span class="line">PUT /collection/resource：返回完整的资源对象</span><br><span class="line">PATCH /collection/resource：返回完整的资源对象</span><br><span class="line">DELETE /collection/resource：返回一个空文档</span><br></pre></td></tr></table></figure>

<h3 id="超媒体"><a href="#超媒体" class="headerlink" title="超媒体"></a>超媒体</h3><p>RESTful API最好做到Hypermedia（即返回结果中提供链接，连向其他API方法），使得用户不查文档，也知道下一步应该做什么。</p>
<p>比如，Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;current_user_url&quot;</span>: <span class="string">&quot;https://api.github.com/user&quot;</span>,</span><br><span class="line"><span class="string">&quot;authorizations_url&quot;</span>: <span class="string">&quot;https://api.github.com/authorizations&quot;</span>,</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>设计规范</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware的.vmdk文件只赠不减的处理方法</title>
    <url>/2019/11/14/VMware%E7%9A%84.vmdk%E6%96%87%E4%BB%B6%E5%8F%AA%E8%B5%A0%E4%B8%8D%E5%87%8F%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>VMware虚拟机的虚拟磁盘的大小会随着使用时间不断变大，而且只赠不减。即使在虚拟系统中删除了磁盘中的文件，虚拟磁盘的大小仍然不会变小。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>VMWare Tools中的 Shrink功能，和vmware-vdiskmanager工具。</p>
<ol>
<li><p>虚拟Windows系统，安装VMWare Tools，直接调用右下角图形工具Shrink。</p>
</li>
<li><p>虚拟Linux系统，关注虚拟机，在VMWare的安装跟路径下，使用vmware-vdiskmanager工具。</p>
</li>
</ol>
<p>如我的VMware安装在H盘，在windows的命令行中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ H:\&gt;cd VMware</span><br><span class="line"></span><br><span class="line">$ H:\VMware&gt;vmware-vdiskmanager.exe -k <span class="string">&quot;H:\UbuntuVMware\Ubuntu 64-bit\Ubuntu 64-bit.vmdk&quot;</span></span><br></pre></td></tr></table></figure>

<p>说明：H:\UbuntuVMware\Ubuntu 64-bit\Ubuntu 64-bit.vmdk是你指定需要shrink的.vmdk文件；另外，由于我的路径中有空格，所以路径用双引号包含，若路径无空格则可以忽略双引号。</p>
<p>如此瘦身之后，我的硬盘并未节省太多空间。原因是Ubuntu系统占用了空间，系统未释放，所有用工具逼它释放并不能达成目的。解决方案如下：</p>
<p>在虚拟Linux系统中，终端使用命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ cat /dev/zero &gt; zero.fill</span><br></pre></td></tr></table></figure>

<p>执行完毕后，发现zero.fill非常大，使用命令将其删除</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ rm -f zero.fill</span><br></pre></td></tr></table></figure>

<p>删除后再退出虚拟系统，在windows下再用vmware-vdiskmanager.exe去shrink文件*.vmdk。结束后我的电脑清理了大量空间。</p>
]]></content>
      <categories>
        <category>环境运维</category>
      </categories>
      <tags>
        <tag>VM</tag>
      </tags>
  </entry>
  <entry>
    <title>tornado websocket源码分析及解决实际问题</title>
    <url>/2019/06/30/tornado%20websocket%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="tornado-websocket"><a href="#tornado-websocket" class="headerlink" title="tornado websocket"></a>tornado websocket</h2><p>tornado版本：4.5.2</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.websocket <span class="keyword">import</span> WebSocketHandler</span><br></pre></td></tr></table></figure>
<p>使用tornado.websocket的websockethandler类</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">class WebSocketHandler(tornado.web.RequestHandler):</span><br></pre></td></tr></table></figure>
<p>websocket继承的是tornado.web.RequestHandler这个类</p>
<h4 id="获取建立连接"><a href="#获取建立连接" class="headerlink" title="获取建立连接"></a>获取建立连接</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@tornado.web.asynchronous</span><br><span class="line">   def get(self, *args, **kwargs):</span><br><span class="line">       self.open_args = args</span><br><span class="line">       self.open_kwargs = kwargs</span><br><span class="line"></span><br><span class="line">       # Upgrade header should be present and should be equal to WebSocket</span><br><span class="line">       <span class="keyword">if</span> self.request.headers.get(<span class="string">&quot;Upgrade&quot;</span>, <span class="string">&quot;&quot;</span>).lower() != <span class="string">&#x27;websocket&#x27;</span>:</span><br><span class="line">           self.set_status(<span class="number">400</span>)</span><br><span class="line">           log_msg = <span class="string">&quot;Can \&quot;Upgrade\&quot; only to \&quot;WebSocket\&quot;.&quot;</span></span><br><span class="line">           self.finish(log_msg)</span><br><span class="line">           gen_log.debug(log_msg)</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">       # Connection header should be upgrade.</span><br><span class="line">       # Some proxy servers/load balancers</span><br><span class="line">       # might mess with it.</span><br><span class="line">       headers = self.request.headers</span><br><span class="line">       connection = map(lambda s: s.strip().lower(),</span><br><span class="line">                        headers.get(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">       <span class="keyword">if</span> <span class="string">&#x27;upgrade&#x27;</span> not <span class="keyword">in</span> connection:</span><br><span class="line">           self.set_status(<span class="number">400</span>)</span><br><span class="line">           log_msg = <span class="string">&quot;\&quot;Connection\&quot; must be \&quot;Upgrade\&quot;.&quot;</span></span><br><span class="line">           self.finish(log_msg)</span><br><span class="line">           gen_log.debug(log_msg)</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">       # Handle WebSocket Origin naming convention differences</span><br><span class="line">       # The difference between version 8 and 13 is that in 8 the</span><br><span class="line">       # client sends a &quot;Sec-Websocket-Origin&quot; header and in 13 it&#x27;s</span><br><span class="line">       # simply &quot;Origin&quot;.</span><br><span class="line">       <span class="keyword">if</span> <span class="string">&quot;Origin&quot;</span> <span class="keyword">in</span> self.request.headers:</span><br><span class="line">           origin = self.request.headers.get(<span class="string">&quot;Origin&quot;</span>)</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           origin = self.request.headers.get(<span class="string">&quot;Sec-Websocket-Origin&quot;</span>, None)</span><br><span class="line"></span><br><span class="line">       # If there was an origin header, check to make sure it matches</span><br><span class="line">       # according to check_origin. When the origin is None, we assume it</span><br><span class="line">       # did not come from a browser and that it can be passed on.</span><br><span class="line">       <span class="keyword">if</span> origin is not None and not self.check_origin(origin):</span><br><span class="line">           self.set_status(<span class="number">403</span>)</span><br><span class="line">           log_msg = <span class="string">&quot;Cross origin websockets not allowed&quot;</span></span><br><span class="line">           self.finish(log_msg)</span><br><span class="line">           gen_log.debug(log_msg)</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">       self.ws_connection = self.get_websocket_protocol()</span><br><span class="line">       <span class="keyword">if</span> self.ws_connection:</span><br><span class="line">           self.ws_connection.accept_connection()</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           self.set_status(<span class="number">426</span>, <span class="string">&quot;Upgrade Required&quot;</span>)</span><br><span class="line">           self.set_header(<span class="string">&quot;Sec-WebSocket-Version&quot;</span>, <span class="string">&quot;7, 8, 13&quot;</span>)</span><br><span class="line">           self.finish()</span><br></pre></td></tr></table></figure>
<p>该方法在建立连接前会检验请求头的信息，是否websocket协议，检查connection连接，是否允许跨域请求，还有浏览器的版本等。调用该方法get_websocket_protocol检查通过，则接受该连接的访问最后accept_connection</p>
<h4 id="ping-pong机制"><a href="#ping-pong机制" class="headerlink" title="ping pong机制"></a>ping pong机制</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@property</span><br><span class="line">    def ping_interval(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;The interval for websocket keep-alive pings.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Set websocket_ping_interval = 0 to disable pings.</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.settings.get(<span class="string">&#x27;websocket_ping_interval&#x27;</span>, None)</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def ping_timeout(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;If no ping is received in this many seconds,</span></span><br><span class="line"><span class="string">        close the websocket connection (VPNs, etc. can fail to cleanly close ws connections).</span></span><br><span class="line"><span class="string">        Default is max of 3 pings or 30 seconds.</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.settings.get(<span class="string">&#x27;websocket_ping_timeout&#x27;</span>, None)</span><br><span class="line">		</span><br><span class="line">def ping(self, data):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;Send ping frame to the remote end.&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.ws_connection is None:</span><br><span class="line">            raise WebSocketClosedError()</span><br><span class="line">        self.ws_connection.write_ping(data)</span><br><span class="line"></span><br><span class="line">    def on_pong(self, data):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;Invoked when the response to a ping frame is received.&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def on_ping(self, data):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;Invoked when the a ping frame is received.&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        pass</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设置为0则为禁用，websocket协议本身自带pingpong机制，用于连接健康检查和保持连接打开状态，但是这个ping pong机制是与浏览器之间进行的，而不是与websocket客户端，且大多由服务端发起，js本身并不存在这样的机制，浏览器又存在各种版本问题，项目中最好由客户端发起心跳去检验服务端，因为由一个服务端对应多个客户端，最好由客户端发起，为了解决这个问题，最好加入心跳机制，来检验连接存活问题。</p>
<h4 id="最大消息"><a href="#最大消息" class="headerlink" title="最大消息"></a>最大消息</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@property</span><br><span class="line">   def max_message_size(self):</span><br><span class="line">       <span class="string">&quot;&quot;</span><span class="string">&quot;Maximum allowed message size.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       If the remote peer sends a message larger than this, the connection</span></span><br><span class="line"><span class="string">       will be closed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Default is 10MiB.</span></span><br><span class="line"><span class="string">       &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.settings.get(<span class="string">&#x27;websocket_max_message_size&#x27;</span>, None)</span><br></pre></td></tr></table></figure>
<p>从源码看最大消息为10M</p>
<h4 id="发消息"><a href="#发消息" class="headerlink" title="发消息"></a>发消息</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def write_message(self, message, binary=False):</span><br><span class="line">       <span class="string">&quot;&quot;</span><span class="string">&quot;Sends the given message to the client of this Web Socket.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       The message may be either a string or a dict (which will be</span></span><br><span class="line"><span class="string">       encoded as json).  If the ``binary`` argument is false, the</span></span><br><span class="line"><span class="string">       message will be sent as utf8; in binary mode any byte string</span></span><br><span class="line"><span class="string">       is allowed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       If the connection is already closed, raises `WebSocketClosedError`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       .. versionchanged:: 3.2</span></span><br><span class="line"><span class="string">          `WebSocketClosedError` was added (previously a closed connection</span></span><br><span class="line"><span class="string">          would raise an `AttributeError`)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       .. versionchanged:: 4.3</span></span><br><span class="line"><span class="string">          Returns a `.Future` which can be used for flow control.</span></span><br><span class="line"><span class="string">       &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">       <span class="keyword">if</span> self.ws_connection is None:</span><br><span class="line">           raise WebSocketClosedError()</span><br><span class="line">       <span class="keyword">if</span> isinstance(message, dict):</span><br><span class="line">           message = tornado.escape.json_encode(message)</span><br><span class="line">       <span class="keyword">return</span> self.ws_connection.write_message(message, binary=binary)</span><br></pre></td></tr></table></figure>
<p>会判断该连接是否存在，不存在则抛出关闭异常，判断消息是否dict，如果是dict则进行编码</p>
<h4 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def check_origin(self, origin):</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;Override to enable support for allowing alternate origins.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      The ``origin`` argument is the value of the ``Origin`` HTTP</span></span><br><span class="line"><span class="string">      header, the url responsible for initiating this request.  This</span></span><br><span class="line"><span class="string">      method is not called for clients that do not send this header;</span></span><br><span class="line"><span class="string">      such requests are always allowed (because all browsers that</span></span><br><span class="line"><span class="string">      implement WebSockets support this header, and non-browser</span></span><br><span class="line"><span class="string">      clients do not have the same cross-site security concerns).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      Should return True to accept the request or False to reject it.</span></span><br><span class="line"><span class="string">      By default, rejects all requests with an origin on a host other</span></span><br><span class="line"><span class="string">      than this one.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      This is a security protection against cross site scripting attacks on</span></span><br><span class="line"><span class="string">      browsers, since WebSockets are allowed to bypass the usual same-origin</span></span><br><span class="line"><span class="string">      policies and don&#x27;t use CORS headers.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      .. warning::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         This is an important security measure; don&#x27;t disable it</span></span><br><span class="line"><span class="string">         without understanding the security implications. In</span></span><br><span class="line"><span class="string">         particular, if your authentication is cookie-based, you</span></span><br><span class="line"><span class="string">         must either restrict the origins allowed by</span></span><br><span class="line"><span class="string">         ``check_origin()`` or implement your own XSRF-like</span></span><br><span class="line"><span class="string">         protection for websocket connections. See `these</span></span><br><span class="line"><span class="string">         &lt;https://www.christian-schneider.net/CrossSiteWebSocketHijacking.html&gt;`_</span></span><br><span class="line"><span class="string">         `articles</span></span><br><span class="line"><span class="string">         &lt;https://devcenter.heroku.com/articles/websocket-security&gt;`_</span></span><br><span class="line"><span class="string">         for more.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      To accept all cross-origin traffic (which was the default prior to</span></span><br><span class="line"><span class="string">      Tornado 4.0), simply override this method to always return true::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          def check_origin(self, origin):</span></span><br><span class="line"><span class="string">              return True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      To allow connections from any subdomain of your site, you might</span></span><br><span class="line"><span class="string">      do something like::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          def check_origin(self, origin):</span></span><br><span class="line"><span class="string">              parsed_origin = urllib.parse.urlparse(origin)</span></span><br><span class="line"><span class="string">              return parsed_origin.netloc.endswith(&quot;</span>.mydomain.com<span class="string">&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      .. versionadded:: 4.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">      parsed_origin = urlparse(origin)</span><br><span class="line">      origin = parsed_origin.netloc</span><br><span class="line">      origin = origin.lower()</span><br><span class="line"></span><br><span class="line">      host = self.request.headers.get(<span class="string">&quot;Host&quot;</span>)</span><br><span class="line"></span><br><span class="line">      # Check to see that origin matches host directly, including ports</span><br><span class="line">      <span class="keyword">return</span> origin == host</span><br></pre></td></tr></table></figure>
<p>重写这个方法 return true则允许跨域请求</p>
<h4 id="建立连接之后"><a href="#建立连接之后" class="headerlink" title="建立连接之后"></a>建立连接之后</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def open(self, *args, **kwargs):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;Invoked when a new WebSocket is opened.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The arguments to `open` are extracted from the `tornado.web.URLSpec`</span></span><br><span class="line"><span class="string">    regular expression, just like the arguments to</span></span><br><span class="line"><span class="string">    `tornado.web.RequestHandler.get`.</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>可重写open方法，在建立连接之后进行业务处理</p>
<h4 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def on_message(self, message):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;Handle incoming messages on the WebSocket</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method must be overridden.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        .. versionchanged:: 4.5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           ``on_message`` can be a coroutine.</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        raise NotImplementedError</span><br></pre></td></tr></table></figure>
<p>由源码看，接收消息的方法必须被重写，不然会抛一个异常</p>
<h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def on_close(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;Invoked when the WebSocket is closed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If the connection was closed cleanly and a status code or reason</span></span><br><span class="line"><span class="string">        phrase was supplied, these values will be available as the attributes</span></span><br><span class="line"><span class="string">        ``self.close_code`` and ``self.close_reason``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        .. versionchanged:: 4.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           Added ``close_code`` and ``close_reason`` attributes.</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def close(self, code=None, reason=None):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;Closes this Web Socket.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Once the close handshake is successful the socket will be closed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        ``code`` may be a numeric status code, taken from the values</span></span><br><span class="line"><span class="string">        defined in `RFC 6455 section 7.4.1</span></span><br><span class="line"><span class="string">        &lt;https://tools.ietf.org/html/rfc6455#section-7.4.1&gt;`_.</span></span><br><span class="line"><span class="string">        ``reason`` may be a textual message about why the connection is</span></span><br><span class="line"><span class="string">        closing.  These values are made available to the client, but are</span></span><br><span class="line"><span class="string">        not otherwise interpreted by the websocket protocol.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        .. versionchanged:: 4.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           Added the ``code`` and ``reason`` arguments.</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.ws_connection:</span><br><span class="line">            self.ws_connection.close(code, reason)</span><br><span class="line">            self.ws_connection = None</span><br></pre></td></tr></table></figure>
<p>on_close方法为连接关闭之后，可以根据业务进行特殊处理，<br>close方法，可由服务端根据业务主动关闭连接，可写code与reason，进行特殊处理，前端的websocket可捕获这个code与reason</p>
<h4 id="发送异常"><a href="#发送异常" class="headerlink" title="发送异常"></a>发送异常</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def send_error(self, *args, **kwargs):</span><br><span class="line">    <span class="keyword">if</span> self.stream is None:</span><br><span class="line">        <span class="built_in">super</span>(WebSocketHandler, self).send_error(*args, **kwargs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    # If we get an uncaught exception during the handshake,</span><br><span class="line">    # we have no choice but to abruptly close the connection.</span><br><span class="line">    # TODO: for uncaught exceptions after the handshake,</span><br><span class="line">    # we can close the connection more gracefully.</span><br><span class="line">    self.stream.close()</span><br></pre></td></tr></table></figure>
<p>send_error发送一个异常，之后会触发关闭连接</p>
<h3 id="根据业务处理特殊问题"><a href="#根据业务处理特殊问题" class="headerlink" title="根据业务处理特殊问题"></a>根据业务处理特殊问题</h3><h4 id="websocket建立连接之前拦截"><a href="#websocket建立连接之前拦截" class="headerlink" title="websocket建立连接之前拦截"></a>websocket建立连接之前拦截</h4><p>经过源码分析可知，没有on_open这种方法，在建立连接之前做一些操作，所以在分析完浏览器请求，接收这个链接之后，建立连接之前重写get_websocket_protocol方法，进行业务相关操作，再调用，如果不符合想要接入的连接，则可以在这里拒绝掉</p>
<h4 id="主动关闭连接，主动发送异常关闭连接"><a href="#主动关闭连接，主动发送异常关闭连接" class="headerlink" title="主动关闭连接，主动发送异常关闭连接"></a>主动关闭连接，主动发送异常关闭连接</h4><p>根据业务需求，我们可以主动调用close方法来主动关闭此次连接，可以设定自定义状态码，然后由前端捕获到，进行业务相关处理。或者调用send_error方法，发送异常来进行业务特殊处理，主动与客户端断开连接</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>tornado-redis版本兼容问题</title>
    <url>/2020/01/16/tornado-redis%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>主要兼容 tornado5.1 因为这个版本删掉了io_loop所以会造成引用时候报错找不到 io_loop.</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>@tornado.web.asynchronous<br>@tornado.gen.engine<br>修改为：</p>
<p>@tornado.gen.coroutine</p>
<p>\Python27\Lib\site-packages\tornadoredis\connection.py</p>
<p>大约75行吧，因为bug多自己修改了一下具体还是搜索下面代码为准：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self._stream = IOStream(sock, io_loop=self._io_loop)</span><br><span class="line">修改为：</span><br><span class="line">self._stream = IOStream(sock)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket分布式共享解决方案</title>
    <url>/2019/07/14/websocket%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E4%BA%AB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="websocket分布式问题"><a href="#websocket分布式问题" class="headerlink" title="websocket分布式问题"></a>websocket分布式问题</h3><p>如果在单机情况下，当websocket需要给用户推送消息时，由于用户已经与websocket服务建立连接，消息推送能够成功。<br>但如果在集群情况下，用户甲向websocket发起连接请求，有多台服务时strong text，只能与一台服务建立连接（以服务A为例），而这些websocket服务都是有可能会给用户甲推送消息，这时候的服务B和C并没有建立连接，所以会有一部分消息推送失败。<br>因为websocket是长连接，session保持在一个server中，所以在不同server在使用websocket推送消息时就需要获取对应的session进行推送，在分布式系统中就无法获取到所有session。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>这里就需要使用一个中间件，将消息推送到个系统中，这里使用redis作为中间件，使用redis的发布订阅功能 pub/sub。<br>在原来的系统里，由业务模块的服务处理业务逻辑，发生需要推送给用户的数据的时候，发消息给websocket服务，由websocket服务推送消息给用户。<br>那么，问题的关键就是确保和用户建立连接的websocket服务就是接收到消息的服务，但是由于建立连接的websockt是由ngnx进行负载均衡分配的，接收消息的服务也是无法确定的，这一点并没有什么太好的办法保证。<br>因此，我们可以换个思路，只要确保对于业务模块发送的消息，所有的websocket服务都能收到消息，只要做到了这一点，与用户建立连接websocket自然也能接收到消息。而且，这种方式相对单台服务收到消息还有一个在处理多点登陆场景下的优势。对于允许多点登录的系统，同一用户可以在多处进行登录，以为着同一用户与多个服务拥有多个websocket连接，这就要求我们保证多台用户消费同一台业务模块的消息。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class RedisListenDelegate(object):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot; redis 队列监控&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, system, connection):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">            init</span></span><br><span class="line"><span class="string">        :param system: 系统名</span></span><br><span class="line"><span class="string">        :param connection: websockets</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        self.connection = connection</span><br><span class="line">        self.system = system</span><br><span class="line">        self.redis = self.get_redis()</span><br><span class="line">        self.redis.connect()</span><br><span class="line">        self.listen()</span><br><span class="line"></span><br><span class="line">    def parse_redis_conf(self, redis_conf):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">            解析redis的配置</span></span><br><span class="line"><span class="string">        :param redis_conf: redis配置</span></span><br><span class="line"><span class="string">        :return: redis配置字典</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> re.match(PATTERN[<span class="string">&#x27;redis_config&#x27;</span>], redis_conf).groupdict()</span><br><span class="line"></span><br><span class="line">    def get_redis(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">            获得redis连接客户端</span></span><br><span class="line"><span class="string">        :return: redis 客户端</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        info = self.parse_redis_conf(REDIS_URL)</span><br><span class="line">        <span class="keyword">return</span> tornadoredis.Client(host=info[<span class="string">&#x27;host&#x27;</span>], port=int(info[<span class="string">&#x27;port&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">    def handle_message(self, message):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">            所有监听redis通道后的处理,都应该继承本函数,本函数是redis通道收到消息后的回调函数</span></span><br><span class="line"><span class="string">        :param message: redis监听结果信息</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        if message.kind != &#x27;message&#x27;:  # 不处理redis连接信息</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.connection.message_delegate.send_message(message.body)  # 发送消息</span><br><span class="line"></span><br><span class="line">    @gen.coroutine</span><br><span class="line">    def listen(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        监听redis通道,回调消息处理</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">yield</span> gen.Task(self.redis.subscribe, SUBSCRIBE_KEY.format(self.system))</span><br><span class="line">        <span class="keyword">yield</span> self.redis.listen(self.handle_message)</span><br><span class="line">		</span><br><span class="line"># 发送消息，访问websocket，最终将消息发布到redis即可，由上面的连接进行监听		</span><br><span class="line">publish(system, message)</span><br></pre></td></tr></table></figure>

<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>每个系统作为一个redis通道进行监听，该系统频道收到消息后，该websocket的server会监听到该消息，通过消息内的用户属性，去从本地服务存储的websocket连接获取该用户的连接，然后对该用户发送消息。分布式情况下，所有的server都会监听到该消息，但是用户建立连接只在其中一个server，这样这个server也就可以监听到这个消息，因为连接存在，所以这个server会对用户发送消息，其他server即使监听到但是没有连接，所以不做处理即可。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1、解决了websocket分布式推送消息的问题。<br>2、代码解耦，websocket服务建立连接，与推送消息到websocket解耦，互不影响，websocket服务挂掉也可以推送消息到redis，无法推消息到redis系统挂掉，也不会影响websocket服务。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket 心跳机制处理</title>
    <url>/2019/07/01/websocket%E5%BF%83%E8%B7%B3%E9%87%8D%E8%BF%9E%E6%9C%BA%E5%88%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="websocket使用问题"><a href="#websocket使用问题" class="headerlink" title="websocket使用问题"></a>websocket使用问题</h3><p>在使用websocket的过程中，有时候会遇到网络断开的情况，或者断电，电脑死机，但是在这些情况下服务器端与客户端并没有触发onclose的事件。这样会有：服务器会继续向客户端发送多余的链接，并且这些数据还会丢失。所以就需要一种机制来检测客户端和服务端是否处于正常的链接状态。因此就有了websocket的心跳了。还有心跳，说明还活着，没有心跳说明已经挂掉了。</p>
<h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><p>心跳机制是每隔一段时间会向服务器发送一个数据包，告诉服务器自己还活着，同时客户端会确认服务器端是否还活着，如果还活着的话，就会回传一个数据包给客户端来确定服务器端也还活着，否则的话，有可能是网络断开连接了。需要重连</p>
<h4 id="关于需要收到服务端回消息才能确认连接存活-的问题"><a href="#关于需要收到服务端回消息才能确认连接存活-的问题" class="headerlink" title="关于需要收到服务端回消息才能确认连接存活 的问题"></a>关于需要收到服务端回消息才能确认连接存活 的问题</h4><p>因为在网络波动，断网，断电情况下，不会触发onclose事件，所以这个时候客户端单独的发消息是可以发送的，这种情况并不能确定断开连接，所以需要服务端回信，如果客户端收到服务端的回信，才能确保连接存活</p>
<h3 id="代码实现及原理"><a href="#代码实现及原理" class="headerlink" title="代码实现及原理"></a>代码实现及原理</h3><h4 id="心跳代码"><a href="#心跳代码" class="headerlink" title="心跳代码"></a>心跳代码</h4><p>前端</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 心跳检测</span></span><br><span class="line">    <span class="function"><span class="title">heartBeat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.timeoutObj &amp;&amp; <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.timeoutObj)</span><br><span class="line">      <span class="built_in">this</span>.serverTimeoutObj &amp;&amp; <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.serverTimeoutObj)</span><br><span class="line">      <span class="built_in">this</span>.timeoutObj = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.websocketSend(<span class="string">&#x27;heart_beat&#x27;</span>)</span><br><span class="line">        <span class="built_in">this</span>.serverTimeoutObj = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.websock.close()     </span><br><span class="line">        &#125;, <span class="number">5000</span>)</span><br><span class="line">      &#125;, <span class="built_in">this</span>.timeout)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<p>后端</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> message == <span class="string">&#x27;heart_beat&#x27;</span>:</span><br><span class="line">    self.write_message(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="心跳原理"><a href="#心跳原理" class="headerlink" title="心跳原理"></a>心跳原理</h4><p>设立两个定时器，由前端发起，第一个定时器为发送心跳的定时器，隔多少秒之后发送一个心跳信息（一分钟），在发送信息之后出发第二个定时器，5秒之后主动关闭连接，也就是说，需要服务端收到心跳之后5秒之内回复消息，如果5秒之内收到消息，则认为客户端与服务端的连接存活，在收到消息的时候会重置心跳定时器，继续以设定的时间延时后发送心跳，如此循环，实现websocket的心跳机制。</p>
<h4 id="重连机制代码"><a href="#重连机制代码" class="headerlink" title="重连机制代码"></a>重连机制代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重连机制</span></span><br><span class="line">    <span class="function"><span class="title">reconnect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 避免重复连接</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.lockReconnect)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.lockReconnect = <span class="literal">true</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;websocket服务异常关闭，正在重连中。。。&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.reconnectTime &gt;= <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;websocket服务重连失败, 请刷新浏览器&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.reconnectData &amp;&amp; <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.reconnectData)</span><br><span class="line">      <span class="built_in">this</span>.reconnectData = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.initWebSocket()</span><br><span class="line">        <span class="built_in">this</span>.reconnectTime++</span><br><span class="line">        <span class="built_in">this</span>.lockReconnect = <span class="literal">false</span></span><br><span class="line">      &#125;,<span class="number">5000</span>)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="重连原理"><a href="#重连原理" class="headerlink" title="重连原理"></a>重连原理</h4><p>在onerror与onclose里都加上了重连机制，也就是说websocket遇到异常，或者关闭进行重连，由于websocket本身在触发onerror事件后一定会触发onclose，所以会进行两次重连，为了避免这种情况，加上了一个重连锁的机制，避免重复连接。<br>当然也不能无限重连，所以要设定重连最大次数，如果到达最大次数还未重连成功，需要用户从新登陆或者刷新浏览器进行重连。<br>设定重连定时器，一但触发重连，5秒之后初始化websocket，从新建立连接，连接次数加一，释放重连锁。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket 服务项目搭建</title>
    <url>/2019/07/10/websocket%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>根据项目要求，在各系统之间实现异步通知服务，从客户端到服务端，从服务端到客户端实现双向通知。以客户端主动，由客户端向服务端发起http请求，来实现任务的发起，服务端执行异步任务，由于非同步，所以客户端并不知道这个任务什么时候执行完毕，所以需要服务端在执行完任务的时候，主动向客户端发送一个请求，来告知客户端我已经完成任务了，来完成服务端客户端的双向通信。</p>
<h3 id="websocket选择"><a href="#websocket选择" class="headerlink" title="websocket选择"></a>websocket选择</h3><p>一般来说，客户端与服务端的交互都是主动的，客户端与服务端对应的模式就是：客户端请求-服务端响应。而服务端主动向客户端推送消息，客户端不像服务端只有一个地址，要解决这一个问题，我考虑到以下两种方式。</p>
<h4 id="Ajax轮询"><a href="#Ajax轮询" class="headerlink" title="Ajax轮询"></a>Ajax轮询</h4><p>所谓的Ajax轮询，其实就是定时的通过Ajax查询服务端，客户端按规定时间定时像服务端发送ajax请求，服务器接到请求后马上返回响应信息并关闭连接。</p>
<p>这种技术方式实现起来非常简单，但是这种方式会有非常严重的问题，就是需要不断的向服务器发送消息询问，这种方式会对服务器造成极大的性能浪费。不是实时通信，不顾及应用的状态改变而盲目检查更新，导致服务器资源的浪费，且会加重网络负载，拖累服务器。</p>
<h4 id="websocket服务"><a href="#websocket服务" class="headerlink" title="websocket服务"></a>websocket服务</h4><p> WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。详情看</p>
<p> 这里选择使用websocket</p>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>Python + tornado + vue + websocket</p>
<h3 id="前端（客户端）建立websocket"><a href="#前端（客户端）建立websocket" class="headerlink" title="前端（客户端）建立websocket"></a>前端（客户端）建立websocket</h3><p>由客户端主动与服务端建立websocket连接，并保持连接通道，通道保持就可以实现双向通信，发消息，建立连接时，根据用户行为（登录等）初始化链接。代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name : <span class="string">&#x27;websocket&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;     </span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      websock: <span class="literal">null</span>,</span><br><span class="line">      reconnectTime: <span class="number">0</span>,       <span class="comment">// 重连次数</span></span><br><span class="line">      reconnectData:<span class="literal">null</span>,     <span class="comment">// 重连定时</span></span><br><span class="line">      lockReconnect:<span class="literal">false</span>,    <span class="comment">//避免重复连接，因为onerror之后会立即触发 onclose</span></span><br><span class="line">      timeout:<span class="number">1000</span>,          <span class="comment">//60s一次心跳检测</span></span><br><span class="line">      timeoutObj:<span class="literal">null</span>,        <span class="comment">// 客户端发送定时</span></span><br><span class="line">      serverTimeoutObj:<span class="literal">null</span>,  <span class="comment">// 收到服务器响应定时</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.initWebSocket()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.lockReconnect = <span class="literal">true</span></span><br><span class="line">    <span class="built_in">this</span>.websock.close()                  <span class="comment">//离开路由之后断开websocket连接</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.reconnectData)      <span class="comment">//离开清除 timeout</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.timeoutObj)         <span class="comment">//离开清除 timeout</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.serverTimeoutObj)   <span class="comment">//离开清除 timeout</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">//初始化weosocket</span></span><br><span class="line">    <span class="function"><span class="title">initWebSocket</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      const wsuri = &#x27; &#x27; # 链接地址</span><br><span class="line">      <span class="built_in">this</span>.websock = <span class="keyword">new</span> WebSocket(wsuri + <span class="string">&#x27;?token=&#x27;</span> + <span class="built_in">this</span>.$store.getters.token)  </span><br><span class="line">      <span class="built_in">this</span>.websock.onmessage = <span class="built_in">this</span>.websocketOnMessage     </span><br><span class="line">      <span class="built_in">this</span>.websock.onopen = <span class="built_in">this</span>.websocketOnOpen    </span><br><span class="line">      <span class="built_in">this</span>.websock.onerror = <span class="built_in">this</span>.websocketOnError    </span><br><span class="line">      <span class="built_in">this</span>.websock.onclose = <span class="built_in">this</span>.websocketClose</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//连接建立之后执行send方法发送数据</span></span><br><span class="line">    <span class="function"><span class="title">websocketOnOpen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.heartBeat()</span><br><span class="line">      <span class="built_in">this</span>.reconnectTime = <span class="number">0</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;websocket服务连接成功&#x27;</span>) </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//连接建立失败重连</span></span><br><span class="line">    <span class="function"><span class="title">websocketOnError</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.reconnect()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//数据发送</span></span><br><span class="line">    <span class="function"><span class="title">websocketSend</span>(<span class="params">Data</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.websock.send(<span class="built_in">JSON</span>.stringify(Data))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    <span class="function"><span class="title">websocketClose</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.reconnect()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//数据接收</span></span><br><span class="line">    <span class="function"><span class="title">websocketOnMessage</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.heartBeat()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 心跳检测</span></span><br><span class="line">    <span class="function"><span class="title">heartBeat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.timeoutObj &amp;&amp; <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.timeoutObj)</span><br><span class="line">      <span class="built_in">this</span>.serverTimeoutObj &amp;&amp; <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.serverTimeoutObj)</span><br><span class="line">      <span class="built_in">this</span>.timeoutObj = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.websocketSend(<span class="string">&#x27;heart_beat&#x27;</span>)</span><br><span class="line">        <span class="built_in">this</span>.serverTimeoutObj = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.websock.close()     </span><br><span class="line">        &#125;, <span class="number">5000</span>)</span><br><span class="line">      &#125;, <span class="built_in">this</span>.timeout)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 重连机制</span></span><br><span class="line">    <span class="function"><span class="title">reconnect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 避免重复连接</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.lockReconnect)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.lockReconnect = <span class="literal">true</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;websocket服务异常关闭，正在重连中。。。&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.reconnectTime &gt;= <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;websocket服务重连失败, 请刷新浏览器&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.reconnectData &amp;&amp; <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.reconnectData)</span><br><span class="line">      <span class="built_in">this</span>.reconnectData = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.initWebSocket()</span><br><span class="line">        <span class="built_in">this</span>.reconnectTime++</span><br><span class="line">        <span class="built_in">this</span>.lockReconnect = <span class="literal">false</span></span><br><span class="line">      &#125;,<span class="number">5000</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>用户行为操作后，或者前端项目启动后，加载这个组件，然后就会初始化websocket，与服务端进行连接，连接成功之后会触发心跳机制维持连接，可以通过websocket的事件进行收发消息</p>
<h3 id="服务端启动websocket服务"><a href="#服务端启动websocket服务" class="headerlink" title="服务端启动websocket服务"></a>服务端启动websocket服务</h3><h4 id="websocket连接层"><a href="#websocket连接层" class="headerlink" title="websocket连接层"></a>websocket连接层</h4><p>前端通过连接地址，指定websocket服务端启动的ip端口，继承websocket基类，创立连接</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base.websocket <span class="keyword">import</span> BaseWebSocket</span><br><span class="line"><span class="keyword">from</span> lib.routes <span class="keyword">import</span> route</span><br><span class="line"><span class="keyword">from</span> services.connection <span class="keyword">import</span> Connection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@route(r<span class="string">&#x27;/websocket&#x27;</span>)</span><br><span class="line">class AthenaWebsocket(BaseWebSocket):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;websocket连接层，创建连接&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    connection = Connection(<span class="string">&#x27;athena&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="websocket基类"><a href="#websocket基类" class="headerlink" title="websocket基类"></a>websocket基类</h4><p>建立连接成功后，可对该连接进行处理，将该用户访问的连接保存在本地，维护连接通道</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ujson</span><br><span class="line"><span class="keyword">from</span> tornado.websocket <span class="keyword">import</span> WebSocketHandler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseWebSocket(WebSocketHandler):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot; websocket基类&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">	user = None</span><br><span class="line">	connection = None  # 维护的连接</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> def open(self, *args, **kwargs):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">            建立websocket时，触发的方法，可对用户进行注册，保存本地连接实例</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">		  self.connection.register(self)</span><br><span class="line"></span><br><span class="line">    def on_message(self, info):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;处理由web页面传递的消息</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            message = ujson.loads(info)</span><br><span class="line">            # 心跳处理</span><br><span class="line">            <span class="keyword">if</span> message == <span class="string">&#x27;heart_beat&#x27;</span>:</span><br><span class="line">                self.write_message(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">        except Exception <span class="keyword">as</span> e:</span><br><span class="line">           pass</span><br><span class="line"></span><br><span class="line">    def on_close(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;websocket 关闭， 移除socket连接实例</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.user:</span><br><span class="line">            self.connection.unregister(self)</span><br><span class="line"></span><br><span class="line">    def check_origin(self, origin):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">             默认允许跨域请求</span></span><br><span class="line"><span class="string">        :param origin:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> True</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="保存连接"><a href="#保存连接" class="headerlink" title="保存连接"></a>保存连接</h4><p>用户通过前端建立连接后，将连接实例保存在本地（无法保存在redis，mysql等库中，为连接对象），之后通过连接实例进行收发消息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class Connection(object):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;连接状态&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, system):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">            连接初始化，若需重写连接状态的部分逻辑，替换对应的代理&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">		# 保存的websocket连接实例</span></span><br><span class="line"><span class="string">        self.websockets = defaultdict(list)</span></span><br><span class="line"><span class="string">        self.message_delegate = MessageDelegate(system, self.websockets)  # 发送消息代理类</span></span><br><span class="line"><span class="string">        self.redis_delegate = RedisListenDelegate(system, self)  # redis 监听类</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def register(self, item):</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">            用户建立webscoket</span><br><span class="line">            <span class="number">1.</span> 添加新连接， </span><br><span class="line">        :param item: websocket instance</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        if item in self.websockets[item.user]:</span></span><br><span class="line"><span class="string">            return</span></span><br><span class="line"><span class="string">        self.websockets[item.user].append(item)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def unregister(self, item):</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">            用户退出websocket</span><br><span class="line">             <span class="number">1.</span> 删除连接,  <span class="number">2.</span>删除用户在线状态</span><br><span class="line">        :param item: websocket instance</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        self.websockets[item.user].remove(item)</span></span><br></pre></td></tr></table></figure>

<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>服务端只要调用发消息的方法，从本地根据连接的用户属性，获取当前用户在建立连接时保存的连接，然后根据连接对象实现主动向客户端发送消息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class MessageDelegate(object):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot; 消息代理&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, system, websockets):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">            init</span></span><br><span class="line"><span class="string">        :param websockets: websoctets</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        self.websockets = websockets  # 和connection宿主维护同一个连接记录池</span><br><span class="line"></span><br><span class="line">    def send_message(self, message):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">             向指定用户发送请求,若用户在线直接发送</span></span><br><span class="line"><span class="string">        :param message:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        msg = ujson.loads(message)</span><br><span class="line">        receiver = msg.get(<span class="string">&#x27;receiver&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> receiver:</span><br><span class="line">            self.unicast(receiver, msg)</span><br><span class="line"></span><br><span class="line">    def unicast(self, receiver, message):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">            指定用户发送消息</span></span><br><span class="line"><span class="string">        :param receiver: 用户</span></span><br><span class="line"><span class="string">        :param message: 消息</span></span><br><span class="line"><span class="string">        # :return:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        websockets = self.websockets.get(receiver, [])</span><br><span class="line">        <span class="keyword">if</span> not websockets:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> websocket <span class="keyword">in</span> websockets:</span><br><span class="line">            self.write_message(websocket, message)</span><br><span class="line"></span><br><span class="line">    def write_message(self, socket, message):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">            向客户端发消息</span></span><br><span class="line"><span class="string">        :param socket: 需要发送信息的websocketHandler连接</span></span><br><span class="line"><span class="string">        :param message: 发送的信息</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        socket.write_message(message)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket状态码</title>
    <url>/2019/06/23/websocket%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<h3 id="websocket状态码的使用"><a href="#websocket状态码的使用" class="headerlink" title="websocket状态码的使用"></a>websocket状态码的使用</h3><p>在websocket协议中，内置了许多供websocket连接中使用的状态码，官方定义了一些</p>
<h4 id="定义连接相关的状态代码"><a href="#定义连接相关的状态代码" class="headerlink" title="定义连接相关的状态代码"></a>定义连接相关的状态代码</h4><p>   1000</p>
<pre><code>  1000表示正常闭合，意味着目的
  建立连接已经完成。</code></pre>
<p>   1001</p>
<pre><code>  1001表示端点“正在离开”，例如服务器
  下降或浏览器已离开页面。</code></pre>
<p>   1002</p>
<pre><code>  1002表示端点正在终止连接</code></pre>
<p>   1003</p>
<pre><code>  1003表示端点正在终止连接
  因为它收到了一种它无法接受的数据</code></pre>
<p>   1004</p>
<pre><code>  保留。具体含义可能在将来定义。</code></pre>
<p>   1005</p>
<pre><code>  1005是保留值，不得设置为a中的状态代码
  由端点关闭控制框架。它被指定用于
  期望状态代码表明没有状态的应用程序
  代码实际上存在。</code></pre>
<p>   1006</p>
<pre><code>  1006是保留值，不得设置为a中的状态码
  由端点关闭控制框架。它被指定用于
  应用程序期望状态代码指示
  连接异常关闭，例如，没有发送或
  接收关闭控制框架。</code></pre>
<p>   1007</p>
<pre><code>  1007表示端点正在终止连接
  因为它已收到消息中没有的数据
  与消息类型一致（例如，非UTF-8 [ RFC3629 ]
  短信中的数据）。</code></pre>
<p>   1008</p>
<pre><code>  1008表示端点正在终止连接
  因为它收到了违反其政策的消息。这个
  是一个通用的状态代码，可以在没有时返回
  其他更合适的状态代码（例如，1003或1009）或是否存在
  需要隐藏有关策略的特定详细信息。</code></pre>
<p>   1009</p>
<pre><code>  1009表示端点正在终止连接，因为它收到的消息太大了
  难以处理。</code></pre>
<p>   1010</p>
<pre><code>  1010表示端点（客户端）正在终止
  连接，因为它已经期望服务器协商一个或
  更多扩展，但服务器没有在响应中返回它们
  WebSocket握手的消息。扩展名列表
  是否应该出现在关闭框架的/ reason /部分中。
  请注意，服务器不使用此状态代码，因为它
  可能会失败WebSocket握手。</code></pre>
<p>   1011</p>
<pre><code>  1011表示服务器正在终止连接，因为
  它遇到了阻止它的意外情况。</code></pre>
<p>   1015</p>
<pre><code>  1015是保留值，不得设置为a中的状态码
  由端点关闭控制框架。它被指定用于
  应用程序期望状态代码指示
  由于未能执行TLS握手，连接已关闭
  （例如，无法验证服务器证书）。</code></pre>
<h4 id="保留的状态代码范围"><a href="#保留的状态代码范围" class="headerlink" title="保留的状态代码范围"></a>保留的状态代码范围</h4><p>   0-999</p>
<pre><code>  不使用0-999范围内的状态代码。</code></pre>
<p>   1000-2999</p>
<pre><code>  1000-2999范围内的状态代码保留用于定义
  此协议，其未来的修订版中随时可用的公共规范。</code></pre>
<p>   3000-3999</p>
<pre><code>  3000-3999范围内的状态代码保留供使用
  库，框架和应用程序。这些状态代码是
  直接在IANA注册。这些代码的解释
  该协议未定义。</code></pre>
<p>   4000-4999</p>
<pre><code>  4000-4999范围内的状态代码保留供私人使用
  因此无法注册。这些代码可以由先前使用
  WebSocket应用程序之间的协议。</code></pre>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>两两交换链表中的节点</title>
    <url>/2021/01/28/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><img src="/2021/01/28/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/1.jpg" alt="1"></p>
<p>图解如下：</p>
<p><img src="/2021/01/28/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/1.jpg" alt="1"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func swapPairs(head *ListNode) *ListNode &#123;</span><br><span class="line">	<span class="comment">// 定义一个head之前的节点，作为初始节点</span></span><br><span class="line">    start := &amp;ListNode&#123;&#125;</span><br><span class="line">    <span class="comment">// 初始节点指向头指针</span></span><br><span class="line">    start.Next = head</span><br><span class="line">    <span class="comment">// 第一个指针指向这个初始节点</span></span><br><span class="line">    prev := start</span><br><span class="line">    <span class="comment">// 开始循环，当前节点为nil，或Next为nil则结束循环</span></span><br><span class="line">    <span class="keyword">for</span> head != nil &amp;&amp; head.Next != nil &#123;</span><br><span class="line">    	<span class="comment">// 图解开始操作指针的next</span></span><br><span class="line">        next := head.Next</span><br><span class="line">        head.Next = next.Next</span><br><span class="line">        next.Next = head</span><br><span class="line">        prev.Next = next</span><br><span class="line">        <span class="comment">// 相当于移动指针，head的next已经改变</span></span><br><span class="line">        prev = head</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后返回初始节点的next，也就是后续节点都已经改变完成的节点</span></span><br><span class="line">    <span class="keyword">return</span> start.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>两个数组的交集</title>
    <url>/2021/02/01/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<p>给定两个数组，编写一个函数来计算它们的交集。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">input：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], nums2 = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">res = [<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。<br>我们可以不考虑输出结果的顺序。</p>
<p>如果给定的数组已经排好序呢？你将如何优化你的算法？ 双指针<br>如果 nums1 的大小比 nums2 小很多，哪种方法更优？ map哈希<br>如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 归并排序</p>
<h2 id="map哈希"><a href="#map哈希" class="headerlink" title="map哈希"></a>map哈希</h2><p>优化：比较两个数组的大小，选择小的那个数组做map哈希</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func intersect(nums1 []int, nums2 []int) []int &#123;</span><br><span class="line">    resMap := make(map[int]int, len(nums1))</span><br><span class="line">    <span class="keyword">for</span> _, <span class="attr">v</span> := range nums1 &#123;</span><br><span class="line">        <span class="keyword">if</span> _, <span class="attr">ok</span> := resMap[v]; ok &#123;</span><br><span class="line">            resMap[v] += <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resMap[v] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res := make([]int, <span class="number">0</span>, len(nums2))</span><br><span class="line">    <span class="keyword">for</span> _, <span class="attr">v</span> := range nums2 &#123;</span><br><span class="line">        <span class="keyword">if</span> _, <span class="attr">ok</span> := resMap[v]; ok &amp;&amp; resMap[v] &gt;= <span class="number">1</span> &#123;</span><br><span class="line">            res = append(res, v)</span><br><span class="line">            resMap[v] -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>优化：如果已经排好序，则减少排序次数</p>
<p>不能用if else, if else是顺序执行，前面++后，最后一层判断会超出slice边界</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func intersect(nums1 []int, nums2 []int) []int &#123;</span><br><span class="line">    sort.Ints(nums1)</span><br><span class="line">    sort.Ints(nums2)</span><br><span class="line">    i, <span class="attr">j</span> := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> res []int</span><br><span class="line">    <span class="keyword">for</span> i &lt; len(nums1) &amp;&amp; j &lt; <span class="function"><span class="title">len</span>(<span class="params">nums2</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> nums1[i] &lt; nums2[j]:</span><br><span class="line">            i++</span><br><span class="line">        <span class="keyword">case</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">            j++</span><br><span class="line">        <span class="keyword">case</span> nums1[i] == nums2[j]:</span><br><span class="line">            res = append(res, nums1[i])</span><br><span class="line">            i++</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序优化三"><a href="#归并排序优化三" class="headerlink" title="归并排序优化三"></a>归并排序优化三</h2><p>可以将分割后的子数组写到单个文件中，归并时将小文件合并为更大的文件。当两个数组均排序完成生成两个大文件后，即可使用双指针遍历两个文件，如此可以使空间复杂度最低</p>
<p>也就是上面双指针，归并排序的思想</p>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>两个有序数组的中位数</title>
    <url>/2020/12/22/%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。</p>
<p>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p>
<h3 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h3><p>合并两个数组，进行排序，然后判断长度奇数，偶数<br>1.奇数则取中间那个<br>2.偶数则取中间两个的和除以2</p>
<h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findMedianSortedArrays(self, <span class="attr">nums1</span>: List[int], <span class="attr">nums2</span>: List[int]) -&gt; float:</span><br><span class="line">        nums1.extend(nums2)</span><br><span class="line">        nums1.sort()</span><br><span class="line">        n = len(nums1)</span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1[int((n - <span class="number">1</span>)/<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (nums1[int(n/<span class="number">2</span>) - <span class="number">1</span>] + nums1[int(n/<span class="number">2</span>)])/<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度是 O(m+n)，空间复杂度是 O(m+n)</p>
<h3 id="优化：二分查找"><a href="#优化：二分查找" class="headerlink" title="优化：二分查找"></a>优化：二分查找</h3><p>不需要合并两个数组，再去找中位数的位置，两个有序数组，可根据下标，直接去找中位数的位置</p>
<p>当 m+n 是奇数时，中位数是两个有序数组中的第 (m+n)/2 个元素，当 m+n 是偶数时，中位数是两个有序数组中的第 (m+n)/2 个元素和第 (m+n)/2+1 个元素的平均值。因此，这道题可以转化成寻找两个有序数组中的第 k 小的数，其中 k 为 (m+n)/2或 (m+n)/2+1。</p>
<p>判断2个有序数组的长度和 m+n<br>长度和为奇数：k=((m+n) +1)/2,第k个数为中位数<br>长度和为偶数：k1=(m+n)/2，k2=(m+n)/2 + 1，这两个数的平均值为中位数</p>
<p>都是有序数组，就是找第k小的数，或者找第k，与第k+1小的数</p>
<p>假设A,B两个数组，比较A[k/2-1]和B[k/2-1]</p>
<p>1.如果A[k/2-1]&lt;B[k/2-1],则比A[k/2−1]小的数最多只有A 的前k/2−1 个数和B 的前k/2−1 个数，即比A[k/2−1] 小的数最多只有k−2 个，因此A[k/2−1]不可能是第k个数A[0]到A[k/2−1]也都不可能是第k个数，可以全部排除</p>
<p>PS: 排除A里面的A[0]到A[k/2−1]</p>
<p>2.如果A[k/2−1]&gt;B[k/2−1]，则可以排除B[0]到B[k/2−1]，与上面同理</p>
<p>3.如果A[k/2−1]=B[k/2−1]，则可以归入第一种情况处理</p>
<p>比较完之后，可以发现，排除了k/2 个不可能是第k小的数，查找范围缩小了一半</p>
<p>然后继续二分查找，同时根据排除的个数，减少k的值</p>
<p>特殊处理的情况：<br>1.如果A[k/2−1]或者B[k/2−1]越界,那么我们可以选取对应数组中的最后一个元素。<br>在这种情况下，我们必须根据排除数的个数减少k的值，而不能直接将k减去k/2。</p>
<p>2.如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 kk 小的元素。</p>
<p>3.如果k=1，我们只要返回两个数组首元素的最小值即可</p>
<h4 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findMedianSortedArrays(self, <span class="attr">nums1</span>: List[int], <span class="attr">nums2</span>: List[int]) -&gt; float:</span><br><span class="line">    	# 二分查找，找两个数组里第k小的数</span><br><span class="line">        def getKthElement(k):</span><br><span class="line">      		# 双指针，两个数组。不包含已排除的有效起始索引下标</span><br><span class="line">            index1, index2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> True:</span><br><span class="line">                # 特殊情况，while循环的结束条件</span><br><span class="line">                <span class="keyword">if</span> index1 == m:</span><br><span class="line">                	# 如果1的索引下标到达了数组长度，也就是0，则数组1都被排除了，返回数组2的剩下的中位数</span><br><span class="line">                    <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> index2 == n:</span><br><span class="line">                	# 如果2的索引下标到达了数组长度，也就是0， 则数组2都被排除了，返回数组1的剩下的中位数</span><br><span class="line">                    <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">                	# 如果k为1，则数组长度为1，则返回两个数组的最小值</span><br><span class="line">                    <span class="keyword">return</span> min(nums1[index1], nums2[index2])</span><br><span class="line"></span><br><span class="line">                # 正常情况</span><br><span class="line">                # 计算新的k得到的下标，与最大下标的最小值，防止越界</span><br><span class="line">                newIndex1 = min(index1 + k <span class="comment">// 2 - 1, m - 1)</span></span><br><span class="line">                newIndex2 = min(index2 + k <span class="comment">// 2 - 1, n - 1)</span></span><br><span class="line">                pivot1, pivot2 = nums1[newIndex1], nums2[newIndex2]</span><br><span class="line">                # 比较两个值，小于等于，第一种情况</span><br><span class="line">                <span class="keyword">if</span> pivot1 &lt;= pivot2:</span><br><span class="line">                	# 第一个数组的值小于第二个数组的值，则排除第一个数组的值之前的元素</span><br><span class="line">                    # 然后偏移k，k减去 新的起始索引减去老的起始索引，即排除的元素</span><br><span class="line">                    k -= newIndex1 - index1 + <span class="number">1</span></span><br><span class="line">                    # 第一个数组往后挪一位，比较后面的，前面的已经被排除了，得到下一个的起始索引</span><br><span class="line">                    index1 = newIndex1 + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                	# 第一个数组的值大于第二个数组的值，则排除第二个数组的值之前的元素</span><br><span class="line">                	# 然后偏移k，k减去 新的起始索引减去老的起始索引，即排除的元素</span><br><span class="line">                    k -= newIndex2 - index2 + <span class="number">1</span></span><br><span class="line">                	# 第二个数组往后挪一位，比较后面的，前面的已经被排除了，得到下一个的起始索引</span><br><span class="line">                    index2 = newIndex2 + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">1.这里开始  # 得到两个数组的长度</span><br><span class="line">        m, n = len(nums1), len(nums2)</span><br><span class="line">        totalLength = m + n</span><br><span class="line">        # 总长度取余，如果有余数是1，就是奇数，+1除以2，得到k，找第k小的数</span><br><span class="line">        <span class="keyword">if</span> totalLength % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> getKthElement((totalLength + <span class="number">1</span>) <span class="comment">// 2)</span></span><br><span class="line">        # 否则就是偶数，除以2得到k，找第k小的数与找第k+1小的数，求和除以2，得到最后的值</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (getKthElement(totalLength <span class="comment">// 2) + getKthElement(totalLength // 2 + 1)) / 2</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(log(m+n))，其中 m 和 n 分别是数组nums1和nums2的长度。初始时有 k=(m+n)/2 或 k=(m+n)/2+1，每一轮循环可以将查找范围减少一半，因此时间复杂度是 O(log(m+n))。</p>
<p>空间复杂度：O(1)</p>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和，三数之和</title>
    <url>/2021/01/27/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>你可以按任意顺序返回答案。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">input = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">res = [<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>注意不能用重复元素，要判断i！=j的条件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func twoSum(nums []int, target int) []int &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;len(nums)-<span class="number">1</span>;i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;len(nums);j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] == target &amp;&amp; i != j &#123;</span><br><span class="line">                <span class="keyword">return</span> []int&#123;i, j&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []int&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两重for循环，o(n方)</p>
<h3 id="map解法"><a href="#map解法" class="headerlink" title="map解法"></a>map解法</h3><p>建立一个map，循环这个数组，判断target-i在不在这个map里，不在就把这个i和其索引放到map里</p>
<p>如果后续有新的i能跟此次循环的i，target-i在这个map里就返回，找到了</p>
<p>重复的数字，索引覆盖即可，也避免了使用同一</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func twoSum(nums []int, target int) []int &#123;</span><br><span class="line">    numsMap := make(map[int]int, len(nums))</span><br><span class="line">    <span class="keyword">for</span> p, <span class="attr">num</span> := range nums &#123;</span><br><span class="line">        <span class="keyword">if</span> q, <span class="attr">ok</span> := numsMap[target - num]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []int&#123;q, p&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        numsMap[num] = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []int&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需循环遍历一次， O(n)</p>
<h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p>相比于2数之和，加了一阶</p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<h3 id="暴力解法三重循环"><a href="#暴力解法三重循环" class="headerlink" title="暴力解法三重循环"></a>暴力解法三重循环</h3><p>三重遍历，O(n三次方)</p>
<p>去除重复，先排序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func threeSum(nums []int) [][]int &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 排序，遇到相同的可以跳过循环</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span> ;i&lt;len(nums);i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span> ;j&lt;len(nums);j++&#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;nums[j]&#123;</span><br><span class="line">                nums[i],nums[j] = nums[j],nums[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	n := <span class="number">0</span>;</span><br><span class="line">	num := make([][]int,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">	<span class="comment">// 开始遍历</span></span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">0</span> ; i&lt;len(nums) ;i++&#123;</span><br><span class="line">		<span class="comment">// 重复的就跳过，下一位</span></span><br><span class="line">        <span class="keyword">if</span> i&gt;=<span class="number">1</span> &amp;&amp; nums[i-<span class="number">1</span>] == nums[i]&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数</span></span><br><span class="line">        n += nums[i]</span><br><span class="line">		<span class="keyword">for</span> j := i+<span class="number">1</span> ; j&lt;len(nums) ;j++&#123;</span><br><span class="line">			<span class="comment">// 第二层遍历，重复的跳过</span></span><br><span class="line">            <span class="keyword">if</span> j&gt;=i+<span class="number">2</span> &amp;&amp; nums[j-<span class="number">1</span>] == nums[j]&#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// 计数</span></span><br><span class="line">            n += nums[j]</span><br><span class="line">			<span class="keyword">for</span> k:= j+<span class="number">1</span> ;k&lt;len(nums) ;k++&#123;</span><br><span class="line">				<span class="comment">// 第三层遍历，重复的跳过</span></span><br><span class="line">                <span class="keyword">if</span> k&gt;=j+<span class="number">2</span> &amp;&amp; nums[k-<span class="number">1</span>] == nums[k]&#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 计数，n是三个数之和，如果为0，则是结果保存</span></span><br><span class="line">                n += nums[k]</span><br><span class="line">				<span class="keyword">if</span> n==<span class="number">0</span>&#123;</span><br><span class="line">                    t := []int&#123;nums[i],nums[j],nums[k]&#125;</span><br><span class="line">					num = append(num,t)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 如果不是，减去k</span></span><br><span class="line">				n -= nums[k]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 再减去j</span></span><br><span class="line">			n -= nums[j]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 减去i</span></span><br><span class="line">		n -= nums[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>会超出时间限制</p>
<h3 id="双指针夹逼"><a href="#双指针夹逼" class="headerlink" title="双指针夹逼"></a>双指针夹逼</h3><p>将数组排序，固定一个指针，然后剩下的两个指针一个在头，一个在尾，往中间移动</p>
<p><img src="/2021/01/27/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/1.jpg" alt="1"></p>
<p>现在已经找到了三个数，当然是计算其三值是否满足三元组。但是这里因为我们已经排好了序，如果固定下来的数（上面蓝色框框）本身就大于0，那三数之和必然无法等于0</p>
<p>我们需要移动指针。现在我们的排序就发挥出用处了，如果和大于 0，那就说明 right 的值太大，需要左移。如果和小于 0，那就说明 left 的值太小，需要右移</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func threeSum(nums []int) [][]int &#123;</span><br><span class="line">	<span class="comment">// 先从小到大排序</span></span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	<span class="comment">// 接收结果</span></span><br><span class="line">	<span class="keyword">var</span> res [][]int</span><br><span class="line">	<span class="comment">// 获取数组长度</span></span><br><span class="line">	length := len(nums)</span><br><span class="line">	<span class="comment">// 边界处理，数字不足三个直接返回空</span></span><br><span class="line">	<span class="keyword">if</span> len(nums) &lt; <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开始循环第一个固定值</span></span><br><span class="line">	<span class="keyword">for</span> index, <span class="attr">value</span> := range nums &#123;</span><br><span class="line">		<span class="comment">// 如果固定位的值已经大于0，因为已经排好序了，后面的两个指针对应的值也肯定大于0，则和不可能为0，所以返回</span></span><br><span class="line">		<span class="keyword">if</span> nums[index] &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> res</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 排除值重复的固定位</span></span><br><span class="line">		<span class="keyword">if</span> index &gt; <span class="number">0</span> &amp;&amp; nums[index] == nums[index-<span class="number">1</span>] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 指针初始位置，固定位右边第一个和数组最后一个</span></span><br><span class="line">		l := index + <span class="number">1</span></span><br><span class="line">		r := length - <span class="number">1</span></span><br><span class="line">		<span class="comment">// 开始移动两个指针</span></span><br><span class="line">		<span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">			<span class="comment">// 判断三个数字之和的三种情况</span></span><br><span class="line">			sum := value + nums[l] + nums[r]</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> sum == <span class="number">0</span>:</span><br><span class="line">				<span class="comment">// 将结果加入二元组</span></span><br><span class="line">				res = append(res, []int&#123;nums[index], nums[l], nums[r]&#125;)</span><br><span class="line">				<span class="comment">// 去重，如果l &lt; r且下一个数字一样，则继续挪动</span></span><br><span class="line">				<span class="keyword">for</span> l &lt; r &amp;&amp; nums[l] == nums[l+<span class="number">1</span>] &#123;</span><br><span class="line">					l += <span class="number">1</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 同理</span></span><br><span class="line">				<span class="keyword">for</span> l &lt; r &amp;&amp; nums[r] == nums[r-<span class="number">1</span>] &#123;</span><br><span class="line">					r -= <span class="number">1</span></span><br><span class="line">				&#125;</span><br><span class="line">				l += <span class="number">1</span></span><br><span class="line">				r -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">case</span> sum &gt; <span class="number">0</span>:</span><br><span class="line">				<span class="comment">// 如果和大于 0，那就说明 right 的值太大，需要左移</span></span><br><span class="line">				r -= <span class="number">1</span></span><br><span class="line">				<span class="comment">// 如果和小于 0，那就说明 left 的值太小，需要右移 </span></span><br><span class="line">			<span class="keyword">case</span> sum &lt; <span class="number">0</span>:</span><br><span class="line">				l += <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/03/29/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>二分查找条件：</p>
<p>1.目标函数单调性，递增或者递减</p>
<p>2.存在上下界</p>
<p>3.能够通过索引访问</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line">func two(nums []int) int &#123;</span><br><span class="line">	<span class="comment">// 左右起点</span></span><br><span class="line">	left, <span class="attr">right</span> := <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">		<span class="comment">// 得到中间值</span></span><br><span class="line">		mid = left + (right - left) &gt;&gt; <span class="number">1</span></span><br><span class="line">		<span class="comment">// 等于找到则返回</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">			<span class="keyword">return</span> target or <span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> mid &lt; target &#123; <span class="comment">// 否则target在mid右侧，左下标到mid+1</span></span><br><span class="line">			left = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// target在mid左侧，右下标到mid-1</span></span><br><span class="line">			right = mid - <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每次循环将搜索范围缩小到之前的一半， O（logN）</p>
<p>PS：<br>1.计算 mid 时 ，不能使用 （left + right ）/ 2,否则有可能会导致溢出</p>
<p>2.for循环结束条件是 left &lt;= right， left=right正是最终结果，不能漏掉</p>
<p>3.left = mid + 1,right = mid - 1 而不是 left = mid 和 right = mid</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="半有序数组"><a href="#半有序数组" class="headerlink" title="半有序数组"></a>半有序数组</h4><p>使用二分查找，寻找一个半有序数组中间无序的地方[4,5,6,7,0,1,2]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找，返回的是数组的索引</span></span><br><span class="line">func search(nums []int) int &#123;</span><br><span class="line">	<span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右下标</span></span><br><span class="line">    l := <span class="number">0</span></span><br><span class="line">    r := len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := (l + r) / <span class="number">2</span></span><br><span class="line">        <span class="comment">// 最后左右相等的时候就是转折</span></span><br><span class="line">        <span class="keyword">if</span> l == r &#123;</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果左边小于中间值，左半部分递增，则转折点在右边，否在在左边</span></span><br><span class="line">        <span class="keyword">if</span> nums[r] &lt; nums[mid] &#123;</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力法</span></span><br><span class="line">func search(nums []int) int &#123;</span><br><span class="line">	<span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, <span class="attr">v</span> := range nums &#123;</span><br><span class="line">    	<span class="comment">// 出现转折，说明下一个值小于前一个值了</span></span><br><span class="line">        <span class="keyword">if</span> v &gt; nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该题类似搜索旋转数组，搜索旋转数组，是要寻找目标值，则在二分查找时，进行数值比对，根据比对不同情况，对左右下标的不同处理</p>
<h4 id="有效的完全平方数"><a href="#有效的完全平方数" class="headerlink" title="有效的完全平方数"></a>有效的完全平方数</h4><p>二分查找方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line">func isPerfectSquare(num int) bool &#123;</span><br><span class="line">	<span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    l := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 平方根一定在一半之前，后面的平方肯定大于num</span></span><br><span class="line">    r := num / <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := (l + r) / <span class="number">2</span></span><br><span class="line">        <span class="comment">// 找到结果返回</span></span><br><span class="line">        <span class="keyword">if</span> mid * mid == num &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> mid * mid &gt; num &#123; </span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;l = mid + <span class="number">1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>奇数方法<br>完全平方数都是由奇数组成的，每次减去奇数，最后是0则是完全平方数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func isPerfectSquare(num int) bool &#123;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">        num -= n</span><br><span class="line">        n += <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>牛顿迭代</p>
<p>以当前点的切线斜率公式推导 x^2 - num = 0</p>
<p>当前点的切线交于x轴为y点</p>
<p>f(x)/(x - y) = f`(x)</p>
<p>(x^2 - num)/(x-y) = 2x</p>
<p>x^2 - num = 2x^2-2xy</p>
<p>y=(x+num/x)/2</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func isPerfectSquare(num int) bool &#123;</span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从一半开始</span></span><br><span class="line">    x := num / <span class="number">2</span></span><br><span class="line">    <span class="comment">// 不断迭代，找其切线斜率的坐标，直到，满足表达式x^2 - num = 0</span></span><br><span class="line">    <span class="keyword">for</span> x * x &gt; num &#123;</span><br><span class="line">        x = (x + num / x) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * x == num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="搜索旋转数组"><a href="#搜索旋转数组" class="headerlink" title="搜索旋转数组"></a>搜索旋转数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找，不同情况比对，特殊条件处理缩小的条件</span></span><br><span class="line">func search(nums []int, target int) int &#123;</span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> target == nums[<span class="number">0</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右下标</span></span><br><span class="line">    l := <span class="number">0</span></span><br><span class="line">    r := len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := (l + r) / <span class="number">2</span></span><br><span class="line">        <span class="comment">// 等于目标值返回索引</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分四种情况</span></span><br><span class="line">        <span class="comment">// 左边小于中间，说明左边升序，旋转在右边</span></span><br><span class="line">        <span class="keyword">if</span> nums[l] &lt;= nums[mid]  &#123;</span><br><span class="line">            <span class="comment">// target在左边，则往左边缩小</span></span><br><span class="line">            <span class="keyword">if</span> target &gt;= nums[l] &amp;&amp; target &lt;= nums[mid] &#123;</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则右边缩小</span></span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 否则右边升序</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// target在右边，往右边缩小，否则左边</span></span><br><span class="line">            <span class="keyword">if</span> target &gt;= nums[mid] &amp;&amp; target &lt;= nums[r] &#123;</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果数组包含重复数字，搜索旋转数组二</span></span><br><span class="line">func search(nums []int, target int) bool &#123;</span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> target == nums[<span class="number">0</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    l := <span class="number">0</span></span><br><span class="line">    r := len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := (l + r) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对重复数字进行处理跳过</span></span><br><span class="line">        <span class="keyword">if</span> nums[l] == nums[mid] &#123;</span><br><span class="line">            l++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] == nums[r] &#123;</span><br><span class="line">            r--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[l] &lt; nums[mid] &#123;</span><br><span class="line">            <span class="keyword">if</span> target &gt;= nums[l] &amp;&amp; target &lt; nums[mid] &#123;</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> target &gt; nums[mid] &amp;&amp; target &lt;= nums[r] &#123;</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="搜索二维矩阵数组"><a href="#搜索二维矩阵数组" class="headerlink" title="搜索二维矩阵数组"></a>搜索二维矩阵数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缩减搜索范围，先找到对应的行。然后再对该行进行二分</span></span><br><span class="line">func searchMatrix(matrix [][]int, target int) bool &#123;</span><br><span class="line">    cur := []int&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, <span class="attr">v</span> := range matrix &#123;</span><br><span class="line">        <span class="keyword">if</span> target &gt;= v[<span class="number">0</span>] &amp;&amp; target &lt;= v[len(v) - <span class="number">1</span>] &#123;</span><br><span class="line">            cur = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> len(cur) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    l := <span class="number">0</span></span><br><span class="line">    r := len(cur) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := (l + r) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> cur[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cur[mid] &gt; target &#123;</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接二分法</span></span><br><span class="line"><span class="comment">// 将二维数组想象成一个完整的一维数组，通过一维数字的索引，转换成二维数组的索引</span></span><br><span class="line"><span class="comment">// 通过一维数组的索引进行二分，每一行的个数是n，整数结果是第几行，取余是第几列</span></span><br><span class="line">func searchMatrix(matrix [][]int, target int) bool &#123;</span><br><span class="line">    m := len(matrix)</span><br><span class="line">    n := len(matrix[<span class="number">0</span>])</span><br><span class="line">    l := <span class="number">0</span></span><br><span class="line">    r := m * n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := l + (r - l) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> matrix[mid / n][mid % n] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> matrix[mid / n][mid % n] &gt; target &#123;</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的前序遍历</title>
    <url>/2020/12/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>二叉树的前序遍历： 根-&gt;左-&gt;右</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>访问根节点——左子树——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候，我们按照同样的方式遍历，直到遍历完整棵树</p>
<h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution:</span><br><span class="line">    def preorderTraversal(self, <span class="attr">root</span>: TreeNode) -&gt; List[int]:</span><br><span class="line">        res = []</span><br><span class="line">        def handle(root):</span><br><span class="line">            <span class="keyword">if</span> not root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            handle(root.left)</span><br><span class="line">            handle(root.right)</span><br><span class="line">        handle(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="go"><a href="#go" class="headerlink" title="go"></a>go</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">func preorderTraversal(root *TreeNode) []int &#123;</span><br><span class="line">    res := []int&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> handle func(*TreeNode)</span><br><span class="line">    handle = <span class="function"><span class="title">func</span>(<span class="params">root *TreeNode</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> root== nil &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = append(res, root.Val)</span><br><span class="line">        handle(root.Left)</span><br><span class="line">        handle(root.Right)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    handle(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，其中n 是二叉树的节点数。每一个节点恰好被遍历一次。</p>
<p>空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同</p>
<p>手动构造栈，for循环条件，节点不为nil，栈的长度大于0，嵌套for循环<br>里层for循环，节点不为nil，把该节点的值放入结果，该节点都放入栈，然后节点等于节点的下层左边节点，进行迭代，下层节点的左边有值继续迭代，直到左边节点为nil，里层for循环结束</p>
<p>外层for循环，取节点为栈里最后一个节点，就是里层for循环里，左边节点为nil的上层节点的右边节点 减少栈，然后再次外层foe循环，遍历这个右边节点的左边，左边为nil，则节点等于上一层放入的节点的右边节点，右边节点为nil，则取栈里上一个节点</p>
<p>也就是<br>内层for循环，顶层到底层逐层遍历左边节点，把节点的值压入结果<br>外层for循环，底层往回到顶层遍历右边节点，把节点压入结果</p>
<h4 id="go-1"><a href="#go-1" class="headerlink" title="go"></a>go</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">func preorderTraversal(root *TreeNode) []int &#123;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    node := root</span><br><span class="line">    vals := []int&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> node != nil || len(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> node != nil &#123;</span><br><span class="line">            vals = append(vals, node.Val)</span><br><span class="line">            stack = append(stack, node)</span><br><span class="line">            node = node.Left</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack[len(stack)-<span class="number">1</span>].Right</span><br><span class="line">        stack = stack[:len(stack)-<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vals</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution:</span><br><span class="line">    def preorderTraversal(self, <span class="attr">root</span>: TreeNode) -&gt; List[int]:</span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> node or stack:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            node = stack[-<span class="number">1</span>].right</span><br><span class="line">            stack = stack[:len(stack)-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</p>
<p>空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)</p>
<h3 id="Morris-遍历"><a href="#Morris-遍历" class="headerlink" title="Morris 遍历"></a>Morris 遍历</h3><p>记录当前处理节点cur<br>tail记录当前节点下层左子树的下层最右节点<br>外层循环节点不为空<br>如果tail不为空，while循环，找到所有tail的位置，直到tail为空，也就是找到左子树的最后一个右节点<br>也就是第一层，往下第一层的左节点，第二层的右节点（到第三层），直到找到最后的右节点 </p>
<p>如果tail.right为空了,则输出这个节点，并设tail.right为当前节点cur</p>
<p>然后cur= cur.left设为左节点，继续外层循环，也就是第二层为根，找到第二层的左节点，<br>第三层，往下第三层的右节点往下，直到为空</p>
<p>然后指向cur为第二层为根节点，指向第三层的左节点，找tail.right,为空则记录结果</p>
<p>直到tail为none，也就是cur的左子节点为空了，说明左子树处理完了，记录结果</p>
<p>cur=cur.right</p>
<p>Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：</p>
<p>新建临时节点，令该节点为 root；</p>
<p>如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；</p>
<p>如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点：</p>
<p>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。</p>
<p>如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。</p>
<p>重复步骤 2 和步骤 3，直到遍历结束</p>
<p>Morris遍历的通解：<br>1）cur无左子节点，向右移动<br>2）cur有左子节点，则找到cur左子节点的最右子节点，即为前驱节点pre<br>2-1) pre.right == null，说明是首次访问，将pre.right指向cur，cur向左移<br>2-2) pre.right == cur，说明是第二次访问，将pre.right置空，cur向右移动<br>3) cur为空时遍历结束</p>
<h4 id="python-2"><a href="#python-2" class="headerlink" title="python"></a>python</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def preorderTraversal(self, <span class="attr">root</span>: TreeNode) -&gt; List[int]:</span><br><span class="line">        # 结果列表</span><br><span class="line">        res = list()</span><br><span class="line">        # 如果不是根节点，返回</span><br><span class="line">        <span class="keyword">if</span> not root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        # 设定起始遍历节点，p1</span><br><span class="line">        p1 = root</span><br><span class="line">        # 遍历树，节点有值就一直遍历</span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            # 选取该节点的左子树节点，该节点的第二层，并设为p2，p2位第二层</span><br><span class="line">            p2 = p1.left</span><br><span class="line">            # 如果该节点有左子树节点</span><br><span class="line">            <span class="keyword">if</span> p2:</span><br><span class="line">                # 对第二层的p2节点的右子树遍历，p2.right为第三层</span><br><span class="line">                # 有值，且不为p1，没有指向第一层，直到 p2.right为空</span><br><span class="line">                # 一直向下遍历，设p2为其下一层的右子树节点</span><br><span class="line">                <span class="keyword">while</span> p2.right and p2.right != p1:</span><br><span class="line">                    p2 = p2.right</span><br><span class="line">                # 遍历到最底层，p2.right为空了</span><br><span class="line">                <span class="keyword">if</span> not p2.right:</span><br><span class="line">                    # 第一层的节点，放入结果</span><br><span class="line">                    res.append(p1.val)</span><br><span class="line">                    # 修改 p2.right，指向第一层的节点</span><br><span class="line">                    p2.right = p1</span><br><span class="line">                    # p1到第二层的左子树节点</span><br><span class="line">                    p1 = p1.left</span><br><span class="line">                    # 返回while继续遍历，第二次循环，就把第二层的左子树节点放入结果</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p2.right = None</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(p1.val)</span><br><span class="line">            p1 = p1.right</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">func preorderTraversal(root *TreeNode) []int &#123;</span><br><span class="line">    res := []int&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    p1 := root</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p1 == nil &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        p2 := p1.Left</span><br><span class="line">        <span class="keyword">if</span> p2 != nil &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> p2.Right != nil &amp;&amp; p2.Right != p1 &#123;</span><br><span class="line">                    p2 = p2.Right</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> p2.Right == nil &#123;</span><br><span class="line">                res = append(res, p1.Val)</span><br><span class="line">                p2.Right = p1</span><br><span class="line">                p1 = p1.Left</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p2.Right = nil</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            res = append(res, p1.Val)</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = p1.Right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，其中 n 是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</p>
<p>空间复杂度：O(1)。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</p>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最大深度</title>
    <url>/2021/02/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点</p>
<h3 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h3><p>递归方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">func maxDepth(root *TreeNode) int &#123;</span><br><span class="line">    <span class="keyword">if</span> root == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(maxDepth(root.Left), maxDepth(root.Right)) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a, b int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过递归的方式，深度优先搜索，如果知道了左子树，右子树的最大深度，l,r</p>
<p>则树的最大深度是max(l,r)+1</p>
<p>时间on<br>空间o高度</p>
<h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h3><p>遍历方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func maxDepth(root *TreeNode) int &#123;</span><br><span class="line">    <span class="keyword">if</span> root == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列，并加入第一个节点</span></span><br><span class="line">    queue := []*TreeNode&#123;&#125;</span><br><span class="line">    queue = append(queue, root)</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 遍历队列</span></span><br><span class="line">    <span class="keyword">for</span> len(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    	<span class="comment">// 获取当前队列长度，第一层是1</span></span><br><span class="line">        sz := len(queue)</span><br><span class="line">        <span class="comment">// 遍历，出队，长度减1，第一层遍历完，结果加一</span></span><br><span class="line">        <span class="keyword">for</span> sz &gt; <span class="number">0</span> &#123;</span><br><span class="line">        	<span class="comment">// 将树的每一层，都放进队列</span></span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            <span class="comment">// 队列先进先出</span></span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="comment">// 将队列的左右儿子加入，也就是下一层</span></span><br><span class="line">            <span class="keyword">if</span> node.Left != nil &#123;</span><br><span class="line">                queue = append(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != nil &#123;</span><br><span class="line">                queue = append(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            sz--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果加一，上一层遍历完，sz=0，队列加入了下一层的值，继续遍历下一层</span></span><br><span class="line">        ans++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最近公共祖先</title>
    <url>/2021/02/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。</p>
<h4 id="递归回溯"><a href="#递归回溯" class="headerlink" title="递归回溯"></a>递归回溯</h4><p>1.若root中只包含p则返回p<br>2.若root中只包含q则返回q<br>3.若root中不包含p也不包含q则返回NULL<br>5.若root中同时包含p和q，则返回root（此时root为最近公共祖先）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123;</span><br><span class="line">	<span class="comment">// 不同层</span></span><br><span class="line">	<span class="keyword">if</span> root == nil || p == root || q == root &#123;</span><br><span class="line">		<span class="keyword">return</span> root</span><br><span class="line">	&#125;</span><br><span class="line">	left := lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">	right := lowestCommonAncestor(root.Right, p, q)</span><br><span class="line">	<span class="comment">// 同层，都不为空，向上返回</span></span><br><span class="line">	<span class="keyword">if</span> left == nil &#123;</span><br><span class="line">		<span class="keyword">return</span> right</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> right == nil &#123;</span><br><span class="line">		<span class="keyword">return</span> left</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>记录父节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123;</span><br><span class="line">	<span class="comment">// 父节点路径</span></span><br><span class="line">    parent := map[int]*TreeNode&#123;&#125;</span><br><span class="line">    <span class="comment">// 访问路径</span></span><br><span class="line">    visited := map[int]bool&#123;&#125;</span><br><span class="line">    <span class="comment">// 遍历树</span></span><br><span class="line">    <span class="keyword">var</span> dfs func(*TreeNode)</span><br><span class="line">    dfs = <span class="function"><span class="title">func</span>(<span class="params">r *TreeNode</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r == nil &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只看左右节点，因为只记录父节点</span></span><br><span class="line">        <span class="keyword">if</span> r.Left != nil &#123;</span><br><span class="line">            parent[r.Left.Val] = r</span><br><span class="line">            dfs(r.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r.Right != nil &#123;</span><br><span class="line">            parent[r.Right.Val] = r</span><br><span class="line">            dfs(r.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录节点的访问路径，从下向上</span></span><br><span class="line">    <span class="keyword">for</span> p != nil &#123;</span><br><span class="line">        visited[p.Val] = <span class="literal">true</span></span><br><span class="line">        p = parent[p.Val]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看另一节点是否有相同值，有则返回就是结果</span></span><br><span class="line">    <span class="keyword">for</span> q != nil &#123;</span><br><span class="line">        <span class="keyword">if</span> visited[q.Val] &#123;</span><br><span class="line">            <span class="keyword">return</span> q</span><br><span class="line">        &#125;</span><br><span class="line">        q = parent[q.Val]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算相关</title>
    <url>/2021/03/26/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="与-amp"><a href="#与-amp" class="headerlink" title="与 &amp;"></a>与 &amp;</h4><p>有两个数都是1结果才为1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b uint8 = <span class="number">20</span> <span class="comment">// 00010100</span></span><br><span class="line"><span class="keyword">var</span> c uint8 = <span class="number">15</span> <span class="comment">// 00001111</span></span><br><span class="line">a := b &amp; c <span class="comment">// 00000100</span></span><br><span class="line">a = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="或"><a href="#或" class="headerlink" title="或 |"></a>或 |</h4><p>两个数有一个是1 结果就是1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b uint8 = <span class="number">20</span> <span class="comment">// 00010100</span></span><br><span class="line"><span class="keyword">var</span> c uint8 = <span class="number">15</span> <span class="comment">// 00001111</span></span><br><span class="line">a := b &amp; c <span class="comment">// 00011111</span></span><br><span class="line">a = <span class="number">31</span></span><br></pre></td></tr></table></figure>

<h4 id="异或"><a href="#异或" class="headerlink" title="异或 ^"></a>异或 ^</h4><p> ^作二元运算符就是异或，相同为0，不相同为1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b uint8 = <span class="number">20</span> <span class="comment">// 00010100</span></span><br><span class="line"><span class="keyword">var</span> c uint8 = <span class="number">15</span> <span class="comment">// 00001111</span></span><br><span class="line">a := b &amp; c <span class="comment">// 00011011</span></span><br><span class="line">a = <span class="number">27</span></span><br></pre></td></tr></table></figure>

<p>^作一元运算符表示是按位取反</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b uint8 = <span class="number">20</span> <span class="comment">// 00010100</span></span><br><span class="line"><span class="keyword">var</span> c uint8 = <span class="number">15</span> <span class="comment">// 00001111</span></span><br><span class="line">a := b &amp; c <span class="comment">// 00011011</span></span><br><span class="line">^a = <span class="number">228</span> <span class="comment">// 11100100</span></span><br></pre></td></tr></table></figure>

<p>uint8与int</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b uint8 = <span class="number">20</span> <span class="comment">// 00010100</span></span><br><span class="line"><span class="keyword">var</span> c int = <span class="number">20</span> <span class="comment">// 00010100</span></span><br><span class="line">^b = <span class="number">228</span> <span class="comment">// 11101011</span></span><br><span class="line">^c = -<span class="number">21</span> <span class="comment">// -10101</span></span><br></pre></td></tr></table></figure>

<p>特殊情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b uint8 = <span class="number">20</span> <span class="comment">// 00010100</span></span><br><span class="line">b ^ b = <span class="number">0</span></span><br><span class="line">b ^ <span class="number">0</span> = b</span><br></pre></td></tr></table></figure>


<p>int类型，故最高位是符号位，符号位取反，所以得到的结果是负数</p>
<p>一个有符号位的^操作为 这个数+1的相反数</p>
<h4 id="amp"><a href="#amp" class="headerlink" title="&amp;^"></a>&amp;^</h4><p>将运算符左边数据相异的位保留，相同位清零</p>
<p>1&amp;^1  得0<br>1&amp;^0  得1<br>0&amp;^1  得0<br>0&amp;^0  得0</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b uint8 = <span class="number">20</span> <span class="comment">// 00010100</span></span><br><span class="line"><span class="keyword">var</span> c uint8 = <span class="number">15</span> <span class="comment">// 00001111</span></span><br><span class="line">a := b &amp;^ c</span><br><span class="line">a = <span class="number">16</span> <span class="comment">// 00010000</span></span><br></pre></td></tr></table></figure>
<p>以b为准，相异保留b的位，相同，清零b的位</p>
<h4 id="lt-lt-左移-gt-gt-右移"><a href="#lt-lt-左移-gt-gt-右移" class="headerlink" title="&lt;&lt; 左移 &gt;&gt; 右移"></a>&lt;&lt; 左移 &gt;&gt; 右移</h4><p>左移规则：右边空出的位用0填补，高位左移溢出则舍弃该高位</p>
<p>右移规则：左边空出的位用0或者1填补。正数用0填补，负数用1填补。注：不同的环境填补方式可能不同。低位右移溢出则舍弃该位</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b uint8 = <span class="number">20</span> <span class="comment">// 00010100</span></span><br><span class="line">a := b &lt;&lt; <span class="number">1</span></span><br><span class="line">a = <span class="number">40</span> <span class="comment">// 00101000</span></span><br><span class="line">c：= b &gt;&gt; <span class="number">1</span></span><br><span class="line">c = <span class="number">10</span> <span class="comment">// 00001010</span></span><br></pre></td></tr></table></figure>
<p>左移1相当于乘以2<br>右移1相当于除以2</p>
<h4 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h4><p>同时也是获取最后一位的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b int = <span class="number">22</span> <span class="comment">// 10110</span></span><br><span class="line">a := b &amp; <span class="number">1</span></span><br><span class="line">a == <span class="number">0</span> <span class="comment">// 偶数</span></span><br><span class="line">a == <span class="number">1</span> <span class="comment">// 奇数</span></span><br></pre></td></tr></table></figure>

<h4 id="清0最低位的1"><a href="#清0最低位的1" class="headerlink" title="清0最低位的1"></a>清0最低位的1</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b int = <span class="number">22</span> <span class="comment">// 10110</span></span><br><span class="line">a := b &amp; (b - <span class="number">1</span>)</span><br><span class="line">a = <span class="number">20</span> <span class="comment">// 10100</span></span><br></pre></td></tr></table></figure>

<h4 id="得到最低位的1"><a href="#得到最低位的1" class="headerlink" title="得到最低位的1"></a>得到最低位的1</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b int = <span class="number">22</span> <span class="comment">// 10110</span></span><br><span class="line">a := b &amp; (-b)</span><br><span class="line">a = <span class="number">2</span> <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h4 id="将第n-1位置为1"><a href="#将第n-1位置为1" class="headerlink" title="将第n+1位置为1"></a>将第n+1位置为1</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b int = <span class="number">22</span> <span class="comment">// 10110</span></span><br><span class="line">a := b | (<span class="number">1</span> &lt;&lt; <span class="number">0</span>) <span class="comment">// 将第0位置为1,1 &lt;&lt; n, 第n位</span></span><br><span class="line">a = <span class="number">23</span> <span class="comment">// 10111</span></span><br></pre></td></tr></table></figure>

<h4 id="将第n-1为置为0"><a href="#将第n-1为置为0" class="headerlink" title="将第n+1为置为0"></a>将第n+1为置为0</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b int = <span class="number">22</span> <span class="comment">// 10110</span></span><br><span class="line">a := b &amp; (^(<span class="number">1</span> &lt;&lt; <span class="number">1</span>)) <span class="comment">// 将第1位置为0,1 &lt;&lt; n, 第n位</span></span><br><span class="line">a = <span class="number">20</span> <span class="comment">// 10100</span></span><br></pre></td></tr></table></figure>

<h4 id="将右n位清0"><a href="#将右n位清0" class="headerlink" title="将右n位清0"></a>将右n位清0</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b int = <span class="number">22</span> <span class="comment">// 10110</span></span><br><span class="line">a := b &amp; (^<span class="number">0</span> &lt;&lt; <span class="number">2</span>)<span class="comment">// 将右边2位清0， n，右边n位</span></span><br><span class="line">a = <span class="number">20</span> <span class="comment">// 10100</span></span><br></pre></td></tr></table></figure>

<h4 id="获取第n-1位值"><a href="#获取第n-1位值" class="headerlink" title="获取第n+1位值"></a>获取第n+1位值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b int = <span class="number">22</span> <span class="comment">// 10110</span></span><br><span class="line">a := (b &gt;&gt; <span class="number">2</span>) &amp; <span class="number">1</span> <span class="comment">// 获取第2位值</span></span><br><span class="line">a = <span class="number">1</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="获取第n-1位的幂值"><a href="#获取第n-1位的幂值" class="headerlink" title="获取第n+1位的幂值"></a>获取第n+1位的幂值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b int = <span class="number">22</span> <span class="comment">// 10110</span></span><br><span class="line">a := b &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>) <span class="comment">// n=2，其实是从右边数第3位的</span></span><br><span class="line">a = <span class="number">4</span> <span class="comment">// 从右边开始算，第一位是0， n</span></span><br></pre></td></tr></table></figure>

<h4 id="将最高位至第n-1位（含）清0"><a href="#将最高位至第n-1位（含）清0" class="headerlink" title="将最高位至第n+1位（含）清0"></a>将最高位至第n+1位（含）清0</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b int = <span class="number">22</span> <span class="comment">// 10110</span></span><br><span class="line">a := b &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">3</span>) - <span class="number">1</span>) <span class="comment">// n=3，其实是从左边数到第3位，不含第3位，前面的都清0</span></span><br><span class="line">a = <span class="number">6</span> <span class="comment">// 110</span></span><br></pre></td></tr></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="颠倒二进制"><a href="#颠倒二进制" class="headerlink" title="颠倒二进制"></a>颠倒二进制</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func reverseBits(num uint32) uint32 &#123;</span><br><span class="line">    <span class="keyword">var</span> res uint32 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">32</span>; i++ &#123;</span><br><span class="line">    	<span class="comment">// 新数字左移1位</span></span><br><span class="line">        res &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="comment">// num &amp; 1是获取num的最后一位，也可以判断奇偶</span></span><br><span class="line">        <span class="comment">// 最后一位加1，用或也可以，因为res最后一位肯定是0</span></span><br><span class="line">        res |= num &amp; <span class="number">1</span></span><br><span class="line">        <span class="comment">// 右移1位，更新num</span></span><br><span class="line">        num &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 16位互相交换</span></span><br><span class="line">func reverseBits(num uint32) uint32 &#123;</span><br><span class="line">    <span class="keyword">var</span> res uint32 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">        res |= (num &amp; (<span class="number">1</span> &lt;&lt; i)) &lt;&lt; (<span class="number">31</span> - <span class="number">2</span> * i) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">16</span>; i &lt; <span class="number">32</span>; i++ &#123;</span><br><span class="line">        res |= (num &amp; (<span class="number">1</span> &lt;&lt; i)) &gt;&gt; (<span class="number">2</span> * i -<span class="number">31</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1的个位"><a href="#1的个位" class="headerlink" title="1的个位"></a>1的个位</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清0次数</span></span><br><span class="line">func hammingWeight(num uint32) int &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">    	<span class="comment">// 将最低位的1清0</span></span><br><span class="line">        num &amp;= num - <span class="number">1</span></span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环检查</span></span><br><span class="line">func hammingWeight(num uint32) int &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">32</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;&gt; i) &amp; <span class="number">1</span> == <span class="number">1</span>&#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2的幂"><a href="#2的幂" class="headerlink" title="2的幂"></a>2的幂</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到最低位的1，看是不是等于本身，是这说明就一个1</span></span><br><span class="line">func isPowerOfTwo(n int) bool &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> n &amp; (-n) == n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清0最低位的1，看是不是等于0，是则说明只有1个1</span></span><br><span class="line">func isPowerOfTwo(n int) bool &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> n &amp; (n-<span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非位运算</span></span><br><span class="line">func isPowerOfTwo(n int) bool &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">for</span>  n % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        n /= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="比特计数"><a href="#比特计数" class="headerlink" title="比特计数"></a>比特计数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非dp算法</span></span><br><span class="line">func countBits(num int) []int &#123;</span><br><span class="line">    res := make([]int, num+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= num; i++ &#123;</span><br><span class="line">        cur := i</span><br><span class="line">        <span class="keyword">for</span> cur != <span class="number">0</span> &#123;</span><br><span class="line">            cur &amp;= cur - <span class="number">1</span></span><br><span class="line">            res[i]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高有效位</span></span><br><span class="line">func countBits(num int) []int &#123;</span><br><span class="line">    dp := make([]int, num+<span class="number">1</span>)</span><br><span class="line">    hb := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= num; i++ &#123;</span><br><span class="line">        <span class="comment">// 如果是2的幂，则更新高有效位 </span></span><br><span class="line">        <span class="keyword">if</span> i &amp; (i - <span class="number">1</span>) == <span class="number">0</span> &#123; </span><br><span class="line">            hb = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 高有效位的下一位是+1，以此类推，直到下一个2的幂，并更新</span></span><br><span class="line">        dp[i] = dp[i - hb] + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 奇偶数，等于去掉最后一位前面的值 加上新的一位，是奇数就是1，偶数就是0</span></span><br><span class="line">func countBits(num int) []int &#123;</span><br><span class="line">    dp := make([]int, num+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= num; i++ &#123;</span><br><span class="line">        dp[i] = dp[i &gt;&gt; <span class="number">1</span>] + i &amp; <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h4><p>基于位运算的回溯递归</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于位运算的递归</span></span><br><span class="line">func solveNQueens(n int) [][]string &#123;</span><br><span class="line">    <span class="comment">// 最终结果</span></span><br><span class="line">    res := [][]string&#123;&#125;</span><br><span class="line">    <span class="comment">// 初始化一个slice，记录每一行q的位置，初始化都为-1</span></span><br><span class="line">    bSlice := make([]int, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        bSlice[i] = -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs func(int, int, int, int)</span><br><span class="line">    <span class="comment">// 递归函数</span></span><br><span class="line">    <span class="comment">// row行。 col列。 dia1.dia2两个对角线</span></span><br><span class="line">    dfs = <span class="function"><span class="title">func</span>(<span class="params">row, col, dia1, dia2 int</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归终止条件,符合规则的一种结果</span></span><br><span class="line">        <span class="keyword">if</span> row == n &#123;</span><br><span class="line">            tmp := []string&#123;&#125;</span><br><span class="line">            <span class="comment">// 遍历每一行，每一列，初始化都为 .</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                cur := make([]byte, n)</span><br><span class="line">                <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">                    cur[j] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 根据每一行的q的位置，更新q</span></span><br><span class="line">                cur[bSlice[i]] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">                <span class="comment">// byte数组转为string加入结果</span></span><br><span class="line">                tmp = append(tmp, string(cur))</span><br><span class="line">            &#125;</span><br><span class="line">            res = append(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 列，两个对角线，或运算(col | dia1 | dia2)，即所有使用了的位置</span></span><br><span class="line">        <span class="comment">// ^对以上结果取反，得到还未使用的位置，即可用的位置</span></span><br><span class="line">        <span class="comment">// (1 &lt;&lt; n) - 1)从最高位到第n位，都清0，得到n位二进制</span></span><br><span class="line">        availP := ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &amp; (^(col | dia1 | dia2))</span><br><span class="line">        <span class="comment">// 循环递归，可用位置不为0</span></span><br><span class="line">        <span class="keyword">for</span> availP != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 取最低位的可用位置</span></span><br><span class="line">            p := availP &amp; (-availP)</span><br><span class="line">            <span class="comment">// 最低位清0，更新可用位置</span></span><br><span class="line">            availP &amp;= availP - <span class="number">1</span></span><br><span class="line">            <span class="comment">// 减去1之后计算1的个数，得到这一行的q的索引位置，也就是p的1在第几位</span></span><br><span class="line">            <span class="comment">// 高位-&gt;低位就是bslice从左-&gt;右</span></span><br><span class="line">            bSlice[row] = bits.OnesCount(uint(p - <span class="number">1</span>))</span><br><span class="line">            <span class="comment">// 继续递归。行数+1， 列与最低位的可用位置取或，代表这一位已经使用了</span></span><br><span class="line">            <span class="comment">// 对角线与可用位置取或，再根据对角线方向，一个左移，一个右移</span></span><br><span class="line">            dfs(row + <span class="number">1</span>, col | p, (dia1 | p) &gt;&gt; <span class="number">1</span>, (dia2 | p) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 回溯，这一行的q的位置为-1</span></span><br><span class="line">            bSlice[row] = -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全技术</title>
    <url>/2024/02/04/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="信息安全基础"><a href="#信息安全基础" class="headerlink" title="信息安全基础"></a>信息安全基础</h3><h4 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h4><p>信息安全包括5个基本要素：机密性、完整性、可用性、可控性与可审查性。<br>1、机密性：机密性指的是信息只能被授权的人员或实体访问，防止未经授权的人获取敏感信息<br>2、完整性：确保信息在传输或存储过程中不被篡改或损坏，保持其准确性和完整性。<br>3、可用性：确保信息和资源在需要时可供访问和使用，避免因服务中断或不可用性导致的损失。<br>4、可控性：是指对系统或信息进行管理和控制，确保只有授权的人员可以进行合法的操作。<br>5、可审查性：指对系统和操作进行监控和审查的能力，记录和跟踪系统中发生的事件，以便追查和解决安全问题</p>
<h4 id="安全范围"><a href="#安全范围" class="headerlink" title="安全范围"></a>安全范围</h4><p>设备安全、数据安全、内容安全和行为安全<br>1、设备安全的主要目标是确保这些设备的操作和功能不会被破坏、篡改或滥用。它包括3个方面：设备的稳定性、可靠性、可用性<br>2、数据安全即采取措施确保数据免受未授权的泄露、篡改和毁坏，包括3个方面：数据的秘密性、完整性、可用性<br>3、内容安全是信息安全在政治、法律、道德层次上的要求<br>4、行为安全关注人的行为和习惯，行为安全的特性包括：行为的秘密性、完整性、可控性</p>
<h4 id="存储安全"><a href="#存储安全" class="headerlink" title="存储安全"></a>存储安全</h4><p>信息的存储安全包括信息使用的安全、系统安全监控、计算机病毒防治、数据的加密和防止非法<br>的攻击等</p>
<h4 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h4><p>1、网络安全漏洞：物理安全性、软件安全漏洞、不兼容使用安全漏洞、选择合适的安全哲理。<br>2、网络安全威胁：非授权的访问、信息泄露或丢失、破坏数据完整性、拒绝服务攻击、利用网络传播病毒。<br>3、安全措施的目标：访问控制、认证、完整性、审计、保密。</p>
<h3 id="安全系统的组成框架"><a href="#安全系统的组成框架" class="headerlink" title="安全系统的组成框架"></a>安全系统的组成框架</h3><p>信息安全系统的组成框架包含三个体系：技术体系、组织结构体系和管理体系</p>
<h4 id="技术体系"><a href="#技术体系" class="headerlink" title="技术体系"></a>技术体系</h4><p>1、基础安全设备包括密码芯片、加密卡、身份识别卡等<br>2、计算机网络安全指信息在网络传输过程中的安全防范<br>3、操作系统安全是指操作系统的无错误配置、无漏洞、无后门、无特洛伊木马等<br>4、数据库安全可粗略划分为数据库管理系统安全和数据库应用系统安全两个部分<br>5、终端安全设备从电信网终端设备的角度分为电话密码机、传真密码机、异步数据密码机等</p>
<h3 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a>加密技术</h3><h4 id="对称加密技术"><a href="#对称加密技术" class="headerlink" title="对称加密技术"></a>对称加密技术</h4><p>对数据的加密和解密的密钥(密码)是相同的，也称为共享密钥加密技术，属于不公开密钥加密算法。其缺点是加密安全性不高(因为只有一个密钥),且密钥分发困难(因为密钥还需要传输给接收方，也要考虑保密性等问题)。但是其加密速度快，非常适合于大数据的加密</p>
<p>算法： DES（56位密钥），3DES(2对56密钥)，AES，RC-5，IDEA，PGP</p>
<h4 id="非对称加密技术"><a href="#非对称加密技术" class="headerlink" title="非对称加密技术"></a>非对称加密技术</h4><p>又称为公开密钥加密技术，各个用户分别有一对密钥，称为公钥和私钥，其中公钥是公开的，所有用户都知道，私钥是保密的，只有自己知道，使用公钥加密，只能对应的私钥能解密，使用私钥加密，同样也只有对应的公钥能解密；非对称加密就是运用了公钥和私钥的原理，其对数据的加密和解密的密钥是不同的，是公开密钥加密算法。缺点是加密速度慢(密钥多，计算量大，不适合加密大数据)</p>
<p>算法：RSA（512位），EIGAMAL，ECC</p>
<h4 id="信息摘要（消息认证）"><a href="#信息摘要（消息认证）" class="headerlink" title="信息摘要（消息认证）"></a>信息摘要（消息认证）</h4><p>就是一段数据的特征信息，当数据发生了改变，信息摘要也会发生改变，发送方会将数据和信息摘要一起传给接收方，接收方会根据接收到的数据重新生成一个信息摘要，若此摘要和接收到的摘要相同，则说明数据正确。信息摘要是由哈希函数生成的</p>
<p>信息摘要的特点：不算数据多长，都会产生固定长度的信息摘要；任何不同的输入数据，都会产生<br>不同的信息摘要；单向性，即只能由数据生成信息摘要，不能由信息摘要还原数据</p>
<p>信息摘要算法：MD5（产生128位的输出）、SHA（安全散列算法，产生160位的输出，安全性更<br>高）</p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>数字签名属于非对称加密体制，主要功能有：不可否认、无法篡改和伪造(报文鉴别)、报文的完整性</p>
<p>原理：若发送方需要发送数据，应该使用发送方的私钥进行数字签名，而其公钥是共享的，任何接收方都可以拿来解密，因此，接收方使用了发送方的公钥解密，就必然知道此数据是由发送方的私钥加密的，而发送的私钥只属于发送方，唯一标识了数据是由谁发送的，这就是数字签名的过程原理</p>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>数字证书又称为数字标识，由用户申请，证书签证机关CA对其核实签发的，对用户的公钥的认证。现在的数字证书版本大多为x.509。</p>
<p>数字证书的原理：每一个发送方都要先向CA申请数字证书，数字证书是经过CA数字签名了的，也即CA使用私钥加密，当发送方要发送数据时，接收方首先下载CA的公钥，去验证数字证书的真伪，如果是真的，就能保证发送方是真的，因为CA是官方权威的机构，其合法性毋庸置疑。</p>
<h4 id="PKI公钥基础设施"><a href="#PKI公钥基础设施" class="headerlink" title="PKI公钥基础设施"></a>PKI公钥基础设施</h4><p>PKI公钥基础设施是提供公钥加密和数字签名服务的系统或平台，目的是为了管理密钥和证书。一个机构通过采用PKI框架管理密钥和证书可以建立一个安全的网络环境。<br>PKI主要包括四个部分：X.509格式的证书；CA操作协议；CA管理协议；CA政策制定。<br>PKI的基础技术包括加密、数字签名、数据完整性机制、数字信封、双重数字签名等。</p>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>访问控制是指主体依据某些控制策略或权限对客体本身或是其资源进行的不同授权访问。访问控制包括3个要素,即主体、客体和控制策略，其中访问控制包括认证、控制策略实现和审计3方面的内容。</p>
<p>访问控制矩阵（ACM）</p>
<p>访问控制表（ACL)。目前最流行、使用最多的访问控制实现技术。每个客体有一个访问控制表，是系统中每一个有权访问这个客体的主体的信息。这种实现技术实际上是按列保存访问矩阵</p>
<p>能力表。对应于访问控制表，这种实现技术实际上是按行保存访问矩阵</p>
<p>授权关系表。每一行（或者说元组）就是访问矩阵中的一个非空元素，是某一个主体对应于某一个客体的访问权限信息</p>
<h3 id="抗攻击技术"><a href="#抗攻击技术" class="headerlink" title="抗攻击技术"></a>抗攻击技术</h3><p>为对抗攻击者的攻击，密钥生成需要考虑3个方面的因素：增大密钥空间、选择强钥（复杂的)、密钥的随机性（使用随机数）</p>
<p>拒绝服务攻击有许多种，网络的内外部用户都可以发动这种攻击。内部用户可以通过长时间占用系统的内存、CPU处理时间使其他用户不能及时得到这些资源，而引起拒绝服务攻击;外部黑客也可以通过占用网络连接使其他用户得不到网络服务。</p>
<p>外部用户针对网络连接发动拒绝服务攻击主要有以下几种模式：消耗资源、破坏或更改配置信息、物理破坏或改变网络部件、利用服务程序中的处理错误使服务失效</p>
<p>分布式拒绝服务DDoS攻击是传统DoS攻击的发展，攻击者首先侵入并控制一些计算机，然后控制这些计算机同时向一个特定的目标发起拒绝服务攻击。克服了传统DOS受网络资源的限制和隐蔽性两大缺点。</p>
<p>拒绝服务攻击的防御方式<br>1、 加强对数据包的特征识别，攻击者发送的数据包中是有一些特征字符串。通过搜寻这些特征字符串,就可以确定攻击服务器和攻击者的位置。<br>2、设置防火墙监视本地主机端口的使用情况。如果发现端口处于监听状态，则系统很可能受到攻击。<br>3、对通信数据量进行统计也可获得有关攻击系统的位置和数量信息。在攻击时，攻击数据的来源地址会发出超出正常极限的数据量。<br>4、尽可能的修正己经发现的问题和系统漏洞。</p>
<h4 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h4><p>主机A想知道局域网内主机B的MAC地址，那么主机A就广播发送ARP请求分组，局域网内主<br>机都会收到，但只有B收到解析后知道是请求自己的MAC地址，所以只有B会返回单播的响应分组，告诉A自己的MAC地址。A收到响应分组后，会建立一个B的IP地址和MAC地址映射，这<br>个映射是动态存在的,如果一定时间AB不再通信，那么就会清空这个地址映射，下次如果还要通信，则重复这个过程</p>
<p>上述过程主机A是不管其有没有发送过请求广播分组的，而是只要收到了返回的分组信息，就会刷新lP地址和MAC地址的映射关系，这样就存在安全隐患，假设有主机C，模拟返回分组格式，构造正确的IP地址和自己的MAC地址映射，A收到后也会刷新映射关系，那么当A再次向B发送信息时，实<br>际就发送到了C的MAC地址，数据就被c监听到了</p>
<p>在winxp下输入命令：arp-s gate-way-ip gate-way-mac固化arp表，阻止arp欺骗。<br>采用双向绑定的方法解决并且防止ARP欺骗<br>ARP防护软件―—ARPGuard</p>
<h4 id="DNS欺骗"><a href="#DNS欺骗" class="headerlink" title="DNS欺骗"></a>DNS欺骗</h4><p>DNS欺骗首先是冒充域名服务器，然后把查询的IP地址设为攻击者的IP地址，这样的话，用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了，这就是DNS欺骗的基本原理。也即改掉了域名和IP地址的对应关系。黑客是通过冒充DNS服务器回复查询IP的</p>
<p>DNS欺骗的检测：<br>1、被动监听检测：通过旁路监听的方式，捕获所有DNS请求和应答数据包，并为其建立一个请求应答映射表。如果在一定的时间间隔内，一个请求对应两个或两个以上结果不同的应答包，则怀疑受到了DNS欺骗攻击。<br>2、虚假报文探测：采用主动发送探测包的手段来检测网络内是否存在DNS欺骗攻击者。如果向一个非DNS服务器发送请求包，正常来说不会收到任何应答，如果收到了应答包，则说明受到了攻击。<br>3、交叉检查查询：在客户端收到DNS应答包之后，向DNS 服务器反向查询应答包中返回的IP地址所对应的DNS名字，如果二者一致说明没有受到攻击，否则说明被欺骗</p>
<h4 id="IP欺骗"><a href="#IP欺骗" class="headerlink" title="IP欺骗"></a>IP欺骗</h4><p>1 . 首先使被冒充主机host b 的网络暂时瘫痪，以免对攻击成干扰;<br>2. 然后黑客计算机会发起TCP连接到目标机host a的某个端口来猜测lSN基值和增加规律;<br>3. 接下来冒充主机host b的ip地址来向host a来发送请求连接：<br>4. 然后等待目标机host a发送响应数据包给已经瘫痪的主机，但是因为host b已经瘫痪，所以无法看不到这个包：<br>5. 最后黑客再次伪装成主机host b向目标主机host a发送带有预测的目标机的ISN的数据包;<br>6. 连接建立，发送命令请求。</p>
<p>IP欺骗的防范：虽然lP欺骗攻击有着相当难度，但这种攻击非常广泛，入侵往往由这里开始。预防这种攻击可以删除UNIX中所有的/etc/hosts.equiv 、$HOME/.rhosts文件，修改/etc/inetd.conf 文件，使得RPC机制无法应用。另外，还可以通过设置防火墙过滤来自外部而信源地址却是内部IP的报文</p>
<h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><p>端口扫描就是尝试与目标主机的某些端口建立连接，如果目标主机该端口有回复（见三次握手中的第二次），则说明该端口开放，即为“活动端口”。<br>1、全TC连接，这种扫描方法使用三次握手，与目标计算机建立标准的TCP连接<br>2、半打开式扫描(SYN扫描)。在这种扫描技术中，扫描主机自动向目标计算机的指定端口发送SYN数据段,表示发送建立连接请求。如果目标计算机的回应TCP报文中SYN=1 ACK=1 ，则说明该端口是活动的，接着扫描主机传送一个RST给目标，主机拒绝建立TCP连接，从而导致三次握手的过程失败。如果目标计算机的回应是RST，则表示该端口为“死端口”，这种情况下，扫描主机不用做任何回应。<br>3、 FIN扫描。依靠发送FIN来判断目标计算机的指定端口是不具备活动的发送一个FIN=1 的TCP报文到一个关闭的端口时，该报文会被丢掉，并返回一个RST报文。但是，如果当FIN报文到一个活动的端口时，该报文只是被简单的丢掉，不会返回任何回应。从FIN 扫描可以看出，这种扫描没有涉及任何TCP连接部分。因此，这种扫描比前两种都安全，可以称之为秘密扫描。<br>4、第三方扫描。第三方扫描又称“代理扫描”，这种扫描是利用第三方主机来代替入侵者进行扫描。这个第三方主机一般是入侵者通过入侵其他计算机而得到的，该“第三方”主机常被入侵者称之为“肉鸡”。这些“肉鸡”一般为安全防御系数极低的个人计算机。</p>
<h4 id="强化TCP-IP堆栈以抵御拒绝服务攻击"><a href="#强化TCP-IP堆栈以抵御拒绝服务攻击" class="headerlink" title="强化TCP/IP堆栈以抵御拒绝服务攻击"></a>强化TCP/IP堆栈以抵御拒绝服务攻击</h4><p>1、同步包风暴(SYN Flooding)：利用TCP协议缺陷发送大量伪造的TCP连接请求，使得被攻击者资源耗尽。三次握手，进行了两次，不进行第三次握手，连接队列处于等待状态，大量这样的等待，会占满全部队列空间，使得系统挂起。可以通过修改注册表防御SYN Flooding攻击</p>
<p>2、ICMP攻击：ICMP协议本身的特点决定了它非常容易被用于攻击网络上的路由器和主机。比如，前面提到的“Ping of Death”攻击就是利用操作系统规定的ICMP数据包的最大尺寸不超过64KB这一规定，达到使TCP/IP堆栈崩溃、主机死机的效果。可以通过修改注册表防御ICMP攻击</p>
<p>3、SNMP攻击：SNMP还能被用于控制这些设备和产品，重定向通信流，改变通信数据包的优先级，甚至断开通信连接。总之，入侵者如果具备相应能力，就能完全接管你的网络。可以通过修改注册表项防御系统漏洞扫描指对重要计算机信息系统进行检查，发现其中可能被黑客利用的漏洞。包括基于网络的漏洞扫描（通过网络远程扫描主机)、基于主机的漏洞扫描（在目标系统安装了代理扫描）</p>
<h3 id="信息安全的保证体系和评估方法"><a href="#信息安全的保证体系和评估方法" class="headerlink" title="信息安全的保证体系和评估方法"></a>信息安全的保证体系和评估方法</h3><h4 id="保证体系"><a href="#保证体系" class="headerlink" title="保证体系"></a>保证体系</h4><p>GB17859—999标准规定了计算机系统安全保护能力的五个等级：<br>1、第一级用户自主保护级：实现基本的用户隔离和自主访问控制。比如：个人电脑操作系统,通过账号密码隔离不同用户,用户只能访问自己的文件和进程。<br>2、第二级系统审计保护级：在第一级基础上实现更细粒度的访问控制和审计。比如：公司内部办公系统,有账号密码登录,对安全相关的登录、文件访问进行日志记录,对不同部门的数据访问设置权限控制。<br>3、第三级安全标记保护级：在第二级基础上实现安全标记和强制访问控制。比如：政府内部文件系统,对文件设置密级标记,用户的访问权限按照政策与文件标记相匹配判定,进行强制访问控制。<br>4、第四级结构化保护级：在第三级基础上实现形式化安全策略和对所有资源的访问控制。比如：军方信息系统,有多级安全策略模型,对所有用户身份、存储数据、网络资源等实施严格的强制访问控制。<br>5、第五级访问验证保护级：实现抗篡改的访问监控器,对单个用户的所有访问进行仲裁。比如：核设施监控系统,通过抗篡改的访问控制器验证每个用户每次访问的权限,拒绝非授权访问。</p>
<h4 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h4><p>安全风险管理：在风险评估实施前，应该考虑：<br>1、确定风险评估的范围。<br>2、确定风险评估的目标。<br>3、建立适当的组织结构。<br>4、建立系统性的风险评估方法。<br>5、获得最高管理者对风险评估策划的批准。</p>
<p>风险评估的基本要素为脆弱性、资产、威胁、风险和安全措施，与这些要素相关的属性分别为业务战略、资产价值、安全需求、安全事件和残余风险，这些也是风险评估要素的一部分</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>信息系统相关</title>
    <url>/2024/01/24/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>信息系统是由计算机硬件、网络和通信设备、计算机软件、信息资源、信息用户和规章制度组成的以处理信息流为目的的人机一体化系统。</p>
<p>信息系统的5个基本功能：输入、存储、处理、输出和控制。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>业务（数据)处理系统(TPS/DPS)<br>管理信息系统(MIS)<br>决策支持系统(DSS)<br>专家系统(ES)<br>办公自动化系统(OAS)<br>综合性信息系统：<br>ERP系统：主要管理公司的各种资源，负责处理进销存、供应链、生产计划MPS、MRP计算、生产订单、管理会计，是财务数据的强力支撑。<br>WMS系统：主要包括库房货位管理，主要有收发料，通过扫码进出库，对库存进行库位、先进先出与盘点;栈板出货管控、库龄管理等内容，主要是立体仓库或大批量仓库数据需求。<br>MES系统：负责生产过程和生产过程中防呆、自动化设备集成，是各个客户审核的重点，是生产全流程管控，也有企业称之为SFC，其实大同小异，但是它是生产过程、生产工艺、生产设备、自动化生产直接的核心。<br>PDM系统：管理研发阶段的物料、BOM、工程变更数据，负责产品数据为主。PDM系统是产品研发全过程管理，主要涉及协同研发等能力。</p>
<h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><h4 id="生产阶段"><a href="#生产阶段" class="headerlink" title="生产阶段"></a>生产阶段</h4><p>信息系统的需求分析阶段</p>
<h4 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h4><p>信息系统的开发阶段：最重要、关键的阶段。包括总体规划、系统分析、系统设计、系统<br>实施和系统验收这5个阶段</p>
<h4 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h4><p>当信息系统通过验收，正式移交给用户以后，系统就进入了运行阶段。系统维护包括即排错性维护、适应性维护、完善性维护和预防性维护</p>
<h4 id="消亡阶段"><a href="#消亡阶段" class="headerlink" title="消亡阶段"></a>消亡阶段</h4><p>在信息系统建设的初期企业就应当注意系统的消亡条件和时机，以及由此而花费的成本。</p>
<h3 id="建设原则"><a href="#建设原则" class="headerlink" title="建设原则"></a>建设原则</h3><p>信息系统建设的原则：高层管理人员介入原则、用户参与开发原则、自顶向下规划原则、工程化原则、其他原则（创新性，整体性，发展性，经济性等)。</p>
<h3 id="开发方法"><a href="#开发方法" class="headerlink" title="开发方法"></a>开发方法</h3><h4 id="结构化方法"><a href="#结构化方法" class="headerlink" title="结构化方法"></a>结构化方法</h4><p>结构化方法是一种传统的信息系统开发方法，由结构化分析（SA)、结构化设计(SD)和结构化程序设计(SP)三部分有机组合而成，其，其精髓是自顶向下、逐步求精和模块化设计。</p>
<p>结构化方法一般利用图形表达用户需求，常用工具有数据流图、数据字典、结构化语言、判定表以及判定树等。</p>
<p>结构化方法的不足和局限：<br>开发周期长：按顺序经历各个阶段，直到实施阶段结束后，用户才能使用系统。<br>难以适应需求变化：不适用于需求不明确或经常变更的项目。<br>很少考虑数据结构：结构化方法是一种面向数据流的开发方法，很少考虑数据结构。</p>
<h4 id="原型化方法"><a href="#原型化方法" class="headerlink" title="原型化方法"></a>原型化方法</h4><p>也称为快速原型法，或者简称为原型法。它是一种根据用户初步需求，利用系统开发工具，快速地建立一个系统模型展示给用户，在此基础上与用户交流，最终实现用户需求的信息系统快速开发的方法</p>
<p>按是否实现功能分类：分为水平原型(行为原型，功能的导航)、垂直原型（结构化原型，实现了部分功能)。</p>
<p>按最终结果分类：分为抛弃式原型、演化式原型。</p>
<p>原型法可以使系统开发的周期缩短、成本和风险降低、速度加快，获得较高的综合开发效益<br>原型法是以用户为中心来开发系统的，用户参与的程度大大提高，开发的系统符合用户的需求，因而增加了用户的满意度，提高了系统开发的成功率。<br>由于用户参与了系统开发的全过程，对系统的功能和结构容易理解和接受，有利于系统的移交，有利于系统的运行与维护。<br>原型法的不足之处：开发的环境要求高。管理水平要求高。</p>
<p>原型法的优点主要在于能更有效地确认用户需求。从直观上来看，原型法适用于那些需求不明确的系统开发。事实上，对于分析层面难度大、技术层面难度不大的系统，适合于原型法开发</p>
<h4 id="面向对象法"><a href="#面向对象法" class="headerlink" title="面向对象法"></a>面向对象法</h4><p>客观世界是由各种对象组成的</p>
<p>使用OO方法构造的系统具有更好的复用性<br>面向对象方法可以普遍适用于各类信息系统的开发<br>面向对象方法的不足之处：必须依靠一定的面向对象技术支持</p>
<h4 id="面向服务法"><a href="#面向服务法" class="headerlink" title="面向服务法"></a>面向服务法</h4><p>面向服务(Service Oriented Architecture,简称SOA)的方法：进一步将接口的定义与实现进行解耦，则催生了服务和面向服务的开发方法，微服务概念</p>
<h3 id="业务处理系统TPS"><a href="#业务处理系统TPS" class="headerlink" title="业务处理系统TPS"></a>业务处理系统TPS</h3><p>为电子数据处理系统(EDP)，最初级形式的信息系统<br>TPS的主要功能就是对企业管理中日常事务所发生的数据进行输入、处理和输出。因此，TPS的数据处理周期由以下几个构成：<br>数据输入<br>数据处理<br>数据维护<br>文件报表的产生<br>查询处理</p>
<p>TPS是其他类型信息系统的信息产生器，<br>由于TPS面对的是结构化程度很高的管理问题，因此可以采用结构化生命周期法来进行开发</p>
<h3 id="管理信息系统MIS"><a href="#管理信息系统MIS" class="headerlink" title="管理信息系统MIS"></a>管理信息系统MIS</h3><p>由业务处理系统发展而成的，是在TPS基础上引进大量管理方法对企业整体信息进行处理，并利用信息进行预测、控制、计划、辅助企业全面管理的信息系统。<br>管理信息系统由四大部件组成，即信息源、信息处理器、信息用户和信息管理者。<br>根据各部件之间的联系可分为开环(不收集外部信息不反馈)和闭环(不断收集信息反馈调整)。根据处理的内容及决策的层次来看，我们可以把管理信息系统看成一个金字塔</p>
<h3 id="决策支持系统DSS"><a href="#决策支持系统DSS" class="headerlink" title="决策支持系统DSS"></a>决策支持系统DSS</h3><p>是支持各种层次的人们进行决策</p>
<p>数据的重组和确认。与决策支持系统相关的数据库的问题是，获得正确的数据井且可用理想的形式操作这些数据。这个问题可以通过数据仓库的概念解决</p>
<p>数据字典的建立。数据仓库是一个与作业层系统分离存在的数据库。通过对数据仓库的存取，管理者可以做出以事实为根据的决策来解决许多业务问题。</p>
<p>数据挖掘和智能体。一旦建成数据仓库，管理者们需要运用工具进行数据存取和查询，使用的工具称为智能体。</p>
<p>模型建立。针对模型库的处理，根据实际业务场景和需求,选择或构建不同的分析模型,用来进行预测、优化、规划等,以便做出更好的决策，模型管理的目的就是帮助决策者理解与选择有关的现象。建立模型的方法有穷枚举法算法、启发式和模拟法</p>
<h3 id="专家系统ES"><a href="#专家系统ES" class="headerlink" title="专家系统ES"></a>专家系统ES</h3><p>基于知识的专家系统(专家系统：Expert System，ES)，是人工智能的一个重要分支。专家系统的能力来自于它所拥有的专家知识，知识的表示及推理的方法则提供了应用的机理<br>专家系统就是一个可模拟专家进行推理的智能系统,让普通人也能获得专家级建议</p>
<p>专家系统不同于传统的应用程序和其他类型的人工智能问题求解程序。主要表现在以下5个方面：<br>1、系统属于人工智能范畴，其求解的问题是半结构化或非结构化问题。<br>2、系统模拟的是人类专家在问题领域的推理，而不是模拟问题领域本身。<br>3、系统由3个要素组成：描述问题状态的综合数据库、存放启发式经验知识的知识库和对知识库的知识进行推理的推理机。三要素分别对应数据级、知识库级和控制级三级知识，而传统应用程序只有数据和程序两级结构。<br>4、系统处理的问题是实际的问题，而不是纯学术的问题。<br>5、解决手段来看，专家系统专用性强，通用性差</p>
<p>人工智能（AI)旨在利用机械、电子、光电或生物器件等制造的装置或机器模仿人类的智能.AI研究的重点放在开发具有智能行为的计算机系统上，智能行为表现出以下5个特点。<br>1、从过去的事件或情形中汲取经验，并将从经验中得到的知识应用于新的环境和场景。<br>2、具有在缺乏重要信息时解决问题的能力。<br>3、具有处理和操纵各种符号、理解形象化图片（图像)的能力。<br>4、想象力和创造力。<br>5、善于启发。</p>
<p>人工智能是一个极为广泛的领域，AI的主要分支有专家系统、机器人技术、视觉系统、自然语言处理、学习系统和神经网络等。</p>
<h3 id="办公化系统OAS"><a href="#办公化系统OAS" class="headerlink" title="办公化系统OAS"></a>办公化系统OAS</h3><p>办公自动化就是办公信息处理手段的自动化。OAS要解决的是包括数据、文字、声音、图像等信息的一体化处理问题。以行为科学为主导，系统科学为理论基础，结合运用计算机技术和通信技术。</p>
<p>主要功能：<br>事务处理<br>信息管理<br>辅助决策</p>
<p>办公自动化系统的组成：计算机设备、办公设备、数据通信及网络设备、软件系统.</p>
<h3 id="企业资源规划ERP"><a href="#企业资源规划ERP" class="headerlink" title="企业资源规划ERP"></a>企业资源规划ERP</h3><p>企业资源规划是指建立在信息技术基础上，以系统化的管理思想，为企业提供决策和运营手段的管理平台。ERP系统是将企业所有资源进行集成整合，并进行全面、一体化管理的信息系统。</p>
<p>企业有三大资源：物流（物流管理)、资金流（财务管理)、信息流（生产控制管理)、现在一般认为人力资源（人力资源管理)是企业第四大资源</p>
<p>1、采购与库存管理。采购与库存管理是ERP的基本模块，其中采购管理模块是对采购工作，即从采购订单产生至货物收到的全过程进行组织、实施与控制，库存管理模块则是对企业物料的进、出、存进行管理。<br>2、质量与设备管理。质量管理贯穿于企业管理的始终。设备管理是指依据企业的生产经营目标，通过一系列的技术、经济和组织措施，对设备寿命周期内的所有设备物资运动形态和价值运动形态进行的综合管理。<br>3、财务管理。会计工作是企业管理的重要组成部分，是以货币的形式反映和监督企业的日常经济活动，并对这些经济业务的数据进行分类、汇总，以便为企业管理和决策提供必要的信息支持。企业财务管理是企业会计工作和活动的统称。<br>4、ERP有关扩展应用模块。如客户关系管理、分销资源管理、供应链管理和电子商务等。这几个扩展模块本身也是一个独立的系统，在市场上它们常作为独立的软件产品进行出售和实施。<br>5、ERP的功能：支持决策的功能、为处于不同行业的企业提供有针对性的IT解决方案、从企业内部的供应链发展为全行业和跨行业的供应链。</p>
<h3 id="企业典型信息系统化架构模型"><a href="#企业典型信息系统化架构模型" class="headerlink" title="企业典型信息系统化架构模型"></a>企业典型信息系统化架构模型</h3><h4 id="政府信息化及电子政务"><a href="#政府信息化及电子政务" class="headerlink" title="政府信息化及电子政务"></a>政府信息化及电子政务</h4><p>电子政务实质上是对现有的、工业时代形成的政府形态的一种改造，</p>
<p>第1 个特征是以互联网为基础设施，构造和发展电子政务。<br>第2个特征是，就电子政务的内涵而言，更强调政府服务功能的发挥和完善，包括政府对企业、对居民的服务以及政府各部门之间的相互服务。</p>
<p>政府到政府（Government-to-Government，G2G）、政府到企业（Government-to-Business，G2B）、政府到公众（Government-to-Citizen，G2C）、企业到政府（Business-to-Government，B2G）和公众到政府（Citizen-to-Government，C2G）</p>
<h4 id="企业信息化"><a href="#企业信息化" class="headerlink" title="企业信息化"></a>企业信息化</h4><p>企业信息化的具体目标是优化企业业务流程，使之更加有效，</p>
<p>企业信息化就是技术和业务的融合。需要从3个层面来实现。<br>1、 企业战略的层面。必须对企业目前的业务策略和未来的发展方向作深入分析。达到战略上的融合。<br>2、业务运作层面。针对企业所确定的业务战略，通过分析获得实现这些目标的关键驱动力和实现这些目标的关键流程。<br>3、管理运作层面。虽然这一层面从价值链的角度上来说，是属于辅助流程，但它对企业日常管理的科学性、高效性是非常重要的。除了提出应用功能的需求外，还必须给出相应的信息技术体系，这些将确保管理模式和组织架构适应信息化的需要</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Celery的异步服务使用</title>
    <url>/2018/05/26/%E5%85%B3%E4%BA%8ECelery%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="什么是Celery？"><a href="#什么是Celery？" class="headerlink" title="什么是Celery？"></a>什么是Celery？</h3><p>Celery是一个专注于实时处理和任务调度的分布式任务队列。所谓任务就是消息，消息中的有效载荷中包含要执行任务需要的全部数据。</p>
<h3 id="为什么使用Celery"><a href="#为什么使用Celery" class="headerlink" title="为什么使用Celery"></a>为什么使用Celery</h3><p>在开发应用中，我们难免会遇到耗时操作，或者需要添加一些定时任务，而服务器本身的框架对于多进程、线程等已经写好，这些附加工作就会被耗时处理，而使用Celery则可以很好的处理这些任务，相当于开了一个额外的进程来处理这些耗时任务，增强了执行效率。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>Web应用。当用户触发的一个操作需要较长时间才能执行完成时，可以把它作为任务交给Celery去异步执行，执行完再返回给用户。这段时间用户不需要等待，提高了用户体验与程序执行效率。</li>
</ol>
<ol start="2">
<li>定时任务。生产环境经常会跑一些定时任务。假如你有上千台的服务器、上千种任务，定时任务的管理很困难，Celery可以帮助我们快速在不同的机器设定不同种任务。</li>
</ol>
<ol start="3">
<li>同步完成的附加工作都可以异步完成。比如发送短信/邮件、推送消息、清理/设置缓存等。</li>
</ol>
<h3 id="Celery架构"><a href="#Celery架构" class="headerlink" title="Celery架构"></a>Celery架构</h3><p><img src="/2018/05/26/%E5%85%B3%E4%BA%8ECelery%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8/1.jpg" alt="1"><br>Celery Beat：任务调度器，Beat进程会读取配置文件的内容，周期性地将配置中到期需要执行的任务发送给任务队列。<br>Result Backend：任务处理完后保存状态信息和结果，以供查询。Celery默认已支持Redis、RabbitMQ、MongoDB、Django ORM、SQLAlchemy等方式，当然Redis应该是最佳选择。</p>
<h3 id="例：对于django框架web开发中发送短信功能使用Celery优化"><a href="#例：对于django框架web开发中发送短信功能使用Celery优化" class="headerlink" title="例：对于django框架web开发中发送短信功能使用Celery优化"></a>例：对于django框架web开发中发送短信功能使用Celery优化</h3><h4 id="为什么要进行优化"><a href="#为什么要进行优化" class="headerlink" title="为什么要进行优化"></a>为什么要进行优化</h4><p>因为发送短信是一个等待操作，用户那边也会设置一个60秒等待操作，为了提高用户体验，增强效率，采用Celery进行优化，设置异步任务，处理短信发送功能。</p>
<p>1.在mamange.py同目录下，新建工具包celery_tasks<br>2.创建config.py<br>    设置代理人，指定队列，这里连接redis第14个数据库</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">broker_url=<span class="string">&#x27;redis://‘设置的ip地址’/14&#x27;</span></span><br></pre></td></tr></table></figure>

<p>3.创建main.py，创建Celery的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">#设置django的配置</span><br><span class="line">os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;项目的settings&quot;</span>)</span><br><span class="line"># 创建对象</span><br><span class="line">app = Celery(<span class="string">&#x27;任意字符串&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 加载配置</span><br><span class="line">app.config_from_object(config)</span><br><span class="line"></span><br><span class="line"># 初始化任务</span><br><span class="line"># 在指定的包中找tasks.py文件，在这个文件中找@app.task的函数</span><br><span class="line">app.autodiscover_tasks([</span><br><span class="line">    <span class="string">&#x27;celery_tasks.sms&#x27;</span>,</span><br><span class="line">])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.新建sms工具包，在包中新建tasks.py文件，定义发送短信的函任务</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.ytx_sdk.sendSMS <span class="keyword">import</span> CCP</span><br><span class="line"><span class="keyword">from</span> celery_tasks.main <span class="keyword">import</span> app</span><br><span class="line"># 发送短信任务</span><br><span class="line">@app.task(name=<span class="string">&#x27;sms_send&#x27;</span>)</span><br><span class="line">def sms_send(mobile, sms_code, expires, template_id):</span><br><span class="line">    CCP.sendTemplateSMS(mobile, sms_code, expires, template_id)</span><br></pre></td></tr></table></figure>

<p>5.启动celery的工人<br>    celery -A celery_tasks.main worker -l info</p>
<p>6.调用：sms_send.delay(参数)</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Celery</tag>
      </tags>
  </entry>
  <entry>
    <title>关于FastDFS文件分布式系统</title>
    <url>/2018/07/16/%E5%85%B3%E4%BA%8EFastDFS%E6%96%87%E4%BB%B6%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="FastDFS简介"><a href="#FastDFS简介" class="headerlink" title="FastDFS简介"></a>FastDFS简介</h2><h3 id="什么是FastDFS"><a href="#什么是FastDFS" class="headerlink" title="什么是FastDFS"></a>什么是FastDFS</h3><p>FastDFS 是一个开源的高性能分布式文件系统（DFS）。 它的主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡。主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB &lt; file_size &lt;500MB）为载体的在线服务。</p>
<p>FastDFS 系统有三个角色：跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)。</p>
<p>　　Tracker Server：跟踪服务器，主要做调度工作，起到均衡的作用；负责管理所有的 storage server和 group，每个 storage 在启动后会连接 Tracker，告知自己所属 group 等信息，并保持周期性心跳。</p>
<p>　　Storage Server：存储服务器，主要提供容量和备份服务；以 group 为单位，每个 group 内可以有多台 storage server，数据互为备份。</p>
<p>　　Client：客户端，上传下载数据的服务器，也就是我们自己的项目所部署在的服务器。<br><img src="/2018/07/16/%E5%85%B3%E4%BA%8EFastDFS%E6%96%87%E4%BB%B6%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/1.jpg" alt="1"><br>服务端两个角色:</p>
<p>Tracker: 管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。<br>Storage: 实际保存文件， Storage 分为多个组，每个组之间保存的文件是不同的。每 个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有 主从的概念。</p>
<h3 id="FastDFS存储策略"><a href="#FastDFS存储策略" class="headerlink" title="FastDFS存储策略"></a>FastDFS存储策略</h3><p>为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。</p>
<p>在卷中增加服务器时，同步已有的文件由系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了存储系统的容量。</p>
<h3 id="文件上传流程"><a href="#文件上传流程" class="headerlink" title="文件上传流程"></a>文件上传流程</h3><p>FastDFS向使用者提供基本文件访问接口，比如upload、download、append、delete等，以客户端库的方式提供给用户使用。</p>
<p>Storage Server会定期的向Tracker Server发送自己的存储信息。当Tracker Server Cluster中的Tracker Server不止一个时，各个Tracker之间的关系是对等的，所以客户端上传时可以选择任意一个Tracker。<br><img src="/2018/07/16/%E5%85%B3%E4%BA%8EFastDFS%E6%96%87%E4%BB%B6%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2.jpg" alt="2"><br>当Tracker收到客户端上传文件的请求时，会为该文件分配一个可以存储文件的group，当选定了group后就要决定给客户端分配group中的哪一个storage server。当分配好storage server后，客户端向storage发送写文件请求，storage将会为文件分配一个数据存储目录。然后为文件分配一个fileid，最后根据以上的信息生成文件名存储文件。</p>
<h3 id="文件名组成"><a href="#文件名组成" class="headerlink" title="文件名组成"></a>文件名组成</h3><p>文件名如下：<br><img src="/2018/07/16/%E5%85%B3%E4%BA%8EFastDFS%E6%96%87%E4%BB%B6%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/3.jpg" alt="3"><br>组名：文件上传后所在的 storage 组名称，在文件上传成功后有 storage 服务器返回， 需要客户端自行保存。<br>虚拟磁盘路径：storage 配置的虚拟路径，与磁盘选项 store_path对应。如果配置了 store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推。<br>数据两级目录：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据 文件。<br>文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含:源存储 服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。</p>
<h2 id="简易FastDFS构建"><a href="#简易FastDFS构建" class="headerlink" title="简易FastDFS构建"></a>简易FastDFS构建</h2><h3 id="使用docker安装FastDFS"><a href="#使用docker安装FastDFS" class="headerlink" title="使用docker安装FastDFS"></a>使用docker安装FastDFS</h3><p>拉取镜像</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker image pull delron/fastdfs</span><br></pre></td></tr></table></figure>
<p>运行tracker</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker run -dti --network=host --name tracker -v /<span class="keyword">var</span>/fdfs/tracker:<span class="regexp">/var/</span>fdfs delron/fastdfs tracker</span><br></pre></td></tr></table></figure>
<p>运行storage</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker run -dti --network=host --name storage -e TRACKER_SERVER=本机ip:<span class="number">22122</span> -v /<span class="keyword">var</span>/fdfs/storage:<span class="regexp">/var/</span>fdfs delron/fastdfs storage</span><br></pre></td></tr></table></figure>
<p>然后可使用docker命令进行管理操作。</p>
<h3 id="FastDFS的Python客户端，Django使用FastDFS"><a href="#FastDFS的Python客户端，Django使用FastDFS" class="headerlink" title="FastDFS的Python客户端，Django使用FastDFS"></a>FastDFS的Python客户端，Django使用FastDFS</h3><p>参考：<a href="https://github.com/jefforeilly/fdfs_client-py">点这里</a></p>
<p>安装环境<br>下载安装包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pip install fdfs_client-py-master.zip</span><br><span class="line">pip install mutagen</span><br><span class="line">pip install requests</span><br></pre></td></tr></table></figure>
<p>配置<br>我们在utils包下新建fastdfs包，client.conf配置文件放到这个目录中。<br>然后改一下其中的配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">base_path=FastDFS客户端存放日志文件的目录</span><br><span class="line">tracker_server=运行tracker服务的机器ip:<span class="number">22122</span></span><br></pre></td></tr></table></figure>
<p>上传文件需要先创建fdfs_client.client.Fdfs_client的对象，并指明配置文件，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fdfs_client.client <span class="keyword">import</span> Fdfs_client</span><br><span class="line">client = Fdfs_client(<span class="string">&#x27;utils/fastdfs/client.conf&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>通过创建的对象，执行上传文件的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fdfs_client.client <span class="keyword">import</span> Fdfs_client</span><br><span class="line">client = Fdfs_client(<span class="string">&#x27;utils/fastdfs/client.conf&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="自定义Django文件存储系统"><a href="#自定义Django文件存储系统" class="headerlink" title="自定义Django文件存储系统"></a>自定义Django文件存储系统</h3><p>django自带文件存储系统，但是存储路径是本地，怎样将文件存储到FastDFS的服务器上呢<br>参考文档：<a href="https://yiyibooks.cn/xx/Django_1.11.6/howto/custom-file-storage.html">点这里</a></p>
<p>自定义文件存储系统的方法如下：<br>1）需要继承自django.core.files.storage.Storage，如</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.files.storage <span class="keyword">import</span> Storage</span><br><span class="line"></span><br><span class="line">class FastDFSStorage(Storage):</span><br></pre></td></tr></table></figure>
<p>2）支持Django不带任何参数来实例化存储类，也就是说任何设置都应该从django.conf.settings中获取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.core.files.storage <span class="keyword">import</span> Storage</span><br><span class="line"></span><br><span class="line">class FastDFSStorage(Storage):</span><br><span class="line">    def __init__(self, base_url=None, client_conf=None):</span><br><span class="line">        <span class="keyword">if</span> base_url is None:</span><br><span class="line">            base_url = settings.FDFS_URL</span><br><span class="line">        self.base_url = base_url</span><br><span class="line">        <span class="keyword">if</span> client_conf is None:</span><br><span class="line">            client_conf = settings.FDFS_CLIENT_CONF</span><br><span class="line">        self.client_conf = client_conf</span><br></pre></td></tr></table></figure>
<p>3）存储类中必须实现_open()和_save()方法，以及任何后续使用中可能用到的其他方法。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">_open(name, mode=<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"># 被Storage.open()调用，在打开文件时被使用。</span><br><span class="line">_save(name, content)</span><br><span class="line"># 被Storage.save()调用，name是传入的文件名，content是Django接收到的文件内容，该方法需要将content文件内容保存。</span><br><span class="line"># Django会将该方法的返回值保存到数据库中对应的文件字段，也就是说该方法应该返回要保存在数据库中的文件名称信息。</span><br><span class="line">exists(name)</span><br><span class="line"># 如果名为name的文件在文件系统中存在，则返回True，否则返回False。</span><br><span class="line">url(name)</span><br><span class="line"># 返回文件的完整访问URL</span><br><span class="line"><span class="keyword">delete</span>(name)</span><br><span class="line"># 删除name的文件</span><br><span class="line">listdir(path)</span><br><span class="line"># 列出指定路径的内容</span><br><span class="line">size(name)</span><br><span class="line"># 返回name文件的总大小</span><br></pre></td></tr></table></figure>
<p>4）需要为存储类添加django.utils.deconstruct.deconstructible装饰器<br>我们在utils/fastdfs目录中创建fdfs_storage.py文件，实现可以使用FastDFS存储文件的存储类如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.core.files.storage <span class="keyword">import</span> Storage</span><br><span class="line"><span class="keyword">from</span> django.utils.deconstruct <span class="keyword">import</span> deconstructible</span><br><span class="line"><span class="keyword">from</span> fdfs_client.client <span class="keyword">import</span> Fdfs_client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@deconstructible</span><br><span class="line">class FastDFSStorage(Storage):</span><br><span class="line">    def __init__(self, base_url=None, client_conf=None):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        初始化</span></span><br><span class="line"><span class="string">        :param base_url: 用于构造图片完整路径使用，图片服务器的域名</span></span><br><span class="line"><span class="string">        :param client_conf: FastDFS客户端配置文件的路径</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> base_url is None:</span><br><span class="line">            base_url = settings.FDFS_URL</span><br><span class="line">        self.base_url = base_url</span><br><span class="line">        <span class="keyword">if</span> client_conf is None:</span><br><span class="line">            client_conf = settings.FDFS_CLIENT_CONF</span><br><span class="line">        self.client_conf = client_conf</span><br><span class="line"></span><br><span class="line">    def _open(self, name, mode=<span class="string">&#x27;rb&#x27;</span>):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        用不到打开文件，所以省略</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def _save(self, name, content):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        在FastDFS中保存文件</span></span><br><span class="line"><span class="string">        :param name: 传入的文件名</span></span><br><span class="line"><span class="string">        :param content: 文件内容</span></span><br><span class="line"><span class="string">        :return: 保存到数据库中的FastDFS的文件名</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        client = Fdfs_client(self.client_conf)</span><br><span class="line">        ret = client.upload_by_buffer(content.read())</span><br><span class="line">        <span class="keyword">if</span> ret.get(<span class="string">&quot;Status&quot;</span>) != <span class="string">&quot;Upload successed.&quot;</span>:</span><br><span class="line">            raise Exception(<span class="string">&quot;upload file failed&quot;</span>)</span><br><span class="line">        file_name = ret.get(<span class="string">&quot;Remote file_id&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> file_name</span><br><span class="line"></span><br><span class="line">    def url(self, name):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        返回文件的完整URL路径</span></span><br><span class="line"><span class="string">        :param name: 数据库中保存的文件名</span></span><br><span class="line"><span class="string">        :return: 完整的URL</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.base_url + name</span><br><span class="line"></span><br><span class="line">    def exists(self, name):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        判断文件是否存在，FastDFS可以自行解决文件的重名问题</span></span><br><span class="line"><span class="string">        所以此处返回False，告诉Django上传的都是新文件</span></span><br><span class="line"><span class="string">        :param name:  文件名</span></span><br><span class="line"><span class="string">        :return: False</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> False</span><br></pre></td></tr></table></figure>

<h3 id="在Django配置中设置自定义文件存储类"><a href="#在Django配置中设置自定义文件存储类" class="headerlink" title="在Django配置中设置自定义文件存储类"></a>在Django配置中设置自定义文件存储类</h3><p>在settings.py文件中添加设置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># django文件存储</span><br><span class="line">DEFAULT_FILE_STORAGE = <span class="string">&#x27;utils.fastdfs.fdfs_storage.FastDFSStorage&#x27;</span></span><br><span class="line"></span><br><span class="line"># FastDFS</span><br><span class="line">FDFS_URL = <span class="string">&#x27;你的域名:8888/&#x27;</span>  </span><br><span class="line">FDFS_CLIENT_CONF = os.path.join(BASE_DIR, <span class="string">&#x27;utils/fastdfs/client.conf&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="添加image域名"><a href="#添加image域名" class="headerlink" title="添加image域名"></a>添加image域名</h3><p>在/etc/hosts中添加访问FastDFS storage服务器的域名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">IP   image.域名</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>环境运维</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于HTTP网络通信相关</title>
    <url>/2021/03/29/%E5%85%B3%E4%BA%8EHTTP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP 全称超⽂文本传输协议，是建立在tcp传输层协议上的</p>
<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>七层网络</p>
<p><img src="/2021/03/29/%E5%85%B3%E4%BA%8EHTTP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3/1.png" alt="1"></p>
<p>http协议位于应用层</p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>统一资源</p>
<h4 id="协议部分"><a href="#协议部分" class="headerlink" title="协议部分"></a>协议部分</h4><p>协议部分为http还是https，会用//为分隔符</p>
<h4 id="域名部分"><a href="#域名部分" class="headerlink" title="域名部分"></a>域名部分</h4><p>在发送请求前，会向DNS服务器解析IP，如果已经知道ip，还可以跳过DNS解析那一步，直接把IP当做域名部分使用</p>
<h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>域名后面有些时候会带有端口，和域名之间用:分隔，端口不是一个URL的必须的部分。当网址为http://时，默认端口为80</p>
<p>当网址为https://时，默认端口为443，以上两种都可以省略端口号。上面的URL其实省略了443端口号</p>
<h4 id="虚拟目录"><a href="#虚拟目录" class="headerlink" title="虚拟目录"></a>虚拟目录</h4><p>域名的第一个/开始到最后一个/为止，是虚拟目录的部分</p>
<h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p>域名最后一个/开始到?为止，是文件名部分， 没有？， #就到结束</p>
<h4 id="url和uri的区别"><a href="#url和uri的区别" class="headerlink" title="url和uri的区别"></a>url和uri的区别</h4><p>url： 统一资源定位符</p>
<p>uri： 统一资源标识符</p>
<p>URL是URI的子集</p>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>请求指定的页面信息，并返回消息主体(body)+头信息(header)，会有长度限制，过长容易截断，并不安全，请求参数在url里</p>
<h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p>HEAD和GET本质是一样的，区别在于HEAD只返回头信息(header)，不返回消息主体(body)</p>
<p>如果想要判断某个资源是否存在，虽然用GET也能做到，但这里用HEAD还省下拿body的消耗，返回状态码200就是有404就是无</p>
<p>如果请求的是一个比较大的资源，比如一个超大视频和文件，你只想知道它到底有多大，而不需要整个下载下来，这时候使用HEAD请求，返回的headers会带有文件的大小（content-lenght）</p>
<h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><p>向服务器提交数据，请求参数在data里，加密的，不会被截断</p>
<h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p>推送添加，类似post，不过一般用post代替</p>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>删除一个资源，一般用post代替</p>
<h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>用于对资源进行部分修改</p>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</p>
<h4 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h4><p>回显服务器收到的请求，主要用于测试或诊断</p>
<h4 id="options"><a href="#options" class="headerlink" title="options"></a>options</h4><p>它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP响应头部中带上给各种“Allow”的头，表明某个请求在对应的服务器中都支持哪种请求方法</p>
<p><img src="/2021/03/29/%E5%85%B3%E4%BA%8EHTTP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3/2.png" alt="2"></p>
<p>指明了允许携带的首部字段</p>
<p>允许什么方法</p>
<p>允许跨域请求的域名，允许所有*</p>
<p>允许携带的header信息</p>
<p>结果缓存时间多久</p>
<h5 id="什么时候options请求"><a href="#什么时候options请求" class="headerlink" title="什么时候options请求"></a>什么时候options请求</h5><p>在跨域（记住这个词，待会解释）的情况下，浏览器发起复杂请求前会自动发起 options 请求</p>
<p>浏览器必须首先使用 options 方法发起一个预检请求，从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求</p>
<h5 id="简单请求与复杂请求"><a href="#简单请求与复杂请求" class="headerlink" title="简单请求与复杂请求"></a>简单请求与复杂请求</h5><p>某些请求不会触发 CORS 预检请求，这样的请求一般称为”简单请求”，而会触发预检的请求则为”复杂请求”，get，head， post</p>
<h5 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h5><p>同源是指，域名、协议、端口均相同</p>
<p>而非同源之间网页调用就是我们所说的跨域</p>
<h5 id="options问题"><a href="#options问题" class="headerlink" title="options问题"></a>options问题</h5><p>复杂请求的条件其实非常容易满足，而一旦满足复杂请求的条件，则浏览器便会发送2次请求（一次预检options，一次复杂请求），这一次options就一来一回（一个RTT），显然会导致延迟和不必要的网络资源浪费，高并发情况下则可能为服务器带来严重的性能消耗</p>
<h5 id="优化options请求"><a href="#优化options请求" class="headerlink" title="优化options请求"></a>优化options请求</h5><p>每次复杂请求前都会调用一次options，这其实非常没有必要。因为大部分时候相同的请求，短时间内获得的结果是不会变的</p>
<p>通过缓存优化</p>
<p>Access-Control-Max-Age就是优化这个流程中使用的一个Header。它的作用是当你每次请求options方法时，服务端返回调用支持的方法（Access-Control-Allow-Methods ）和Headers（Access-Control-Allow-Headers）有哪些，同时告诉你，它在接下来 Access-Control-Max-Age时间（单位是秒）里都支持，则这段时间内，不再需要使用options进行请求。特别注意的是，当Access-Control-Max-Age的值为-1时，表示禁用缓存，每一次请求都需要发送预检请求，即用OPTIONS请求进行检测</p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>1xx：表示请求已接收，继续处理</p>
<p>2xx: 表示请求已成功，接受</p>
<p>3xx：重定向</p>
<p>4xx：客户端错误</p>
<p>5xx：服务端错误</p>
<p><img src="/2021/03/29/%E5%85%B3%E4%BA%8EHTTP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3/3.png" alt="3"></p>
<h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><p>200 : 代表请求已成功，数据也正常返回</p>
<p>204：常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据</p>
<p>206:  服务器已经成功处理了部分GET请求。类似于B站看视频或者迅雷这类的HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载</p>
<p>301：表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问</p>
<p>302：表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问 Loocation字段</p>
<p>304：表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制</p>
<p>307: 内部重定向,跳转到别的网址上</p>
<p>400：请求报文有错</p>
<p>403：禁止访问</p>
<p>404：没有这个地址路由，或者方法不对，get，post</p>
<p>499：由于服务端处理时间过长，客户端超时。一般常见于，后端服务器处理时间过长，而客户端也设置了一个超时等待时间，客户端等得“不耐烦”了，主动关掉连接时报出</p>
<p>501：请求的功能不支持</p>
<p>502： 服务器崩溃</p>
<p>503：表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思</p>
<p>504：网络请求过程中，由于服务端处理时间过长，网关超时。一般常见于，后端服务器逻辑处理时间过长，甚至长于nginx设置的最长等待时间时报错。它跟 499 状态码非常像，区别在于499表示的是客户端超时，504是网关超时。如果是499超时，可以考虑修改客户端的代码调整超时时间，如果是504，则考虑调整nginx的超时配置。</p>
<h3 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h3><h4 id="content-length"><a href="#content-length" class="headerlink" title="content-length"></a>content-length</h4><p>Content-Length是HTTP的消息长度,用十进制数字表示。Content-Length首部指出报文中消息的当前实际字节大小。如果消息文本进行了gzip压缩的话， Content-Length指的就是压缩后的大小而不是原始大小</p>
<p>正常情况下Content-Length是不需要手动去设置的，大部分语言的网络库都会自动封装好，但是如果在一些特殊情况下，出现Content-Length与实际要发送的消息大小不一致，就会出现一些问题</p>
<p>小于实际长度：会被截断</p>
<p>大于实际长度：会阻塞</p>
<h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p>请求文件的起始结束阶段，视频播放等</p>
<p>不支持range，200，会下载整个文件</p>
<p>服务器支持 Range Requests，会读取视频文件，响应码为 206，则浏览器会在接收到足够字节（比如当前播放进度往后推20s）时结束掉请求，以节省网络流量；当播放进度继续往前，缓存不够时，浏览器会发起一个新的 Range Requests 请求，请求的 Range 直接从缓存结尾的字节开始，只加载剩余的部分文件。同时返回的Response Headers中有一个 content-range 的字段域，用于告诉了客户端发送了多少数据。content-range描述了响应覆盖的范围和整个实体长度。一般格式：Content-Range：开始字节位置-结束字节位置／文件大小（byte）</p>
<h4 id="connection"><a href="#connection" class="headerlink" title="connection"></a>connection</h4><p>短链接close<br>长连接keep-alive，表示链接不关闭，做到只建立一次连接，多次资源请求都复用该连接，完成后关闭</p>
<p>Request Header和Reponse Header中都有可能出现一个Connection: keep-alive 头信息。Request Header里的Connection: keep-alive 头是为了告诉服务端，客户端想要以长连接形式进行通信。而Response Header里的Connection: keep-alive 头是服务端告诉客户端，我的服务器支持以长连接的方式进行通信。如果不能使用长连接，会返回  Connection: close</p>
<p>tcp层连接，需要三次握手，四次挥手，每次都需要这个步骤，如果能只连接一次，保持住这个连接不断开，期间通信就可以省下建立连接和断开连接的过程，对于提升HTTP性能有很大的帮助</p>
<p>长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。但是在长连接的应用场景下，需要有一方主动关闭连接。如果客户端和服务端之间的连接一直不关闭的话，连接数则会越来越多，严重的时候会造成资源占用过高。</p>
<p>解决方案也比较简单。如果这些连接其实长时间内并没有任何数据传输的话，那其实属于空闲连接，这时候可以在服务端设置空闲连接的存活时间，超过一定时间后由服务端主动断掉，从而保证无用连接及时释放</p>
<h4 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h4><p>识别用户身份，持久化用户信息，保存到本地</p>
<h4 id="Referrer-Policy-和-Referrer"><a href="#Referrer-Policy-和-Referrer" class="headerlink" title="Referrer Policy 和 Referrer"></a>Referrer Policy 和 Referrer</h4><p>Referrer 是HTTP请求header的报文头，用于指明当前流量的来源参考页面，常被用于分析用户来源等信息。通过这个信息，我们可以知道访客是怎么来到当前页面的</p>
<p>而 Referrer Policy 则是用于控制Referrer信息传不传、传哪些信息、在什么时候传的策略，过滤referrer的敏感信息</p>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>cache-control: private<br>具有“private”指令的响应只能由客户端缓存，不能由中间代理（例如 CDN或代理）缓存。这些资源通常是包含私密数据的资源，例如显示用户个人信息的网站。</p>
<p>cache-control: public<br>相反，“public”指令表示资源可以由任何缓存存储。</p>
<p>cache-control: no-store<br>带有“no-store”指令的响应无法缓存到任何位置，也永不缓存。也就是说，用户每次请求此数据时，都必须将请求发送到源站服务器以获取新副本。此指令通常保留给包含极其敏感数据的资源，例如银行帐户信息。</p>
<p>cache-control: max-age<br>此指令指定了生存时间，也就是资源在下载后可以缓存多少秒钟。例如，如果将最大期限设置为 1800，则首次从服务器请求资源后的 1800 秒（30 分钟）内，后续请求都会向用户提供该资源的缓存版本。如果 30 分钟后用户再次请求资源，则客户端需要向服务器重新请求该资源。</p>
<p>cache-control: no-cache</p>
<p>从B站截图里可以看出，使用的缓存控制指令是cache-control: no-cache。它表示，只有先检查资源没有更新版本后，才可使用所请求资源的缓存版本。那么问题来了，怎么判断资源是否有更新版本呢？这就需要 ETag</p>
<h3 id="ETAG"><a href="#ETAG" class="headerlink" title="ETAG"></a>ETAG</h3><p>Etag是 Entity tag的缩写，是服务端的一个资源版本的令牌标识。在 HTTP 响应头中将其传送到客户端。每当资源更新时，此令牌会更新。</p>
<p>比如，浏览器第一次请求资源的时候，服务端返回了这个资源的ETag: “095933fff2323351d3b495f2f879616f1762f752”。</p>
<p>当浏览器再次请求这个资源的时候，浏览器会将If-None-Match: “095933fff2323351d3b495f2f879616f1762f752” 传输给服务端，服务端拿到该ETAG，对比资源是否发生变化。</p>
<p>如果资源未发生改变，则返回304HTTP状态码，不返回具体的资源。</p>
<p>否则表示资源已经更新，浏览器需要下载新版本以提供给用户。</p>
<p>此过程可确保用户始终获得资源的最新版本，并且无需进行不必要的下载</p>
<h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><p>TCP/IP协议是一个协议簇。里面包括很多协议的，UDP只是其中的一个</p>
<h3 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h3><p>无连接：只知道对端的IP和端口号就可以发送，不需要实现建立连接。</p>
<p>不可靠：没有确认机制， 没有重传机制。如果因为网络故障该段无法发到对方， UDP协议层也不会给应用层返回任何错误信息。</p>
<p>面向数据报： 应用层交给UDP多长的报文， UDP原样发送既不会拆分，也不会合并。如果发送端调用一次sendto, 发送100个字节, 那么接收端也必须调用对应的一次recvfrom,接收100个字节，而不能循环调用10次recvfrom,每次接收10个字节。所以UDP不能够灵活的控制读写数据的次数和数量</p>
<h4 id="udp缓冲区"><a href="#udp缓冲区" class="headerlink" title="udp缓冲区"></a>udp缓冲区</h4><p>接收缓冲区：具有接收缓冲区，但不能保证收到的UDP报文的顺序和发送UDP报的顺序一致，如果缓冲区满了再到达的UDP数据报就会被丢弃</p>
<p>发送缓冲区：没有发送缓冲区，调用sendto时会直接将数据交给内核，由内核将数据传给网络层协议进行后续的传输动作</p>
<p>不保证可靠性，它没有重传机制，当报文丢失时，UDP不需要重新发送，而TCP不同，他必须具备发送缓冲区，当报文丢失时，TCP必须保证重新发送，用户不会管，所以必须要具备发送缓冲区</p>
<h4 id="长度大小"><a href="#长度大小" class="headerlink" title="长度大小"></a>长度大小</h4><p>UDP协议首部中有一个16位的大长度. 也就是说一个UDP能传输的报文长度是64K(包含UDP首部)。如果我们需要传输的数据超过64K, 就需要在应用层手动的分包, 多次发送, 并在接收端手动拼装</p>
<p>DNS域名解析就是udp协议</p>
<p>TFTP：简单文件传输协议</p>
<h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><h4 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h4><p>一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）</p>
<p>ACK —— 确认，使得确认号有效。<br>RST —— 重置连接（经常看到的reset by peer）就是此字段<br>SYN —— 用于初如化一个连接的序列号<br>FIN —— 该报文段的发送方已经结束向对方发送数据</p>
<h5 id="建立连接阶段（三次握手）"><a href="#建立连接阶段（三次握手）" class="headerlink" title="建立连接阶段（三次握手）"></a>建立连接阶段（三次握手）</h5><p>1、客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c)</p>
<p>2、服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN,将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传</p>
<p>3、为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值，并携带客户到服务端的数据</p>
<p>第三次握手可以携带数据，前两次不可以</p>
<h5 id="断开连接（四次挥手）"><a href="#断开连接（四次挥手）" class="headerlink" title="断开连接（四次挥手）"></a>断开连接（四次挥手）</h5><p>1、客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据</p>
<p>2、服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作</p>
<p>3、服务端发起自己的FIN段，ACK=K+1</p>
<p>4、客户端确认。ACK=L+1</p>
<h5 id="为啥要3，4"><a href="#为啥要3，4" class="headerlink" title="为啥要3，4"></a>为啥要3，4</h5><p>“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的</p>
<p>第一次：客户端发送网络包，服务端收到</p>
<p>服务端知道客户端的发送能力、服务端的接收能力是正常的</p>
<p>第二次：服务端发包，客户端收到</p>
<p>客户端知道服务端的接收、发送能力，客户端的接收、发送能力是正常的</p>
<p>第三次：客户端发包，服务端收到</p>
<p>客户端的接收、发送能力，服务端的发送、接收能力是正常的</p>
<p>得需要客户端服务端都知道对方以及自己的收发能力正常，所以需要3次，2次不足以满足</p>
<p>首要原因：</p>
<p>1、防止旧的重复连接初始化造成混乱</p>
<p>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；</p>
<p>那么此时服务端就会回一个 SYN + ACK 报文给客户端；</p>
<p>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接</p>
<p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</p>
<p>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 RST 报文，以此中止历史连接；</p>
<p>如果不是历史连接，则第三次发送的报文是 ACK 报文，通信双方就会成功建立连接；</p>
<p>所以要3次</p>
<p>2、有效同步序列号，没有ack的话就无法确认序列号是否同步</p>
<p>接收方可以去除重复的数据；</p>
<p>接收方可以根据数据包的序列号按序接收；</p>
<p>可以标识发送出去的数据包中， 哪些是已经被对方收到的</p>
<p>3、资源浪费，没有ack的话，网络阻塞，就会多出很多冗余链接</p>
<p>4次挥手</p>
<p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据，一方要关闭，对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接</p>
<p>服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接</p>
<p>接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的</p>
<h5 id="为啥建立是3，断开是4"><a href="#为啥建立是3，断开是4" class="headerlink" title="为啥建立是3，断开是4"></a>为啥建立是3，断开是4</h5><p>收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。</p>
<p>而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送</p>
<p>如果服务器已经没有数据需要传了，第二次第三次可以合并作一次</p>
<h5 id="syn-flood攻击"><a href="#syn-flood攻击" class="headerlink" title="syn flood攻击"></a>syn flood攻击</h5><p>恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源</p>
<p>解决方法：</p>
<p>监控无效链接，半开连接，不活动连接，达到阈值，拆除</p>
<p>延缓TCB分配： 服务器收到SYN包的时候，使用 数据结构 TCB 来存储这次连接的信息，成功建立连接之后才分配TCB</p>
<h4 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h4><p>TCP在传输数据过程中，还加入了超时重传机制。假设主机A发送数据给主机B，主机B没有收到数据包，主机B自然就不会应答，如果主机A在一个特定时间间隔内没有收到主机B发来的确认应答，就会进行重发，这就是超时重传机制</p>
<p>有可能会收到很多重复数据，那么TCP协议需要能够识别出那些包是重复的包， 并且把重复的包丢弃掉，这时候我们可以利用tcp报文里的16位 序列号，数据校验，就可以很容易做到去重的效果</p>
<p>linux的超时重传是500ms的整数倍</p>
<p>RTT 包的往返时间<br>RTO 超时重传时间</p>
<p>当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；</p>
<p>当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发</p>
<p>超时重传时间 RTO 的值应该略大于报文往返  RTT 的值</p>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题</p>
<h4 id="SACK和D-SACK"><a href="#SACK和D-SACK" class="headerlink" title="SACK和D-SACK"></a>SACK和D-SACK</h4><p>SACK：可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据</p>
<p>D-SACK：其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了</p>
<h4 id="Time-Wait状态"><a href="#Time-Wait状态" class="headerlink" title="Time Wait状态"></a>Time Wait状态</h4><p>服务器运行起来然后将服务器关闭掉，再次重新启动服务器会发现一个问题：就是不能马上再次绑定这个端口号和ip，需要等一会才可以重新绑定，其实等的这一会就是TIME_WAIT状态</p>
<p>协议规定主动关闭连接的一方要处于TIME_ WAIT状态，等待两个MSL的时间后才能回到CLOSED状态</p>
<p>TIME_WAIT是为了防止最后一个ACK丢失，如果没有TIME_WAIT，那么主动断开连接的一方就已经关闭连接，但是另一方还没有断开连接，它收不到确认ACK会认为自己上次发送的FIN报文丢失会重发该报文，但是另一方已经断开连接了，这就会造成连接不一致的问题，所以TIME_WAIT是必须的</p>
<p>MSL是TCP报文在发送缓冲区的最大生存时间，如果TIME_WAIT持续存在2MSL的话就能保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失</p>
<p>但是当用户量请求很大的时候，主动断开连接，就会产生大量的timewait状态</p>
<p>优化：</p>
<p>1、使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符<br>2、net.ipv4.tcp_tw_reuse 和 tcp_timestamps，复用处于timewait状态的新连接</p>
<p>net.ipv4.tcp_tw_reuse要慎用，因为使用了它就必然要打开时间戳的支持 net.ipv4.tcp_timestamps，当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉</p>
<p>3、net.ipv4.tcp_max_tw_buckets一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置，暴力解决</p>
<h4 id="close-wait状态"><a href="#close-wait状态" class="headerlink" title="close wait状态"></a>close wait状态</h4><p>客户端是主动断开连接的一方，在服务器端假设没有关闭新连接，这时服务器端就会产生一个CLOSE_WAIT状态</p>
<p>服务器上出现大量的CLOSE_WAIT状态，原因就是服务器没有正确的关闭 socket，导致四次挥手没有正确完成</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>一次一次发送性能较低，每一次都要ack确认，一次发送多条，窗口大小指的是无需等待确认应答而可以继续发送数据的最大值，收到第一个ACK后滑动窗口向后移动，继续发送后面的数据，</p>
<p>内核为了维护这个滑动窗口，需要开辟发送缓冲区来记录当前还有哪些数据没有应答。只有确认应答过的数据，才能从缓冲区删掉，窗口越大，则网络的吞吐率就越高</p>
<p>累计确认，累计应答， ack600丢失，ack700收到，则认为600收到</p>
<p>三个指针控制窗口大小，窗口大小，已发送未确认收到，未发送，可发送范围</p>
<p>服务端繁忙会减少窗口大小，先减少缓存，再减少窗口会引发丢包现象</p>
<p>TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间在减少缓存，这样就可以避免了丢包情况</p>
<p>非0窗口的ack丢失引发死锁</p>
<p>窗口关闭引发死锁：为了解决这个问题，TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</p>
<p>如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小</p>
<h4 id="丢包与快重传"><a href="#丢包与快重传" class="headerlink" title="丢包与快重传"></a>丢包与快重传</h4><p>数据到达，ack丢失：发送后面的数据1001-2000字节的数据，收到2001的ack，就可以认为前面的1000的数据接收成功</p>
<p>数据丢失： 1001-2000丢失，后面的数据接收到之后，接收方会收到失序的报文，则会发送1001的ack连续3次，发送端连续3次收到1001的ack就会将1001-2000的数据重发，同时后面的数据接收不变</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>接收端处理数据的速度是有限的，如果发送端发的太快，导致接收端的缓冲区被装满，这个时候如果发送端继续发送，就会造成丢包</p>
<p>TCP支持根据接收端的处理能力，来决定发送端的发送速度，这个机制就叫做流量控制</p>
<p>1、接收端将自己可以接收的缓冲区大小放入TCP首部中的”窗口大小”字段，通过ACK确认报文通知发送端</p>
<p>2、窗口大小字段越大，说明网络的吞吐量越高，接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端</p>
<p>3、发送端接受到这个窗口之后，就会减慢自己的发送速度，如果接收端缓冲区满了，就会将窗口置为0。这时发送方不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端，防止窗口更新丢失，发送端会有窗口探测包</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>拥塞窗口是发送方维护，滑动窗口是接收方维护，发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值</p>
<p>只要网络中没有出现拥塞，cwnd 就会增大；</p>
<p>但网络中出现了拥塞，cwnd 就减少</p>
<p>发生超时重传就认为是拥塞</p>
<h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p>在刚开始网络拥堵时再发送大量数据仍然有可能会造成堵塞</p>
<p>所以tcp有慢启动机制，开始发送的数据量较少，试探网络情况，然后指数级增长，增长很快</p>
<p>为了不增长的那么快，因此不能使拥塞窗口单纯的加倍，此处引入一个叫做慢启动的阈值当拥塞窗口超过这个阈值的时候，不再按照指数方式增长， 而是按照线性方式增长</p>
<p>少量的丢包，我们仅仅是触发超时重传。大量的丢包，我们就认为网络拥塞。当TCP通信开始后，网络吞吐量会逐渐上升。随着网络发生拥堵，吞吐量会立刻下降。拥塞控制归根结底是TCP协议想尽可能快的把数据传输给对方，但是又要避免给网络造成太大压力的折中方案</p>
<h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p>慢启动增长转为线性增长</p>
<p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p>
<p>当触发了重传机制，也就进入了「拥塞发生算法」</p>
<h5 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h5><p>超时重传的话就会重新慢启动，减少数据流，比较暴力，会造成网络卡顿，慢启动门限会变成1</p>
<p>快速重传：比较平缓，拥塞窗口变为原来一半，慢启动门限也会变为拥塞窗口大小，然后进入快速恢复</p>
<p>快速恢复：持续再增长拥塞窗口</p>
<h4 id="延迟应答"><a href="#延迟应答" class="headerlink" title="延迟应答"></a>延迟应答</h4><p>如果接收方立刻返回ack，这时候返回的窗口可能比较小。假设接收端缓冲区为1M 一次收到了500K的数据。如果立刻应答，返回的窗口就是500K。 但实际上可能处理端处理的速度很快，10ms之内就把500K数据从缓冲区消费掉了，在这种情况下，接收端处理还远没有达到自己的极限，即使窗口再放大一些也能处理过来。如果接收端稍微等一会再应答，比如等待200ms再应答，那么这个时候返回的窗口大小就是1M。</p>
<p>窗口越大，网络吞吐量就越大，传输效率就越高。我们的目标是在保证网络不拥塞的情况下尽量提高传输效率。</p>
<p>数量限制: 每隔N个包就应答一次<br>时间限制: 超过大延迟时间就应答一次<br>PS：具体的数量和超时时间, 依操作系统不同也有差异; 一般N取2, 超时时间取200ms</p>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="tcp与udp的特点与区别及应用场景"><a href="#tcp与udp的特点与区别及应用场景" class="headerlink" title="tcp与udp的特点与区别及应用场景"></a>tcp与udp的特点与区别及应用场景</h3><ol>
<li><p>基于连接vs无连接<br>TCP是面向连接的协议。<br>UDP是无连接的协议。UDP更加适合消息的多播发布，从单个点向多个点传输消息。</p>
</li>
<li><p>可靠性<br>TCP提供交付保证，传输过程中丢失，将会重发。<br>UDP是不可靠的，不提供任何交付保证。（网游和视频的丢包情况）</p>
</li>
<li><p>有序性<br>TCP保证了消息的有序性，即使到达客户端顺序不同，TCP也会排序。<br>UDP不提供有序性保证。</p>
</li>
<li><p>数据边界<br>TCP不保存数据边界。<br>虽然TCP也将在收集所有字节之后生成一个完整的消息，但是这些信息在传给传输给接受端之前将储存在TCP缓冲区，以确保更好的使用网络带宽。</p>
</li>
</ol>
<p>UDP保证。<br>在UDP中，数据包单独发送的，只有当他们到达时，才会再次集成。包有明确的界限来哪些包已经收到，这意味着在消息发送后，在接收器接口将会有一个读操作，来生成一个完整的消息。</p>
<ol start="5">
<li><p>速度<br>TCP速度慢<br>UDP速度快。应用在在线视频媒体，电视广播和多人在线游戏。</p>
</li>
<li><p>发送消耗<br>TCP是重量级。<br>UDP是轻量级。<br>因为UDP传输的信息中不承担任何间接创造连接，保证交货或秩序的的信息。<br>这也反映在用于报头大小。</p>
</li>
</ol>
<ol start="7">
<li>报头大小</li>
</ol>
<p>TCP头大。<br>一个TCP数据包报头的大小是20字节。<br>TCP报头中包含序列号，ACK号，数据偏移量，保留，控制位，窗口，紧急指针，可选项，填充项，校验位，源端口和目的端口。<br>UDP头小。<br>UDP数据报报头是8个字节。<br>而UDP报头只包含长度，源端口号，目的端口，和校验和。</p>
<ol start="8">
<li>拥塞或流控制</li>
</ol>
<p>TCP有流量控制。<br>在任何用户数据可以被发送之前，TCP需要三数据包来设置一个套接字连接。TCP处理的可靠性和拥塞控制。<br>UDP不能进行流量控制。</p>
<ol start="9">
<li>应用<br>由于TCP提供可靠交付和有序性的保证，它是最适合需要高可靠并且对传输时间要求不高的应用。<br>UDP是更适合的应用程序需要快速，高效的传输的应用，如游戏。<br>UDP是无状态的性质，在服务器端需要对大量客户端产生的少量请求进行应答的应用中是非常有用的。<br>在实践中，TCP被用于金融领域，如FIX协议是一种基于TCP的协议，而UDP是大量使用在游戏和娱乐场所。</li>
</ol>
<p>10.上层使用的协议</p>
<p>基于TCP协议的：Telnet，FTP以及SMTP协议。<br>基于UDP协议的：DHCP、DNS、SNMP、TFTP、BOOTP。</p>
<h3 id="udp与tcp的首部位"><a href="#udp与tcp的首部位" class="headerlink" title="udp与tcp的首部位"></a>udp与tcp的首部位</h3><p>UDP 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的</p>
<p>tcp首部字段：序号，确认号，控制位（ack， fin，syn），窗口值</p>
<h3 id="为什么3，4"><a href="#为什么3，4" class="headerlink" title="为什么3，4"></a>为什么3，4</h3><p>相关看上面</p>
<h3 id="time-wait状态"><a href="#time-wait状态" class="headerlink" title="time wait状态"></a>time wait状态</h3><p>相关看上面</p>
<h3 id="短链接和长连接"><a href="#短链接和长连接" class="headerlink" title="短链接和长连接"></a>短链接和长连接</h3><p>Client 向 Server 发送消息，Server 回应 Client，然后一次读写就完成了，这时候双方任何一个都可以发起 close 操作，不过一般都是 Client 先发起 close 操作。短连接一般只会在 Client/Server 间传递一次读写操作。</p>
<p>短连接的优点：管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段</p>
<p>Client 与 Server 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>
<p>关闭策略：Client 与 Server 之间的连接如果一直不关闭的话，随着客户端连接越来越多，Server 压力也越来越大，这时候 Server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 Server 端服务受损；如果条件再允许可以以客户端为颗粒度，限制每个客户端的最大长连接数，从而避免某个客户端连累后端的服务</p>
<h3 id="地址栏输入-URL-发生了什么，http工作原理"><a href="#地址栏输入-URL-发生了什么，http工作原理" class="headerlink" title="地址栏输入 URL 发生了什么，http工作原理"></a>地址栏输入 URL 发生了什么，http工作原理</h3><p>1、在浏览器地址栏中输入url，先解析url，检测url地址是否合法</p>
<p>2、查看本地缓存，是否有缓存</p>
<p>3、浏览器会根据你输入的 URL 地址，去查找域名是否被本地 DNS 缓存，不同浏览器对 DNS 的设置不同，如果浏览器缓存了你想访问的 URL 地址，那就直接返回 ip。如果没有缓存你的 URL 地址，浏览器就会发起系统调用来查询本机 hosts 文件是否有配置 ip 地址，如果找到，直接返回。如果找不到，就向网络中发起一个 DNS 查询</p>
<p>4、查询到ip之后放到协议栈，浏览器需要和目标服务器建立 TCP 连接，需要经过三次握手的过程，然后由IP模块，封装网络包，生成包头，ip报文</p>
<p>5、IP报文加上MAC头部，由网卡转换电信号发送，有交换机，路由，发送到服务端，服务端解析报文，TCP头部， IP头部,MAC头部，</p>
<p>5、在建立连接后，浏览器会向目标服务器发起 HTTP-GET 请求，包括其中的 URL，HTTP 1.1 后默认使用长连接，只需要一次握手即可多次传输数据。</p>
<p>6、如果目标服务器只是一个简单的页面，就会直接返回。但是对于某些大型网站的站点，往往不会直接返回主机名所在的页面，而会直接重定向。返回的状态码就不是 200 ，而是 301,302 以 3 开头的重定向码，浏览器在获取了重定向响应后，在响应报文中 Location 项找到重定向地址，浏览器重新第一步访问即可。</p>
<p>7、然后浏览器重新发送请求，携带新的 URL，返回状态码 200 OK，表示服务器可以响应请求，返回报文</p>
<h3 id="https工作原理"><a href="#https工作原理" class="headerlink" title="https工作原理"></a>https工作原理</h3><p>在进行通信前，首先会进行 HTTP 的三次握手，握手完成后，再进行 TLS 的握手过程</p>
<p>TLS 旨在为 Internet 提供通信安全的加密协议。TLS 握手是启动和使用 TLS 加密的通信会话的过程</p>
<h3 id="为什么post是两个tcp包"><a href="#为什么post是两个tcp包" class="headerlink" title="为什么post是两个tcp包"></a>为什么post是两个tcp包</h3><p>post先去检测一下服务器是否能正常应答，然后再把data携带过去，如果应答不了，就没有了第二步数据传输</p>
<h3 id="get与post请求的区别"><a href="#get与post请求的区别" class="headerlink" title="get与post请求的区别"></a>get与post请求的区别</h3><p>1、get 请求的 URL 有长度限制，而 post 请求会把参数和值放在消息体中，对数据长度没有要求。</p>
<p>2、get 请求会被浏览器主动 cache，而 post 不会，除非手动设置。</p>
<p>3、get 请求在浏览器反复的 回退/前进 操作是无害的，而 post 操作会再次提交表单请求。</p>
<p>4、get 请求在发送过程中会产生一个 TCP 数据包；post 在发送过程中会产生两个 TCP 数据包。对于 get 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 post，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）</p>
<p>5、get 方法是不安全的，因为你在发送请求的过程中，你的请求参数会拼在 URL 后面， post 方法是把参数放在请求体 body 中的，这对用户来说不可见</p>
<h3 id="无状态协议"><a href="#无状态协议" class="headerlink" title="无状态协议"></a>无状态协议</h3><p>无状态协议(Stateless Protocol) 就是指浏览器对于事务的处理没有记忆能力</p>
<p>HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力</p>
<p>通过cookie实现（大概20个，30个，50个左右， cookie大小限制4000kb左右）</p>
<h3 id="cookies与session的区别"><a href="#cookies与session的区别" class="headerlink" title="cookies与session的区别"></a>cookies与session的区别</h3><h3 id="http与https的区别"><a href="#http与https的区别" class="headerlink" title="http与https的区别"></a>http与https的区别</h3><p>HTTPS=SSL+HTTP</p>
<p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p>
<p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>（这个只是默认端口不一样，实际上端口是可以改的）</p>
<p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<h3 id="put与post的区别"><a href="#put与post的区别" class="headerlink" title="put与post的区别"></a>put与post的区别</h3><p>PUT 和POST方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用），而POST方法是非幂等的</p>
<h3 id="put和patcch"><a href="#put和patcch" class="headerlink" title="put和patcch"></a>put和patcch</h3><p>PUT和PATCH都是更新资源，而PATCH用来对已知资源进行局部更新</p>
<h3 id="http-2特点，优势"><a href="#http-2特点，优势" class="headerlink" title="http/2特点，优势"></a>http/2特点，优势</h3><p>头部压缩</p>
<p>HTTP2中：<br>同域名下所有通信都在单个连接上完成。<br>单个连接可以承载任意数量的双向数据流。<br>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装</p>
<p>二进制格式数据传输</p>
<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>五层： 应用（http， DNS），传输（tcp，udp），网络（ip），链路（mac）， 物理</p>
<p>七层：加上表示层和会话层</p>
<h3 id="tcp全连接队列与半连接队列溢出"><a href="#tcp全连接队列与半连接队列溢出" class="headerlink" title="tcp全连接队列与半连接队列溢出"></a>tcp全连接队列与半连接队列溢出</h3><p>全连接队列溢出：</p>
<p>当服务端并发处理大量请求时，如果 TCP 全连接队列过小，就容易溢出。发生 TCP 全连接队溢出的时候，后续的请求就会被丢弃，这样就会出现服务端请求数量上不去的现象</p>
<p>查看溢出：netstat -s |grep overflowed</p>
<p>调整全连接队列最大值</p>
<p>ss -lnt 查看全连接队列</p>
<p>Recv-Q：当前全连接队列的大小，也就是当前已完成三次握手并等待服务端 accept() 的 TCP 连接个数；</p>
<p>Send-Q：当前全连接最大队列长度，上面的输出结果说明监听 8088 端口的 TCP 服务进程，最大全连接长度为 128；</p>
<p>TCP 全连接队列足最大值取决于 somaxconn 和 backlog 之间的最小值，也就是 min(somaxconn, backlog)</p>
<p>somaxconn 是 Linux 内核的参数，默认值是 128，可以通过 /proc/sys/net/core/somaxconn 来设置其值；</p>
<p>backlog 是 listen(int sockfd, int backlog) 函数中的 backlog 大小，Nginx 默认值是 511，可以通过修改配置文件设置其长度</p>
<p>半连接队列溢出：</p>
<p>服务端处于 SYN_RECV 状态的 TCP 连接，就是在 TCP 半连接队列</p>
<p>netstat -natp |grep syn_recv |wc -l</p>
<p>查看溢出：netstat -s |grep “SYNs to Listen”</p>
<p>隔几秒执行几次，如果有上升的趋势，说明当前存在半连接队列溢出的现象</p>
<p>如果半连接队列满了，并且没有开启 tcp_syncookies，则会丢弃；</p>
<p>若全连接队列满了，且没有重传 SYN+ACK 包的连接请求多于 1 个，则会丢弃；</p>
<p>如果没有开启 tcp_syncookies，并且 max_syn_backlog 减去 当前半连接队列长度小于 (max_syn_backlog &gt;&gt; 2)，则会丢弃</p>
<p>半连接最大队列一般是256个</p>
<p>syncookies功能：不使用半连接队列，服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK </p>
<p>0：关闭，1：半连接对列放不下开启， 2：无条件开启</p>
<p>防御syn攻击：</p>
<p>服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的 SYN 接收队列（未连接队列）</p>
<p>增大半连接队列：也需要同同时增大全连接队列</p>
<p>开启syncookies</p>
<p>减少重传次数：当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接，加快连接断开</p>
<h3 id="ping的工作原理"><a href="#ping的工作原理" class="headerlink" title="ping的工作原理"></a>ping的工作原理</h3><p>ping 是基于 ICMP 协议工作的，互联网控制报文协议</p>
<p>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等</p>
<p>1、Ping 命令会构建一个 固定格式的 ICMP 请求数据包（Echo Request）</p>
<p>2、ICMP协议会将数据包，连同去往的地址放到IP层</p>
<p>3、IP协议将本机作为源地址，目的地址，加上一些控制信息，交给链路层</p>
<p>4、链路层加上mac地址，到物理层发出</p>
<p>5、服务端收到后拆包，检测目的地址，然后给icmp协议处理，然后响应</p>
<h3 id="如果已经建立链接，客户端突然出现故障。怎么办"><a href="#如果已经建立链接，客户端突然出现故障。怎么办" class="headerlink" title="如果已经建立链接，客户端突然出现故障。怎么办"></a>如果已经建立链接，客户端突然出现故障。怎么办</h3><p>保活机制</p>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序</p>
<p>net.ipv4.tcp_keepalive_time=7200<br>net.ipv4.tcp_keepalive_intvl=75<br>net.ipv4.tcp_keepalive_probes=9</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Linux buff/cache缓存处理</title>
    <url>/2020/09/12/%E5%85%B3%E4%BA%8ELinux%20buff_cache%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="buff-cache"><a href="#buff-cache" class="headerlink" title="buff/cache"></a>buff/cache</h3><p>buffer/cache 一般用于磁盘或文件的缓存，一些shared memory 也会放在这里，一般情况下大部分都是可以回收的，在一些较新版本的Linux 中，free 命令会有一个available 的列，它表示在计算了可回收的buffer/cache的情况下可用的内存</p>
<p>Linux内存回收机制比较复杂，但一般来说会在内存不足的情况下主动去释放cache，在/proc/meminfo 里可以看到相对详细的数据，包括哪些内存是可以回收的，哪些是不能回收的。如果你通过命令这种方法主动去清理的话，如果内存中有一些没有落盘的数据，会在这个时候去写回。如果这个过程顺利进行，就不会有数据的丢失或损坏，但是下次你要使用这些文件，又需要重新从磁盘读到内存，所以大多数情况下没有正面意义，反而会降低效率。</p>
<h3 id="buff-cache占用过大，清理"><a href="#buff-cache占用过大，清理" class="headerlink" title="buff/cache占用过大，清理"></a>buff/cache占用过大，清理</h3><p>在Linux下经常会遇到buff/cache内存占用过多问题，尤其是使用云主机的时候最严重，由于很多是虚拟内存，因此如果buff/cache占用过大的，free空闲内存就很少，影响使用；</p>
<p>可以使用<code>free -m</code>查看<br><img src="/2020/09/12/%E5%85%B3%E4%BA%8ELinux%20buff_cache%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86/1.png" alt="1"></p>
<p>通常内存关系是：</p>
<p>普通机器：total=used+free</p>
<p>虚拟机器：total=used+free+buff/cache</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/vm/drop_caches</span><br><span class="line">echo <span class="number">2</span> &gt; <span class="regexp">/proc/</span>sys/vm/drop_caches</span><br><span class="line">echo <span class="number">3</span> &gt; <span class="regexp">/proc/</span>sys/vm/drop_caches</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>环境运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Linux swap分区相关处理</title>
    <url>/2020/08/15/%E5%85%B3%E4%BA%8ELinux%20swap%E5%88%86%E5%8C%BA%E7%9B%B8%E5%85%B3%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="什么是swap分区"><a href="#什么是swap分区" class="headerlink" title="什么是swap分区"></a>什么是swap分区</h3><p>在Linux下，SWAP的作用类似Windows系统下的“虚拟内存”。当物理内存不足时，拿出部分硬盘空间当SWAP分区（虚拟成内存）使用，从而解决内存容量不足的情况。</p>
<p>SWAP意思是交换，顾名思义，当某进程向OS请求内存发现不足时，OS会把内存中暂时不用的数据交换出去，放在SWAP分区中，这个过程称为SWAP OUT。当某进程又需要这些数据且OS发现还有空闲物理内存时，又会把SWAP分区中的数据交换回物理内存中，这个过程称为SWAP IN。</p>
<p>当然，swap大小是有上限的，一旦swap使用完，操作系统会触发OOM-Killer机制，把消耗内存最多的进程kill掉以释放内存。</p>
<p>使用 swap 交换分区，显著的优点是，通过操作系统的调度，应用程序实际可以使用的内存空间将远远超过系统的物理内存。由于硬盘空间的价格远比 RAM 要低，因此这种方式无疑是经济实惠的。当然，频繁地读写硬盘，会显著降低操作系统的运行速率，这也是使用 swap 交换分区最大的限制。</p>
<p>具体使用多大的 swap 分区，取决于物理内存大小和硬盘的容量。一般来讲，swap 分区容量应大于物理内存大小，建议是内存的两倍，但不超过 2GB。但是，有时服务器的访问量确实很大，有可能出现 swap 分区不够用的情况</p>
<h3 id="swap对数据库的影响"><a href="#swap对数据库的影响" class="headerlink" title="swap对数据库的影响"></a>swap对数据库的影响</h3><p>swap机制的初衷是为了缓解物理内存用尽而选择直接粗暴OOM进程的尴尬。但坦白讲，几乎所有数据库对swap都不怎么待见，无论MySQL、Oracal、MongoDB抑或HBase，为什么？这主要和下面两个方面有关：</p>
<ol>
<li><p>数据库系统一般都对响应延迟比较敏感，如果使用swap代替内存，数据库服务性能必然不可接受。对于响应延迟极其敏感的系统来讲，延迟太大和服务不可用没有任何区别，比服务不可用更严重的是，swap场景下进程就是不死，这就意味着系统一直不可用……再想想如果不使用swap直接oom，是不是一种更好的选择，这样很多高可用系统直接会主从切换掉，用户基本无感知。</p>
</li>
<li><p>另外对分布式系统来说，其实并不担心某个节点宕掉，而恰恰担心某个节点夯住。一个节点宕掉，最多就是小部分请求短暂不可用，重试即可恢复。但是一个节点夯住会将所有分布式请求都夯住，服务器端线程资源被占用不放，导致整个集群请求阻塞，甚至集群被拖垮。</p>
</li>
</ol>
<p>从这两个角度考虑，所有数据库都不喜欢swap还是很有道理的！</p>
<h3 id="swap关闭重启命令"><a href="#swap关闭重启命令" class="headerlink" title="swap关闭重启命令"></a>swap关闭重启命令</h3><p>对swap分区进行关闭重启，可清空swap虚拟内存数据<br>root用户下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">swapoff a 关闭swap分区</span><br><span class="line">swapon a 开启swap分区</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>环境运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Linux终端的常用命令（一）</title>
    <url>/2018/01/15/%E5%85%B3%E4%BA%8ELinux%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux由Unix发展而来，于1991年林纳斯（linus）发布，分为内核与发行版，内核（kernel）是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，主要做一些基本的，也是重要的操作。比如进程管理、内存管理、磁盘管理、驱动管理、电源管理、安全管理等。
Linux 内核版本又分为 稳定版 和 开发版，两种版本是相互关联，相互循环。
稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些 bug 或加入一些新的驱动程序
开发版：由于要试验各种解决方案，所以变化很快
内核源码网址：[点这里](http://www.kernel.org)
</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux发行版通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件。<br>
主要有：ubantu，centos，redhat, debian等，这里主要是ubantu的基本常用命令。
</div>
### Linux终端命令基本使用
----------
<div>终端命令格式：Command 【-options（选项，可以配合使用）】【parameter（对象）】</div>


<h4 id="1-查看文件信息（在当前路径下输入即可查看当前路径文件）"><a href="#1-查看文件信息（在当前路径下输入即可查看当前路径文件）" class="headerlink" title="1. 查看文件信息（在当前路径下输入即可查看当前路径文件）"></a>1. 查看文件信息（在当前路径下输入即可查看当前路径文件）</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">ls -l # 查看详情</span><br><span class="line">ls -a # 查看所有文件</span><br><span class="line">ls -h # 配合-l显示文件大小</span><br></pre></td></tr></table></figure>

<h4 id="2-通配符，可以代替字符"><a href="#2-通配符，可以代替字符" class="headerlink" title="2. 通配符，可以代替字符"></a>2. 通配符，可以代替字符</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">* # 代表0个或多个任意字符</span><br><span class="line">？ # 代表任意一个字符</span><br></pre></td></tr></table></figure>



<h4 id="3-清屏"><a href="#3-清屏" class="headerlink" title="3. 清屏"></a>3. 清屏</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">按键：ctrl +L</span><br></pre></td></tr></table></figure>

<h4 id="4-切换路径（分为相对路径和绝对路径，相对路径从当前目录开始；绝对路径从根目录（-）开始）"><a href="#4-切换路径（分为相对路径和绝对路径，相对路径从当前目录开始；绝对路径从根目录（-）开始）" class="headerlink" title="4. 切换路径（分为相对路径和绝对路径，相对路径从当前目录开始；绝对路径从根目录（/）开始）"></a>4. 切换路径（分为相对路径和绝对路径，相对路径从当前目录开始；绝对路径从根目录（/）开始）</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">cd ./Desktop # .代表当前路径</span><br><span class="line">cd ../ # ..代表上一级路径</span><br></pre></td></tr></table></figure>

<h4 id="5-显示当前绝对路径"><a href="#5-显示当前绝对路径" class="headerlink" title="5. 显示当前绝对路径"></a>5. 显示当前绝对路径</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<h4 id="6-创建目录"><a href="#6-创建目录" class="headerlink" title="6. 创建目录"></a>6. 创建目录</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mkdir 目录名</span><br><span class="line">mkdir a/b/c -p # 创建级联目录</span><br></pre></td></tr></table></figure>

<h4 id="7-创建文件（文件名指定后缀名）"><a href="#7-创建文件（文件名指定后缀名）" class="headerlink" title="7. 创建文件（文件名指定后缀名）"></a>7. 创建文件（文件名指定后缀名）</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">touch 文件名</span><br><span class="line">touch 文件1 文件2 文件3 # 创建多个文件</span><br></pre></td></tr></table></figure>

<h4 id="8-删除文件，目录"><a href="#8-删除文件，目录" class="headerlink" title="8. 删除文件，目录"></a>8. 删除文件，目录</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">rm -i # 删除文件给予交互提示</span><br><span class="line">rm -f # 强制删除</span><br><span class="line">rm -r # 递归删除，删除目录</span><br></pre></td></tr></table></figure>



<h4 id="9-拷贝文件，目录"><a href="#9-拷贝文件，目录" class="headerlink" title="9. 拷贝文件，目录"></a>9. 拷贝文件，目录</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cp 【源文件名】【目标目录路径】# 拷贝文件不能在本目录下，不能重名</span><br><span class="line">例： cp <span class="number">1.</span>txt ./a 将<span class="number">1.</span>txt复制到当前目录的a目录下</span><br><span class="line">cp 【源文件名】【目标文件名】# 拷贝并重命名</span><br><span class="line">例： cp a.txt b.txt 复制a并命名为b</span><br><span class="line">选项： -r 拷贝文件夹  -f 强制拷贝 -i交互提示</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="10-移动文件，文件夹"><a href="#10-移动文件，文件夹" class="headerlink" title="10. 移动文件，文件夹"></a>10. 移动文件，文件夹</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mv 【源文件名】【移动目标路径】# 移动目录不用-r 例：mv 1.txt ./a 将1文件移动到当前目录的a目录下</span><br><span class="line">mv 【源文件名】【移动后文件名】# 重命名，不能重名 例： mv a.py b.py</span><br></pre></td></tr></table></figure>



<h4 id="11-树状显示目录"><a href="#11-树状显示目录" class="headerlink" title="11. 树状显示目录"></a>11. 树状显示目录</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">tree</span><br></pre></td></tr></table></figure>

<h4 id="12-查看历史命令"><a href="#12-查看历史命令" class="headerlink" title="12. 查看历史命令"></a>12. 查看历史命令</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">history # 显示历史命令</span><br><span class="line">！数字 # 引用某一行命令 例：！20，引用20行命令</span><br></pre></td></tr></table></figure>

<h4 id="13-查看，写入文件内容"><a href="#13-查看，写入文件内容" class="headerlink" title="13. 查看，写入文件内容"></a>13. 查看，写入文件内容</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">cat 【文件名】 # 查看 例：cat 1.txt</span><br><span class="line">gedit 【文件名】# 写入 例 ： gedit 1.txt</span><br></pre></td></tr></table></figure>

<h4 id="14-重定向（将命令执行结果保存到另一个文件中）"><a href="#14-重定向（将命令执行结果保存到另一个文件中）" class="headerlink" title="14. 重定向（将命令执行结果保存到另一个文件中）"></a>14. 重定向（将命令执行结果保存到另一个文件中）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; # 覆盖</span><br><span class="line">&gt;&gt; # 追加 </span><br><span class="line">例： cat <span class="number">1.</span>txt <span class="number">2.</span>txt &gt; <span class="number">3</span>,txt 将<span class="number">1</span>,<span class="number">2</span>两个文件的内容重定向到<span class="number">3</span>里，<span class="number">3.</span>txt不存在则创建</span><br></pre></td></tr></table></figure>

<h4 id="15-分屏显示内容"><a href="#15-分屏显示内容" class="headerlink" title="15. 分屏显示内容"></a>15. 分屏显示内容</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">more # 分屏显示文件内容，一般接到其他命令后，空格切换屏幕</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>环境运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Linux的常用基本命令（二）</title>
    <url>/2018/01/24/%E5%85%B3%E4%BA%8ELinux%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<div>接上面《关于Linux的常用基本命令（一）》</div>[点这里](https://zypuu.github.io/2018/08/15/%E5%85%B3%E4%BA%8ELinux%E7%9A%84%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/)

<h4 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">【命令1】 | 【命令2】 # 命令1的输出结果作为命令2的输入</span><br></pre></td></tr></table></figure>

<h4 id="查找某个文件的文本"><a href="#查找某个文件的文本" class="headerlink" title="查找某个文件的文本"></a>查找某个文件的文本</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">grep 【选项】 “字符串”  【文件】</span><br><span class="line">选项：-i 忽略大小写</span><br><span class="line">		  -n 显示匹配行及行号</span><br><span class="line">		  -v 取反（显示余下的信息）</span><br></pre></td></tr></table></figure>
<div>例： ps -aux | grep ’mysql‘ 查看运行中的进程，带有mysql的进程</div>

<h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">find 【路径】 【选项】</span><br><span class="line">选项：-name ’字符串‘ # 查找该文件名的文件</span><br><span class="line">           -size +（-）’大小‘ # 查找文件大于（小于）多少的文件</span><br><span class="line">		   -permission 权限 # 查找拥有该权限的文件</span><br></pre></td></tr></table></figure>

<h4 id="tar打包压缩文件与解压缩"><a href="#tar打包压缩文件与解压缩" class="headerlink" title="tar打包压缩文件与解压缩"></a>tar打包压缩文件与解压缩</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">tar 【选项】【打包后的文件名】【 要打包的文件名】</span><br><span class="line">选项： -c 生成打包文件</span><br><span class="line">			-v 显示进度</span><br><span class="line">			-f 指定打包文件名称，所以f选项要放最后</span><br><span class="line">			-x 拆包解包</span><br><span class="line">			-z gzip格式压缩解压</span><br><span class="line">			-j bzip2格式压缩解压</span><br><span class="line">			c 指定目录</span><br></pre></td></tr></table></figure>

<h4 id="gzip格式压缩解压"><a href="#gzip格式压缩解压" class="headerlink" title="gzip格式压缩解压"></a>gzip格式压缩解压</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">gizp 【文件名】 # 压缩文件</span><br><span class="line">gzip -d 【文件名】 # 解压缩文件</span><br></pre></td></tr></table></figure>

<h4 id="查看命令位置"><a href="#查看命令位置" class="headerlink" title="查看命令位置"></a>查看命令位置</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">which</span><br></pre></td></tr></table></figure>

<h4 id="查看当前用户登录"><a href="#查看当前用户登录" class="headerlink" title="查看当前用户登录"></a>查看当前用户登录</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">who # tty 本地登录 pts 远程登录</span><br></pre></td></tr></table></figure>

<h4 id="授权当前用户执行命令"><a href="#授权当前用户执行命令" class="headerlink" title="授权当前用户执行命令"></a>授权当前用户执行命令</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">sudo # 管理员权限</span><br></pre></td></tr></table></figure>

<h4 id="退出终端，回到上一用户，退出远程"><a href="#退出终端，回到上一用户，退出远程" class="headerlink" title="退出终端，回到上一用户，退出远程"></a>退出终端，回到上一用户，退出远程</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<h4 id="软件卸载与安装"><a href="#软件卸载与安装" class="headerlink" title="软件卸载与安装"></a>软件卸载与安装</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">sudo apt-get install “安装包” # 安装</span><br><span class="line">sudo apt-get remove “安装包” # 删除</span><br><span class="line">sudo apt-get update “安装包” # 更新</span><br></pre></td></tr></table></figure>

<h4 id="关机重启"><a href="#关机重启" class="headerlink" title="关机重启"></a>关机重启</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">shutdown -h now （或加时间） # 立即关机，或者多少时间后关机</span><br><span class="line">				-r # 重启</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>环境运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Mysql的sql注入问题</title>
    <url>/2018/06/15/%E5%85%B3%E4%BA%8EMysql%E7%9A%84sql%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="什么是sql注入"><a href="#什么是sql注入" class="headerlink" title="什么是sql注入"></a>什么是sql注入</h2><p>所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将(恶意的)SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入(恶意)SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。</p>
<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>SQL注入产生的原因：程序开发过程中不注意规范书写 sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST 和GET 提交一些 sql语句正常执行。<br>比如：拼接字符串的方法</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">    sql = <span class="string">&#x27;select * from goods where name=&quot;%s&quot;&#x27;</span> % find_name</span><br><span class="line">   # 执行select语句，并返回受影响的行数：查询所有数据</span><br><span class="line"># findname为要输入的查询对象</span><br></pre></td></tr></table></figure>
<p>输入 “ or 1=1 or “ (双引号也要输入)就会产生sql注入</p>
<h2 id="后果"><a href="#后果" class="headerlink" title="后果"></a>后果</h2><p>如果是让别人发现了你的这个注入的漏洞的话，你的整个数据库有可能直接获得管理员的权限，也就是说这个数据库又可以能掌握在别人的手里，里面的数据想查询就查询，想删除就删除，想对你数据库怎样就怎样，后果很严重。</p>
<h2 id="预防sql注入"><a href="#预防sql注入" class="headerlink" title="预防sql注入"></a>预防sql注入</h2><h3 id="解决办法一：查询参数预防sql注入，预编译"><a href="#解决办法一：查询参数预防sql注入，预编译" class="headerlink" title="解决办法一：查询参数预防sql注入，预编译"></a>解决办法一：查询参数预防sql注入，预编译</h3><p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> args = (id, type)</span><br><span class="line"><span class="number">2</span> cur.execute(<span class="string">&#x27;select id, type ,name from xl_bugs where id = %s and type = %s&#x27;</span>, args )</span><br></pre></td></tr></table></figure>
<p>使用如此参数带入方式，python会自动过滤args中的特殊字符，制止SQL注入的产生。</p>
<h3 id="解决办法二：正则表达式过滤传入参数"><a href="#解决办法二：正则表达式过滤传入参数" class="headerlink" title="解决办法二：正则表达式过滤传入参数"></a>解决办法二：正则表达式过滤传入参数</h3><p>检测SQL meta-characters的正则表达式 ：/(%27)|(\’)|(--)|(%23)|(#)/ix</p>
<p>修正检测SQL meta-characters的正则表达式 ：/((%3D)|(=))[^\n]*((%27)|(\’)|(--)|(%3B)|(:))/i</p>
<p>典型的SQL 注入攻击的正则表达式 ：/\w*((%27)|(\’))((%6F)|o|(%4F))((%72)|r|(%52))/ix</p>
<p>检测SQL注入，UNION查询关键字的正则表达式 ：/((%27)|(\’))union/ix(%27)|(\’)</p>
<p>检测MS SQL Server SQL注入攻击的正则表达式：/exec(\s|+)+(s|x)p\w+/ix</p>
<h3 id="解决办法三：前端js防sql注入"><a href="#解决办法三：前端js防sql注入" class="headerlink" title="解决办法三：前端js防sql注入"></a>解决办法三：前端js防sql注入</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = location.search;</span><br><span class="line"><span class="keyword">var</span> re=<span class="regexp">/^\?(.*)(select%20|insert%20|delete%20from%20|count\(|drop%20table|update%20truncate%20|asc\(|mid\(|char\(|xp_cmdshell|exec%20master|net%20localgroup%20administrators|\&quot;|:|net%20user|\|%20or%20)(.*)$/gi</span>;</span><br><span class="line"><span class="keyword">var</span> e = re.test(url);</span><br><span class="line"><span class="keyword">if</span>(e) &#123;</span><br><span class="line">    alert(<span class="string">&quot;地址中含有非法字符～&quot;</span>);</span><br><span class="line">    location.href=<span class="string">&quot;error.asp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前端验证只能起到一定作用，还需要后台参数化阻止SQL注入。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Mysql的视图与事务</title>
    <url>/2018/04/30/%E5%85%B3%E4%BA%8EMysql%E7%9A%84%E8%A7%86%E5%9B%BE%E3%80%81%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。<br>对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。<br>视图是存储在数据库中的查询的SQL 语句，它主要出于两种原因：安全原因， 视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。这个视图就像一个“窗口”，从中只能看到你想看的数据列。这意味着你可以在这个视图上使用SELECT 语句，而你看到的将是你在视图定义里给出的那些数据列。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1.视图能简化用户操作<br>视图机制使用户可以将注意力集中在所关心地数据上。如果这些数据不是直接来自基本表，则可以通过定义视图，使数据库看起来结构简单、清晰，并且可以简化用户的的数据查询操作。<br>2.使用户能以多种角度看待同一数据<br>视图机制能使不同的用户以不同的方式看待同一数据，当许多不同种类的用户共享同一个数据库时，这种灵活性是非常必要的。<br>3.视图对重构数据库提供了一定程度的逻辑独立性<br>数据的物理独立性是指用户的应用程序不依赖于数据库的物理结构。数据的逻辑独立性是指当数据库重构造时，如增加新的关系或对原有的关系增加新的字段，用户的应用程序不会受影响。层次数据库和网状数据库一般能较好地支持数据的物理独立性，而对于逻辑独立性则不能完全的支持。<br>在关许数据库中，数据库的重构造往往是不可避免的。重构数据库最常见的是将一个基本表“垂直”地分成多个基本表。如果使用视图，应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。<br>当然，视图只能在一定程度上提供数据的逻辑独立，比如由于视图的更新是有条件的，因此应用程序中修改数据的语句可能仍会因为基本表构造的改变而改变。<br>4.视图能够对机密数据提供安全保护<br>有了视图机制，就可以在设计数据库应用系统时，对不同的用户定义不同的视图，使机密数据不出现在不应该看到这些数据的用户视图上。这样视图机制就自动提供了对机密数据的安全保护功能。</p>
<h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">create view v-表名 <span class="keyword">as</span> 查询语句</span><br></pre></td></tr></table></figure>

<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">drop view v-表名；</span><br></pre></td></tr></table></figure>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>所谓事务,它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。</p>
<h3 id="四大特性（ACID）"><a href="#四大特性（ACID）" class="headerlink" title="四大特性（ACID）"></a>四大特性（ACID）</h3><h4 id="原子性（A）"><a href="#原子性（A）" class="headerlink" title="原子性（A）"></a>原子性（A）</h4><p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性</p>
<h4 id="一致性（C）"><a href="#一致性（C）" class="headerlink" title="一致性（C）"></a>一致性（C）</h4><p>数据库总是从一个一致性的状态转换到另一个一致性的状态。事务不提交是不会修改数据的。</p>
<h4 id="隔离性（I）"><a href="#隔离性（I）" class="headerlink" title="隔离性（I）"></a>隔离性（I）</h4><p>通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p>
<h4 id="持久性（D）"><a href="#持久性（D）" class="headerlink" title="持久性（D）"></a>持久性（D）</h4><p>一旦事务提交，则其所做的修改会永久保存到数据库。</p>
<h3 id="事务命令"><a href="#事务命令" class="headerlink" title="事务命令"></a>事务命令</h3><p>表的引擎类型必须是innodb类型才可以使用事务，这是mysql表的默认引擎。</p>
<h4 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">或者</span><br><span class="line">start transaction;</span><br></pre></td></tr></table></figure>

<h4 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure>

<h4 id="回滚事务"><a href="#回滚事务" class="headerlink" title="回滚事务"></a>回滚事务</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rollback;</span><br></pre></td></tr></table></figure>
<p>注意：<br>修改数据的命令会自动的触发事务，包括insert、update、delete<br>而在SQL语句中有手动开启事务的原因是：可以进行多次数据的修改，如果成功一起成功，否则一起会滚到之前的数据。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Python的冒泡排序</title>
    <url>/2018/06/26/%E5%85%B3%E4%BA%8EPython%E7%9A%84%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>冒泡排序的思想: 每次比较两个相邻的元素, 如果他们的顺序错误就把他们交换位置。<br>比如有五个数: 12, 35, 99, 18, 76, 从大到小排序, 对相邻的两位进行比较</p>
<p>第一趟:<br>第一次比较: 35, 12, 99, 18, 76<br>第二次比较: 35, 99, 12, 18, 76<br>第三次比较: 35, 99, 18, 12, 76<br>第四次比较: 35, 99, 18, 76, 12<br>经过第一趟比较后, 五个数中最小的数已经在最后面了, 接下来只比较前四个数, 依次类推</p>
<p>第二趟<br>99, 35, 76, 18, 12<br>第三趟<br>99, 76, 35, 18, 12<br>第四趟<br>99, 76, 35, 18, 12<br>比较完成<br>冒泡排序原理: 每一趟只能将一个数归位, 如果有n个数进行排序,只需将n-1个数归位, 也就是说要进行n-1趟操作(已经归位的数不用再比较)</p>
<h2 id="代码实现一"><a href="#代码实现一" class="headerlink" title="代码实现一"></a>代码实现一</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">8</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">l2=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(l1)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> l1[j]&lt;l1[j-<span class="number">1</span>]:</span><br><span class="line">            l1[j],l1[j-<span class="number">1</span>]=l1[j-<span class="number">1</span>],l1[j]</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,len(l1)):</span><br><span class="line">    l2.append(l1[k])</span><br><span class="line">print(l2)</span><br></pre></td></tr></table></figure>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol>
<li>第一层循环可不用循环所有元素。</li>
</ol>
<p>2.两层循环变量与第一层的循环变量相关联。</p>
<p>3.第二层循环，最终必须循环集合内所有元素。</p>
<h2 id="代码实现二"><a href="#代码实现二" class="headerlink" title="代码实现二"></a>代码实现二</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">8</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">l2=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(l1)-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> l1[j]&lt;l1[j-<span class="number">1</span>]:</span><br><span class="line">            l1[j],l1[j-<span class="number">1</span>]=l1[j-<span class="number">1</span>],l1[j]</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,len(l1)):</span><br><span class="line">    l2.append(l1[k])</span><br><span class="line">print(l2)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Python的快速排序</title>
    <url>/2018/06/26/%E5%85%B3%E4%BA%8EPython%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>快速排序基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>比如有一个数组：</p>
<p>6 2 4 5 3</p>
<p>第一步：选取一个基准数，不要被这个名词吓到了，你可以把它看作是一个比较大小的数，因为排序就是比较大小，</p>
<p>比如我选取最后一个数3为基准数，依次把数组的数和3比较，比3小的放左边，比3大的放右边，这样有如下结果：</p>
<p>2 3 6 4 5</p>
<p>第二步：判断区间个数，经过第一步后左边区间只有一个数了，没有数字再和它比较了，因此不需要重复操作，右边区间还有：</p>
<p>6 4 5</p>
<p>重复第一步，选取5作为基准数，得到比较结果：</p>
<p>4 5 6</p>
<p>这样左右两边区间都只有一个数了，这就标志着排序完成，最后把所有区间合并就得到排序结果：</p>
<p>2 3 4 5 6</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def quick_sort(array):</span><br><span class="line">  less = []; greater = []</span><br><span class="line">  <span class="keyword">if</span> len(array) &lt;= <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">  pivot = array.pop()</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> array:</span><br><span class="line">    <span class="keyword">if</span> x &lt;= pivot: less.append(x)</span><br><span class="line">    <span class="keyword">else</span>: greater.append(x)</span><br><span class="line">  <span class="keyword">return</span> quick_sort(less) + [pivot] + quick_sort(greater)</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>关于docker的个人理解</title>
    <url>/2018/08/01/%E5%85%B3%E4%BA%8Edocker%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="Docker通俗理解"><a href="#Docker通俗理解" class="headerlink" title="Docker通俗理解"></a>Docker通俗理解</h3><p>什么是docker，docker翻译过来的名称就是容器，而容器是干什么用的，容器用来装东西的，就像一个集装箱，一个密闭的容器，不受外部的干扰，也无法干扰外部。<br>docker就是这么一个密闭的容器，将那些程序服务就放在docker里来运行。</p>
<h3 id="为什么使用Docker"><a href="#为什么使用Docker" class="headerlink" title="为什么使用Docker"></a>为什么使用Docker</h3><p>将程序软件安装在docker容器里去运行，本质上讲是一种虚拟技术，提到虚拟技术，就会想到虚拟机，那为什么要将程序安装到docker里运行，不直接在本机安装，使用虚拟技术，它又与虚拟机有和区别呢？</p>
<p>将程序直接安装在本机上，对于服务或者运行效率当然是最佳的体验，所以为什么使用容器，最主要原因就是成本原因，每一台主机都是有成本的，如果为了保证效率，每一台主机只跑部分服务，而需要多台主机的话，那成本就高了，当然有钱的另说，比如银行，追求省心稳定，一个服务器挂一台主机，性能用不完。但是一般的商业公司追求一定的经济性，一个主机只跑一些服务太浪费了，所以就出现把主机分开独立运行的手段—docker，降低服务器成本，还要保证一定的使用效率。</p>
<p>还有VM虚拟机，同样是虚拟技术，docker相对于虚拟机有何优点？<br>docker是直接调用原生系统资源，不像虚拟机是安装在操作系统上层层吃配置的软件服务。它比虚拟机更加强大，体积小，运行速度快，启动和关闭只需要几秒。相对于普通虚拟机来说，启动时间在分钟级别，占用内存大。所以这就是docker出现之后的优势。</p>
<h3 id="docker的应用场景"><a href="#docker的应用场景" class="headerlink" title="docker的应用场景"></a>docker的应用场景</h3><p>容器提供了隔离性，结论是，容器可以为各种测试提供很好的沙盒环境。并且，容器本 身就具有“标准性”的特征，非常适合为服务创建构建块。<br>Docker 的一些应用场景如下:<br>1.加速本地开发和构建流程，使其更加高效、更加轻量化。本地开发人员可以构建、 运行并分享 Docker 容器。容器可以在开发环境中构建，然后轻松的提交到测试环境中，并 最终进入生产环境。<br>2.能够让独立的服务或应用程序在不同的环境中，得到相同的运行结果。这一点在 面向服务的架构和重度依赖微型服务的部署由其实用。<br>3.用 Docker 创建隔离的环境来进行测试。例如，用 Jenkins CI 这样的持续集成工具 启动一个用于测试的容器。<br>4.Docker 可以让开发者先在本机上构建一个复杂的程序或架构来进行测试，而不是 一开始就在生产环境部署、测试。</p>
<h3 id="镜像、容器与仓库"><a href="#镜像、容器与仓库" class="headerlink" title="镜像、容器与仓库"></a>镜像、容器与仓库</h3><h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><p>创建虚拟机和docker 都必不可少的东西。  用过虚拟机的朋友都知道，创建一个虚拟机就先得下载操作系统的ISO镜像文件，然后通过镜像文件安装操作系统，和实体机类似，然后能在虚拟机中去安装各种软件。也可以将镜像当作容器的“源代码”。镜像体积很小，非常便携，易于分享、存储和更新。<br>Docker 容器启动是需要一些文件的， 而这些文件就可以称为 Docker 镜像。</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>通俗拿VM虚拟机和docker来举例，一个容器就类似于一个虚拟机，只不过在docker技术的术语上称为容器。这个容器装的就是我们部署的应用在运行，和虚拟机一样可以开机，关机，重启。docker称为容器的运行，关闭，重启。而且这个容器可以打包为镜像文件，类似虚拟机快照的文件，放在其它虚拟机上又可以保持原样能运行，docker也是如此，把容器打包为镜像文件，然后在新的服务器安装好的docker环境下导入进去，保持原来的状态能够运行。<br>容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。</p>
<h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><p>如果你使用过git和github就很容易理解Docker的仓库概念。Docker 仓库的概念跟Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</p>
<p>Docker 仓库是用来包含镜像的位置，Docker提供一个注册服务器（Register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像。Docker运行中使用的默认仓库是 Docker Hub 公共仓库。</p>
<p>仓库支持的操作类似git，当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。.</p>
<h3 id="docker、容器、镜像的安装与操作"><a href="#docker、容器、镜像的安装与操作" class="headerlink" title="docker、容器、镜像的安装与操作"></a>docker、容器、镜像的安装与操作</h3><h4 id="docker的安装与操作"><a href="#docker的安装与操作" class="headerlink" title="docker的安装与操作"></a>docker的安装与操作</h4><p>添加Docker官方GPG key</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo apt-key add gpg</span><br></pre></td></tr></table></figure>
<p>安装Docker稳定版</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i docker-ce_17<span class="number">.03</span><span class="number">.2</span>~ce-<span class="number">0</span>~ubuntu-xenial_amd64.deb</span><br></pre></td></tr></table></figure>
<p>检查Docker是否安装正确</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<p>为了避免每次命令都输入sudo，可以设置用户权限，注意执行后须注销重新登录</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo usermod -a -G docker $USER</span><br></pre></td></tr></table></figure>
<p>安装完成Docker后，默认已经启动了docker服务，如需手动控制docker服务的启停，可执行如下命令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 启动docker</span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line"># 停止docker</span><br><span class="line">sudo service docker stop</span><br><span class="line"></span><br><span class="line"># 重启docker</span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure>

<h4 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h4><p>列出镜像</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>
<p>拉取镜像。即从官方仓库docker hub上拉取。<a href="https://hub.docker.com/">docker hub</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker image pull library/hello-world</span><br></pre></td></tr></table></figure>
<p>由于 Docker 官方提供的 image 文件，都放在library组里面，所以它的是默认组，可以省略，hello world 是镜像文件名字。</p>
<p>删除镜像</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker image rm 镜像名或镜像id</span><br></pre></td></tr></table></figure>

<h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4><p>创建容器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker run [option] 镜像名 [向启动容器中传入的命令]</span><br></pre></td></tr></table></figure>
<p>-i 表示以“交互模式”运行容器<br>-t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即 分配一个伪终端。<br>–name 为创建的容器命名<br>-v 表示目录映射关系(前者是宿主机目录，后者是映射到宿主机上的目录，即 宿主机目录:容器中目录)，可以使 用多个-v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后 共享到容器上。<br>-d 在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不 会自动登录容器，如果只加-i -t 两个参数，创建后就会自动进去容器)。<br>-p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p 做多个端口映射<br>-e 为容器设置环境变量<br>–network=host 表示将主机的网络环境映射到容器中，容器的网络与主机相同<br>例：<br>交互式容器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker run -it --name=myubuntu ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>可以执行linux命令。<br>守护式容器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker run -dit --name=myubuntu2 ubuntu</span><br></pre></td></tr></table></figure>
<p>如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器。在容器内部exit退出时，容器也不会停止。</p>
<p>查看容器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 列出本机正在运行的容器</span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line"># 列出本机所有容器，包括已经终止运行的</span><br><span class="line">docker container ls --all</span><br></pre></td></tr></table></figure>
<p>停止与启动容器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 停止一个已经在运行的容器</span><br><span class="line">docker container stop 容器名或容器id</span><br><span class="line"></span><br><span class="line"># 启动一个已经停止的容器</span><br><span class="line">docker container start 容器名或容器id</span><br><span class="line"></span><br><span class="line"># kill掉一个已经在运行的容器</span><br><span class="line">docker container kill 容器名或容器id</span><br></pre></td></tr></table></figure>
<p>删除容器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker container rm 容器名或容器id</span><br></pre></td></tr></table></figure>

<h4 id="将容器保存为镜像，备份迁移"><a href="#将容器保存为镜像，备份迁移" class="headerlink" title="将容器保存为镜像，备份迁移"></a>将容器保存为镜像，备份迁移</h4><p>将容器保存为镜像</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker commit 容器名 镜像名</span><br></pre></td></tr></table></figure>
<p>将镜像打包成文件，拷贝给别人使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker save -o 保存的文件名 镜像名</span><br></pre></td></tr></table></figure>
<p>拿到镜像文件加载到本地</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker load -i ./ubuntu.tar</span><br></pre></td></tr></table></figure>
<p>当前目录下的ubantu为例</p>
]]></content>
      <categories>
        <category>环境运维</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>关于session与JWT的认证机制</title>
    <url>/2018/03/21/%E5%85%B3%E4%BA%8Esession%E4%B8%8EJWT%E7%9A%84%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="什么是状态保持"><a href="#什么是状态保持" class="headerlink" title="什么是状态保持"></a>什么是状态保持</h2><p>说到状态保持，首先要讲一下什么是无状态，http 就是一种无状态协议，浏览器请求服务器是无状态的。</p>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>指用户请求过一次后，浏览器与服务器无法知道这个用户做过什么，下一次请求还是新的请求。<br><br><br>发生无状态的原因：浏览器与服务器之间是使用socket套接字通讯的，在一次访问结束后，服务器将访问结果返回给浏览器之后，会关闭当前的socket连接，浏览器在关闭后，服务器也会销毁当前的页面对象。</p>
<h3 id="无状态协议"><a href="#无状态协议" class="headerlink" title="无状态协议"></a>无状态协议</h3><p>1.协议对于事务处理没有记忆能力。<br>2.对同一个 url 请求没有上下文关系。<br>3.每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的4请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况。<br>4.服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器。</p>
<h3 id="有状态"><a href="#有状态" class="headerlink" title="有状态"></a>有状态</h3><p>与无状态相反，相当于有记忆能力，可以记录之前用户的操作，即状态保持，那怎么实现状态保持呢？</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="Cookie的定义"><a href="#Cookie的定义" class="headerlink" title="Cookie的定义"></a>Cookie的定义</h3><p>指某些网站为了辨别用户身份、进行会话跟踪而储存在用户本地的数据。（通常经过加密）<br><br><br>cookie由服务器端生成，发送给客户端浏览器，浏览器可以将cookie的key/value进行保存，下次请求同一网站时就会将cookie同请求信息发送给服务器。<br><br><br>通过cookie就实现了状态保持，即用户登陆过的信息，访问过的页面数据，都会被放在cookie里进行记录，保存在浏览器，下次请求这个网站时会发送给服务器，服务器就能从cookie中快速获取信息，即知道了用户已经登陆过，访问了哪些数据，保持了用户的登录状态，将相关数据快速呈现。</p>
<h3 id="使用cookie的注意事项"><a href="#使用cookie的注意事项" class="headerlink" title="使用cookie的注意事项"></a>使用cookie的注意事项</h3><ol>
<li>cookie是基于域名安全的，不同域名的cookie是不能互相访问的，即同源策略。（在这个页面里可以嵌入窗口iframe，来访问其他域名的cookie）</li>
<li>Cookie是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用。</li>
<li>因为cookie被放在请求报文里发送给服务器，所以服务器端可以通过request对象来获取cookie信息，进行操作。</li>
</ol>
<h3 id="设置cookie与获取cookie"><a href="#设置cookie与获取cookie" class="headerlink" title="设置cookie与获取cookie"></a>设置cookie与获取cookie</h3><h4 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h4><p>获取response对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">response.set_cookie(‘键’，‘值’，max_age=<span class="number">3600</span>）</span><br></pre></td></tr></table></figure>
<p>max_age为过期时间，即第一次访问产生cookie之后，3600秒会自动删除。</p>
<h4 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h4><p>请求对象request</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.cookies.get(<span class="string">&#x27;键&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>根据之前设置的键就能获取到cookie的值。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>cookie说到建议不要保存用户的敏感信息，很容易会被破解，那么这些敏感信息怎么解决，比如用户登录的用户名，密码，这就要用到session来认证用户。</p>
<h3 id="理解session的机制"><a href="#理解session的机制" class="headerlink" title="理解session的机制"></a>理解session的机制</h3><p>对于敏感的信息，要保存在服务器中，不能存储在浏览器中，而服务器采用的状态保持的方案就是session认证。<br><br>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。</p>
<h3 id="session依赖于cookie"><a href="#session依赖于cookie" class="headerlink" title="session依赖于cookie"></a>session依赖于cookie</h3><p>客户端在访问后，由服务端生成session，根据每一个session都会生成它的唯一标识（uuid），然后以session为键，这个唯一标识为值，存放在cookie里。同时服务端本地也会存session（非关系型数据库存储，如redis），以uuid为键，session的键值对为值，存进服务端本地，访问时，根据这个唯一标识在本地进行读取操作。</p>
<h4 id="url重写技术"><a href="#url重写技术" class="headerlink" title="url重写技术"></a>url重写技术</h4><p>由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面，附加方式也有两种，一种是作为URL路径的附加信息，表现形式为<code>http://...../xxx;jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764 </code><br>另一种是作为查询字符串附加在URL后面，表现形式为<code>http://...../xxx?jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764 </code><br>这两种方式对于用户来说是没有区别的，只是服务器在解析的时候处理的方式不同，采用第一种方式也有利于把session id的信息和正常程序参数区分开来。<br>为了在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个session id。</p>
<h4 id="表单隐藏字段技术"><a href="#表单隐藏字段技术" class="headerlink" title="表单隐藏字段技术"></a>表单隐藏字段技术</h4><p>另一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如下面的表单： </p>
<pre><code>&lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt; 
&lt;input type=&quot;text&quot;&gt; 
&lt;/form&gt; 

在被传递给客户端之前将被改写成： 

&lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt; 
&lt;input type=&quot;hidden&quot; name=&quot;jsessionid&quot; value=&quot;ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764&quot;&gt; 
&lt;input type=&quot;text&quot;&gt; 
&lt;/form&gt; </code></pre>
<p>这种技术使用相对较少了。</p>
<h3 id="session数据的读写"><a href="#session数据的读写" class="headerlink" title="session数据的读写"></a>session数据的读写</h3><h4 id="读取session数据"><a href="#读取session数据" class="headerlink" title="读取session数据"></a>读取session数据</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">session.get(<span class="string">&#x27;键&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="写入session数据"><a href="#写入session数据" class="headerlink" title="写入session数据"></a>写入session数据</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">session[<span class="string">&#x27;键&#x27;</span>] = <span class="string">&#x27;值&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="session认证所显露的问题"><a href="#session认证所显露的问题" class="headerlink" title="session认证所显露的问题"></a>session认证所显露的问题</h3><p>1.用户通过session认证，都要在服务器端做一次记录，而session是保存在服务器端的内存中，随着用户的增多，服务器端的开销会明显增大。<br>2.而且用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。<br>3.session是依赖于cookie，如果cookie被截获，很容易受到跨站请求伪造的攻击（csrf），安全性不足。<br><br><br>这就引入了jwt认证机制</p>
<h3 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h3><p>JWT，全名Json Web Token，是一种基于token的认证机制，类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。<br><br>流程上是这样的：</p>
<ul>
<li>用户使用用户名密码来请求服务器 </li>
<li>服务器进行验证用户的信息 </li>
<li>服务器通过验证发送给用户一个token</li>
<li>客户端存储token，并在每次请求时附送上这个token值 </li>
<li>服务端验证token值，并返回数据</li>
</ul>
<h3 id="JWT的构成"><a href="#JWT的构成" class="headerlink" title="JWT的构成"></a>JWT的构成</h3><p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure>
<p>如上所示，是一个JWT的token，分为三个部分</p>
<h4 id="header头部"><a href="#header头部" class="headerlink" title="header头部"></a>header头部</h4><p>第一部分header存两部分信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x27;typ&#x27;: &#x27;JWT&#x27;,  # 声明类型为jwt</span><br><span class="line">  &#x27;alg&#x27;: &#x27;HS256&#x27; # 加密算法 HMAC SHA256</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过base64算法加密构成第一部分，<code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code></p>
<h4 id="payload载荷"><a href="#payload载荷" class="headerlink" title="payload载荷"></a>payload载荷</h4><p>载荷是存放有效信息的地方，有效信息分为三部分：</p>
<ol>
<li>标准中注册的声明：<br>iss: jwt签发者<br>sub: jwt所面向的用户<br>aud: 接收jwt的一方<br>exp: jwt的过期时间，这个过期时间必须要大于签发时间<br>nbf: 定义在什么时间之前，该jwt都是不可用的.<br>iat: jwt的签发时间<br>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li>
<li>公共的声明：<br>添加用户信息，不建议添加敏感信息，因为base64算法是对称算法，可解密</li>
<li>私有的声明：<br>私有声明是提供者和消费者所共同定义的声明。<br>定义一个payload</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line"> 	 <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line"> 	 <span class="string">&quot;admin&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>base64算法加密后就是第二段<code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</code></p>
<h4 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h4><p>jwt的第三部分是一个签证信息，签证信息由三部分组成：<br>header<br>payload<br>secret<br>这部分信息将header、payload中的base64加密后的信息连接成字符串，然后通过header里声明的HS256算法加上secret进行加密，就构成了jwt的第三部分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> encodedString = base64UrlEncode(header) + <span class="string">&#x27;.&#x27;</span> + base64UrlEncode(payload);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> signature = HMACSHA256(encodedString, <span class="string">&#x27;secret&#x27;</span>); </span><br></pre></td></tr></table></figure>
<p>构成第三部分<code>TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</code><br>三部分构成完整的JWT的token</p>
<p>PS：secret是保存在服务端的，jwt签发也是在服务端，所以secret是服务端的私钥，不能泄露出去。虽然header和payload可以通过base64解密，但是没有secret是无法进行认证的，这就保证了安全性。</p>
<h3 id="JWT的应用"><a href="#JWT的应用" class="headerlink" title="JWT的应用"></a>JWT的应用</h3><p>Django rest framework中应用jwt<br>详情可参考文档网站：<a href="http://getblimp.github.io/django-rest-framework-jwt/">JWT官方文档</a></p>
<h4 id="安装jwt应用"><a href="#安装jwt应用" class="headerlink" title="安装jwt应用"></a>安装jwt应用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pip install djangorestframework-jwt</span><br></pre></td></tr></table></figure>

<h4 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h4><p>指定jwt认证</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework_jwt.authentication.JSONWebTokenAuthentication&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.SessionAuthentication&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.BasicAuthentication&#x27;</span>,</span><br><span class="line">    ),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JWT_AUTH = &#123;</span><br><span class="line">    <span class="string">&#x27;JWT_EXPIRATION_DELTA&#x27;</span>: datetime.timedelta(days=<span class="number">1</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JWT_EXPIRATION_DELTA指明jwt的有效期</p>
<h4 id="使用jwt返回token"><a href="#使用jwt返回token" class="headerlink" title="使用jwt返回token"></a>使用jwt返回token</h4><p>生成口令并返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework_jwt.settings <span class="keyword">import</span> api_settings</span><br><span class="line"></span><br><span class="line">jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</span><br><span class="line"></span><br><span class="line">payload = jwt_payload_handler(user)</span><br><span class="line">token = jwt_encode_handler(payload)</span><br></pre></td></tr></table></figure>
<p>比如注册中使用token，因为token要返回输出，所以在定义序列化器时要添加token字段</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">token = serializers.CharField(label=&#x27;登录状态token&#x27;, read_only=True)  # 增加token字段</span><br></pre></td></tr></table></figure>

<h4 id="登录功能中使用JWT返回指定字段"><a href="#登录功能中使用JWT返回指定字段" class="headerlink" title="登录功能中使用JWT返回指定字段"></a>登录功能中使用JWT返回指定字段</h4><p>将上面的jwt应用于登录认证时，登录成功后，发现api接口只返回了jwt的token，如图所示</p>
<p><img src="/2018/03/21/%E5%85%B3%E4%BA%8Esession%E4%B8%8EJWT%E7%9A%84%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/1.jpg" alt="1"><br>如果想将用户的其他字段比如用户名，怎么返回呢<br>jwt配合django的内部框架提供了登录验证功能，在Django框架中直接使用jwt的登录验证视图函数obtain_jwt_token</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">from rest_framework_jwt.views import obtain_jwt_token # 导入包</span><br><span class="line">url(r&#x27;^路由规则$&#x27;, obtain_jwt_token), # url中配置地址</span><br></pre></td></tr></table></figure>
<p>定义以上路由地址即可，jwt自带的登录验证便可应用<br>jwt提供的视图obtain_jwt_token内部逻辑：<br>    1.定义视图类，继承自APIView<br>    2.定义序列化器，继承自Serializer，然后调用django内部贡献的authenticate()方法<br>    3.接收用户名、密码<br>    4.查询数据库，进行密码对比<br>    5.如果成功，则生成口令并返回<br>这是查看obtain_jwt_token的源码，和jwt的官方文档，就可以理解这个视图的工作原理。</p>
<p>然后自定义接口响应值：<br>1.在users应用下新建utils.py。<br>2.创建函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def jwt_response_payload_handler(token, user=None, request=None):</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="string">&#x27;token&#x27;</span>: token,</span><br><span class="line">			<span class="string">&#x27;username&#x27;</span>:user.username</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>3.在settings.py中配置添加<br>    ‘JWT_RESPONSE_PAYLOAD_HANDLER’:’users.utils.jwt_response_payload_handler’,</p>
<p>然后重新运行即可，效果如下</p>
<p><img src="/2018/03/21/%E5%85%B3%E4%BA%8Esession%E4%B8%8EJWT%E7%9A%84%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/2.jpg" alt="2"></p>
<h3 id="jwt的优点"><a href="#jwt的优点" class="headerlink" title="jwt的优点"></a>jwt的优点</h3><p>1.因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。<br>2.因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。<br>3.便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。<br>4.它不需要在服务端保存会话信息, 所以它易于应用的扩展</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title>关于ubuntu18下docker无法启动服务的问题解决</title>
    <url>/2018/10/14/%E5%85%B3%E4%BA%8Eubuntu18%E4%B8%8Bdocker%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>近日在最新版本的Ubuntu下安装docker，配置指定安全参数ip（<code>--insecure -registry</code>），并启动docker服务的时候，遇到无法启动的问题，通过查看启动日志<br>查看启动日志</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>
<p>查看docker.service的启动日志，发现如下错误</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Failed to start Docker Application Container Engine</span><br></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="修改docker启动默认配置文件"><a href="#修改docker启动默认配置文件" class="headerlink" title="修改docker启动默认配置文件"></a>修改docker启动默认配置文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vim etc/<span class="keyword">default</span>/docker</span><br></pre></td></tr></table></figure>
<p>vim打开这个文件，找到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">DOCKER_OPTS = ......</span><br></pre></td></tr></table></figure>
<p>在这一行打开注释，添加自己的安全参数，ip等信息，然后保存退出。</p>
<h4 id="修改docker启动服务文件"><a href="#修改docker启动服务文件" class="headerlink" title="修改docker启动服务文件"></a>修改docker启动服务文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vim  /lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>
<p>vim打开docker启动服务文件</p>
<p>在里面添加指定环境文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">EnvironmentFile = -/etc/default/docker # 就是第一步修改的文件</span><br></pre></td></tr></table></figure>
<p>然后下一行找到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Execstart = <span class="regexp">/usr/</span>bin dockerd -H fd:<span class="comment">// $DOCKER_OPTS </span></span><br></pre></td></tr></table></figure>
<p>即加载第一步环境文件里的DOCKER_OPTS，自己指定的insecure registry.</p>
<h4 id="删除其他默认的加载"><a href="#删除其他默认的加载" class="headerlink" title="删除其他默认的加载"></a>删除其他默认的加载</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rm /etc/systemd/system/docke.service.d</span><br><span class="line">rm /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>
<p>删除这两个文件，不删除，会加载这两个文件里的配置</p>
<h4 id="重新启动docker服务"><a href="#重新启动docker服务" class="headerlink" title="重新启动docker服务"></a>重新启动docker服务</h4><p>重新启动</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">systemctl daemon -reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>查看docker进程</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ps -ef | grep docker</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>环境运维</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>关于vue的ref与$ref的问题</title>
    <url>/2020/03/29/%E5%85%B3%E4%BA%8Evue%E7%9A%84ref%E4%B8%8E$ref%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="释义"><a href="#释义" class="headerlink" title="释义"></a>释义</h3><h4 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h4><p>vm.$refs，一个对象，object，持有已注册过ref的所有子组件。</p>
<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>ref用来给元素或子组件注册引用信息。引用信息将会注册在父组件的refs上。如果普通dom上使用，引用指向的就是dom元素，如果用在子组件上，引用就指向子组件示例。</p>
<h4 id="注意问题：ref属于非响应式"><a href="#注意问题：ref属于非响应式" class="headerlink" title="注意问题：ref属于非响应式"></a>注意问题：ref属于非响应式</h4><p>ref本身是作为渲染结果被创建的，在初始渲染的时候并不能访问他们，因为还不存在，会报错。而$refs也不是响应式的，所以同样不能访问，要注意。</p>
<h4 id="开发中的实例问题"><a href="#开发中的实例问题" class="headerlink" title="开发中的实例问题"></a>开发中的实例问题</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;el-form ref=<span class="string">&quot;booksForm&quot;</span> onsubmit=<span class="string">&quot;return false&quot;</span> :model=<span class="string">&quot;form&quot;</span> :inline=<span class="string">&quot;true&quot;</span> :rules=<span class="string">&quot;rules_search&quot;</span>&gt;</span><br><span class="line">&lt;el-form-item prop=<span class="string">&quot;books_ids&quot;</span>&gt;</span><br><span class="line">        &lt;el-input</span><br><span class="line">          style=<span class="string">&quot;width: 300px;&quot;</span></span><br><span class="line">          placeholder=<span class="string">&quot;ID搜索,逗号英文分隔&quot;</span></span><br><span class="line">          v-model=<span class="string">&quot;form.books_ids&quot;</span></span><br><span class="line">          clearable</span><br><span class="line">        &gt;&lt;/el-input&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br></pre></td></tr></table></figure>
<p>在页面表单中绑定了ref，el-input是一个搜索输入框，如果不输入值，则默认搜索全部数据。</p>
<p>但是在搜索的时候需要在前端进行验证，检验是否是数字</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="title">getBooks</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.$refs[<span class="string">&#x27;booksForm&#x27;</span>].validate(<span class="function"><span class="params">valid</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;.....&#125;</span><br><span class="line"></span><br><span class="line"># ......中为通过api，查询数据库的逻辑，然后返回数据</span><br></pre></td></tr></table></figure>
<p>看上面代码，是通过$ref绑定调用，进行的验证。</p>
<p>但是在页面刚进入，对象实例在被创建前，也就是在vue对象创建的钩子函数中，需要对页面进行初始化，查询数据显示，也就是在mounted中进行一次查询操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.getBooks()</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>然后问题就来了，因为$ref是非响应式的，所以在页面初始化的时候，并没有被创建，也就无法通过验证，会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">validate is <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>将验证方法，拆出来，也就是调用ref的地方，不要放在钩子函数中，待页面加载完在进行调用验证。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">   <span class="function"><span class="title">searchBooks</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.$refs[<span class="string">&#x27;booksForm&#x27;</span>].validate(<span class="function"><span class="params">valid</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">         <span class="built_in">this</span>.getBooks(<span class="built_in">this</span>.booksData)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>
<p>由searchBooks进行一层包装，将调用ref的验证放到外面，在mounted的钩子函数中还是调用getBooks方法。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>关于vue前端的生命周期与钩子函数</title>
    <url>/2020/05/03/%E5%85%B3%E4%BA%8Evue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h4><p>Vue对象用新方法实例化。它创建一个Vue类的对象来处理DOM元素。对象的这个生命阶段可以通过beforeCreated 挂钩来访问 。我们可以在这个钩子中插入我们的代码，在对象初始化之前执行。</p>
<h4 id="created"><a href="#created" class="headerlink" title="created"></a>created</h4><p>在这个生命阶段，对象及其事件完全初始化。 created 是访问这个阶段并编写代码的钩子。</p>
<h4 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h4><p>这个钩子被调用 beforeMounted。在这个阶段，它检查是否有任何模板可用于要在DOM中呈现的对象。如果没有找到模板，那么它将所定义元素的外部HTML视为模板。</p>
<h4 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h4><p>一旦模板准备就绪。它将数据放入模板并创建可呈现元素。用这个新的数据填充元素替换DOM元素。这一切都发生在mounted钩子上。</p>
<h4 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h4><p>在外部事件/用户输入beforeUpdate发生更改时，此钩子即 在反映原始DOM元素的更改之前被触发。</p>
<p>为了解决这个问题 beforeUpdated，我添加了下面的代码。它通过更新DOM来更改运行时中的hello_message。</p>
<h4 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h4><p>然后，通过实际更新DOM对象并触发updated，屏幕上的变化得到呈现 。</p>
<h4 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h4><h4 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h4><p>vue实例在被创建的时候会经历这些钩子函数</p>
<ol>
<li>在beforeCreate和created钩子函数之间的生命周期<br>在这个生命周期之间，进行初始化事件，进行数据的观测，可以看到在created的时候数据已经和data属性进行绑定（放在data中的属性当值发生改变的同时，视图也会改变）。created的时候，数据已经和data进行绑定了<br>注意看下：此时还是没有el选项，也就是beforecreate的时候，数据还没有和data绑定。</li>
<li>created钩子函数和beforeMount间的生命周期<br>首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>关于web开发用户注册功能的图形验证码与短信验证码</title>
    <url>/2018/06/18/%E5%85%B3%E4%BA%8Eweb%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E4%B8%8E%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="Flask框架"><a href="#Flask框架" class="headerlink" title="Flask框架"></a>Flask框架</h2><div>前后端不分离</div>

<h3 id="图片验证码"><a href="#图片验证码" class="headerlink" title="图片验证码"></a>图片验证码</h3><h4 id="Captcha"><a href="#Captcha" class="headerlink" title="Captcha"></a>Captcha</h4><div>1.基于captcha实现图片验证码，什么是captcha？<br>
Captcha是一个第三方工具，提供生成验证码图片通用解决办法，提供了非常灵活的生成验证码图片的框架，可以自由的组合生成图片过程中的各种元素，例如，字体、颜色、背景、扭曲样式等，不仅提供了丰富的变形资源，即使不能满足需求的情况下，也可以实现固有的接口，创造出自己的字体变形的方式，所以该框架应该可以满足生成验证图片的大部分需求。<br>

<h4 id="Flask框架中使用captcha完成图片验证码功能"><a href="#Flask框架中使用captcha完成图片验证码功能" class="headerlink" title="Flask框架中使用captcha完成图片验证码功能"></a>Flask框架中使用captcha完成图片验证码功能<br></h4><p>将chptcha的第三方包放在utils文件夹中，utils是基于python创建一个flask工程后一个专门存放第三方工具包的文件夹。然后在功能视图模块中</p></div><p></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.captcha.captcha <span class="keyword">import</span> captcha</span><br></pre></td></tr></table></figure>
<p>视图函数中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># @user_blueprint是flask框架中，经过创建蓝图，蓝图注册的路由，后面是路由地址</span><br><span class="line">@user_blueprint.route(<span class="string">&#x27;/image_code&#x27;</span>)</span><br><span class="line">def image_code():</span><br><span class="line">    # 调用第三方的工具，生成图形验证码数据</span><br><span class="line">    name, text, image = captcha.generate_captcha()</span><br><span class="line">    # 保存text值，存放于session中，用于后续的对比验证</span><br><span class="line">    session[<span class="string">&#x27;image_code&#x27;</span>] = text</span><br><span class="line"> </span><br><span class="line">    # 创建响应对象，响应体为图片数据</span><br><span class="line">    response = make_response(image)</span><br><span class="line">    # 注意：这里一定要设置响应数据的类型为图片，不然会在网页上无法显示，生成乱码数据</span><br><span class="line">    response.content_type = <span class="string">&#x27;image/png&#x27;</span></span><br><span class="line">    # 返回到响应体</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
<p>在首页的页面中index.html中，添加如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;/user/image_code?1&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;get_pic_code&quot;</span> onclick=<span class="string">&quot;generateImageCode()&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>显示图片，设置css样式，并绑定点击事件，生成图片验证码<br>然后在main.js（主页js里）添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateImageCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;.get_pic_code&#x27;</span>).attr(<span class="string">&#x27;src&#x27;</span>, $(<span class="string">&#x27;.get_pic_code&#x27;</span>).attr(<span class="string">&#x27;src&#x27;</span>) + <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击事件，点击即修改他的src属性，重新生成图片验证码，即可实现<br>$(‘.get_pic_code’)是类选择器，attr获取其src属性进行修改</p>
<h3 id="短信验证码"><a href="#短信验证码" class="headerlink" title="短信验证码"></a>短信验证码</h3><h4 id="容联云通讯"><a href="#容联云通讯" class="headerlink" title="容联云通讯"></a>容联云通讯</h4><p>容联云通讯为第三方服务，云通讯平台将传统电信网络通讯能力、基于IP的通讯能力，通过开放API的方式提供给开发者与合作伙伴，让开发者们在应用程序中集成网络电话和电话会议功能变得简单。<br><br>可提供语音、IVR、短信、IM、视频等web开发接口，这里使用短信功能，详情可查看官方开发文档<a href="http://doc.yuntongxun.com/space/5a5098313b8496dd00dcdd7f">点这里</a><br>查看基于python的短信发送接口。</p>
<h4 id="实现短信验证码发送功能"><a href="#实现短信验证码发送功能" class="headerlink" title="实现短信验证码发送功能"></a>实现短信验证码发送功能</h4><p>将云通讯第三方工具包放入utils文件夹中，云通讯文档使用说明：<br>1.接口声明文件：SDK \CCPRestSDK.py</p>
<p>2.接口函数定义：def sendTemplateSMS(self, to,datas,tempId) </p>
<p>3.参数说明：</p>
<p>to: 短信接收手机号码集合,用英文逗号分开,如 ‘13810001000,13810011001’,最多一次发送200个。</p>
<p>datas：内容数据，需定义成数组方式，如模板中有两个参数，定义方式为array[‘Marry’,’Alon’]。 </p>
<p>templateId: 模板Id,如使用测试模板，模板id为”1”，如使用自己创建的模板，则使用自己创建的短信模板id即可。<br>4.接口调用示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">编码说明：coding=utf-<span class="number">8</span>或gbk</span><br><span class="line"> <span class="keyword">from</span> CCPRestSDK <span class="keyword">import</span> REST</span><br><span class="line"> <span class="keyword">import</span> ConfigParser</span><br><span class="line"> </span><br><span class="line"> accountSid= <span class="string">&#x27;您的主账号&#x27;</span>; </span><br><span class="line"> #说明：主账号，登陆云通讯网站后，可在控制台首页中看到开发者主账号ACCOUNT SID。</span><br><span class="line"> </span><br><span class="line"> accountToken= <span class="string">&#x27;您的主账号Token&#x27;</span>; </span><br><span class="line"> #说明：主账号Token，登陆云通讯网站后，可在控制台首页中看到开发者主账号AUTH TOKEN。</span><br><span class="line"> </span><br><span class="line"> appId=<span class="string">&#x27;您的应用ID&#x27;</span>; </span><br><span class="line"> #请使用管理控制台中已创建应用的APPID。</span><br><span class="line"> </span><br><span class="line"> serverIP=<span class="string">&#x27;app.cloopen.com&#x27;</span>;</span><br><span class="line"> #说明：请求地址，生产环境配置成app.cloopen.com。</span><br><span class="line"> </span><br><span class="line"> serverPort=<span class="string">&#x27;8883&#x27;</span>; </span><br><span class="line"> #说明：请求端口 ，生产环境为8883.</span><br><span class="line"> </span><br><span class="line"> softVersion=&#x27;2013-12-26&#x27;; #说明：REST API版本号保持不变。 </span><br><span class="line"> </span><br><span class="line"> def sendTemplateSMS(to,datas,tempId): </span><br><span class="line">    #初始化REST SDK</span><br><span class="line">    rest = REST(serverIP,serverPort,softVersion) </span><br><span class="line">    rest.setAccount(accountSid,accountToken) </span><br><span class="line">    rest.setAppId(appId)</span><br><span class="line"> </span><br><span class="line">    result = rest.sendTemplateSMS(to,datas,tempId) </span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> result.iteritems():</span><br><span class="line">        <span class="keyword">if</span> k==<span class="string">&#x27;templateSMS&#x27;</span> : </span><br><span class="line">                <span class="keyword">for</span> k,s <span class="keyword">in</span> v.iteritems():</span><br><span class="line">                    print <span class="string">&#x27;%s:%s&#x27;</span> % (k, s) </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            print <span class="string">&#x27;%s:%s&#x27;</span> % (k, v) </span><br></pre></td></tr></table></figure>
<p>在视图函数中定义如下视图：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 蓝图注册</span><br><span class="line">@user_blueprint.route(<span class="string">&#x27;/sms_code&#x27;</span>)</span><br><span class="line">def sms_code():</span><br><span class="line">    # 接收:手机号，图形验证码，从请求报文中接收</span><br><span class="line">    mobile = request.args.get(<span class="string">&#x27;mobile&#x27;</span>)</span><br><span class="line">    imagecode = request.args.get(<span class="string">&#x27;imagecode&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    # 验证</span><br><span class="line">    # 1.值必填  空在python中为False</span><br><span class="line">    # 如果都不为空</span><br><span class="line">    <span class="keyword">if</span> not all([mobile, imagecode]):</span><br><span class="line">        # 返回json数据格式，由前端代码进一步处理</span><br><span class="line">        <span class="keyword">return</span> jsonify(result=<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    # 2.检验图形验证码一致，之前图形验证码已经存在session中</span><br><span class="line">    imagecode_session = session.get(<span class="string">&#x27;image_code&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> not imagecode_session:</span><br><span class="line">        <span class="keyword">return</span> jsonify(result=<span class="number">4</span>)</span><br><span class="line">    # 删除session中的数据，强制图形验证码过期，防止客户端不停尝试</span><br><span class="line">    del session[<span class="string">&#x27;image_code&#x27;</span>]</span><br><span class="line">	# 验证码不对的情况</span><br><span class="line">    <span class="keyword">if</span> imagecode != imagecode_session:</span><br><span class="line">        <span class="keyword">return</span> jsonify(result=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    # 处理</span><br><span class="line">    # 1.通过random随机数生成随机的验证码</span><br><span class="line">    smscode = str(random.randint(<span class="number">100000</span>, <span class="number">999999</span>))</span><br><span class="line">    # 2.保存验证码，用于后续验证，存到session中</span><br><span class="line">    session[<span class="string">&#x27;sms_code&#x27;</span>] = smscode</span><br><span class="line">    # 3.发送短信，云通讯工具包中封装好的函数功能</span><br><span class="line">    ytx_send.sendTemplateSMS(mobile, [smscode, <span class="string">&#x27;10&#x27;</span>], <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    # 响应</span><br><span class="line">    <span class="keyword">return</span> jsonify(result=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>在mian.JS中修改如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送短信验证码的点击事件，页面css已经由前端绑定好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendSMSCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 校验参数，保证输入框有数据填写</span></span><br><span class="line">	<span class="comment">// 先移除绑定事件，防止用户不符合条件下点击执行函数</span></span><br><span class="line">    $(<span class="string">&quot;.get_code&quot;</span>).removeAttr(<span class="string">&quot;onclick&quot;</span>);</span><br><span class="line">	<span class="comment">// 前端检验规则</span></span><br><span class="line">    <span class="keyword">var</span> mobile = $(<span class="string">&quot;#register_mobile&quot;</span>).val();</span><br><span class="line">    <span class="keyword">if</span> (!mobile) &#123;</span><br><span class="line">        $(<span class="string">&quot;#register-mobile-err&quot;</span>).html(<span class="string">&quot;请填写正确的手机号！&quot;</span>);</span><br><span class="line">        $(<span class="string">&quot;#register-mobile-err&quot;</span>).show();</span><br><span class="line">        $(<span class="string">&quot;.get_code&quot;</span>).attr(<span class="string">&quot;onclick&quot;</span>, <span class="string">&quot;sendSMSCode();&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> imageCode = $(<span class="string">&quot;#imagecode&quot;</span>).val();</span><br><span class="line">    <span class="keyword">if</span> (!imageCode) &#123;</span><br><span class="line">        $(<span class="string">&quot;#image-code-err&quot;</span>).html(<span class="string">&quot;请填写验证码！&quot;</span>);</span><br><span class="line">        $(<span class="string">&quot;#image-code-err&quot;</span>).show();</span><br><span class="line">        $(<span class="string">&quot;.get_code&quot;</span>).attr(<span class="string">&quot;onclick&quot;</span>, <span class="string">&quot;sendSMSCode();&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 发送短信验证码</span></span><br><span class="line">	<span class="comment">// 根据后端返回的json数据实现不同提示，局部刷新，要使用ajax请求</span></span><br><span class="line">    $.get(<span class="string">&#x27;/user/sms_code&#x27;</span>,&#123;</span><br><span class="line">        <span class="string">&#x27;mobile&#x27;</span>:mobile,</span><br><span class="line">        <span class="string">&#x27;imagecode&#x27;</span>:imageCode,</span><br><span class="line">    &#125;,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.result==<span class="number">1</span>)&#123;</span><br><span class="line">            alert(<span class="string">&#x27;请填写完整数据&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data.result==<span class="number">2</span> || data.result==<span class="number">4</span>)&#123;</span><br><span class="line">            alert(<span class="string">&#x27;图形验证码错误&#x27;</span>);</span><br><span class="line">            $(<span class="string">&quot;.get_code&quot;</span>).attr(<span class="string">&quot;onclick&quot;</span>, <span class="string">&quot;sendSMSCode();&quot;</span>);</span><br><span class="line">            generateImageCode();</span><br><span class="line">            $(<span class="string">&quot;#imagecode&quot;</span>).val(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data.result==<span class="number">3</span>)&#123;</span><br><span class="line">            alert(<span class="string">&#x27;请查看手机&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至于短信验证码等待60秒功能会在下文Django的框架中实现。</p>
<h2 id="Django框架"><a href="#Django框架" class="headerlink" title="Django框架"></a>Django框架</h2><p>前后端分离相比于Flas,k所以不需要再写前端代码，只要按照restful的开发格式，返回json数据即可</p>
<h3 id="短信验证码-1"><a href="#短信验证码-1" class="headerlink" title="短信验证码"></a>短信验证码</h3><p>djang框架实现短信验证码功能，同样使用第三方工具包云通讯功能，云通讯配置及使用方法在上述过程中已有介绍，这里就不在赘述。</p>
<h4 id="Django框架API接口设计"><a href="#Django框架API接口设计" class="headerlink" title="Django框架API接口设计"></a>Django框架API接口设计</h4><p>访问方式： GET /sms_codes/(?P<mobile>1[3-9]\d{9})/</mobile></p>
<p>请求参数： 路径参数与查询字符串参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><font color="#000000">mobile</font></td>
<td><font color="#000000">str</font></td>
<td><font color="#000000">是</font></td>
<td><font color="#000000">手机号</font></td>
</tr>
<tr>
<td>返回数据：json</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>类型</th>
<th>是否必传</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><font color="#000000">message</font></td>
<td><font color="#000000">str</font></td>
<td><font color="#000000">否</font></td>
<td><font color="#000000">OK，发送成功</font></td>
</tr>
</tbody></table>
<h4 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h4><p>在应用的urls.py中配置路由</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(r<span class="string">&#x27;^sms_code/(?P&lt;mobile&gt;1[3-9]\d&#123;9&#125;)/$&#x27;</span>,views.SMSCodeView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在应用的views.py中定义视图</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class SMSCodeView(APIView):</span><br><span class="line">   </span><br><span class="line">    def get(self, request, mobile):</span><br><span class="line">        <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        接收手机号，发送短信验证码</span></span><br><span class="line"><span class="string">        :param mobile: 手机号</span></span><br><span class="line"><span class="string">        :return: 是否成功</span></span><br><span class="line"><span class="string">        &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">        # 获取redis的连接</span><br><span class="line">        redis_cli = get_redis_connection(<span class="string">&#x27;verify_code&#x27;</span>)</span><br><span class="line">        # 检查是否在60s内有发送记录</span><br><span class="line">        sms_flag = redis_cli.get(<span class="string">&#x27;sms_flag_&#x27;</span> + mobile)</span><br><span class="line">        <span class="keyword">if</span> sms_flag:</span><br><span class="line">            raise serializers.ValidationError(<span class="string">&#x27;请稍候再发送短信验证码&#x27;</span>)</span><br><span class="line">        # 生成短信验证码</span><br><span class="line">        sms_code = str(random.randint(<span class="number">100000</span>, <span class="number">999999</span>))</span><br><span class="line">        # 保存短信验证码与发送记录</span><br><span class="line">        # 存验证码，300秒</span><br><span class="line">        redis_cli.setex(<span class="string">&#x27;sms_code_&#x27;</span> + mobile, <span class="number">300</span>, sms_code)</span><br><span class="line">        # 存发送标记，60秒</span><br><span class="line">        redis_cli.setex(<span class="string">&#x27;sms_flag_&#x27;</span> + mobile, <span class="number">60</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        # 发送短信</span><br><span class="line">        CCP.sendTemplateSMS(mobile,sms_code,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;OK&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>用的djang的drf框架，别忘了导入各种包(response对象，redis数据库连接，APIview，云通讯，random，序列化器)</p>
<h4 id="关于与redis数据库交互的优化"><a href="#关于与redis数据库交互的优化" class="headerlink" title="关于与redis数据库交互的优化"></a>关于与redis数据库交互的优化</h4><p>上边代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 保存短信验证码与发送记录</span><br><span class="line">     # 存验证码，300秒</span><br><span class="line">     redis_cli.setex(<span class="string">&#x27;sms_code_&#x27;</span> + mobile, <span class="number">300</span>, sms_code)</span><br><span class="line">     # 存发送标记，60秒</span><br><span class="line">     redis_cli.setex(<span class="string">&#x27;sms_flag_&#x27;</span> + mobile, <span class="number">60</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>这部分代码与redis数据库交互了两次，如何进行优化，只交互一次呢？<br>采用redis管道，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 优化redis交互，减少通信的次数，管道pipeline</span><br><span class="line">     redis_pl = redis_cli.pipeline()</span><br><span class="line">     redis_pl.setex(<span class="string">&#x27;sms_code_&#x27;</span> + mobile, <span class="number">300</span>, sms_code)</span><br><span class="line">     redis_pl.setex(<span class="string">&#x27;sms_flag_&#x27;</span> + mobile, <span class="number">60</span>, <span class="number">1</span>)</span><br><span class="line">     redis_pl.execute()</span><br></pre></td></tr></table></figure>
<p>即可优化redis的交互次数。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title>关于数据库redis与Mysql的区别以及在web开发中的配合使用</title>
    <url>/2018/08/18/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93redis%E4%B8%8EMysql%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8web%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="传统型关系数据库Mysql的瓶颈"><a href="#传统型关系数据库Mysql的瓶颈" class="headerlink" title="传统型关系数据库Mysql的瓶颈"></a>传统型关系数据库Mysql的瓶颈</h3><p>在互联网领域，MySQL作为一款关系型数据库为互联网的发展做出了卓越的贡献。然而随着互联网的发展，在大数据量高并发的环境下，应用开发也越来越复杂，具有很强的技术挑战性。分表分库子库等无不在增加数据库结构的复杂程度。MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变得非常的小。<br><br>关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差，大数据下IO压力大，表结构更改困难。</p>
<h3 id="Nosql与redis"><a href="#Nosql与redis" class="headerlink" title="Nosql与redis"></a>Nosql与redis</h3><p>NoSQL最常见的解释是“non-relational”，“Not Only SQL”也被很多人接受，指的是非关系型的数据库。</p>
<h4 id="Nosql的优势"><a href="#Nosql的优势" class="headerlink" title="Nosql的优势"></a>Nosql的优势</h4><p>易扩展：NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。<br>大数据量，高性能：NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单<br>灵活的数据模型：NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦<br>高可用：NoSQL在不太影响性能的情况，就可以方便的实现高可用的架构。</p>
<h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><p>Redis是一个开源（BSD许可）的、内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。<br>redis是一个高性能的key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sortedset–有序集合)和hash（哈希类型）。redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Python，Ruby，Erlang，PHP客户端，使用很方便<br>Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>NoSQL数据库的出现，弥补了关系数据（比如MySQL）在某些方面的不足，在某些方面能极大的节省开发成本和维护成本<br>MySQL和NoSQL都有各自的特点和使用的应用场景，两者的紧密结合将会给数据库发展带来新的思路。让关系数据库关注在关系上，NoSQL关注在存储上。</p>
<h3 id="利用redis做mysql的缓存"><a href="#利用redis做mysql的缓存" class="headerlink" title="利用redis做mysql的缓存"></a>利用redis做mysql的缓存</h3><p>前面部分已经介绍mysql的瓶颈，当网站的处理和访问量非常大的时候，我们的数据库的压力就变大了，数据库的连接池，数据库同时处理数据的能力就会受到很大的挑战，一旦数据库承受了其最大承受能力，网站的数据处理效率就会大打折扣。此时就要使用高并发处理、负载均衡和分布式数据库，而这些技术既花费人力，又花费资金。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p><img src="/2018/08/18/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93redis%E4%B8%8EMysql%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8web%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8/1.jpg" alt="1"></p>
<p>页面缓存经常用在CMS(content manage system)内存管理系统里面。<br>数据缓存经常会用在页面的具体数据里面。</p>
<h4 id="Redis缓存原理"><a href="#Redis缓存原理" class="headerlink" title="Redis缓存原理"></a>Redis缓存原理</h4><p>采用redis nosql数据库作为Mysql数据库的缓存，在查找的时候，首先查找redis缓存，如果找到则返回结果；如果在redis中没有找到，那么查找Mysql数据库，找到的花则返回结果并且更新redis；如果没有找到则返回空。</p>
<p><img src="/2018/08/18/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93redis%E4%B8%8EMysql%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8web%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8/2.jpg" alt="2"></p>
<p>对于写入：用户增删改数据库，先访问mysql，mysql再把数据更新到redis。</p>
<p>Mysql中的数据都是按表存储的；更微观地看，这些表都是按行存储的。每执行一次select查询，Mysql都会返回一个结果集，这个结果集由若干行组成。所以，一个自然而然的想法就是在Redis中找到一种对应于Mysql行的数据结构。<br>Redis中提供了五种基本数据结构，即字符串（string）、列表（list）、哈希（hash）、集合（set）和有序集合（sorted set）。经过调研，发现适合存储行的数据结构有两种，即string和hash。</p>
<p>用户的缓存数据在返回时一般都是JSON的字典格式，对应的存到redis里就是hash格式，这个与python的字典是相对应的。</p>
<table>
<thead>
<tr>
<th>redis中的hash</th>
<th>python中的字典</th>
</tr>
</thead>
<tbody><tr>
<td><font color="#000000">key</font></td>
<td><font color="#000000">对象</font></td>
</tr>
<tr>
<td><font color="#000000">field</font></td>
<td><font color="#000000">key</font></td>
</tr>
<tr>
<td><font color="#000000">value</font></td>
<td><font color="#000000">value</font></td>
</tr>
<tr>
<td>即hash会根据要缓存的数据生成唯一标识UUID，UUID作为键，用户的字典数据中的键值对作为UUID键的值，存储到redis中。</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>列表整数加1</title>
    <url>/2021/01/26/%E5%88%97%E8%A1%A8%E6%95%B4%E6%95%B0%E5%8A%A01/</url>
    <content><![CDATA[<p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">input = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">res = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func plusOne(digits []int) []int &#123;</span><br><span class="line">    isAdd := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i:=len(digits)-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> isAdd &#123;</span><br><span class="line">            digits[i] += <span class="number">1</span></span><br><span class="line">            isAdd = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> digits[i] &gt;= <span class="number">10</span> &#123;</span><br><span class="line">            digits[i] = <span class="number">0</span></span><br><span class="line">            isAdd = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> isAdd &#123;</span><br><span class="line">        digits = append(digits, <span class="number">1</span>)</span><br><span class="line">        copy(digits[<span class="number">1</span>:], digits[<span class="number">0</span>:])</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序数组中的重复项</title>
    <url>/2020/12/09/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>首先注意数组是有序的，那么重复的元素一定会相邻。</p>
<p>要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。</p>
<p>考虑用 2 个指针，一个在前记作a，一个在后记作 b，算法流程如下：</p>
<p>比较 a 和 b 位置的元素是否相等。</p>
<p>如果相等，b 后移 1 位<br>如果不相等，将 a 位置的元素复制到 a+1 位置上，a 后移一位，b 后移 1 位<br>重复上述过程，直到 b 等于数组长度。</p>
<p>返回 a + 1，即为新数组长度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func removeDuplicates(nums []int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    a, <span class="attr">b</span> := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ;b &lt; len(nums);b++ &#123;</span><br><span class="line">        <span class="keyword">if</span> b == <span class="function"><span class="title">len</span>(<span class="params">nums</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[b]!=nums[a] &#123;</span><br><span class="line">            nums[a+<span class="number">1</span>] = nums[b]</span><br><span class="line">            a++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>判断字符串是否由纯数字组成</title>
    <url>/2020/06/16/%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E7%BA%AF%E6%95%B0%E5%AD%97%E7%BB%84%E6%88%90/</url>
    <content><![CDATA[<p>Python isdigit() 方法检测字符串是否只由数字组成。</p>
<p>如果字符串只包含数字，则返回true，否则返回false</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">str.isdigit()  # 用法</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划专题</title>
    <url>/2021/03/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p>学习笔记</p>
<h2 id="动态规划思路"><a href="#动态规划思路" class="headerlink" title="动态规划思路"></a>动态规划思路</h2><p>1、根据大问题找重复子问题</p>
<p>2、定义dp状态数组，明确dp[i]含义</p>
<p>3、找dp方程，明确边界条件等，不同处理</p>
<h2 id="动态规划解题步骤"><a href="#动态规划解题步骤" class="headerlink" title="动态规划解题步骤"></a>动态规划解题步骤</h2><h3 id="判断边界条件"><a href="#判断边界条件" class="headerlink" title="判断边界条件"></a>判断边界条件</h3><p>1、给的值为空，提前返回</p>
<p>2、长度为1这种特殊值</p>
<h3 id="初始化dp"><a href="#初始化dp" class="headerlink" title="初始化dp"></a>初始化dp</h3><h4 id="初始化一维dp数组，-dp-，要明白dp-i-的意义"><a href="#初始化一维dp数组，-dp-，要明白dp-i-的意义" class="headerlink" title="初始化一维dp数组， dp=[]，要明白dp[i]的意义"></a>初始化一维dp数组， dp=[]，要明白dp[i]的意义</h4><p>初始化方式:<br>    新开数组，并赋上初始0值，然后迭代修改<br>    以原数组直接为dp（优化空间复杂度，不过会修改原数组的值）<br>例：<br>    1、爬楼梯问题：<br>        新开数组，dp[i]代表，第i个数的斐波那契数值，最后迭代到dp[i]即可<br>        初始化dp[0]=1,dp[1]=1,第一个数是1，0是用于初始计算，n是正整数<br>    2、打家劫舍问题：<br>        新开dp数组，dp[i]表示当前的最大值，初始化0值，1值（要不偷0，要不偷1，两个的最大值）<br>        不开dp数组，直接nums为dp，初始化nums[1]=max(nums[0], nums[1])<br>    3、零钱兑换问题：<br>        新开dp，初始化一个amount+1的数组，dp[i]组成该金额的最小组合，最终结果是dp[amount]<br>        金额依次递增，算出每个金额的最小组合，索引即代表金额<br>    4、最长有效括号问题：<br>        dp数组，初始化均为0，dp[i]代表当前位置为结尾的最长有效括号，只看）这个的dp，（的为0<br>    5、最长递增子序列问题：<br>        一维dp数组，dp值代表以当前位置为结尾的最长递增子序列</p>
<h4 id="一维dp数组通过优化，可将空间复杂度降为1，通过指针迭代"><a href="#一维dp数组通过优化，可将空间复杂度降为1，通过指针迭代" class="headerlink" title="一维dp数组通过优化，可将空间复杂度降为1，通过指针迭代"></a>一维dp数组通过优化，可将空间复杂度降为1，通过指针迭代</h4><p>要明白每个指针的意义，以及特殊问题相关<br>一般都会2个-3个指针，分别代表，现在的值，前一个值，结果值或后一个值，迭代过程中不断更新指针值<br>例：<br>    1、爬楼梯问题：<br>        对于上面开数组的优化， a,b,c 三个指针，n是正整数，初始化a=0，b=1，c=1<br>        a：n-2， b：n-1， c：n<br>    2、打家劫舍问题：<br>        数组优化，两个指针cur,pre,pre前一个，cur当前个<br>    3、最大子序和问题：<br>        不需要初始化数组，根据特殊情况，双指针迭代，或者单指针，修改数组，循环中舍弃不符合条件的值<br>        res最终结果，sum当前和，res初始化数组第一个值，从第二个开始<br>    4、最大乘积和：<br>        初始化一个最大值，一个最小值，结果，三个值，处理正负数的问题<br>    5、解码方法问题：<br>        初始化两个指针，一个当前位置的解码方法，一个前一个位置的解码方法</p>
<h4 id="初始化二维dp数组，dp-int-dp-i-j-的意义"><a href="#初始化二维dp数组，dp-int-dp-i-j-的意义" class="headerlink" title="初始化二维dp数组，dp=[][]int, dp[i][j]的意义"></a>初始化二维dp数组，dp=[][]int, dp[i][j]的意义</h4><p>例：<br>    1、打家劫舍问题（一维问题二维化）：<br>        初始化dp数组，dp=[][]int,升维思路记录额外数据，dp[i][0,1],0代表不偷，1代表偷<br>        并初始化0值,dp[0][0],dp[0][1],初始值偷与不偷的情况<br>    2、三角形最小路径和问题：<br>        初始化dp数组[][]int,并将最后一行赋值，逆向循环，从倒数第二行开始<br>        不开dp数组，直接triangle，不需要赋值了<br>        优化空间复杂度，只需dp[],初始化最后一层，记录每一层，逆向循环，整层更新掉<br>    3、回文子串（一维问题二维化）：<br>        初始化二维dp数组，记录i，j下标为起始的字符串是否是回文串，true，false<br>        可优化为1维，在一次里层循环中使用，外层直接从头更新<br>    4、最大正方形问题：<br>        初始化二维数组，并赋值1，与原数组对应，dp[i][j]代表最大正方形的边长，并初始化最初结果1<br>    5、最小路径和问题：<br>        初始化二维dp，dp[i][j]代表到当前点的最小路径和<br>    6、编辑距离问题：<br>        初始化二维dp，长度加1，单词前面加一个空串处理，dp[i][j]表示，单词1和单词2的前ij字符匹配所需要的最小编辑次数<br>    7、不同路径问题：<br>        初始化二维dp，dp[i][j]表示，到达当前点的不同路径和，初始化注意0，0点，如果有 障碍，dp值是1<br>    8、最长重复子数组问题：<br>        初始化二维dp，长度加1，dp[i][j]代表两个数组的指针位置，到当前位置子数组的长度<br>    9、不同子序列问题：<br>        初始化二维dp数组，两个字符串，都是+1的长度初始化，从空串开始</p>
<h3 id="循环迭代dp值"><a href="#循环迭代dp值" class="headerlink" title="循环迭代dp值"></a>循环迭代dp值</h3><p>根据循环方向不同，循环初始值不同，结束值不同，维度不同分多这种情况</p>
<p>每次循环处理dp方程,区分情况，注意边界条件，分治，可能各个条件的dp方程不一样</p>
<p>注意dp[i]的意义，根据循环的正序，倒序返回</p>
<h4 id="一维循环：从开始往后循环，i"><a href="#一维循环：从开始往后循环，i" class="headerlink" title="一维循环：从开始往后循环，i++"></a>一维循环：从开始往后循环，i++</h4><p>例：<br>    1、爬楼梯问题:<br>        初始值，初始到了dp[1]，从2开始循环到n，返回dp[n]，初始的数组要到n+1<br>        dp方程：dp[i] = dp[i-1] + dp[i-2]<br>        返回dp[n]<br>        指针形式：c就相当于n的值，初始化了1的值，从1开始循环到n<br>        先更新值，然后计算<br>        a = b<br>        b = c<br>        c = a + b<br>        返回c<br>    2、打家劫舍问题：（打家劫舍2就是分两种情况dp, 先记录第一种情况的结果dp[n-2]，比较第二种的结果dp[n-1]）<br>        初始化是二维数组：<br>        dp[i]每次计算偷与不偷的情况，最后返回偷与不偷的最大值，从i=1开始，正向<br>        dp方程：   dp[i][0] = max(dp[i-1][0], dp[i-1][1]) // i不偷，i-1偷与不偷之间的最大值<br>                dp[i][1] = nums[i] + dp[i-1][0] // i偷，则当前i加上i-1不偷的值<br>        初始化是一维数组：<br>        dp[i]是代表最大值，不关心偷与不偷，只获取偷和，不偷的最大值， i-2包含了i-3，i-4等<br>        dp方程：dp[i] = max(dp[i-1], dp[i-2] + nums[i])<br>        不开dp数组，直接nums为dp 初始化nums[1]：<br>        dp方程：nums[i] = max(nums[i-1], nums[i-2] + nums[i])<br>        指针pre          ，cur从2开始循环：<br>        dp方程：pre, cur = cur, max(cur, pre + nums[i])<br>    3、最大子序和：<br>        res记录结果，sum当前值，然后对sum进行累加，如果sum累加之后小于0，则把从下一个值从新开始，赋值为sum<br>        比较结果，更新res<br>        另一种思路：更新nums[i],进行累加nums[i] + nums[i-1] &gt; nums[i]，说明nums[i-1]是正数，否则nums[i-1]是负数<br>        则不动，nums[i]就是dp[i]代表累加和<br>    4、最大乘积和：<br>        每次循环，获取当前的最大，最小值，每次更新最大最小值<br>        最大值：比较最大值<em>当前值，当前值，当前值</em>最小值的大小，针对0，变号的处理<br>        最小值：比较最小值<em>当前值，当前值，当前值</em>最大值的大小，针对0，变号的处理<br>        另外思路：负数的个数，偶数则是全部最大，奇数则从前，从后连乘，舍弃1个负数的两种情况的最大值<br>    5、解码方法问题：<br>        先根据0的位置分情况，只有10,20符合且只能这么解码，所以次数不变<br>        除了上一种其他0都不符合<br>        然后找正常可组成26之内的，则解码方法等于加上之前的，然后更新cur，pre<br>        否则就是单数字那种，更新pre<br>        注意判断条件(s[i] &lt;= ‘6’ &amp;&amp; (s[i - 1] == ‘1’ || s[i - 1] == ‘2’)) || (s[i] &gt; ‘6’ &amp;&amp; s[i  - 1] == ‘1’)<br>    6、最长有效括号：<br>        从1开始循环，2个长度才可能有效，只看当前位置是）的dp<br>        pre = i - 1 - dp[i-1]，如果前一个是（，则dp[i-1]=0，也兼容进去<br>        如果pre的位置 存在，且pre的位置是（，则说明有效，结果+2，如果pre前面还有，则加上前面的dp值<br>        dp方程：dp[i] = dp[i-1] + 2<br>        最后返回每次循环的最大值</p>
<h4 id="一维循环：从后往前循环，i–"><a href="#一维循环：从后往前循环，i–" class="headerlink" title="一维循环：从后往前循环，i–"></a>一维循环：从后往前循环，i–</h4><h4 id="二维循环：从前往后循环，i–"><a href="#二维循环：从前往后循环，i–" class="headerlink" title="二维循环：从前往后循环，i–"></a>二维循环：从前往后循环，i–</h4><p>例：<br>    1、零钱兑换问题：<br>        外层循环：从第一个金额开始向后遍历，每个金额初始dp[i] = -1<br>        内层循环：遍历硬币数组当前金额即索引小于硬币数，则为-1跳过或者减去这个硬币金额后前一个也无解是-1<br>             前一个有解的话，就是前一个所需的最小组合数+1，如果这个数字小于dp[i],或者dp[i]没有计算过,则更新dp[i]<br>    最后返回amount索引的金额<br>    2、回文串问题：<br>        外层循环：字符串结束下标<br>        里层循环：字符串起始下标，记录起始下标到结束下标（3种情况：1，ij相等，2：ij差1且相等，3，ij差2以上且相等且里面的dp是true，是回文串），一维优化后，只记录起始下标i，不符合记录false，下一个外层从头更新<br>    3、最大正方形问题：<br>        以右下角包含1的为正方形的右下角，其他三个点的最小值+1，只看dp[i][j]是1的，才有正方形<br>        dp方程：dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1<br>    4、最小路径和问题：<br>        分边界考虑：边界：没得选择，加上前面那点的dp值，加上原数组的值<br>        非边界：前面的两个的最小值，加上原数组值<br>        dp方程：dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]<br>    5、编辑距离问题：<br>        里外层循环，两个单词两个指针位置移动，从0开始，0是空串，边界条件初始化（一个单词为空串）<br>        当word ij相等时，不需要操作，ij = i-1，j-1<br>        word ij不等时，三种操作下的最小值+1<br>        替换操作：i-1与j-1匹配，ij替换即可  +1<br>        插入操作：i与j-1匹配，i后面插入j  +1<br>        删除操作：i-1与j匹配，删除i  +1<br>        dp方程： if word1[i-1] == word2[j-1]: dp[i][j] = dp[i - 1][j - 1]<br>                else：dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1<br>        最后返回dp[m][n]<br>    6、不同路径问题：<br>        两层循环，从前往后，处理i0，j0的边界条件<br>        dp方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]<br>    7、不同路径问题2：<br>        两层循环，从前往后，处理i0，j0的边界条件，障碍那点的dp值是0<br>        dp方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]<br>    8、递增子序列问题：<br>        一维dp，二维循环，<br>        外层循环，重置当前dp值是1，然后内层循环代表，以当前i为结束位置，遍历之前每一个点，如果i的值大于j的值<br>        则dp[i]就是dp[j] +1与dp[i]相比的最大值，然后和结果比较<br>        dp方程：if dp[j] + 1 &gt; dp[i] {dp[i] = dp[j] + 1；if dp[i] &gt; res { res = dp[i]}}</p>
<h4 id="二维循环：从后往前循环，i–"><a href="#二维循环：从后往前循环，i–" class="headerlink" title="二维循环：从后往前循环，i–"></a>二维循环：从后往前循环，i–</h4><p>自下向上循环，注意初始值的处理，看看最后一层是不是需要进入循环，不进入直接初始化最后一层</p>
<p>例：<br>    1、最小三角形路径和：<br>    外层循环从倒数第二层开始。n-2往前，里层循环正向，dp[i][j]为下一层相邻的最小值<br>    dp方程：dp[i][j] = min(dp[i+1][j], dp[i+1][j+1]) + triangle[i][j]<br>    优化空间复杂度：dp[]初始化最后一层，向上循环，每次整层更新<br>    dp方程：dp[j] = min(dp[j], dp[j+1]) + triangle[i][j]<br>    2、最长重复子数组：<br>    外层循环从m-1开始，内层循环从n-1开始，如果这两个元素长度相等，这说明后面位置的最长子数组加1<br>    如果不等，说明这两个位置肯定不在最长子数组里，这个位置的dp值就是0<br>    dp方程：dp[i][j] = dp[i + 1][j + 1] + 1<br>    是双层遍历<br>    2、不同的子序列<br>    从后往前，两个字符串，初始化是空串为1，dp[i][n] = 1，然后内外层都往前<br>    dp方程: 两个字符相等，则匹配当前这个，或者不匹配，走上一个<br>    if s[i] == t[j] {<br>        dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]<br>    } else { 两个字符不等，只能走上一个<br>        dp[i][j] = dp[i + 1][j]<br>    }</p>
<h2 id="动态规划例题"><a href="#动态规划例题" class="headerlink" title="动态规划例题"></a>动态规划例题</h2><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func climbStairs(n int) int &#123;</span><br><span class="line">    a, b, <span class="attr">c</span> := <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        a = b</span><br><span class="line">        b = c</span><br><span class="line">        c = a + b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func rob(nums []int) int &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    pre := nums[<span class="number">0</span>]</span><br><span class="line">    cur := max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">        pre, cur = cur, max(cur, pre + nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打家劫舍2"><a href="#打家劫舍2" class="headerlink" title="打家劫舍2"></a>打家劫舍2</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func rob(nums []int) int &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    dp := make([]int, n)</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n - <span class="number">1</span>; i++  &#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    res1 := dp[n - <span class="number">2</span>]</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++  &#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(res1, dp[n-<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><p>完全背包问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func coinChange(coins []int, amount int) int &#123;</span><br><span class="line">    dp := make([]int, amount + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= amount; i++ &#123;</span><br><span class="line">        dp[i] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _, <span class="attr">c</span> := range coins &#123;</span><br><span class="line">            <span class="keyword">if</span> i &lt; c || dp[i-c] == -<span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            count := dp[i-c] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == -<span class="number">1</span> || dp[i] &gt; count &#123;</span><br><span class="line">                    dp[i] = count</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func maxSubArray(nums []int) int &#123;</span><br><span class="line">    res := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] + nums[i-<span class="number">1</span>] &gt; nums[i]&#123;</span><br><span class="line">            nums[i] += nums[i -<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; res &#123;</span><br><span class="line">            res = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大乘积"><a href="#最大乘积" class="headerlink" title="最大乘积"></a>最大乘积</h3><p>遍历法，根据负数的数量是奇数还是偶数个</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func maxProduct(nums []int) int &#123;</span><br><span class="line">    res := nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    cur := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(nums); i++ &#123;</span><br><span class="line">        cur *= nums[i]</span><br><span class="line">        res = max(cur, res)</span><br><span class="line">        <span class="keyword">if</span> nums[i] == <span class="number">0</span> &#123;cur = <span class="number">1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := len(nums) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        cur *= nums[i]</span><br><span class="line">        res = max(cur, res)</span><br><span class="line">        <span class="keyword">if</span> nums[i] == <span class="number">0</span> &#123;cur = <span class="number">1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func maxProduct(nums []int) int &#123;</span><br><span class="line">    mxf, mnf, <span class="attr">res</span> := nums[<span class="number">0</span>], nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(nums); i++ &#123;</span><br><span class="line">        mx, <span class="attr">mn</span> := mxf, mnf</span><br><span class="line">        mxf = max(mx * nums[i], max(nums[i], nums[i] * mn))</span><br><span class="line">        mnf = min(mn * nums[i], min(nums[i], nums[i] * mx))</span><br><span class="line">        res = max(mxf, res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func minimumTotal(triangle [][]int) int &#123;</span><br><span class="line">    n := len(triangle)</span><br><span class="line">    dp := make([]int, len(triangle[n-<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(triangle[n-<span class="number">1</span>]); i++ &#123;</span><br><span class="line">        dp[i] = triangle[n-<span class="number">1</span>][i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; len(triangle[i]); j++ &#123;</span><br><span class="line">            dp[j] = min(dp[j], dp[j+<span class="number">1</span>]) + triangle[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func countSubstrings(s string) int &#123;</span><br><span class="line">    n := len(s)</span><br><span class="line">    dp := make([]bool, n)</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= j; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i == j &#123;</span><br><span class="line">                res++</span><br><span class="line">                dp[i] = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> j - i == <span class="number">1</span> &amp;&amp; s[i] == s[j] &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span></span><br><span class="line">                res++</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> j - i &gt; <span class="number">1</span> &amp;&amp; s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>] &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span></span><br><span class="line">                res++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a>解码方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func numDecodings(s string) int &#123;</span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一维dp，优化空间复杂度</span></span><br><span class="line">    cur, <span class="attr">pre</span> := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(s); i++ &#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="comment">// ‘10’， ‘20’这种情况，不会有额外的解码方法，保持不变，cur=pre，且1,2只能跟0组合，所以是等于前面的</span></span><br><span class="line">        <span class="keyword">case</span> s[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; (s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span>):</span><br><span class="line">            cur = pre</span><br><span class="line">        <span class="comment">// 除去上一种，其他的0都不合法，直接返回</span></span><br><span class="line">        <span class="keyword">case</span> s[i] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">// 可以与前一个数字多一种解码方法的，加上之前的解码方法，并更新</span></span><br><span class="line">        <span class="keyword">case</span> (s[i] &lt;= <span class="string">&#x27;6&#x27;</span> &amp;&amp; (s[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)) || (s[i] &gt; <span class="string">&#x27;6&#x27;</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>):</span><br><span class="line">            tmp := cur</span><br><span class="line">            cur += pre</span><br><span class="line">            pre = tmp</span><br><span class="line">        <span class="comment">// 没有多出解码方法的，cur保持不变， pre=cur</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a>最大正方形</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func maximalSquare(matrix [][]byte) int &#123;</span><br><span class="line">    m := len(matrix)</span><br><span class="line">    n := len(matrix[<span class="number">0</span>])</span><br><span class="line">    dp := make([][]int, m)</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 初始化，并赋值，如果有1，结果为1，特殊处理</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        dp[i] = make([]int, n)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span></span><br><span class="line">                res = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0那一行，最多就是1，不需要进行更新，从1开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="comment">// 如果当前值是1,则以当前点为右下角包含1的正方形，为其他三个点的最小值+1</span></span><br><span class="line">            <span class="comment">// 为0的则 跳过</span></span><br><span class="line">           <span class="keyword">if</span> dp[i][j] == <span class="number">1</span>&#123;</span><br><span class="line">               dp[i][j] = min(min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]), dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 更新res</span></span><br><span class="line">           <span class="keyword">if</span> dp[i][j] &gt; res &#123;</span><br><span class="line">               res = dp[i][j]</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res * res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func minPathSum(grid [][]int) int &#123;</span><br><span class="line">    <span class="comment">// 初始化dp矩阵，与原数据矩阵对应</span></span><br><span class="line">    m := len(grid)</span><br><span class="line">    n := len(grid[<span class="number">0</span>])</span><br><span class="line">    dp := make([][]int, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        dp[i] = make([]int, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历矩阵，递推出dp[i][j]的值</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++  &#123;</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="comment">// 0,0点特殊处理</span></span><br><span class="line">            <span class="keyword">case</span> i == <span class="number">0</span>  &amp;&amp; j == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = grid[i][j]</span><br><span class="line">            <span class="comment">// 边界特殊处理，原矩阵当前点的 值加上之前的dp值，就是dp当前点的值</span></span><br><span class="line">            <span class="keyword">case</span> i == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + grid[i][j]</span><br><span class="line">            <span class="keyword">case</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j]</span><br><span class="line">            <span class="comment">// 非边界递推，最小路径，只能向右，向下，之前两个点的最小值，加上原矩阵当前点的值</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="矩形区域不超过k的最大和"><a href="#矩形区域不超过k的最大和" class="headerlink" title="矩形区域不超过k的最大和"></a>矩形区域不超过k的最大和</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前缀和加上最大子序和</span></span><br><span class="line">func maxSumSubmatrix(matrix [][]int, k int) int &#123;</span><br><span class="line">    rowNum, <span class="attr">colNum</span> := len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">// 最小值作为初始结果</span></span><br><span class="line">    result := math.MinInt32</span><br><span class="line">    <span class="comment">// 按列遍历，起始指针</span></span><br><span class="line">    <span class="keyword">for</span> left := <span class="number">0</span>; left &lt; colNum; left ++ &#123;</span><br><span class="line">        rowSum := make([]int, rowNum)</span><br><span class="line">        <span class="comment">// 按列遍历，结束指针</span></span><br><span class="line">        <span class="keyword">for</span> right := left; right &lt; colNum; right++ &#123;</span><br><span class="line">            <span class="comment">// 按行遍历，逐列想加，每一列都是之前列的行行和</span></span><br><span class="line">            <span class="keyword">for</span> row := <span class="number">0</span>; row &lt; rowNum; row++ &#123;</span><br><span class="line">                rowSum[row] += matrix[row][right]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找最大值，每一列的最大子序和，就是矩形区域的和</span></span><br><span class="line">            result = max(result, maxSubArrBelowK(rowSum, k))</span><br><span class="line">            <span class="keyword">if</span> result == k &#123;</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找最大子序和，因为有k限制</span></span><br><span class="line">func maxSubArrBelowK(arr []int, k int) int &#123;</span><br><span class="line">    <span class="comment">// 先按动态规划找最大子序和，找到可以减少时间复杂度</span></span><br><span class="line">    sum, max, <span class="attr">l</span> := arr[<span class="number">0</span>], arr[<span class="number">0</span>], len(arr)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; l; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> sum &gt; <span class="number">0</span> &#123;</span><br><span class="line">            sum += arr[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum = arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sum &gt; max &#123;</span><br><span class="line">            max = sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果结果小于k，则找到，返回</span></span><br><span class="line">    <span class="keyword">if</span> max &lt;= k &#123;</span><br><span class="line">        <span class="keyword">return</span> max</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结果大于k，则只能暴力法去找，最接近k的</span></span><br><span class="line">    max = math.MinInt32</span><br><span class="line">    <span class="keyword">for</span> left := <span class="number">0</span>; left &lt; l; left++ &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right := left; right &lt; l; right++ &#123;</span><br><span class="line">            sum += arr[right]</span><br><span class="line">            <span class="keyword">if</span> sum &gt; max &amp;&amp; sum &lt;= k &#123;</span><br><span class="line">                max = sum</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> max == k &#123;</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func minDistance(word1 string, word2 string) int &#123;</span><br><span class="line">    m := len(word1)</span><br><span class="line">    n := len(word2)</span><br><span class="line">    <span class="comment">// 初始化m+!,n+1,单词前面加一个空串处理</span></span><br><span class="line">    dp := make([][]int, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m + <span class="number">1</span>; i++ &#123;</span><br><span class="line">        dp[i] = make([]int, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m+<span class="number">1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n+<span class="number">1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="comment">// 00位置两个空串是0</span></span><br><span class="line">            <span class="keyword">case</span> i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 空串对于另一个单词就一直插入</span></span><br><span class="line">            <span class="keyword">case</span> i == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">case</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span></span><br><span class="line">            <span class="comment">// 如果两个单词相等，则不需要操作</span></span><br><span class="line">            <span class="keyword">case</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">            <span class="comment">// dp[i - 1][j - 1]代表替换，dp[i - 1][j]。i-1与j一样，删除i；i与j-1一样。i后面插入j</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                dp[i][j] = min(min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最长 有效括号，双向遍历法</span></span><br><span class="line">func longestValidParentheses(s string) int &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    left, right, <span class="attr">res</span> := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(s); i++ &#123;</span><br><span class="line">        <span class="comment">// 左右计数++</span></span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123; left++ &#125;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &#123; right++ &#125;</span><br><span class="line">        <span class="comment">// 右括号比左括号多，则重置，前面的舍弃</span></span><br><span class="line">        <span class="keyword">if</span> right &gt; left &#123; </span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新结果</span></span><br><span class="line">        <span class="keyword">if</span> left == right &#123; res = max(res, right) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以上会漏掉一种就是左括号始终比右括号多，这种是找不到的</span></span><br><span class="line">    <span class="comment">// 逆向遍历，正向排除右比左多的，逆向排除左比右多的</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := len(s) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123; left++ &#125;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &#123; right++ &#125;</span><br><span class="line">        <span class="keyword">if</span> right &lt; left &#123; </span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left == right &#123; res = max(res, right) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划方法</span></span><br><span class="line">func longestValidParentheses(s string) int &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> || len(s) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp := make([]int, len(s))</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 从1开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(s); i++ &#123;</span><br><span class="line">        <span class="comment">// 结尾是）才能形成有效括号，只看结尾是）的前面， （的dp值都是0</span></span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">            <span class="comment">// 找前面的（，如果前一个就是（，前一个dp值是0，也能找到</span></span><br><span class="line">            pre := i - <span class="number">1</span>- dp[i - <span class="number">1</span>]</span><br><span class="line">            <span class="comment">// 如果大于0，且找到是（，则结果+2</span></span><br><span class="line">            <span class="keyword">if</span> pre &gt;= <span class="number">0</span> &amp;&amp; s[pre] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="comment">// 如果有再前一个，则加上再前一个的dp值</span></span><br><span class="line">                <span class="keyword">if</span> pre - <span class="number">1</span> &gt;= <span class="number">0</span> &#123; dp[i] += dp[pre - <span class="number">1</span>] &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回最大值</span></span><br><span class="line">            res = max(res, dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="青蛙过河"><a href="#青蛙过河" class="headerlink" title="青蛙过河"></a>青蛙过河</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dfs递归，剪枝</span></span><br><span class="line">func canCross(stones []int) bool &#123;</span><br><span class="line">    <span class="comment">// 记录在别的分支处理过的子问题</span></span><br><span class="line">    vis := make(map[int]bool, len(stones))</span><br><span class="line">    <span class="keyword">var</span> dfs func(int, int) bool</span><br><span class="line">    dfs = func(index, k int) bool &#123;</span><br><span class="line">        <span class="comment">// 如果在别的分支处理过，说明别的分支无法通过，能通过就说明不会有子问题，一直到底结束递归</span></span><br><span class="line">        <span class="comment">// 如果找到，说明别的分支没到底，则1直接返回false</span></span><br><span class="line">        <span class="comment">// 保证石头位置唯一</span></span><br><span class="line">        <span class="keyword">if</span> vis[index*<span class="number">100</span> + k] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        vis[index*<span class="number">100</span> + k] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> i := index + <span class="number">1</span>; i &lt; len(stones); i++ &#123;</span><br><span class="line">            <span class="comment">// 计算下一个石头与当前石头之间的距离</span></span><br><span class="line">            dis := stones[i] - stones[index]</span><br><span class="line">            <span class="comment">// 在跳跃单位内，则继续递归，，return true</span></span><br><span class="line">            <span class="keyword">if</span> dis &gt;= k - <span class="number">1</span> &amp;&amp; dis &lt;= k + <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="function"><span class="title">dfs</span>(<span class="params">i, dis</span>)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 超过了k+1，则说明无法到达，直接break</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> dis &gt; k + <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125; <span class="comment">// 小于k-1，说明太近了，可以下一波循环找后面的石头</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前分支最后是否到达最后位置</span></span><br><span class="line">        <span class="keyword">return</span> index == len(stones) - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line">func canCross(stones []int) bool &#123;</span><br><span class="line">    <span class="comment">// dp[stones[i]] 用个map保存第i个位置所有能跳的k值</span></span><br><span class="line">    dp := make(map[int]map[int]int, len(stones))</span><br><span class="line">    <span class="comment">// 初始化每个石头，和能跳的k值</span></span><br><span class="line">    <span class="keyword">for</span> _, <span class="attr">i</span> := range stones &#123;</span><br><span class="line">        dp[i] = make(map[int]int)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一个石头，0值，跳0步</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(stones); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> _, <span class="attr">k</span> := range dp[stones[i]] &#123;</span><br><span class="line">             <span class="comment">// 初始0，-1， 0， 1，只有1步可以跳到下一个石头 </span></span><br><span class="line">             <span class="keyword">for</span> step := k - <span class="number">1</span>; step &lt;= k + <span class="number">1</span>; step++ &#123;</span><br><span class="line">                <span class="comment">//  如[0,1,3,5,6,8,12,17] 1 点能跳 0，1， 2 共3种距离 只有2跳到了 3里面  </span></span><br><span class="line">                 <span class="keyword">if</span> step &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 跳的距离大于0 且 跳到数组中存在的位置 </span></span><br><span class="line">                    <span class="keyword">if</span> _, <span class="attr">ok</span> := dp[stones[i] + step]; ok &#123;</span><br><span class="line">                        <span class="comment">// 则更新这个位置，dp【1】【0】 = 1</span></span><br><span class="line">                        dp[stones[i] + step][i] = step</span><br><span class="line">                    &#125;           </span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  len(dp[stones[len(stones)-<span class="number">1</span>]]) != <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func findLength(A []int, B []int) int &#123;</span><br><span class="line">    m := len(A)</span><br><span class="line">    n := len(B)</span><br><span class="line">    dp := make([][]int, m + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m + <span class="number">1</span>; i++ &#123;</span><br><span class="line">        dp[i] = make([]int, n + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">for</span> j := n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">            <span class="keyword">if</span> A[i] == B[j] &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; dp[i][j] = <span class="number">0</span> &#125;</span><br><span class="line">            <span class="keyword">if</span> res &lt; dp[i][j] &#123;</span><br><span class="line">                res = dp[i][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">滑动窗口解法</span><br><span class="line">func findLength(A []int, B []int) int &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    m := len(A)</span><br><span class="line">    n := len(B)</span><br><span class="line">    <span class="comment">// 一个不动，一个动</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        win := min(n, m - i)</span><br><span class="line">        res = max(res, handle(A, B, i, <span class="number">0</span>, win))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        win := min(m, n - i)</span><br><span class="line">        res = max(res, handle(A, B, <span class="number">0</span>, i, win))</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handle(A, B []int, sA, sB, win int) int &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    tmp := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; win; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> A[sA + i] == B[sB + i] &#123;</span><br><span class="line">            tmp++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, tmp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长上升子序"><a href="#最长上升子序" class="headerlink" title="最长上升子序"></a>最长上升子序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func lengthOfLIS(nums []int) int &#123;</span><br><span class="line">    dp := make([]int, len(nums))</span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(nums); i++ &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j] &#123;</span><br><span class="line">                <span class="keyword">if</span> dp[j] + <span class="number">1</span> &gt; dp[i] &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> dp[i] &gt; res &#123; res = dp[i]&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">二分查找+贪心</span><br><span class="line"><span class="comment">// 初始化一个n+1的数组，从1位置开始计算，最终的位置就是长度</span></span><br><span class="line">func lengthOfLIS(nums []int) int &#123;</span><br><span class="line">    d := make([]int, len(nums) + <span class="number">1</span>)</span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="comment">// 1的位置就是数字0</span></span><br><span class="line">    d[res] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(nums); i++ &#123;</span><br><span class="line">        <span class="comment">// 遍历数组，如果数字大于d的最后一位就是放进去，是递增的</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; d[res] &#123;</span><br><span class="line">            res++</span><br><span class="line">            d[res] = nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不大于，就在d里面二分查找，比nums【i】小的，最靠近nums[i]的位置</span></span><br><span class="line">            s, e, <span class="attr">p</span> := <span class="number">1</span>, res, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> s &lt;= e &#123;</span><br><span class="line">                mid := s + (e - s) &gt;&gt; <span class="number">1</span></span><br><span class="line">                <span class="comment">// 大于就更新p</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; d[mid] &#123;</span><br><span class="line">                    s = mid + <span class="number">1</span></span><br><span class="line">                    p = mid</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    e = mid - <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到后下一位就往里插入</span></span><br><span class="line">            d[p + <span class="number">1</span>] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 也就是大于的往后放，小于的往前插入</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">股票<span class="number">1</span>：只买卖一次</span><br><span class="line">func maxProfit(prices []int) int &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    cur := prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] - cur &lt; <span class="number">0</span> &#123;</span><br><span class="line">            cur = prices[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> prices[i] - cur &gt; res &#123;</span><br><span class="line">            res = prices[i] - cur</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">股票<span class="number">2</span>：无限买卖</span><br><span class="line">func maxProfit(prices []int) int &#123;</span><br><span class="line">    dp := make([][<span class="number">2</span>]int, len(prices))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        dp[i] = [<span class="number">2</span>]int&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0 卖出，1买入</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>]- prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>] )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(dp[len(prices) - <span class="number">1</span>][<span class="number">0</span>], dp[len(prices) - <span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">求累计和</span><br><span class="line">func maxProfit(prices []int) int &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &gt; prices[i - <span class="number">1</span>] &#123;</span><br><span class="line">            res += prices[i] - prices[i-<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">股票<span class="number">3</span>：最多交易<span class="number">2</span>次，三维，第二个是交易次数</span><br><span class="line">func maxProfit(prices []int) int &#123;</span><br><span class="line">    dp := make([][<span class="number">3</span>][<span class="number">2</span>]int, len(prices))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        dp[i] = [<span class="number">3</span>][<span class="number">2</span>]int&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">            dp[i][j] = [<span class="number">2</span>]int&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="number">3</span>;j++ &#123;</span><br><span class="line">            dp[i][j][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i])</span><br><span class="line">            dp[i][j][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i] )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len(prices) - <span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">股票<span class="number">4</span>：最多交易k次</span><br><span class="line">func maxProfit(k int, prices []int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> len(prices) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp := make([][][<span class="number">2</span>]int, len(prices))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        dp[i] = make([][<span class="number">2</span>]int, k + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++ &#123;</span><br><span class="line">            dp[i][j] = [<span class="number">2</span>]int&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++ &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++ &#123;</span><br><span class="line">            dp[i][j][<span class="number">0</span>] = max(dp[i- <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i])</span><br><span class="line">            dp[i][j][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len(prices) - <span class="number">1</span>][k][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123; </span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">股票<span class="number">5</span>：冷冻期，第i天持有买入，则前一天是冷冻期，所以从前两天卖出来看，所以要初始化第<span class="number">0</span>天，第<span class="number">1</span>天的</span><br><span class="line">func maxProfit(prices []int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> len(prices) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp := make([][<span class="number">3</span>]int, len(prices))</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = max(<span class="number">0</span>, prices[<span class="number">1</span>] - prices[<span class="number">0</span>])</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = max(-prices[<span class="number">1</span>], -prices[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len(prices) - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">股票<span class="number">6</span>：手续费， 如果当天卖出，前一天买入的话，则需要扣除手续费</span><br><span class="line">func maxProfit(prices []int, fee int) int &#123;</span><br><span class="line">    dp := make([][<span class="number">2</span>]int, len(prices))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        dp[i] = [<span class="number">2</span>]int&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee)</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len(prices) - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法</title>
    <url>/2021/04/01/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>分成两个数组，对每个数组进行递归排序，不断递归，最后得到排好序的 数组</p>
<p>先处理排序，再递归</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">quickSort</span>(<span class="params">q []int, l, r int</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 递归终止条件</span></span><br><span class="line">	<span class="keyword">if</span> l &gt;= r &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	x := q[(l+r)&gt;&gt;<span class="number">1</span>] <span class="comment">// 确定分界点，从中间开始</span></span><br><span class="line">	i, <span class="attr">j</span> := l-<span class="number">1</span>, r+<span class="number">1</span> <span class="comment">// 两个指针，因为do while要先自增/自减</span></span><br><span class="line">	<span class="comment">// ，大的放右边，小的放左边</span></span><br><span class="line">	<span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			i++</span><br><span class="line">			<span class="comment">// 碰到大于的就停止</span></span><br><span class="line">			<span class="keyword">if</span> q[i] &gt;= x &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			j--</span><br><span class="line">			<span class="comment">// 碰到小于的就停止</span></span><br><span class="line">			<span class="keyword">if</span> q[j] &lt;= x &#123; <span class="keyword">break</span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i &lt; j &#123; <span class="comment">// swap 两个元素</span></span><br><span class="line">			q[i], q[j] = q[j], q[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 递归处理左右两段</span></span><br><span class="line">	quickSort(q, l, j) </span><br><span class="line">	quickSort(q, j+<span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间：O(nlogn)<br>空间：O(n)<br>稳定</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>分治思想与快排相反，先排，再合并，先递归在合并</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func <span class="function"><span class="title">merge_sort</span>(<span class="params">nums []int, left, right int</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left &gt;= right &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">	<span class="comment">// 找中间位置</span></span><br><span class="line">	mid := (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">	<span class="comment">// 左右排序</span></span><br><span class="line">	merge_sort1(nums, left, mid)</span><br><span class="line">	merge_sort1(nums, mid+<span class="number">1</span>, right)</span><br><span class="line">	<span class="comment">//合并</span></span><br><span class="line">	tmp := []int&#123;&#125;</span><br><span class="line">	<span class="comment">// 左右的起始位置</span></span><br><span class="line">	i, <span class="attr">j</span> := left, mid+<span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i &lt;= mid &amp;&amp; j &lt;= right &#123;</span><br><span class="line">		<span class="comment">// 比较两个指针的位置，放入新数组</span></span><br><span class="line">		<span class="keyword">if</span> nums[i] &lt;= nums[j] &#123;</span><br><span class="line">			tmp = append(tmp, nums[i])</span><br><span class="line">			i++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tmp = append(tmp, nums[j])</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 没排完的，放到后面</span></span><br><span class="line">	<span class="keyword">if</span> i &lt;= mid &#123;</span><br><span class="line">		tmp = append(tmp, nums[i:mid+<span class="number">1</span>]...)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果使用...运算符，可以将一个切片的所有元素追加到另一个切片里</span></span><br><span class="line">		tmp = append(tmp, nums[j:right+<span class="number">1</span>]...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 放到nums里</span></span><br><span class="line">	copy(nums[left:right+<span class="number">1</span>], tmp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间： O(nlogn)<br>空间：O(n) 临时数组加递归深度<br>稳定</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>将数组生成大顶堆，或者小顶堆，再逐步取出堆顶元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func heap_sort(nums []int) []int &#123;</span><br><span class="line">    lens := len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 建堆 O(n) lens/2后面都是叶子节点，不需要向下调整</span></span><br><span class="line">    <span class="keyword">for</span> i := lens/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i -- &#123; </span><br><span class="line">        down(nums, i, lens)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := lens; j &gt;= <span class="number">1</span>; j -- &#123;</span><br><span class="line">    	<span class="comment">// 将最大值放到后面</span></span><br><span class="line">        nums[<span class="number">0</span>], nums[j] = nums[j], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 最后一位已经是最大值，调整之前的值</span></span><br><span class="line">        lens --</span><br><span class="line">        down(nums, <span class="number">0</span>, lens)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//O(logn)大根堆，如果堆顶节点小于叶子，向下调整</span></span><br><span class="line">func <span class="function"><span class="title">down</span>(<span class="params">nums []int, i, lens int</span>)</span> &#123; </span><br><span class="line">	<span class="comment">// 当前值是最大值</span></span><br><span class="line">    max := i </span><br><span class="line">    <span class="comment">// 如果他的左节点大于最大值</span></span><br><span class="line">    <span class="keyword">if</span> i&lt;&lt;<span class="number">1</span>+<span class="number">1</span> &lt;= lens &amp;&amp; nums[i&lt;&lt;<span class="number">1</span>+<span class="number">1</span>] &gt; nums[max] &#123;</span><br><span class="line">    	<span class="comment">// 则最大值等于子节点</span></span><br><span class="line">        max = i&lt;&lt;<span class="number">1</span>+<span class="number">1</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 如果他的右节点大于最大值</span></span><br><span class="line">    <span class="keyword">if</span> i&lt;&lt;<span class="number">1</span>+<span class="number">2</span> &lt;= lens &amp;&amp; nums[i&lt;&lt;<span class="number">1</span>+<span class="number">2</span>] &gt; nums[max] &#123;</span><br><span class="line">        max = i&lt;&lt;<span class="number">1</span> + <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果最大值发生变化，则交换两个位置</span></span><br><span class="line">    <span class="keyword">if</span> max != i &#123;</span><br><span class="line">        nums[max], nums[i] = nums[i], nums[max]</span><br><span class="line">        <span class="comment">// 递归向下调整</span></span><br><span class="line">        down(nums, max, lens)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间: O(nlogn)<br>空间：O(1）<br>不稳定</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>当前循环的值为最小值，内层循环遍历后面的，后面的小于最小值，找到一个最小的，最后交换位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">select_sort</span>(<span class="params">q []int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(q) - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        minIndex := i</span><br><span class="line">        <span class="keyword">for</span> j := i;j &lt; len(q); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> q[j] &lt; q[minIndex] &#123;</span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q[i], q[minIndex] = q[minIndex], q[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n ^2)<br>空间复杂度:O(1)<br>不稳定</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>两两交换，保证最后一个是最大值，然后第二次遍历就到最后一个的前面截止</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">bubbleSort</span>(<span class="params">q []int</span>)</span> &#123;</span><br><span class="line">    n := len(q)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        exchange := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n-<span class="number">1</span>-i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> q[j] &gt; q[j+<span class="number">1</span>] &#123;</span><br><span class="line">                q[j], q[j+<span class="number">1</span>] = q[j+<span class="number">1</span>], q[j]</span><br><span class="line">                exchange = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !exchange &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n ^2)<br>空间复杂度:O(1)<br>稳定</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func insertSort(nums []int) []int &#123;</span><br><span class="line">	n := len(nums)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">		tmp := nums[i]</span><br><span class="line">		j := i - <span class="number">1</span></span><br><span class="line">		<span class="comment">//左边比右边大</span></span><br><span class="line">		<span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; tmp &#123; </span><br><span class="line">			<span class="comment">//右边的数就等于前一个数，最后大于tmp的都被j+1赋值，相当于右移</span></span><br><span class="line">			nums[j+<span class="number">1</span>] = nums[j] </span><br><span class="line">			j--                 <span class="comment">//到前一个数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 上一步比tmp大的 都右移过去之后，小于tmp的右边</span></span><br><span class="line">		nums[j+<span class="number">1</span>] = tmp</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n ^2)<br>空间复杂度:O(1)<br>稳定</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>插入排序的优化，长度/2，再次/4</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">shell_sort</span>(<span class="params">q []int</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 先排n/2，后面的排好，再排n/4</span></span><br><span class="line">    <span class="keyword">for</span> k := len(q) / <span class="number">2</span>; k &gt; <span class="number">0</span>; k /= <span class="number">2</span> &#123;</span><br><span class="line">    	<span class="comment">// 从k开始往后，插入排序</span></span><br><span class="line">        <span class="keyword">for</span> i := k; i &lt; len(q); i++ &#123;</span><br><span class="line">            tmp := q[i]</span><br><span class="line">            j := i - k</span><br><span class="line">            <span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; tmp &lt; q[j] &#123;</span><br><span class="line">                q[j+k] = q[j]</span><br><span class="line">                j -= k</span><br><span class="line">            &#125;</span><br><span class="line">           q[j+k] = tmp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(nlogn)<br>空间复杂度: O(1)<br>不稳定</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>找出最大值即可，然后从1到最大值生成map，有值记为1，没有的记为0</p>
<p>然后继续0到最大值，遍历，从字典取值，就是按顺序取的，按顺序放到数组里</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">qSort</span>(<span class="params">q []int</span>)</span> &#123;</span><br><span class="line">    v := [<span class="number">10001</span>]int&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(q); i++&#123;</span><br><span class="line">        v[<span class="number">5000</span>+q[i]]++</span><br><span class="line">    &#125;</span><br><span class="line">    idx := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10001</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> v[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            q[idx] = i - <span class="number">5000</span></span><br><span class="line">            idx++</span><br><span class="line">            v[i]--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n+k)<br>空间复杂度:O(k)<br>稳定排序</p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">bin_sort</span>(<span class="params">li []int, bin_num int</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 找最大值，找最小值</span></span><br><span class="line">    min_num, <span class="attr">max_num</span> := li[<span class="number">0</span>], li[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(li); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> min_num &gt; li[i] &#123;</span><br><span class="line">            min_num = li[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> max_num &lt; li[i] &#123;</span><br><span class="line">            max_num = li[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 捅数，生成捅</span></span><br><span class="line">    bin := make([][]int, bin_num)</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; len(li); j++ &#123;</span><br><span class="line">    	<span class="comment">// 计算捅的位置，减去最小值，除以 （最大值-最小值+1）/桶数</span></span><br><span class="line">        n := (li[j] - min_num) / ((max_num - min_num + <span class="number">1</span>) / bin_num)</span><br><span class="line">        <span class="comment">// 加入捅</span></span><br><span class="line">        bin[n] = append(bin[n], li[j])</span><br><span class="line">        <span class="comment">// ，每个捅排序，插入排序</span></span><br><span class="line">        k := len(bin[n]) - <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> k &gt;= <span class="number">0</span> &amp;&amp; li[j] &lt; bin[n][k] &#123;</span><br><span class="line">            bin[n][k+<span class="number">1</span>] = bin[n][k]</span><br><span class="line">            k--</span><br><span class="line">        &#125;</span><br><span class="line">        bin[n][k+<span class="number">1</span>] = li[j]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排好序后给到结果</span></span><br><span class="line">    o := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> p, <span class="attr">q</span> := range bin &#123;</span><br><span class="line">        <span class="keyword">for</span> t := <span class="number">0</span>; t &lt; len(q); t++ &#123;</span><br><span class="line">            li[o] = bin[p][t]</span><br><span class="line">            o++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n+k)<br>空间复杂度: O(n+k)<br>稳定</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>个位，十位，百位排序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">radix_sort</span>(<span class="params">li []int</span>)</span> &#123;</span><br><span class="line">    max_num := li[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(li); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> max_num &lt; li[i] &#123;</span><br><span class="line">            max_num = li[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; len(strconv.Itoa(max_num)); j++ &#123;</span><br><span class="line">        bin := make([][]int, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; len(li); k++ &#123;</span><br><span class="line">            n := li[k] / int(math.Pow(<span class="number">10</span>, float64(j))) % <span class="number">10</span></span><br><span class="line">            bin[n] = append(bin[n], li[k])</span><br><span class="line">        &#125;</span><br><span class="line">        m := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p := <span class="number">0</span>; p &lt; len(bin); p++ &#123;</span><br><span class="line">            <span class="keyword">for</span> q := <span class="number">0</span>; q &lt; len(bin[p]); q++ &#123;</span><br><span class="line">                li[m] = bin[p][q]</span><br><span class="line">                m++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(kn)<br>空间复杂度: O(n+k)<br>稳定</p>
<h3 id="翻转对"><a href="#翻转对" class="headerlink" title="翻转对"></a>翻转对</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func reversePairs(nums []int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span> &#123; <span class="comment">// 没有元素，没有翻转对</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    count := <span class="number">0</span> <span class="comment">// 翻转对个数</span></span><br><span class="line">    mergeSort(nums, &amp;count, <span class="number">0</span>, len(nums)-<span class="number">1</span>) <span class="comment">// 归并的范围：0到末尾</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对当前的序列（start到end）进行归并排序</span></span><br><span class="line">func <span class="function"><span class="title">mergeSort</span>(<span class="params">nums []int, count *int, start, end int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> start == end &#123; <span class="comment">// 递归的出口：不能再二分了，返回</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    mid := start + (end-start)&gt;&gt;<span class="number">1</span> <span class="comment">// 当前序列的中点索引</span></span><br><span class="line"></span><br><span class="line">    mergeSort(nums, count, start, mid) <span class="comment">// 递归左序列</span></span><br><span class="line">    mergeSort(nums, count, mid+<span class="number">1</span>, end) <span class="comment">// 递归右序列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时左右序列已升序，现在做：合并前的统计、以及合并</span></span><br><span class="line">    i := start                 <span class="comment">// 左序列的开头</span></span><br><span class="line">    j := mid + <span class="number">1</span>               <span class="comment">// 右序列的开头</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;= mid &amp;&amp; j &lt;= end &#123; <span class="comment">// i j 都不越界</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">2</span>*nums[j] &#123;</span><br><span class="line">            *count += mid - i + <span class="number">1</span> <span class="comment">// i 到 mid，都ok</span></span><br><span class="line">            j++                   <span class="comment">// 考察下一个j，继续找 i</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                  <span class="comment">// 当前i不满足，考察下一个i</span></span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i = start  </span><br><span class="line">    j = mid + <span class="number">1</span> <span class="comment">// 复原 i j 指针，因为现在要合并左右序列</span></span><br><span class="line"></span><br><span class="line">    temp := make([]int, end-start+<span class="number">1</span>) <span class="comment">// 辅助数组，存放合并排序的数</span></span><br><span class="line">    index := <span class="number">0</span>                       <span class="comment">// 从0开始</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;= mid &amp;&amp; j &lt;= end &#123;       <span class="comment">// 如果 i j 都没越界</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[j] &#123;    <span class="comment">// nums[i]更小</span></span><br><span class="line">            temp[index] = nums[i] <span class="comment">// 取nums[i]，确定了temp[index]</span></span><br><span class="line">            index++               <span class="comment">// 确定下一个</span></span><br><span class="line">            i++                   <span class="comment">// 考察下一个i，j不动</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[index] = nums[j]</span><br><span class="line">            index++</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i &lt;= mid &#123;            <span class="comment">// 如果 i 没越界，j越界了</span></span><br><span class="line">        temp[index] = nums[i] <span class="comment">// i 和 i右边的都取过来</span></span><br><span class="line">        index++               <span class="comment">// 确定下一个数</span></span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j &lt;= end &#123;            <span class="comment">// j 没越界，i越界了</span></span><br><span class="line">        temp[index] = nums[j] <span class="comment">// j 和 j右边的都取过来</span></span><br><span class="line">        index++               <span class="comment">// 确定下一个数</span></span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    k := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := start; i &lt;= end; i++ &#123; <span class="comment">// 根据合并后的情况，更新nums</span></span><br><span class="line">        nums[i] = temp[k]</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>双向BFS</title>
    <url>/2021/03/26/%E5%8F%8C%E5%90%91BFS/</url>
    <content><![CDATA[<h3 id="DFS模板"><a href="#DFS模板" class="headerlink" title="DFS模板"></a>DFS模板</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深度优先，栈遍历</span></span><br><span class="line">func <span class="function"><span class="title">dfs</span>(<span class="params">root *TreeNode</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// root不存在则返回</span></span><br><span class="line">	<span class="keyword">if</span> root == nil &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> dfs func()</span><br><span class="line">	dfs = <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> visit[root] &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		visit[root] = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> i := range root.Children &#123;</span><br><span class="line">			<span class="keyword">if</span> !visit[i] &#123;</span><br><span class="line">				dfs(i)</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="BFS模板"><a href="#BFS模板" class="headerlink" title="BFS模板"></a>BFS模板</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 广度优先，队列遍历</span></span><br><span class="line">func <span class="function"><span class="title">bfs</span>(<span class="params">root *TreeNode</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// root不存在则返回</span></span><br><span class="line">	<span class="keyword">if</span> root == nil &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 手动维护一个队列，初始化，并放入root，还有一个visited的map</span></span><br><span class="line">	q := []*TreeNode&#123;root&#125;</span><br><span class="line">	visited := map[*TreeNode]bool&#123;&#125;</span><br><span class="line"> 	<span class="comment">// 未访问则记录,处理当前层</span></span><br><span class="line"> 	<span class="keyword">for</span> len(q) &gt; <span class="number">0</span> &#123;</span><br><span class="line"> 		<span class="comment">// 节点出队</span></span><br><span class="line"> 		node := q[<span class="number">0</span>]</span><br><span class="line"> 		q = q[<span class="number">1</span>:]</span><br><span class="line"> 		<span class="comment">// 访问记录</span></span><br><span class="line"> 		visited[node] = <span class="literal">true</span></span><br><span class="line"> 		<span class="comment">// 处理逻辑</span></span><br><span class="line"> 		process(node)</span><br><span class="line"> 		<span class="comment">// 更新q，更新node</span></span><br><span class="line"> 		nodes = related(node)</span><br><span class="line"> 		q = append(q, nodes...)</span><br><span class="line"> 	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="双向BFS模板"><a href="#双向BFS模板" class="headerlink" title="双向BFS模板"></a>双向BFS模板</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向bfs</span></span><br><span class="line">func <span class="function"><span class="title">tebfs</span>(<span class="params">root *TreeNode</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 开始队列</span></span><br><span class="line">	startQ := []interface&#123;&#125;</span><br><span class="line">	<span class="comment">// 结束队列</span></span><br><span class="line">	endQ := []interface&#123;&#125;</span><br><span class="line">	<span class="comment">// 开始使用过的记录</span></span><br><span class="line">	visitedStart := map[int]bool</span><br><span class="line">	<span class="comment">// 结束使用记录</span></span><br><span class="line">	visitedEnd := map[int]bool</span><br><span class="line">	<span class="comment">// 全局使用记录</span></span><br><span class="line">	visited := map[int]bool</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 遍历</span></span><br><span class="line">	<span class="keyword">for</span> len(startQ) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 遍历开始队列</span></span><br><span class="line">		qLen := len(startQ)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; qLen; i++ &#123;</span><br><span class="line">			cur := q[<span class="number">0</span>]</span><br><span class="line">			q = q[<span class="number">1</span>:]</span><br><span class="line">			<span class="comment">// 处理逻辑</span></span><br><span class="line">			process()</span><br><span class="line">			<span class="comment">// 开始记录处理</span></span><br><span class="line">			visitedStart()</span><br><span class="line">			<span class="comment">// 放入队列</span></span><br><span class="line">			startQ = append(startQ, ...)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 层遍历完处理逻辑,互换队列，互换记录map</span></span><br><span class="line">		<span class="keyword">if</span> len(startQ) &gt; <span class="function"><span class="title">len</span>(<span class="params">endQ</span>)</span> &#123;</span><br><span class="line">			startQ, endQ = endQ, startQ</span><br><span class="line">			visitedStart, visitedEnd = visitedEnd, visitedStart</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="A-模板"><a href="#A-模板" class="headerlink" title="A* 模板"></a>A* 模板</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">ASearch</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 初始化优先队列</span></span><br><span class="line">	pq = priorityQ()</span><br><span class="line"></span><br><span class="line">	pq =append(pq, start) <span class="comment">// 获取优先队列</span></span><br><span class="line"></span><br><span class="line">	visited := map[int]bool&#123;<span class="attr">start</span> : <span class="literal">true</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> len(pq) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		node := pq.get() <span class="comment">// 根据优先级获取</span></span><br><span class="line">		visited[node] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">		process()</span><br><span class="line">		<span class="comment">// 添加进队列</span></span><br><span class="line">		pq = append(node.next)</span><br><span class="line">	&#125; 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a>单词接龙</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ladderLength </span></span><br><span class="line"><span class="comment">// 单向bfs</span></span><br><span class="line">func ladderLength(beginWord string, endWord string, wordList []string) int &#123;</span><br><span class="line">    vis := make(map[string]bool, len(wordList))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(wordList); i++ &#123;</span><br><span class="line">        vis[wordList[i]] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化队列</span></span><br><span class="line">    q := []string&#123;beginWord&#125;</span><br><span class="line">    <span class="comment">// count是for之后++</span></span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> len(q) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    	<span class="comment">// 记录当前队列长度，遍历当前队列，q长度会变</span></span><br><span class="line">        qLen := len(q)</span><br><span class="line">        <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; qLen; k++ &#123;</span><br><span class="line">        	<span class="comment">// 出队</span></span><br><span class="line">            cur := q[<span class="number">0</span>]</span><br><span class="line">            q = q[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> cur == endWord &#123;</span><br><span class="line">                <span class="keyword">return</span> count</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(cur); i++ &#123;</span><br><span class="line">                <span class="keyword">for</span> j := <span class="string">&#x27;a&#x27;</span>; j &lt;= <span class="string">&#x27;z&#x27;</span>; j++ &#123;</span><br><span class="line">                	<span class="comment">// 得到新单词</span></span><br><span class="line">                    newWord := cur[:i] + string(j) + cur[i+<span class="number">1</span>:]</span><br><span class="line">                    <span class="comment">// 在map里</span></span><br><span class="line">                    <span class="keyword">if</span> vis[newWord] &#123;</span><br><span class="line">                        q = append(q, newWord)</span><br><span class="line">                        vis[newWord] = <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count++ </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向bfs</span></span><br><span class="line">func ladderLength(beginWord string, endWord string, wordList []string) int &#123;</span><br><span class="line">	<span class="comment">// 初始化startq， endq</span></span><br><span class="line">    startQ := []string&#123;beginWord&#125;</span><br><span class="line">    endQ := []string&#123;endWord&#125;</span><br><span class="line">    <span class="comment">// 初始化从前从后的两个map，记录是否使用过</span></span><br><span class="line">    visStart := make(map[string]bool, len(wordList))</span><br><span class="line">    visEnd := make(map[string]bool, len(wordList))</span><br><span class="line">    <span class="comment">// end是最终结果</span></span><br><span class="line">    visEnd[endWord] = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 单词map，用于判断是不是在库里</span></span><br><span class="line">    vis := make(map[string]bool, len(wordList))</span><br><span class="line">    <span class="keyword">for</span> _, <span class="attr">v</span> := range wordList &#123;</span><br><span class="line">        vis[v] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果结尾不在库里，返回0</span></span><br><span class="line">    <span class="keyword">if</span> _, <span class="attr">ok</span> := vis[endWord]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// count是for之后++</span></span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">    <span class="comment">// 遍历队列</span></span><br><span class="line">    <span class="keyword">for</span> len(startQ) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        qLen := len(startQ)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; qLen; i++ &#123;</span><br><span class="line">        	<span class="comment">// 出队</span></span><br><span class="line">            cur := startQ[<span class="number">0</span>]</span><br><span class="line">            startQ = startQ[<span class="number">1</span>:]</span><br><span class="line">            <span class="comment">// 拼新单词</span></span><br><span class="line">            <span class="keyword">for</span> c := <span class="number">0</span>; c &lt; len(cur); c++ &#123;</span><br><span class="line">                <span class="keyword">for</span> j := <span class="string">&#x27;a&#x27;</span>; j &lt;= <span class="string">&#x27;z&#x27;</span>; j++ &#123;</span><br><span class="line">                    <span class="keyword">new</span> := cur[:c] + string(j) + cur[c+<span class="number">1</span>:]</span><br><span class="line">                    <span class="comment">// 如果不在库里，或者起始的记录过则跳过</span></span><br><span class="line">                    <span class="keyword">if</span> !vis[<span class="keyword">new</span>] || visStart[<span class="keyword">new</span>] &#123;</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果在结束的map里，这说明匹配到了</span></span><br><span class="line">                    <span class="keyword">if</span> visEnd[<span class="keyword">new</span>] &#123;</span><br><span class="line">                        <span class="keyword">return</span> count + <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 加入队列，记录start</span></span><br><span class="line">                    startQ = append(startQ, <span class="keyword">new</span>)</span><br><span class="line">                    visStart[<span class="keyword">new</span>] = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 层级遍历完++</span></span><br><span class="line">        count++</span><br><span class="line">        <span class="comment">// 互换队列，保证每次遍历的队列长度最小，互换记录</span></span><br><span class="line">        <span class="comment">// 每次遍历都是 startq</span></span><br><span class="line">        <span class="keyword">if</span> len(startQ) &gt; <span class="function"><span class="title">len</span>(<span class="params">endQ</span>)</span> &#123;</span><br><span class="line">            startQ, endQ = endQ, startQ</span><br><span class="line">            visStart, visEnd = visEnd, visStart</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="最小基因变化"><a href="#最小基因变化" class="headerlink" title="最小基因变化"></a>最小基因变化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// minMutation ...</span></span><br><span class="line"><span class="comment">// 单向bfs</span></span><br><span class="line">func minMutation(start string, end string, bank []string) int &#123;</span><br><span class="line">    vis := make(map[string]bool, len(bank))</span><br><span class="line">    <span class="comment">// 判断是否重复，避免死循环</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(bank); i++ &#123;</span><br><span class="line">        vis[bank[i]] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    q := []string&#123;start&#125;</span><br><span class="line">    item := []string&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;T&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 这是转换次数，单词接龙是单词数目，注意</span></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> len(q) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        qLen := len(q)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; qLen; i++ &#123;</span><br><span class="line">        	<span class="comment">// 出队</span></span><br><span class="line">            cur := q[<span class="number">0</span>]</span><br><span class="line">            q = q[<span class="number">1</span>:]</span><br><span class="line">            <span class="comment">// 找到结果</span></span><br><span class="line">            <span class="keyword">if</span> cur == end &#123;</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 循环每个字符</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(cur); i++ &#123;</span><br><span class="line">                <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">4</span>; j++ &#123;</span><br><span class="line">                    <span class="keyword">new</span> := cur[:i] + item[j] + cur[i+<span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">if</span> vis[<span class="keyword">new</span>] &#123;</span><br><span class="line">                        q = append(q, <span class="keyword">new</span>)</span><br><span class="line">                        vis[<span class="keyword">new</span>] = <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历完一层，结果++</span></span><br><span class="line">        res++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向bfs</span></span><br><span class="line">func minMutation(start string, end string, bank []string) int &#123;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	startQ := []string&#123;start&#125;</span><br><span class="line">    endQ := []string&#123;end&#125;</span><br><span class="line"></span><br><span class="line">    visStart := make(map[string]bool, len(bank))</span><br><span class="line">    visEnd := make(map[string]bool, len(bank))</span><br><span class="line">    visEnd[end] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断end在不在库，初始化库</span></span><br><span class="line">    vis := make(map[string]bool, len(bank))</span><br><span class="line">    <span class="keyword">for</span> _, <span class="attr">v</span> := range bank &#123;</span><br><span class="line">        vis[v] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, <span class="attr">ok</span> := vis[end];!ok &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可更改字符</span></span><br><span class="line">    item := []string&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;T&quot;</span>&#125;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> len(startQ) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        qLen := len(startQ)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; qLen; i++ &#123;</span><br><span class="line">            cur := startQ[<span class="number">0</span>]</span><br><span class="line">            startQ = startQ[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">for</span> c := <span class="number">0</span>; c &lt; len(cur); c++ &#123;</span><br><span class="line">                <span class="keyword">for</span> _, <span class="attr">v</span> := range item &#123;</span><br><span class="line">                    <span class="keyword">new</span> := cur[:c] + v + cur[c+<span class="number">1</span>:]</span><br><span class="line">                    <span class="comment">// 不在库里，或者已使用过则跳过</span></span><br><span class="line">                    <span class="keyword">if</span> !vis[<span class="keyword">new</span>] || visStart[<span class="keyword">new</span>] &#123;</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 在结束里，返回结果+1</span></span><br><span class="line">                    <span class="keyword">if</span> visEnd[<span class="keyword">new</span>] &#123;</span><br><span class="line">                        <span class="keyword">return</span> res + <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    startQ = append(startQ, <span class="keyword">new</span>)</span><br><span class="line">                    visStart[<span class="keyword">new</span>] = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res++</span><br><span class="line">        <span class="comment">// 互换队列</span></span><br><span class="line">        <span class="keyword">if</span> len(startQ) &gt; <span class="function"><span class="title">len</span>(<span class="params">endQ</span>)</span> &#123;</span><br><span class="line">            startQ, endQ = endQ, startQ</span><br><span class="line">            visStart, visEnd = visEnd, visStart</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数独问题"><a href="#数独问题" class="headerlink" title="数独问题"></a>数独问题</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// isValidSudoku</span></span><br><span class="line"><span class="comment">// 遍历通过map判断字符是否已经使用过</span></span><br><span class="line"><span class="comment">// 外层i，里层j， ij顺序代表一行一行遍历， ji顺序代表一列一列遍历</span></span><br><span class="line"><span class="comment">// 分块 行(i%3)*3 + j%3 列(i/3)*3 + j/3，得到的是一块9个的索引</span></span><br><span class="line">func isValidSudoku(board [][]byte) bool &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9</span>; i++ &#123;</span><br><span class="line">        visr := make(map[byte]bool, <span class="number">9</span>)</span><br><span class="line">        visc := make(map[byte]bool, <span class="number">9</span>)</span><br><span class="line">        visb := make(map[byte]bool, <span class="number">9</span>)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">9</span>; j++ &#123;</span><br><span class="line">            <span class="comment">// 行 ij</span></span><br><span class="line">            <span class="keyword">if</span> board[i][j] != <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> visr[board[i][j]] &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">                visr[board[i][j]] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 列 ji</span></span><br><span class="line">            <span class="keyword">if</span> board[j][i] != <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> visc[board[j][i]] &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">                visc[board[j][i]] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 分块</span></span><br><span class="line">            row := (i%<span class="number">3</span>)*<span class="number">3</span> + j%<span class="number">3</span></span><br><span class="line">            col := (i/<span class="number">3</span>)*<span class="number">3</span> + j/<span class="number">3</span></span><br><span class="line">            <span class="keyword">if</span> board[row][col] != <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> visb[board[row][col]] &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">                visb[board[row][col]] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// solveSudoku</span></span><br><span class="line"><span class="comment">// 递归回溯</span></span><br><span class="line">func <span class="function"><span class="title">solveSudoku</span>(<span class="params">board [][]byte</span>)</span>  &#123;</span><br><span class="line">	<span class="comment">// 初始化，通过每一行的索引数字判断（每一列同理）</span></span><br><span class="line">    <span class="keyword">var</span> visr, visc [<span class="number">9</span>][<span class="number">9</span>]bool</span><br><span class="line">    <span class="comment">// 初始化块的，块的索引，以及里面的数字的索引判断</span></span><br><span class="line">    <span class="keyword">var</span> visb [<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>]bool</span><br><span class="line">    <span class="comment">// 初始化需要填入的点</span></span><br><span class="line">    <span class="keyword">var</span> spaces [][<span class="number">2</span>]int</span><br><span class="line">    <span class="comment">// 预处理数据</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">9</span>; j++ &#123;</span><br><span class="line">        	<span class="comment">// 需要填入的点加入列表</span></span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">                spaces = append(spaces, [<span class="number">2</span>]int&#123;i, j&#125;)</span><br><span class="line">            <span class="comment">// 不需要填入的点，根据位置设置true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// byte转int，-1</span></span><br><span class="line">                b := board[i][j] - <span class="string">&#x27;1&#x27;</span></span><br><span class="line">                visr[i][b] = <span class="literal">true</span></span><br><span class="line">                visc[j][b] = <span class="literal">true</span></span><br><span class="line">                visb[i/<span class="number">3</span>][j/<span class="number">3</span>][b] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归函数</span></span><br><span class="line">    <span class="keyword">var</span> dfs func(n int) bool</span><br><span class="line">    dfs= func(n int) bool &#123;</span><br><span class="line">    	<span class="comment">// 遍历到最后一个点结束后，终止</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="function"><span class="title">len</span>(<span class="params">spaces</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取要填入的点</span></span><br><span class="line">        i, <span class="attr">j</span> := spaces[n][<span class="number">0</span>], spaces[n][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> k := byte(<span class="number">0</span>); k &lt; <span class="number">9</span>; k++ &#123;</span><br><span class="line">        	<span class="comment">// 判断是否已经使用过，有则跳过</span></span><br><span class="line">            <span class="keyword">if</span> visr[i][k] || visc[j][k] || visb[i/<span class="number">3</span>][j/<span class="number">3</span>][k] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有记录</span></span><br><span class="line">            board[i][j] = k + <span class="string">&#x27;1&#x27;</span></span><br><span class="line">            visr[i][k] = <span class="literal">true</span></span><br><span class="line">            visc[j][k] = <span class="literal">true</span></span><br><span class="line">            visb[i/<span class="number">3</span>][j/<span class="number">3</span>][k] = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 递归下一个点，如果下一个点返回true，则返回true</span></span><br><span class="line">            <span class="keyword">if</span> <span class="function"><span class="title">dfs</span>(<span class="params">n + <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            board[i][j] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">            visr[i][k] = <span class="literal">false</span></span><br><span class="line">            visc[j][k] = <span class="literal">false</span></span><br><span class="line">            visb[i/<span class="number">3</span>][j/<span class="number">3</span>][k] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终如果都不返回true，则返回false，失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="扫雷游戏"><a href="#扫雷游戏" class="headerlink" title="扫雷游戏"></a>扫雷游戏</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深度优先，递归</span></span><br><span class="line">func updateBoard(board [][]byte, click []int) [][]byte &#123;</span><br><span class="line">    <span class="comment">// 8个方向的使用</span></span><br><span class="line">    <span class="keyword">var</span> dirX = []int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> dirY = []int&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果点击的是M，则是游戏结束，更新值</span></span><br><span class="line">    <span class="keyword">if</span> board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] == <span class="string">&#x27;M&#x27;</span> &#123;</span><br><span class="line">        board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> board</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数是坐标值，和每次递归更新后的board</span></span><br><span class="line">    <span class="keyword">var</span> dfs func([][]byte, int, int)</span><br><span class="line">    dfs = <span class="function"><span class="title">func</span>(<span class="params">board [][]byte, x, y int</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录周围的M数量</span></span><br><span class="line">        mCount := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">            tx := x + dirX[i]</span><br><span class="line">            ty := y + dirY[i]</span><br><span class="line">            <span class="comment">// 边界条件</span></span><br><span class="line">            <span class="keyword">if</span> tx &lt; <span class="number">0</span> || ty &lt; <span class="number">0</span> || tx &gt;= len(board) || ty &gt;= <span class="function"><span class="title">len</span>(<span class="params">board[<span class="number">0</span>]</span>)</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">            <span class="comment">// 如果周围有M，则数字+1</span></span><br><span class="line">            <span class="keyword">if</span> board[tx][ty] == <span class="string">&#x27;M&#x27;</span> &#123;</span><br><span class="line">                mCount++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 周围有M，则更新为byte数字</span></span><br><span class="line">        <span class="keyword">if</span> mCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">            board[x][y] = byte(mCount + <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 周围没有M则更新为B</span></span><br><span class="line">            board[x][y] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">            <span class="comment">// 向8个方向扩展</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">                tx := x + dirX[i]</span><br><span class="line">                ty := y + dirY[i]</span><br><span class="line">                <span class="comment">// 如果周边的不是E，说明已经被访问过了，则跳过</span></span><br><span class="line">                <span class="keyword">if</span> tx &lt; <span class="number">0</span> || ty &lt; <span class="number">0</span> || tx &gt;= len(board) || ty &gt;= len(board[<span class="number">0</span>]) || board[tx][ty] != <span class="string">&#x27;E&#x27;</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">                dfs(board, tx, ty)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    dfs(board, click[<span class="number">0</span>], click[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> board</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 广度优先，bfs</span></span><br><span class="line">func updateBoard(board [][]byte, click []int) [][]byte &#123;</span><br><span class="line">    <span class="comment">// 8个方向</span></span><br><span class="line">    <span class="keyword">var</span> dirX = []int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> dirY = []int&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击到M结束</span></span><br><span class="line">    <span class="keyword">if</span> board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] == <span class="string">&#x27;M&#x27;</span> &#123;</span><br><span class="line">        board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> board</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> bfs func([][]byte, int, int)</span><br><span class="line">    bfs = <span class="function"><span class="title">func</span>(<span class="params">board [][]byte, x, y int</span>)</span> &#123;</span><br><span class="line">        q := [][]int&#123;&#125;</span><br><span class="line">        vis := make([][]bool, len(board))</span><br><span class="line">        <span class="comment">// 初始化所有的节点，是否被访问过</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(vis); i++ &#123;</span><br><span class="line">            vis[i] = make([]bool, len(board[<span class="number">0</span>]))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前点击加入队列</span></span><br><span class="line">        q = append(q, []int&#123;x, y&#125;)</span><br><span class="line">        <span class="comment">// 记录当前点击访问</span></span><br><span class="line">        vis[x][y] = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 遍历队列</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(q); i++ &#123;</span><br><span class="line">            <span class="comment">// 获取当前坐标，初始化周围M的数量</span></span><br><span class="line">            mCount, cx, <span class="attr">cy</span> := <span class="number">0</span>, q[i][<span class="number">0</span>], q[i][<span class="number">1</span>]</span><br><span class="line">            <span class="comment">// 找周围的M</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">                tx, <span class="attr">ty</span> := cx + dirX[i], cy + dirY[i]</span><br><span class="line">                <span class="keyword">if</span> tx &lt; <span class="number">0</span> || tx &gt;= len(board) || ty &lt; <span class="number">0</span> || ty &gt;= <span class="function"><span class="title">len</span>(<span class="params">board[<span class="number">0</span>]</span>)</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 记录周围的M</span></span><br><span class="line">                <span class="keyword">if</span> board[tx][ty] == <span class="string">&#x27;M&#x27;</span> &#123;</span><br><span class="line">                    mCount++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果有M，更新值</span></span><br><span class="line">            <span class="keyword">if</span> mCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">                board[cx][cy] = byte(mCount + <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有M更新为B</span></span><br><span class="line">                board[cx][cy] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">                <span class="comment">// 将周围的加入队列</span></span><br><span class="line">                <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">                    tx, <span class="attr">ty</span> := cx + dirX[i], cy + dirY[i]</span><br><span class="line">                    <span class="comment">// 这里不需要在存在 B 的时候继续扩展，因为 B 之前被点击的时候已经被扩展过了</span></span><br><span class="line">                    <span class="keyword">if</span> tx &lt; <span class="number">0</span> || tx &gt;= len(board) || ty &lt; <span class="number">0</span> || ty &gt;= len(board[<span class="number">0</span>]) || board[tx][ty] != <span class="string">&#x27;E&#x27;</span> || vis[tx][ty] &#123;</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    q = append(q, []int&#123;tx, ty&#125;)</span><br><span class="line">                    vis[tx][ty] = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bfs(board, click[<span class="number">0</span>], click[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> board</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2020/12/18/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</p>
<p>5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, <span class="attr">head</span>: ListNode) -&gt; ListNode:</span><br><span class="line">        prev = None</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            a = cur.next</span><br><span class="line">            cur.next = prev</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = a</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>

<h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">func reverseList(head *ListNode) *ListNode &#123;</span><br><span class="line">    <span class="keyword">var</span>  prev *ListNode</span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cur == nil &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取指向当前的下一个</span></span><br><span class="line">        a := cur.Next</span><br><span class="line">        <span class="comment">// 当前的指向前一个</span></span><br><span class="line">        cur.Next = prev</span><br><span class="line">        <span class="comment">// 为下次循环准备，前一个变成当前的</span></span><br><span class="line">        prev = cur</span><br><span class="line">        <span class="comment">// 当前的变成下一个</span></span><br><span class="line">        cur = a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，假设 n 是列表的长度，时间复杂度是 O(n)。<br>空间复杂度：O(1)。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, <span class="attr">head</span>: ListNode) -&gt; ListNode:</span><br><span class="line">        def handle(cur, prev):</span><br><span class="line">            # 终止条件</span><br><span class="line">            <span class="keyword">if</span> not cur:</span><br><span class="line">                <span class="keyword">return</span> prev</span><br><span class="line">            # 递归执行</span><br><span class="line">            res = handle(cur.next, cur)</span><br><span class="line">            # 重复逻辑，将指针指向前一个，前后逻辑不影响</span><br><span class="line">            cur.next = prev</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> handle(head, None)</span><br></pre></td></tr></table></figure>

<h3 id="go-1"><a href="#go-1" class="headerlink" title="go"></a>go</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">func reverseList(head *ListNode) *ListNode &#123;</span><br><span class="line">    # 判断结束条件，当前节点为空，或者该节点的指向为空</span><br><span class="line">    <span class="keyword">if</span> head == nil || head.Next == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    # 递归调用，直接拿到最后一个的前一个节点</span><br><span class="line">    node := reverseList(head.Next)</span><br><span class="line">    # 然后最后一个前一个节点的next，也就是最后一个节点，最后一个节点的next指针指向他前一个节点</span><br><span class="line">    head.Next.Next = head</span><br><span class="line">    # 修改当前指向nil</span><br><span class="line">    head.Next = nil</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要人肉递归，当前指向nil了，前一个怎么办，通用就是前一个指向nil<br>要在递归后再修改指向，不然就找不到最后一层，无法进行递归</p>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序链表</title>
    <url>/2021/01/29/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], l2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">res = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>for 循环方法，简单迭代：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123;</span><br><span class="line">    start := &amp;ListNode&#123;&#125;</span><br><span class="line">    prev := start</span><br><span class="line">    <span class="keyword">for</span> l1 != nil || l2 != nil &#123;</span><br><span class="line">        <span class="keyword">if</span> l1 == nil &amp;&amp; l2 != nil &#123;</span><br><span class="line">            prev.Next = l2</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 == nil &amp;&amp; l1 != nil&#123;</span><br><span class="line">            prev.Next = l1</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l1 != nil &amp;&amp; l2 != nil &#123;</span><br><span class="line">            <span class="keyword">if</span> l1.Val &gt;= l2.Val &#123;</span><br><span class="line">                prev.Next = l2</span><br><span class="line">                l2 = l2.Next</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.Next = l1</span><br><span class="line">                l1 = l1.Next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归：</p>
<p>终止条件：当两个链表都为空时，表示我们对链表已合并完成。<br>如何递归：我们判断 l1 和 l2 头结点哪个更小，然后较小结点的 next 指针指向其余结点的合并结果。（调用递归），较小的排在前面，指向剩余的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> l1 == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l2 == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">    <span class="keyword">if</span> l1.Val &gt; l2.Val &#123;</span><br><span class="line">        l2.Next = mergeTwoLists(l1, l2.Next)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l1.Next = mergeTwoLists(l1.Next, l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>多米诺骨牌等价问题</title>
    <url>/2021/01/26/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C%E7%AD%89%E4%BB%B7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>给你一个由一些多米诺骨牌组成的列表 dominoes。</p>
<p>如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。</p>
<p>形式上，dominoes[i] = [a, b] 和 dominoes[j] = [c, d] 等价的前提是 a==c 且 b==d，或是 a==d 且 b==c。</p>
<p>在 0 &lt;= i &lt; j &lt; dominoes.length 的前提下，找出满足 dominoes[i] 和 dominoes[j] 等价的骨牌对 (i, j) 的数量。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">input = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">res = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>通过map的方式进行过滤，符合多米诺骨牌的条件都加1，然后对这个数字求其对数</p>
<p>通过这个结果10* i[0] + i[1] 判断，i，j不同的大小比较，算一种结果</p>
<p>最后求对数，遍历字典，加起来，k* (k-1)/2，去算有同样骨牌可以产出的对数，最后都加起来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func numEquivDominoPairs(dominoes [][]int) int &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    res := make(map[int]int, len(dominoes))</span><br><span class="line">    <span class="keyword">for</span> _, <span class="attr">i</span> := range dominoes &#123;</span><br><span class="line">        <span class="keyword">var</span> num int</span><br><span class="line">        <span class="keyword">if</span> i[<span class="number">0</span>] &lt; i[<span class="number">1</span>] &#123;</span><br><span class="line">            num = <span class="number">10</span>*i[<span class="number">0</span>] + i[<span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num = <span class="number">10</span>*i[<span class="number">1</span>] + i[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        res[num] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, <span class="attr">i</span> := range res &#123;</span><br><span class="line">        count += int(i*(i-<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>如何设计一个消息队列</title>
    <url>/2023/01/04/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>那么如何设计一个消息队列，设计一个消息中间件</p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>1、明确地提出消息中间件的几个重要角色，分别是生产者、消费者、Broker、注册中心。<br>2、消息中间件数据流转过程，无非就是生产者生成消息，发送至 Broker，Broker 可以暂缓消息，然后消费者再从 Broker 获取消息，用于消费。<br>3、注册中心用于服务的发现包括：Broker 的发现、生产者的发现、消费者的发现，当然还包括下线，可以说服务的高可用离不开注册中心。<br>4、实现要点，可以同通信讲起：各模块的通信可以基于 Netty 然后自定义协议来实现，注册<br>中心可以利用 zookeeper、consul、eureka、nacos 等等，也可以像 RocketMQ 自己实现简单的<br>namesrv （这一句话就都是关键词）。<br>5、为了考虑扩容和整体的性能，采用分布式的思想，像 Kafka 一样采取分区理念，一个 Topic 分为多个partition，并且为保证数据可靠性，采取多副本存储，即 Leader 和 follower，根据性能和数据可靠权衡提供异步和同步的刷盘存储。并且利用选举算法保证 Leader 挂了之后 follower 可以顶上，保证消息队列的高可用。也同样为了提高消息队列的可靠性利用本地文件系统来存储消息，并且采用顺序写的方式来提高性能。可根据消息队列的特性利用内存映射、零拷贝进一步的提升性能，还可利用像 Kafka 这种批处理思想提高整体的吞吐。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树，前缀树</title>
    <url>/2021/03/26/%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%8C%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    <content><![CDATA[<h3 id="trie-字典树实现"><a href="#trie-字典树实现" class="headerlink" title="trie 字典树实现"></a>trie 字典树实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type Trie struct &#123;</span><br><span class="line">    isEnd       bool</span><br><span class="line">    children    [<span class="number">26</span>]*Trie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">func Constructor() Trie &#123;</span><br><span class="line">    <span class="keyword">return</span> Trie&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">func (<span class="built_in">this</span> *Trie) <span class="function"><span class="title">Insert</span>(<span class="params">word string</span>)</span>  &#123;</span><br><span class="line">    root := <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 每个单词字符处理，是nil的话就新建</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(word); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> root.children[word[i] - <span class="string">&#x27;a&#x27;</span>] == nil &#123;</span><br><span class="line">            root.children[word[i] - <span class="string">&#x27;a&#x27;</span>] = &amp;Trie&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是nil就更新下一节点去遍历</span></span><br><span class="line">        root = root.children[word[i] - <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个节点是单词结尾</span></span><br><span class="line">    root.isEnd = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">func (<span class="built_in">this</span> *Trie) Search(word string) bool &#123;</span><br><span class="line">    root := <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 搜索与插入类似，是nil的话直接返回false</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(word); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> root.children[word[i] - <span class="string">&#x27;a&#x27;</span>] == nil &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = root.children[word[i] - <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后判断是前缀，还是完整单词</span></span><br><span class="line">    <span class="keyword">if</span> root.isEnd != <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">func (<span class="built_in">this</span> *Trie) StartsWith(prefix string) bool &#123;</span><br><span class="line">    root := <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 只判断前缀，不需要判断完整单词</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(prefix); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> root.children[prefix[i] - <span class="string">&#x27;a&#x27;</span>] == nil &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = root.children[prefix[i] - <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Insert(word);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Search(word);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.StartsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="类似二叉树的层序遍历"><a href="#类似二叉树的层序遍历" class="headerlink" title="类似二叉树的层序遍历"></a>类似二叉树的层序遍历</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dfs</span></span><br><span class="line">func levelOrder(root *TreeNode) [][]int &#123;</span><br><span class="line">    res := [][]int&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> dfs func(*TreeNode, int)</span><br><span class="line">    dfs = <span class="function"><span class="title">func</span>(<span class="params">root *TreeNode, l int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> l == <span class="function"><span class="title">len</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line">            res = append(res, []int&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        res[l] = append(res[l], root.Val)</span><br><span class="line">        <span class="keyword">if</span> root.Left != nil &#123; dfs(root.Left, l + <span class="number">1</span>) &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Right != nil &#123; dfs(root.Right, l + <span class="number">1</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bfs</span></span><br><span class="line">func levelOrder(root *TreeNode) [][]int &#123;</span><br><span class="line">    res := [][]int&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> len(q) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        qLen := len(q)</span><br><span class="line">        curRes := []int&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; qLen; i++ &#123;</span><br><span class="line">            node := q[<span class="number">0</span>]</span><br><span class="line">            q = q[<span class="number">1</span>:]</span><br><span class="line">            curRes = append(curRes, node.Val)</span><br><span class="line">            <span class="keyword">if</span> node.Left != nil &#123; q = append(q, node.Left) &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != nil &#123; q = append(q, node.Right) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = append(res, curRes)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意判断边界条件，开始的root是否为nil， root的left，right是否为nil</p>
<h3 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dfs</span></span><br><span class="line">func exist(board [][]byte, word string) bool &#123;</span><br><span class="line">    dirI := []int&#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">    dirJ := []int&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> dfs func(int, int, int) bool</span><br><span class="line">    dfs = func(i, j, l int) bool &#123;</span><br><span class="line">        <span class="keyword">if</span> board[i][j] != word[l] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l == len(word) - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">        defer <span class="function"><span class="title">func</span>(<span class="params">i, j int, b byte</span>)</span>  &#123; board[i][j] = b &#125;(i, j, word[l])</span><br><span class="line">        <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; <span class="number">4</span>; k++ &#123;</span><br><span class="line">            newI := i + dirI[k]</span><br><span class="line">            newJ := j + dirJ[k]</span><br><span class="line">            <span class="keyword">if</span> newI &gt;= <span class="number">0</span> &amp;&amp; newJ &gt;= <span class="number">0</span> &amp;&amp; newI &lt; len(board) &amp;&amp; newJ &lt; len(board[<span class="number">0</span>]) &amp;&amp; board[newI][newJ] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="function"><span class="title">dfs</span>(<span class="params">newI, newJ, l + <span class="number">1</span></span>)</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(board); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; len(board[<span class="number">0</span>]); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == word[<span class="number">0</span>] &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="function"><span class="title">dfs</span>(<span class="params">i, j, <span class="number">0</span></span>)</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trie 字典树， 注释看单词搜索2，一样</span></span><br><span class="line">type Trie struct &#123;</span><br><span class="line">    isEnd bool</span><br><span class="line">    childrens [<span class="number">58</span>]*Trie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func exist(board [][]byte, word string) bool &#123;</span><br><span class="line">    root := &amp;Trie&#123;&#125;</span><br><span class="line">    node := root</span><br><span class="line">    <span class="keyword">for</span> _, <span class="attr">v</span> := range word &#123;</span><br><span class="line">        <span class="keyword">if</span> node.childrens[v - <span class="string">&#x27;A&#x27;</span>] == nil &#123;</span><br><span class="line">            node.childrens[v - <span class="string">&#x27;A&#x27;</span>] = &amp;Trie&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.childrens[v - <span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    node.isEnd = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    dirx := []int&#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    diry := []int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs func(x, y int, root *Trie) bool</span><br><span class="line">    dfs = func(x, y int, root *Trie) bool &#123;</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x == len(board) || y == <span class="function"><span class="title">len</span>(<span class="params">board[<span class="number">0</span>]</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur := board[x][y]</span><br><span class="line">        <span class="keyword">if</span> cur == <span class="string">&#x27; &#x27;</span> || root.childrens[cur - <span class="string">&#x27;A&#x27;</span>] == nil &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = root.childrens[cur - <span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> root.isEnd &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">        <span class="keyword">for</span> p := <span class="number">0</span>; p &lt; <span class="number">4</span>; p++ &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="function"><span class="title">dfs</span>(<span class="params">x + dirx[p], y + diry[p], root</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = cur</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; len(board); x++ &#123;</span><br><span class="line">        <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; len(board[<span class="number">0</span>]); y++ &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="function"><span class="title">dfs</span>(<span class="params">x, y, root</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单词搜索II"><a href="#单词搜索II" class="headerlink" title="单词搜索II"></a>单词搜索II</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dfs</span></span><br><span class="line">func findWords(board [][]byte, words []string) []string &#123;</span><br><span class="line">    m := len(board)</span><br><span class="line">    n := len(board[<span class="number">0</span>])</span><br><span class="line">    res := make([]string, <span class="number">0</span>, len(words))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(words); i++ &#123;</span><br><span class="line">        flag := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; m; j++ &#123;</span><br><span class="line">            <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; n; k++ &#123;</span><br><span class="line">                flag = dfs(board, words, j, k, i, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> flag &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> flag &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> flag &#123; res = append(res, words[i]) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dirx = []int&#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">var</span> diry = []int&#123;<span class="number">0</span>, <span class="number">0</span> ,-<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">func dfs(board [][]byte, words []string, j, k, i, t int) bool &#123;</span><br><span class="line">    <span class="keyword">if</span> board[j][k] != words[i][t] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t == len(words[i]) - <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    board[j][k] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">    <span class="comment">// 还原board</span></span><br><span class="line">    defer <span class="function"><span class="title">func</span>(<span class="params">j, k int, b byte</span>)</span> &#123; board[j][k] = b &#125; (j, k, words[i][t])</span><br><span class="line">    <span class="keyword">for</span> d := <span class="number">0</span>; d &lt; <span class="number">4</span>; d++ &#123;</span><br><span class="line">        newJ := j + dirx[d]</span><br><span class="line">        newK := k + diry[d]</span><br><span class="line">        <span class="keyword">if</span> newJ &gt;= <span class="number">0</span> &amp;&amp; newK &gt;= <span class="number">0</span> &amp;&amp; newJ &lt; len(board) &amp;&amp; newK &lt; len(board[<span class="number">0</span>]) &amp;&amp; board[newJ][newK] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="function"><span class="title">dfs</span>(<span class="params">board, words, newJ, newK, i, t + <span class="number">1</span></span>)</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trie树方法</span></span><br><span class="line"><span class="comment">// 创建字典树</span></span><br><span class="line">type Trie struct &#123;</span><br><span class="line">    word string</span><br><span class="line">    childrens [<span class="number">26</span>]*Trie</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方向</span></span><br><span class="line"><span class="keyword">var</span> dirx = []int&#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">var</span> diry = []int&#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">func findWords(board [][]byte, words []string) []string &#123;</span><br><span class="line">    res := []string&#123;&#125;</span><br><span class="line">    <span class="comment">// 初始化root</span></span><br><span class="line">    root := &amp;Trie&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, <span class="attr">v</span> := range words &#123;</span><br><span class="line">    	<span class="comment">// 每个单词重新从root开始</span></span><br><span class="line">        node := root</span><br><span class="line">        <span class="comment">// 插入字典树</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(v); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> node.childrens[v[i] - <span class="string">&#x27;a&#x27;</span>] == nil &#123;</span><br><span class="line">                node.childrens[v[i] - <span class="string">&#x27;a&#x27;</span>] = &amp;Trie&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.childrens[v[i] - <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        node.word = v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">var</span> dfs func(x, y int, root *Trie)</span><br><span class="line">    dfs = <span class="function"><span class="title">func</span>(<span class="params">x, y int, root *Trie</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 超出边界，return</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x == len(board) || y == <span class="function"><span class="title">len</span>(<span class="params">board[<span class="number">0</span>]</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取当前点</span></span><br><span class="line">        cur := board[x][y]</span><br><span class="line">        <span class="comment">// 如果当前点使用过，或者不在字典树里，则return</span></span><br><span class="line">        <span class="keyword">if</span> cur == <span class="string">&#x27; &#x27;</span> || root.childrens[cur - <span class="string">&#x27;a&#x27;</span>] == nil &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在字典树里，且没有使用过，则更新到下一个节点</span></span><br><span class="line">        root = root.childrens[cur - <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">        <span class="comment">// 如果到结束，找到单词，加入结果</span></span><br><span class="line">        <span class="keyword">if</span> root.word != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            res = append(res, root.word)</span><br><span class="line">            root.word = <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记防止重复</span></span><br><span class="line">        board[x][y] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">        <span class="comment">// 继续dfs</span></span><br><span class="line">        <span class="keyword">for</span> p := <span class="number">0</span>; p &lt; <span class="number">4</span>; p++ &#123;</span><br><span class="line">            dfs(x + dirx[p], y + diry[p], root)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还原</span></span><br><span class="line">        board[x][y] = cur</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历 dfs</span></span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; len(board); x++ &#123;</span><br><span class="line">        <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; len(board[<span class="number">0</span>]); y++ &#123;</span><br><span class="line">            dfs(x, y, root)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单词搜索II，字典树方法的时间复杂度<br>O（m * n * 4^L）m,n是二维网格的长宽，L是单词的平均长度</p>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字典设置默认值 defaultdict</title>
    <url>/2020/07/20/%E5%AD%97%E5%85%B8%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%80%BCdefault/</url>
    <content><![CDATA[<h3 id="关于python中defaultdict的用法"><a href="#关于python中defaultdict的用法" class="headerlink" title="关于python中defaultdict的用法"></a>关于python中defaultdict的用法</h3><p>当我使用普通的字典时，用法一般是dict={},添加元素的只需要dict[element] =value即，调用的时候也是如此，dict[element] = xxx,但前提是element字典里，如果不在字典里就会报错，keyerror的错误。</p>
<p>为了防止报错，我们可以先给字典中的键设置默认值，再对其进行操作，这里就用到defaultdict</p>
<p>defaultdict可以指定str，list，set，int默认值，<br>对应的分别是空字符串，[], （），0</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">dict1 = defaultdict(str) # 列表，集合，数字一样</span><br></pre></td></tr></table></figure>
<p>之后即可对dict1操作，不存在的键即取到默认值。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相关算法</title>
    <url>/2021/03/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="转换成小写字母"><a href="#转换成小写字母" class="headerlink" title="转换成小写字母"></a>转换成小写字母</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func toLowerCase(str string) string &#123;</span><br><span class="line">    tmp := []byte(str)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(tmp); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> tmp[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; tmp[i] &lt;= <span class="string">&#x27;Z&#x27;</span> &#123;</span><br><span class="line">            tmp[i] += <span class="number">32</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string(tmp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最后一个单词长度"><a href="#最后一个单词长度" class="headerlink" title="最后一个单词长度"></a>最后一个单词长度</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func lengthOfLastWord(s string) int &#123;</span><br><span class="line">	tail := len(s) - <span class="number">1</span></span><br><span class="line">	<span class="comment">// 找到第一个不是空的</span></span><br><span class="line">	<span class="keyword">for</span> tail &gt;= <span class="number">0</span> &amp;&amp; s[tail] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">		tail--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tail &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  从第一个不是空的往前找，找到第一个是空的</span></span><br><span class="line">	head := tail</span><br><span class="line">	<span class="keyword">for</span> head &gt;= <span class="number">0</span> &amp;&amp; s[head] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">		head--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tail - head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串中第一个唯一字符"><a href="#字符串中第一个唯一字符" class="headerlink" title="字符串中第一个唯一字符"></a>字符串中第一个唯一字符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func firstUniqChar(s string) int &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    countMap := make(map[byte]int, len(s))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(s); i++ &#123;</span><br><span class="line">        countMap[s[i]]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> countMap[s[i]] == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反转字符串问题"><a href="#反转字符串问题" class="headerlink" title="反转字符串问题"></a>反转字符串问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">reverseString</span>(<span class="params">s []byte</span>)</span>  &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(s) &gt;&gt; <span class="number">1</span>; i++ &#123;</span><br><span class="line">        s[i], s[len(s) - <span class="number">1</span> - i] = s[len(s) - <span class="number">1</span> - i], s[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每咯2k反转前k个</span></span><br><span class="line">func reverseStr(s string, k int) string &#123;</span><br><span class="line">    tmp := []byte(s)</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="function"><span class="title">len</span>(<span class="params">tmp</span>)</span> &#123;</span><br><span class="line">        l := i</span><br><span class="line">        r := i + k - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> r &gt; len(s) - <span class="number">1</span>&#123;</span><br><span class="line">            r = len(s) - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> k := l; k &lt; r; k++ &#123;</span><br><span class="line">            tmp[k], tmp[r] = tmp[r], tmp[k]</span><br><span class="line">            r--</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">2</span> * k</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string(tmp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转字符串里的单词</span></span><br><span class="line">func reverseWords(s string) string &#123;</span><br><span class="line">    tmp := []string&#123;&#125;</span><br><span class="line">    single := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> single != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                tmp = append(tmp, single)</span><br><span class="line">            &#125;</span><br><span class="line">            single = <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            single += string(s[i])</span><br><span class="line">            <span class="keyword">if</span> i == len(s) - <span class="number">1</span> &#123;</span><br><span class="line">                tmp = append(tmp, single)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reverseAll(tmp)</span><br><span class="line">    res := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, <span class="attr">v</span> := range tmp &#123;</span><br><span class="line">        res += (<span class="string">&quot; &quot;</span> + string(v))</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">reverseAll</span>(<span class="params">s []string</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt; len(s)&gt;&gt;<span class="number">1</span>; i++ &#123;</span><br><span class="line">        s[i], s[len(s) - i -<span class="number">1</span>] = s[len(s) - i -<span class="number">1</span>], s[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转字符串中的单词3</span></span><br><span class="line">func reverseWords(s string) string &#123;</span><br><span class="line">    tmp := strings.Split(s, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(tmp); i++ &#123;</span><br><span class="line">        tmp[i] = reverSingle([]byte(tmp[i]))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strings.Join(tmp, <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func reverSingle(s []byte) string &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(s) &gt;&gt;<span class="number">1</span>; i++ &#123;</span><br><span class="line">        s[i], s[len(s) - <span class="number">1</span>- i] = s[len(s) - <span class="number">1</span>- i], s[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针解法</span></span><br><span class="line">func reverseWords(s string) string &#123;</span><br><span class="line">	b :=[]byte(s)</span><br><span class="line">	l :=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i,<span class="attr">v</span> :=range s&#123;</span><br><span class="line">		<span class="keyword">if</span> v==<span class="string">&#x27; &#x27;</span>||i==len(s)-<span class="number">1</span>&#123;</span><br><span class="line">			r :=i-<span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> i==len(s)-<span class="number">1</span>&#123;</span><br><span class="line">				r =i</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> l&lt;r&#123;</span><br><span class="line">				b[l],b[r] =b[r],b[l]</span><br><span class="line">				l++</span><br><span class="line">				r--</span><br><span class="line">			&#125;</span><br><span class="line">			l=i+<span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> string(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="仅仅反转字母"><a href="#仅仅反转字母" class="headerlink" title="仅仅反转字母"></a>仅仅反转字母</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针反转</span></span><br><span class="line">func reverseOnlyLetters(S string) string &#123;</span><br><span class="line">	tmp := []byte(S)</span><br><span class="line">	<span class="keyword">for</span> i, <span class="attr">j</span> := <span class="number">0</span>, len(tmp)-<span class="number">1</span>; i &lt; j; &#123;</span><br><span class="line">		<span class="keyword">for</span> i &lt; j &amp;&amp; !<span class="function"><span class="title">isLetter</span>(<span class="params">tmp[i]</span>)</span> &#123;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i &lt; j &amp;&amp; !<span class="function"><span class="title">isLetter</span>(<span class="params">tmp[j]</span>)</span> &#123;</span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line">		tmp[i], tmp[j] = tmp[j], tmp[i]</span><br><span class="line">		i++</span><br><span class="line">		j--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> string(tmp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func isLetter(c byte) bool &#123;</span><br><span class="line">	<span class="keyword">if</span> c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span> || c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="同构字符串"><a href="#同构字符串" class="headerlink" title="同构字符串"></a>同构字符串</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func isIsomorphic(s string, t string) bool &#123;</span><br><span class="line">    <span class="keyword">if</span> len(s) != <span class="function"><span class="title">len</span>(<span class="params">t</span>)</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    tmps := make(map[byte]byte, len(s))</span><br><span class="line">    tmpt := make(map[byte]byte, len(t))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> _, <span class="attr">ok</span> := tmps[s[i]]; !ok &#123;</span><br><span class="line">            tmps[s[i]] = t[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _, <span class="attr">ok</span> := tmpt[t[i]]; !ok &#123;</span><br><span class="line">            tmpt[t[i]] = s[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> tmps[s[i]] != t[i] &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> tmpt[t[i]] != s[i] &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func isPalindrome(s string) bool &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    j := len(s) - <span class="number">1</span></span><br><span class="line">    s = strings.ToLower(s)</span><br><span class="line">    <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; !<span class="function"><span class="title">validS</span>(<span class="params">s[i]</span>)</span> &#123; i++ &#125;</span><br><span class="line">        <span class="keyword">for</span> i &lt; j &amp;&amp; !<span class="function"><span class="title">validS</span>(<span class="params">s[j]</span>)</span> &#123; j-- &#125;</span><br><span class="line">        <span class="keyword">if</span> s[i] != s[j] &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">        i++</span><br><span class="line">        j--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func validS(i byte) bool &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; i &lt;= <span class="string">&#x27;z&#x27;</span>) || (i &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; i &lt;= <span class="string">&#x27;Z&#x27;</span>) || (i &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; i &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证回文串2，最多删除一个字符后是不是回文串</span></span><br><span class="line">func validPalindrome(s string) bool &#123;</span><br><span class="line">    l, <span class="attr">r</span> := <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">        <span class="keyword">if</span> s[l] == s[r] &#123;</span><br><span class="line">            l++</span><br><span class="line">            r--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flag1, <span class="attr">flag2</span> := <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 两种情况，删除后还得继续看里面的是不是回文串，两种情况都验证</span></span><br><span class="line">            <span class="keyword">for</span> i, <span class="attr">j</span> := l, r- <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line">                    flag1 =<span class="literal">false</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> i, <span class="attr">j</span> := l + <span class="number">1</span>, r; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line">                    flag2 = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag1 || flag2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中心扩展法</span></span><br><span class="line">func longestPalindrome(s string) string &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    start, <span class="attr">end</span> := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">// 遍历，中心扩展</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(s); i++ &#123;</span><br><span class="line">        <span class="comment">// 奇数情况</span></span><br><span class="line">        l1, <span class="attr">r1</span> := expandS(s, i, i)</span><br><span class="line">        <span class="comment">// 偶数情况</span></span><br><span class="line">        l2, <span class="attr">r2</span> := expandS(s, i, i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> r1 - l1 &gt; end - start &#123;</span><br><span class="line">            start = l1</span><br><span class="line">            end = r1</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r2 - l2 &gt; end - start &#123;</span><br><span class="line">            start = l2</span><br><span class="line">            end = r2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[start:end + <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func expandS(s string, l, r int) (int, int) &#123;</span><br><span class="line">    <span class="keyword">for</span> l &gt;= <span class="number">0</span> &amp;&amp; r &lt;= len(s) - <span class="number">1</span> &amp;&amp; s[l] == s[r] &#123;</span><br><span class="line">        l--</span><br><span class="line">        r++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l + <span class="number">1</span>, r - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line">func longestPalindrome(s string) string &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp := make([][]bool, len(s))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(s); i++ &#123;</span><br><span class="line">        dp[i] = make([]bool, len(s))</span><br><span class="line">    &#125;</span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    maxLen := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(s); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="comment">// 同一个字符串，肯定是</span></span><br><span class="line">            <span class="keyword">case</span> i == j: dp[j][i] = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 相等的情况下，如果长度小于2，肯定是，或者里面的是回文串</span></span><br><span class="line">            <span class="keyword">case</span> s[i] == s[j] &amp;&amp; (i - j &lt;= <span class="number">2</span> || dp[j + <span class="number">1</span>][i - <span class="number">1</span>]): dp[j][i] = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">default</span>:  dp[j][i] = <span class="literal">false</span> </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录最大长度与起始位置</span></span><br><span class="line">            <span class="keyword">if</span> dp[j][i] &#123;</span><br><span class="line">                curLen := i - j + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> curLen &gt; maxLen &#123;</span><br><span class="line">                    maxLen = curLen</span><br><span class="line">                    start = j</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[start:start + maxLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>实现Django框架邮箱验证功能</title>
    <url>/2018/05/24/%E5%AE%9E%E7%8E%B0Django%E6%A1%86%E6%9E%B6%E9%82%AE%E7%AE%B1%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>Django框架中，实现用户中心页面的设置邮箱功能，并根据用户设置的邮箱，发送验证邮箱，用户通过点击验证地址，完成邮箱验证。</p>
<h3 id="用户表添加字段"><a href="#用户表添加字段" class="headerlink" title="用户表添加字段"></a>用户表添加字段</h3><p>在用户的user表中添加字段，代表该用户使用的邮箱是否通过验证，true为通过验证，相反为false。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">email_active = models.BooleanField(<span class="keyword">default</span>=False, verbose_name=<span class="string">&#x27;邮箱验证状态&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>然后进行数据库迁移，完成字段创建。</p>
<h3 id="保存用户邮箱，并发送验证邮箱"><a href="#保存用户邮箱，并发送验证邮箱" class="headerlink" title="保存用户邮箱，并发送验证邮箱"></a>保存用户邮箱，并发送验证邮箱</h3><p>用户根据页面输入框输入邮箱后，点击保存，将用户输入的邮箱验证，并保存到数据库user表中，然后根据这个地址，发送验证邮件。</p>
<h4 id="定义序列化器"><a href="#定义序列化器" class="headerlink" title="定义序列化器"></a>定义序列化器</h4><p>继承自modelserializer</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class EmailSerializer(serializers.ModelSerializer):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    邮箱序列化器</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    # 指定模型类，属性</span><br><span class="line">    class Meta:</span><br><span class="line">        model = User</span><br><span class="line">        fields = (<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;email&#x27;</span>)</span><br><span class="line">        extra_kwargs = &#123;</span><br><span class="line">            <span class="string">&#x27;email&#x27;</span>: &#123;</span><br><span class="line">			# 验证邮箱为必填字段</span><br><span class="line">                <span class="string">&#x27;required&#x27;</span>: True</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">	   # 重写update方法，数据库修改该用户的邮箱</span><br><span class="line">		def update(self, instance, validated_data):</span><br><span class="line">        # 从请求体中接收数据，后面向这个邮箱发送邮件</span><br><span class="line">        email = validated_data[<span class="string">&#x27;email&#x27;</span>]</span><br><span class="line">        # instance要序列化的对象，即user，给email属性赋值</span><br><span class="line">        instance.email = validated_data[<span class="string">&#x27;email&#x27;</span>]</span><br><span class="line">        # 提交</span><br><span class="line">        instance.save()</span><br></pre></td></tr></table></figure>

<h4 id="定义保存的视图类"><a href="#定义保存的视图类" class="headerlink" title="定义保存的视图类"></a>定义保存的视图类</h4><p>因为不是根据用户id来修改邮箱，而是根据当前登录的用户，所以不传pk，而是重写get_object方法，来获取当前登录的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class SaveEmail(UpdateAPIView):</span><br><span class="line">    # 验证用户是否登陆，Drf提供的验证功能</span><br><span class="line">    permission_classes = [IsAuthenticated]</span><br><span class="line">    # 指定序列化器</span><br><span class="line">    serializer_class = EmailSerializer</span><br><span class="line">    # 因为不获取ｐｋ，所以保存的时候获取当前登陆用户的对象</span><br><span class="line">    def get_object(self):</span><br><span class="line">        # 将对象存到ｒｅｑｕｅｓｔ里</span><br><span class="line">        <span class="keyword">return</span> self.request.user</span><br></pre></td></tr></table></figure>
<p>然后配置url即可。</p>
<h4 id="生成验证地址"><a href="#生成验证地址" class="headerlink" title="生成验证地址"></a>生成验证地址</h4><p>保存用户输入的邮箱之后，向这个邮箱发送验证地址，首先需要生成验证地址。<br>在user的models里添加方法，实现生成地址的功能，在拼接地址时要经过加密，导入jwt，使用jwt加密</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 定义生成地址的方法</span><br><span class="line">    def generate_verify_email_url(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        生成验证邮箱的url</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        # 设置itsdangerous加密</span><br><span class="line">        serializer = TJWSSerializer(settings.SECRET_KEY, expires_in=constants.VERIFY_EMAIL_TOKEN_EXPIRES)</span><br><span class="line">        data = &#123;<span class="string">&#x27;user_id&#x27;</span>: self.id, <span class="string">&#x27;email&#x27;</span>: self.email&#125;</span><br><span class="line">        token = serializer.dumps(data).decode()</span><br><span class="line">        verify_url = <span class="string">&#x27;http://域名/success_verify_email.html?token=&#x27;</span> + token</span><br><span class="line">        # 返回生成的地址</span><br><span class="line">        <span class="keyword">return</span> verify_url</span><br></pre></td></tr></table></figure>
<p>然后在序列化器 EmailSerializer下的update方法下添加代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 生成验证链接，调用生成验证连接的函数</span><br><span class="line">       verify_url = instance.generate_verify_email_url()</span><br></pre></td></tr></table></figure>
<p>接收生成后的url地址</p>
<h4 id="向用户的邮箱发送验证地址"><a href="#向用户的邮箱发送验证地址" class="headerlink" title="向用户的邮箱发送验证地址"></a>向用户的邮箱发送验证地址</h4><p>发送邮箱，属于等待耗时操作，所以使用Celery异步服务（详情看：<a href="https://zypuu.github.io/2018/08/20/%E5%85%B3%E4%BA%8ECelery%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8/">点这里</a>）<br>在celery_tasks下新建包email，在包里新建文件tasks.py,然后在main.py里添加<code>&#39;celery_tasks.email&#39;,</code><br>在tasks文件里添加任务代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> celery_tasks.main <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line">@app.task(name=<span class="string">&#x27;send_verify_email&#x27;</span>)</span><br><span class="line">def send_verify_email(to_email, verify_url):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    发送验证邮箱邮件</span></span><br><span class="line"><span class="string">    :param to_email: 收件人邮箱</span></span><br><span class="line"><span class="string">    :param verify_url: 验证链接</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    subject = <span class="string">&quot;邮件标题（例：***邮箱验证）&quot;</span></span><br><span class="line">    html_message = <span class="string">&#x27;&lt;p&gt;尊敬的用户您好！&lt;/p&gt;&#x27;</span> \</span><br><span class="line">                   <span class="string">&#x27;&lt;p&gt;感谢您使用*****。&lt;/p&gt;&#x27;</span> \</span><br><span class="line">                   <span class="string">&#x27;&lt;p&gt;您的邮箱为：%s 。请点击此链接激活您的邮箱：&lt;/p&gt;&#x27;</span> \</span><br><span class="line">                   <span class="string">&#x27;&lt;p&gt;&lt;a href=&quot;%s&quot;&gt;%s&lt;a&gt;&lt;/p&gt;&#x27;</span> % (to_email, verify_url, verify_url)</span><br><span class="line">	# Django自带的发送邮件功能 </span><br><span class="line">    send_mail(subject, <span class="string">&quot;&quot;</span>, settings.EMAIL_FROM, [to_email], html_message=html_message)</span><br></pre></td></tr></table></figure>
<p>然后在序列化器 EmailSerializer下的update方法下添加代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 发送验证邮件，邮箱，与验证连接作为参数</span><br><span class="line">       # 使用celery异步服务发送验证，在tasks里面</span><br><span class="line">       send_verify_email.delay(email, verify_url)</span><br><span class="line">       # 最后，经过保存，接收验证地址，发送地址等功能后，返回该对象</span><br><span class="line">       <span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure>
<p>到此发送验证邮件完成</p>
<h4 id="技术补充点：Django发送邮件"><a href="#技术补充点：Django发送邮件" class="headerlink" title="技术补充点：Django发送邮件"></a>技术补充点：Django发送邮件</h4><p>首先注册一个专门用来发送邮件的邮箱163,126，qq等，然后在这些邮箱配置SMTP服务器（设置中开启，经过手机验证后会收到授权码的短信，然后填写授权码，开启。详情可百度）</p>
<p>然后在配置中添加代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">EMAIL_BACKEND = <span class="string">&#x27;django.core.mail.backends.smtp.EmailBackend&#x27;</span></span><br><span class="line">EMAIL_HOST = &#x27;smtp.163.com&#x27; # （163为例）</span><br><span class="line">EMAIL_PORT = <span class="number">25</span></span><br><span class="line">#发送邮件的邮箱</span><br><span class="line">EMAIL_HOST_USER = <span class="string">&#x27;你的账号&#x27;</span></span><br><span class="line">#在邮箱中设置的客户端授权密码</span><br><span class="line">EMAIL_HOST_PASSWORD = <span class="string">&#x27;你的授权密码&#x27;</span></span><br><span class="line">#收件人看到的发件人</span><br><span class="line">EMAIL_FROM = <span class="string">&#x27;&lt;你的邮箱&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>使用django发送邮件：</p>
<p>在django.core.mail模块提供了send_mail来发送邮件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">在django.core.mail模块提供了send_mail来发送邮件。</span><br><span class="line"></span><br><span class="line">send_mail(subject, message, from_email, recipient_list,html_message=None)</span><br><span class="line"># 各个参数的含义</span><br><span class="line">	subject 邮件标题</span><br><span class="line">	message 普通邮件正文， 普通字符串</span><br><span class="line">	from_email 发件人</span><br><span class="line">	recipient_list 收件人列表</span><br><span class="line">	html_message 多媒体邮件正文，可以是html字符串可以呈现html页面</span><br></pre></td></tr></table></figure>

<h3 id="验证邮箱"><a href="#验证邮箱" class="headerlink" title="验证邮箱"></a>验证邮箱</h3><p>用户在邮箱收到验证邮件后，点击地址进行验证，验证成功返回用户中心页面。</p>
<h4 id="设置解密"><a href="#设置解密" class="headerlink" title="设置解密"></a>设置解密</h4><p>因为生成的验证邮箱地址时带有itsdangerous加密的token的，所以要先解密，在user的models里添加解密方法，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 设置解密方法</span><br><span class="line">    @staticmethod</span><br><span class="line">    def check_verify_email_token(token):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        检查验证邮件的token</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        # 解密</span><br><span class="line">        serializer = TJWSSerializer(settings.SECRET_KEY, expires_in=constants.VERIFY_EMAIL_TOKEN_EXPIRES)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = serializer.loads(token)</span><br><span class="line">        except BadData:</span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            # 解密之后，获取data里面的数据</span><br><span class="line">            email = data.get(<span class="string">&#x27;email&#x27;</span>)</span><br><span class="line">            user_id = data.get(<span class="string">&#x27;user_id&#x27;</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                # 根据数据，获取对象</span><br><span class="line">                user = User.objects.get(id=user_id, email=email)</span><br><span class="line">            except User.DoesNotExist:</span><br><span class="line">                <span class="keyword">return</span> None</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                # 返回对象</span><br><span class="line">                <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure>

<p>然后新建constants.py常量文件，然后添加代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">VERIFY_EMAIL_TOKEN_EXPIRES=<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span></span><br></pre></td></tr></table></figure>
<p>设置过期时间。</p>
<h4 id="定义视图函数"><a href="#定义视图函数" class="headerlink" title="定义视图函数"></a>定义视图函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class SendEmail(APIView):</span><br><span class="line">    def get(self, request):</span><br><span class="line">        # 获取token，由jwt签发的token，在查询参数里，获取查询参数</span><br><span class="line">        token = request.query_params.get(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> not token:</span><br><span class="line">            # 如果没有token，则返回信息，与状态码</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;缺少token&#x27;</span>&#125;, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line">        # 验证过程</span><br><span class="line">        # 取得token后验证token，解密，确定是否被更改</span><br><span class="line">        # 接收解密后返回的对象</span><br><span class="line">        user = User.check_verify_email_token(token)</span><br><span class="line">        <span class="keyword">if</span> user is None:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;链接信息无效&#x27;</span>&#125;, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            # 没被更改即验证成功</span><br><span class="line">            # 数据库在邮箱验证的通过字段添加信息</span><br><span class="line">            user.email_active = True</span><br><span class="line">            # 提交保存</span><br><span class="line">            user.save()</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;OK&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>由前端代码收到这个return后，跳转回用户页面即可。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找数组的中心索引</title>
    <url>/2021/01/28/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>给你一个整数数组 nums，请编写一个能够返回数组 “中心索引” 的方法。</p>
<p>数组 中心索引 是数组的一个索引，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>
<p>如果数组不存在中心索引，返回 -1 。如果数组有多个中心索引，应该返回最靠近左边的那一个。</p>
<p>注意：中心索引可能出现在数组的两端。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">input = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">res = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>直接遍历解法，两边求和</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func pivotIndex(nums []int) int &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;len(nums);i++ &#123;</span><br><span class="line">        leftRes, <span class="attr">rightRes</span> := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> _, <span class="attr">j</span> := range nums[:i] &#123;</span><br><span class="line">                leftRes += j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i &lt; len(nums) - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> _, <span class="attr">k</span> := range nums[i:] &#123;</span><br><span class="line">                rightRes += k</span><br><span class="line">            &#125;</span><br><span class="line">            rightRes -= nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> leftRes == rightRes &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化：总和是不变的，先求一遍总和，然后只求一边的和，得到另一边的和</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func pivotIndex(nums []int) int &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 先算总和</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;len(nums);i++ &#123;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leftRes := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 循环遍历求左边的和</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;len(nums);i++ &#123;</span><br><span class="line">    	<span class="comment">// 不计算当前值</span></span><br><span class="line">        <span class="keyword">if</span>  i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            leftRes += nums[i-<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算右边的和时候减去当前值</span></span><br><span class="line">        <span class="keyword">if</span> leftRes == sum - leftRes - nums[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>微处理</title>
    <url>/2024/01/20/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BE%AE%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="嵌入式技术"><a href="#嵌入式技术" class="headerlink" title="嵌入式技术"></a>嵌入式技术</h2><p>特定的硬件设备中集成计算机系统及软件，来实现某种特定功能技术</p>
<p>特点：</p>
<p>1、专用性</p>
<p>2、实时性</p>
<p>3、低成本</p>
<p>4、可靠性</p>
<p>5、体积小</p>
<h2 id="嵌入式硬件"><a href="#嵌入式硬件" class="headerlink" title="嵌入式硬件"></a>嵌入式硬件</h2><h3 id="处理体系结构"><a href="#处理体系结构" class="headerlink" title="处理体系结构"></a>处理体系结构</h3><h4 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h4><p>传统计算机采用冯·诺依曼（Von Neumann）结构，也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。<br>冯·诺依曼结构的计算机程序和数据共用一个存储空间，程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置。<br>采用单一的地址及数据总线，程序指令和数据的宽度相同。<br>处理器执行指令时，先从储存器中取出指令解码，再取操作数执行运算，即使单条指令也要耗费几个甚至几十个周期，在高速运算时，在传输通道上会出现瓶颈效应。这是一种串行结构。相对比较低效</p>
<p>指令数据存储在一个存储器中，只能串行读取，通过相同的数据总线传输</p>
<p>AMD</p>
<h4 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a>哈佛结构</h4><p>是一种并行体系结构，它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个相互独立的存储器，每个存储器独立编址、独立访问。<br>• 与两个存储器相对应的是系统中的两套独立的地址总线和数据总线。<br>• 这种分离的程序总线和数据总线可允许在一个机器周期内同时获取指令字（来自程序存储器）和操作数（来自数据存储器），从而提高了执行速度，使数据的吞吐率提高了1倍</p>
<p>DSP</p>
<p>指令和数据存在不同存储结构中，可并行读取，有较高的数据吞吐率，指令和数据的数据总线和地址总线</p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>在冯诺依曼架构中，指令和数据共享同一个存储器，CPU 只能执行一条指令，因为它需要等待指令和数据都被读取到 CPU 中。而在哈佛架构中，指令和数据存储在不同的内存中，CPU 可以同时访问指令和数据内存，因此可以同时执行多条指令。所以，可以这样<br>理解，冯诺依曼架构是单车道，而哈佛架构是多车道。</p>
<p>冯诺依曼架构的好处，就是简单、易于实现和设计。哈佛架构的好处，可以使用不同的技术来优化性能。</p>
<p>冯·诺依曼架构适用于大多数通用计算机，因为它能够灵活地处理各种不同的计算任务，同时还可以使用缓存等技术来优化性能。而哈佛架构则适用于一些特定的应用领域，例如需要高效地处理大量数据的嵌入式系统，或数字信号处理器等领域。</p>
<h3 id="微处理器分类"><a href="#微处理器分类" class="headerlink" title="微处理器分类"></a>微处理器分类</h3><p>字长宽度分类：16位以下MCU，32位以上MPU</p>
<p>如果按系统集成度划分，可分为两类：一种是微处理器内部仅包含单纯的中央处理器单元，称为一般用途型微处理器：另一种则是将CPU、ROM、RAM及I/O等部件集成到同一个芯片上，称为单芯片微控制器（Single Chip Microcontroller）。</p>
<p>• 如果根据用途分类，一般分为嵌入式微控制器MCU、嵌入式微处理器MPU、嵌入式数字信号处理器DSP、嵌入式片上系统SOC等</p>
<h4 id="嵌入式微控制器MCU"><a href="#嵌入式微控制器MCU" class="headerlink" title="嵌入式微控制器MCU"></a>嵌入式微控制器MCU</h4><p>16位以下的，典型代表是单片机，是单片化，体积大大减小，从而使功耗和成本下降、可靠性提高，嵌入式系统工业的主流</p>
<h4 id="嵌入式微处理器MPU"><a href="#嵌入式微处理器MPU" class="headerlink" title="嵌入式微处理器MPU"></a>嵌入式微处理器MPU</h4><p>通用计算机中的CPU演变而来。它的特征是具有32位以上的处理器，具有较高的性能，当然其价格也相应较高。但与计算机处理器不同的是，在实际嵌入式应用中，只保留和嵌入式应用紧密相关的功能硬件，去除其他的冗余功能部分，这样就以最低的功耗和资源实现嵌入式应用的特殊要求。与工业控制计算机相比，嵌入式微处理器具有体积小、重量轻、成本低、可靠性高的</p>
<h4 id="嵌入式数字信号处理器DSP"><a href="#嵌入式数字信号处理器DSP" class="headerlink" title="嵌入式数字信号处理器DSP"></a>嵌入式数字信号处理器DSP</h4><p>哈佛结构， 运算性能最好，专门用于信号处理方面的处理器，其在系统结构和指令算法方面进行了特殊设计，具有很高的编译效率和指令的执行速度。采用哈佛结构，流水线处理，其处理速度比最快的CPU还快10—50倍。</p>
<h4 id="嵌入式片上系统SOC"><a href="#嵌入式片上系统SOC" class="headerlink" title="嵌入式片上系统SOC"></a>嵌入式片上系统SOC</h4><p>集成度最高，追求产品系统最大包容的集成器件。SoC最大的特点是成功实现了软硬件无缝结合，直接在处理器片内嵌入操作系统的代码模块</p>
<p>高端SoC芯片主要集中于手机、平板电脑、服务器市场等，次高端SoC芯片多应用于安防、智能音频、物联网等领域，专用型SoC芯片多应用于TWS耳机和智能手表等</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>性能与功能：dsp，mpu，soc，mcu</p>
<p>集成度：soc，mcu</p>
<p>成本：dsp，mpu，soc，mcu</p>
<p>适用场景：</p>
<p>1、mcu用于简单控制与接口</p>
<p>2、mpu高性能控制与应用</p>
<p>3、dsp专业信号处理，运算性能最高</p>
<p>4、soc单一智能设备，集成度最高</p>
<h3 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h3><p>多核指多个微处理器内核，是将两个或更多的微处理器封装在一起，集成在一个电路中。多核处理器是单枚芯片，能够直接插入单一的处理器插槽中。多核与多CPU相比，很好的降低了计算机系统的功耗和体积。在多核技术中，由操作系统软件进行调度，多进程，多线程并发都可以。<br>2个或多个内核工作协调实现方式：<br>• 对称多处理技术SMP：将2颗完全一样的处理器封装在一个芯片内，达到双倍或接近双倍的处理性能，节省运算资源。<br>• 非对称处理技术AMP：2个处理内核彼此不同，各自处理和执行特定的功能，在软件的协调下分担不同的计算任务。</p>
<p> 多核CPU的调度(当有多个任务运行时，如何进行CPU的分配)<br>• 多核CPU环境下进程的调度算法一般有全局队列调度和局部队列调度两种. </p>
<p>• 全局队列调度是指操作系统维护一个全局的任务等待队列，当系统中有一个CPU空闲时，操作系统就从全局任务等待队列中选取就绪任务开始执行，CPU核心利用率高。<br>• 局部队列调度是操作系统为每个CPU内核维护一个局部的任务等待队列，当系统中有一个CPU内核空闲时，就从该核心的任务等待队列中选取适当的任务执行，优点是无需在多个CPU之间切换。</p>
<h2 id="嵌入式软件"><a href="#嵌入式软件" class="headerlink" title="嵌入式软件"></a>嵌入式软件</h2><p>嵌入式软件是指应用在嵌入式计算机系统当中的各种软件，除了具有通用软件的一般特性，还具有一些与嵌入式系统相关的特点，包括：规模较小、开发难度大、实时性和可靠性要求高、要求固化存储。</p>
<h3 id="BSP"><a href="#BSP" class="headerlink" title="BSP"></a>BSP</h3><p>板级支持包，包含了与硬件相关的驱动程序，引导程序，硬件抽象层。BSP主要负责底层硬件资源的管理和控制，提供给上层软件使用</p>
<p>特点：</p>
<p>硬件相关性：需要特定的硬件平台</p>
<p>操作系统相关性：相同硬件平台的不同操作系统也需要不同的BSP软件包支持</p>
<p>内容：</p>
<p>引导加载程序BootLoader</p>
<p>设备驱动器</p>
<h3 id="BootLoader"><a href="#BootLoader" class="headerlink" title="BootLoader"></a>BootLoader</h3><p>嵌入式系统，加电后运行的第一段软件代码，是操作系统内核运行之前的一小段运行程序，以便为最终调用操作系统做好准备</p>
<p>1、片段初始化：纯硬件的初始化，芯片</p>
<p>2、板级初始化：同时包含软件和硬件的初始化</p>
<p>3、加载内核，系统级初始化，将操作系统和应用程序的Flash内存复制到系统内存中</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>系统软件：控制和管理嵌入式系统资源，为嵌入式应用提供支持的各种软件，如设备驱动程序、嵌入式操作系统、嵌入式中间件等。<br>应用软件：嵌入式系统中的上层软件，定义了嵌入式设备的主要功能和用途，并负责与用户交互，一般面向特定的应用领域，如飞行控制软件、手机软件、地图等。<br>支撑软件：辅助软件开发的工具软件，如系统分析设计工具、在线仿真工具、交叉编译器等。</p>
<h3 id="嵌入式系统"><a href="#嵌入式系统" class="headerlink" title="嵌入式系统"></a>嵌入式系统</h3><p>一般嵌入式系统由嵌入式处理器、相关支撑硬件、嵌入式操作系统、支撑软件以及应用软件组成<br>嵌入式系统分为硬件层、抽象层、操作系统层、中间件层和应用层<br>操作系统层主要由嵌入式操作系统、文件系统、图形用户接口、网络系统和通用组件等可配置模块组成</p>
<p>嵌入式系统应具备以下特性：</p>
<p>1、专用性强</p>
<p>2、技术融合</p>
<p>3、软硬一体，软件为主</p>
<p>4、比通用计算机资源少</p>
<p>5、程序化代码固化在非易失存储器中</p>
<p>6、需专门开发工具和环境</p>
<p>7、安全性和可靠性要求高</p>
<p>8、体积小，实时性要求高</p>
<h4 id="嵌入式处理器"><a href="#嵌入式处理器" class="headerlink" title="嵌入式处理器"></a>嵌入式处理器</h4><p>嵌入式处理器芯片除满足低功耗、体积小等需求外，根据不同环境需求，其工艺可分为民用、工业和军用等三个档次</p>
<h4 id="相关支撑硬件"><a href="#相关支撑硬件" class="headerlink" title="相关支撑硬件"></a>相关支撑硬件</h4><p>括存储器、定时器、总线、I0接口以及相关专用硬件。</p>
<h4 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h4><p>运行在嵌入式系统中的基础软件，主要用于管理计算机资源和应用软件。与通用操作系统不同，嵌入式操作系统应具备实时性、可剪裁性和安全性等特征</p>
<h4 id="支撑软件"><a href="#支撑软件" class="headerlink" title="支撑软件"></a>支撑软件</h4><p>应用软件开发与运行提供公共服务、软件开发、调试能力</p>
<h4 id="应用软件"><a href="#应用软件" class="headerlink" title="应用软件"></a>应用软件</h4><h3 id="嵌入式数据库系统EDBMS"><a href="#嵌入式数据库系统EDBMS" class="headerlink" title="嵌入式数据库系统EDBMS"></a>嵌入式数据库系统EDBMS</h3><p>设备随时移动性<br>网络频繁断接<br>网络条件多样化<br>通信能力不对称</p>
<p>一个完整的EDBMS由若干子系统组成，包括主数据库、同步服务器、嵌入式数据库和连接网络等几个子系统</p>
<p>嵌入式移动数据库在实际应用中必须解决好数据的一致性（复制性）、高效的事务处理和数据的安全性等关键问题</p>
<h3 id="嵌入式操作系统-1"><a href="#嵌入式操作系统-1" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h3><p>嵌入式操作系统EOS与通用操作系统相比，EOS主要有以下特点：<br>（1）微型化。EOS的运行平台不是通用计算机，而是嵌入式系统。这类系统一般没有大容量的内存，几乎没有外存，因此，EOS必须做得小巧，以占用尽量少的系统资源。<br>（2）代码质量高。在大多数嵌入式应用中，存储空间依然是宝贵的资源，这就要求程序代码的质量要高，代码要尽量精简。<br>（3）专业化。嵌入式系统的硬件平台多种多样，处理器的更新速度快，每种处理器都是针对不同的应用领域而专门设计的。因此，EOS要有很好适应性和移植性，还要支持多种开发平台。<br>（4）实时性强。嵌入式系统广泛应用于过程控制、数据采集、通信、多媒体信息处理等要求实时响应的场合，因此，实时性成为EOS的又一特点。<br>（5）可裁减和可配置。应用的多样性要求EOS具有较强的适应能力，能够根据应用的特点和具体要求进行灵活配置和合理裁减，以适应微型化和专业化的要求。</p>
<h3 id="嵌入式实时操作系统"><a href="#嵌入式实时操作系统" class="headerlink" title="嵌入式实时操作系统"></a>嵌入式实时操作系统</h3><p>嵌入式实时系统是一种完全嵌入受控器件内部，为特定应用而设计的专用计算机系统。在嵌入式实时系统中，要求系统在投入运行前即具有确定性和可预测性。</p>
<p>实时操作系统（RTOS）的特点<br>当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统做出快速响应，并控制所有实时任务协调一致运行。因而，提供及时响应和高可靠性是其主要特点。<br>实时操作系统有硬实时和软实时之分，硬实时要求在规定的时间内必须完成操作，这是在操作系统设计时保证的；软实时则只要按照任务的优先级，尽可能快地完成操作即可</p>
<p>实时操作系统的特征：<br>高精度计时系统<br>多级中断机制：需要建立多级中断嵌套处理机制，以确保对紧迫程度较高的实时事件进行及时响应和处理<br>实时调度机制：调度策略和算法上保证优先调度实时任务；建立更多“安全切换”时间点，保证及时调度实时任务</p>
<h3 id="嵌入式软件设计"><a href="#嵌入式软件设计" class="headerlink" title="嵌入式软件设计"></a>嵌入式软件设计</h3><p>交叉平台开发环境，包含三个高度集成的部分：</p>
<p>1、运行在宿主机强有力的交叉开发工具和程序</p>
<p>2、运行在目标机的高性能，可剪裁的实时操作系统</p>
<p>3、连接宿主机和目标机的多种通信方式</p>
<p>嵌入式系统软件的特点：规模较小、开发难度大、实时性和可靠性要求高、要求固化存储</p>
<p>嵌入式系统的开发需要借助宿主机（通用计算机）来编译出目标机的可执行代码</p>
<p>嵌入式软件的开发可以分为几个阶段：编码、交叉编译、交叉调试。</p>
<p>调试时采用的是在宿主机和目标机之间进行的交叉调试，调试器仍然运行在宿主机的通用操作系统之上，但被调试的进程却是运行在基于特定硬件平台的嵌入式操作系统中</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2021/03/31/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<p>布隆过滤器是二进制向量数据结构，它具有很好的空间和时间效率，被用来检测一个元素是不是集合中的一个成员</p>
<p>判定可能已存在和绝对不存在两种情况。</p>
<p>如果检测结果为是，该元素不一定在集合中</p>
<p>但如果检测结果为否，该元素一定不在集合中</p>
<p>应用场景：</p>
<p>ip黑名单，爬虫url过滤， 垃圾邮件过滤，去重</p>
<p>实现步骤：</p>
<p>1、开辟一个长度为m的bit数组，可以用文件来实现</p>
<p>2、通过hash函数计算得到位置值，并将数组里对应的位置的二进制置为1</p>
<p>3、查找时，通养通过hash计算得到位置，该位置的如果都是1，可能存在，如果有0，则一定不存在</p>
<p>优点：</p>
<p>有很好的空间和时间效率</p>
<p>不需要存储元素本身，在某些对保密要求非常严格的场合有优势</p>
<p>存储空间和插入查询都是常数复杂度</p>
<p>缺点：</p>
<p>误判率会随元素的增加而增加</p>
<p>不能从布隆过滤器中删除元素</p>
<p>redis 4.0以上支持布隆过滤器</p>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/03/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>代码模板</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type UF struct &#123;</span><br><span class="line">	union []int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">func newUF(cap int) *UF &#123;</span><br><span class="line">	uf := UF&#123;</span><br><span class="line">		make([]int, cap),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 每个元素的索引等于自己,每一个元素是一个集合，索引也代表元素</span></span><br><span class="line">	<span class="comment">// 每个元素是代表元素</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cap; i++ &#123;</span><br><span class="line">		uf.union[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;uf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line">func (u *UF) <span class="function"><span class="title">Union</span>(<span class="params">x, y int</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 查找两个元素的代表元素</span></span><br><span class="line">	rootX := u.find(x)</span><br><span class="line">	rootY := u.find(y)</span><br><span class="line">	<span class="comment">// 如果代表元素一样 ，则属于同一集合</span></span><br><span class="line">	<span class="keyword">if</span> rootX == rootY &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果不是则x元素的代表元素位置的代表元素改为y的代表元素</span></span><br><span class="line">	u.union[rootX] = rootY</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断两个元素是不是同一集合。也就是两个位置上的root代表元素是不是同一个</span></span><br><span class="line">func (u *UF) Connected(x, y int) bool &#123;</span><br><span class="line">	<span class="keyword">return</span> u.find(x) == u.find(y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询一个元素的代表元素，属于哪个集合</span></span><br><span class="line">func (u *UF) find(x int) int &#123;</span><br><span class="line">	root := x</span><br><span class="line">	<span class="comment">// x元素位置是不是x自己，如果不是，说明该元素被合并过，有别的代表元素</span></span><br><span class="line">	<span class="comment">// 被合并过后x位置上的元素就是它的父节点</span></span><br><span class="line">	<span class="comment">// 此过程是不断往上找 父节点，找他的代表元素</span></span><br><span class="line">	<span class="keyword">for</span> u.union[root] != root &#123;</span><br><span class="line">		root = u.union[root]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 压缩路径，将该条分支上的所有子节点的位置上的元素都是root</span></span><br><span class="line">	<span class="comment">// 先取x位置上的节点，然后x位置上改为root</span></span><br><span class="line">	<span class="comment">// 再把x位置改为刚取出的节点的位置，看是不是root</span></span><br><span class="line">	<span class="keyword">for</span> x != root &#123;</span><br><span class="line">		tmp := u.union[x]</span><br><span class="line">		u.union[x] = root</span><br><span class="line">		x = tmp</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后返回root节点，也就是x的代表元素</span></span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dfs</span></span><br><span class="line">func numIslands(grid [][]byte) int &#123;</span><br><span class="line">    <span class="keyword">var</span> dfs func(i,j int)</span><br><span class="line">    dfs = <span class="function"><span class="title">func</span>(<span class="params">i, j int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; len(grid) &amp;&amp; j &lt; len(grid[<span class="number">0</span>]) &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">            grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">            dfs(i + <span class="number">1</span>, j)</span><br><span class="line">            dfs(i - <span class="number">1</span>, j)</span><br><span class="line">            dfs(i, j - <span class="number">1</span>)</span><br><span class="line">            dfs(i, j + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(grid); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; len(grid[<span class="number">0</span>]); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                dfs(i, j)</span><br><span class="line">                res++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集方法</span></span><br><span class="line"><span class="comment">// 并查集，记录count</span></span><br><span class="line">type UF struct &#123;</span><br><span class="line">	union []int</span><br><span class="line">    count int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化并查集</span></span><br><span class="line">func newUF(m, n int, grid [][]byte) *UF &#123;</span><br><span class="line">	uf := UF&#123;make([]int, m * n), <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">        	<span class="comment">// 默认所有的1都是单独集合，索引位置是i*n+j</span></span><br><span class="line">            uf.union[i * n + j] = i * n + j</span><br><span class="line">            <span class="comment">// 如果是1，集合数+1</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                uf.count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;uf</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并，合并成功，集合数-1</span></span><br><span class="line">func (u *UF) <span class="function"><span class="title">Union</span>(<span class="params">x, y int</span>)</span> &#123;</span><br><span class="line">	rootX := u.find(x)</span><br><span class="line">	rootY := u.find(y)</span><br><span class="line">	<span class="keyword">if</span> rootX == rootY &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	u.union[rootX] = rootY</span><br><span class="line">    u.count--</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  查找不需要修改</span></span><br><span class="line">func (u *UF) find(x int) int &#123;</span><br><span class="line">	root := x</span><br><span class="line">	<span class="keyword">for</span> u.union[root] != root &#123;</span><br><span class="line">		root = u.union[root]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> x != root &#123;</span><br><span class="line">		tmp := u.union[x]</span><br><span class="line">		u.union[x] = root</span><br><span class="line">		x = tmp</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">func numIslands(grid [][]byte) int &#123;</span><br><span class="line">    m := len(grid)</span><br><span class="line">    n := len(grid[<span class="number">0</span>])</span><br><span class="line">    uf := newUF(m, n, grid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">        	<span class="comment">// 如果是1，则看其他四个方向是不是1，是1就合并，然后置成0</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i-<span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">					uf.Union(i*n+j, (i-<span class="number">1</span>)*n+j)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> i + <span class="number">1</span> &lt; m &amp;&amp; grid[i+<span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">					uf.Union(i*n+j, (i+<span class="number">1</span>)*n+j)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j-<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">					uf.Union(i*n+j, i*n+(j-<span class="number">1</span>))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> j + <span class="number">1</span> &lt; n &amp;&amp; grid[i][j+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">					uf.Union(i*n+j, i*n+(j+<span class="number">1</span>))</span><br><span class="line">				&#125;</span><br><span class="line">				grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后返回集合数即可</span></span><br><span class="line">    <span class="keyword">return</span> uf.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="被围绕区域"><a href="#被围绕区域" class="headerlink" title="被围绕区域"></a>被围绕区域</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dfs</span></span><br><span class="line">func <span class="function"><span class="title">solve</span>(<span class="params">board [][]byte</span>)</span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> dfs func(i, j int)</span><br><span class="line">    dfs = <span class="function"><span class="title">func</span>(<span class="params">i, j int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; len(board) &amp;&amp; j &lt; <span class="function"><span class="title">len</span>(<span class="params">board[<span class="number">0</span>]</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">            	<span class="comment">// 先改成别的，最后再遍历统一更新</span></span><br><span class="line">                board[i][j] = <span class="string">&#x27;Y&#x27;</span></span><br><span class="line">                dfs(i - <span class="number">1</span>, j)</span><br><span class="line">                dfs(i + <span class="number">1</span>, j)</span><br><span class="line">                dfs(i, j - <span class="number">1</span>)</span><br><span class="line">                dfs(i, j + <span class="number">1</span>)</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(board); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span> &#123; dfs(i, <span class="number">0</span>) &#125;</span><br><span class="line">        <span class="keyword">if</span> board[i][len(board[<span class="number">0</span>]) - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span> &#123; dfs(i, len(board[<span class="number">0</span>]) - <span class="number">1</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; len(board[<span class="number">0</span>]); j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span> &#123; dfs(<span class="number">0</span>, j) &#125;</span><br><span class="line">        <span class="keyword">if</span> board[len(board) - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span> &#123; dfs(len(board) - <span class="number">1</span>, j) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(board); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; len(board[<span class="number">0</span>]); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] != <span class="string">&#x27;Y&#x27;</span> &#123;</span><br><span class="line">                board[i][j] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                board[i][j] = <span class="string">&#x27;O&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集</span></span><br><span class="line">type UF struct &#123;</span><br><span class="line">    parents []int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newUF (n int) *UF &#123;</span><br><span class="line">    uf := UF&#123;make([]int, n)&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        uf.parents[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;uf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(uf *UF)find(x int) int &#123;</span><br><span class="line">    root := x</span><br><span class="line">    <span class="keyword">for</span> root != uf.parents[root] &#123;</span><br><span class="line">        root = uf.parents[root]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> x != root &#123;</span><br><span class="line">        tmp := uf.parents[x]</span><br><span class="line">        uf.parents[x] = root</span><br><span class="line">        x = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(uf *UF)<span class="function"><span class="title">union</span>(<span class="params">x, y int</span>)</span> &#123;</span><br><span class="line">    rootX := uf.find(x)</span><br><span class="line">    rootY := uf.find(y)</span><br><span class="line">    <span class="keyword">if</span> rootX == rootY &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    uf.parents[rootX] = rootY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(uf *UF)isConnect(x, y int) bool &#123;</span><br><span class="line">    <span class="keyword">return</span> uf.find(x) == uf.find(y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">solve</span>(<span class="params">board [][]byte</span>)</span>  &#123;</span><br><span class="line">    m := len(board)</span><br><span class="line">    n := len(board[<span class="number">0</span>])</span><br><span class="line">    t := m * n</span><br><span class="line">    <span class="comment">// 多创建一个集合，边界元素放到该集合内，以该集合为准</span></span><br><span class="line">    uf := newUF(t + <span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">                <span class="comment">// 边界位置都归到一个单独的集合</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> || j == <span class="number">0</span> || i == m - <span class="number">1</span>|| j == n -<span class="number">1</span> &#123;</span><br><span class="line">                    uf.union(i * n + j, t)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 只判断左边和上边，即可覆盖全部元素</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; board[i - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span> &#123; uf.union(i *n + j, (i - <span class="number">1</span>)*n + j) &#125;</span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span> &amp;&amp; board[i][j - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span> &#123; uf.union(i *n + j, i*n + j - <span class="number">1</span>) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="comment">// 判断是O的如果不和边界的元素属于同一集合，，则是被包围，更新为X</span></span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;O&#x27;</span> &amp;&amp; !uf.isConnect(i * n + j, t) &#123;</span><br><span class="line">                board[i][j] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a>省份数量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dfs</span></span><br><span class="line">func findCircleNum(isConnected [][]int) int &#123;</span><br><span class="line">    <span class="keyword">var</span> dfs func(i, j int)</span><br><span class="line">    dfs = <span class="function"><span class="title">func</span>(<span class="params">i,j int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> isConnected[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">            isConnected[i][j] = <span class="number">0</span></span><br><span class="line">            isConnected[j][i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; len(isConnected); x++ &#123;</span><br><span class="line">                dfs(x, j)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; len(isConnected[<span class="number">0</span>]); y++ &#123;</span><br><span class="line">                dfs(i, y)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(isConnected); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; len(isConnected[<span class="number">0</span>]); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> isConnected[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">                dfs(i, j)</span><br><span class="line">                res++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集1，每个元素单独处理，所有元素都加入集合</span></span><br><span class="line">type UF struct &#123;</span><br><span class="line">    union []int</span><br><span class="line">    count int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newUf (m, n int, isConnected [][]int) *UF &#123;</span><br><span class="line">    uf := UF&#123;make([]int, m * n), <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            uf.union[i * n + j] = i * n + j</span><br><span class="line">            <span class="keyword">if</span> isConnected[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">                uf.count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;uf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(uf *UF) find(x int) int &#123;</span><br><span class="line">    root := x</span><br><span class="line">    <span class="keyword">for</span> uf.union[root] != root &#123;</span><br><span class="line">        root = uf.union[root]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> x != root &#123;</span><br><span class="line">        tmp := uf.union[x]</span><br><span class="line">        uf.union[x] = root</span><br><span class="line">        x = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(uf *UF) <span class="function"><span class="title">Union</span>(<span class="params">x, y int</span>)</span> &#123;</span><br><span class="line">    rootX := uf.find(x)</span><br><span class="line">    rootY := uf.find(y)</span><br><span class="line">    <span class="keyword">if</span> rootX == rootY &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    uf.union[rootX] = rootY</span><br><span class="line">    uf.count--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func findCircleNum(isConnected [][]int) int &#123;</span><br><span class="line">    m := len(isConnected)</span><br><span class="line">    n := len(isConnected[<span class="number">0</span>])</span><br><span class="line">    uf := newUf(m, n, isConnected)</span><br><span class="line">    <span class="comment">// 看全部位置</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> isConnected[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">            	<span class="comment">// 合并对称位置</span></span><br><span class="line">                uf.Union(i*n + j, j*n + i)</span><br><span class="line">                isConnected[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="comment">// 合并当前位置和对称位置的同一列</span></span><br><span class="line">                <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; m; x++ &#123;</span><br><span class="line">                    <span class="keyword">if</span> isConnected[x][j] == <span class="number">1</span> &#123;</span><br><span class="line">                        uf.Union(i*n + j, x*n + j)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> isConnected[x][i] == <span class="number">1</span>&#123;</span><br><span class="line">                        uf.Union(j*n + i, x*n + i)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 合并当前位置和对称位置的同一行</span></span><br><span class="line">                <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; n; y++ &#123;</span><br><span class="line">                    <span class="keyword">if</span> isConnected[i][y] == <span class="number">1</span> &#123;</span><br><span class="line">                        uf.Union(i*n + j, i*n + y)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> isConnected[j][y] == <span class="number">1</span> &#123;</span><br><span class="line">                        uf.Union(j*n + i, j*n + y)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uf.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集2， 优化，初始化并查集直接按对称位置初始化</span></span><br><span class="line">type UF struct &#123;</span><br><span class="line">    union []int</span><br><span class="line">    count int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newUf (m int) *UF &#123;</span><br><span class="line">    uf := UF&#123;make([]int, m), m&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        uf.union[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;uf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(uf *UF) <span class="function"><span class="title">Union</span>(<span class="params">x, y int</span>)</span> &#123;</span><br><span class="line">    rootX := uf.find(x)</span><br><span class="line">    rootY := uf.find(y)</span><br><span class="line">    <span class="keyword">if</span> rootX == rootY &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    uf.union[rootX] = rootY</span><br><span class="line">    uf.count--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(uf *UF) find(x int) int &#123;</span><br><span class="line">    root := x</span><br><span class="line">    <span class="keyword">for</span> uf.union[root] != root &#123;</span><br><span class="line">        root = uf.union[root]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> x != root &#123;</span><br><span class="line">        tmp := uf.union[x]</span><br><span class="line">        uf.union[x] = root</span><br><span class="line">        x = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func findCircleNum(isConnected [][]int) int &#123;</span><br><span class="line">    m := len(isConnected)</span><br><span class="line">    uf := newUf(m)</span><br><span class="line">    <span class="comment">// 只看对称位置</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; m; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> isConnected[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">                uf.Union(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uf.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2018/01/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习编程之后，逐渐在这一领域有了一定的了解，在CSDN博客上看各种大神写的文章，那些未知的技术，引起了我的求知欲，同时看着别人炫酷的博客，也让我有了一个搭建自己的博客网站的想法，来对自己学过的知识，进行总结梳理，于是开始了我的博客之旅。</p>
<h4 id="1-搭建自己的博客网站需要耐心"><a href="#1-搭建自己的博客网站需要耐心" class="headerlink" title="1.搭建自己的博客网站需要耐心"></a>1.搭建自己的博客网站需要耐心</h4><p>对于我这种博客小白来说，搭建自己的个人博客，着实费了一番功夫，经过大约一周时间的研究学习，查阅各种资料，解决各种bug，尝试不同的主题效果，终于搭建好我自己的个人博客网站，可以开始写自己的第一篇博客文章，此刻我的心情是非常激动的，毕竟这大约一周时间的努力，取得了一定的成果，效果还比较满意，不过还要继续完善。</p>
<p>总的来说，过程非常繁琐，需要耐心，网上教程都很详细，一步步按照教程走即可，但是过程中有些细节需要综合自己的实际情况来定，不然会出一些难解决的bug，所以要懂一些js，css知识的原理。我用的是github+hexo搭建的，个人认为比较简单吧，也研究过ruby，jkelly那些方法，不过没安装上环境，就换了hexo，有兴趣的可以好好研究下。</p>
<h4 id="2-IT知识研究领域"><a href="#2-IT知识研究领域" class="headerlink" title="2. IT知识研究领域"></a>2. IT知识研究领域</h4><p>我主要学习的是Python，所以我的博客内容主要围绕着python来展开的，当然这只是一种编写程序的语言方式，所以本质上还是编程以及相关内容，比如Linux，web开发，框架，算法，爬虫，人工智能等，我个人对人工智能非常感兴趣，所以也会慢慢往这个方向去靠近，机器学习，神经网络等，自己慢慢研究学习吧。</p>
<h4 id="3-写博客文章的一些基本格式与上传命令"><a href="#3-写博客文章的一些基本格式与上传命令" class="headerlink" title="3. 写博客文章的一些基本格式与上传命令"></a>3. 写博客文章的一些基本格式与上传命令</h4><p>为了以后方便写博客，对于我这个博客小白，还是有必要在这里对于一些文章相关格式及命令，进行总结的。</p>
<p>通过github+hexo搭建好博客后，如何创建一篇新博客呢</p>
<p>在搭建博客的时候，会安装git软件，在根目录下打开git，通过git命令来执行，新建一篇博客：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> <span class="string">&quot;你的博客的名称&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后在根目录文件夹下source/_posts下新生成一个md文件，名称就是你自己起的名字，打开就可以开始写博客啦，要用markdown语法写，所以要提前准备一款编辑器，我个人用的是小书匠编辑器，还不错。</p>
<p>文章的一些格式属性有以下几种可以自己设置：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">title: 文章标题</span><br><span class="line">date:  创建时间，这里可以随意修改</span><br><span class="line">categories:  文章分类目录，可以为空</span><br><span class="line"><span class="keyword">tags:</span> 文章标签，可空，多标签请用格式[tag1,tag2,tag3]</span><br><span class="line">description: 对本页的描述，相当于是一个简介，如果这个定义了，就会在首页中出现这里的内容而不会出现整个文章详细内容。</span><br></pre></td></tr></table></figure>
<p>然后下面就可以开始写文章了，写完即可通过git上传了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>即可部署到github上。</p>
<h3 id="Algolia-Search"><a href="#Algolia-Search" class="headerlink" title="Algolia Search"></a>Algolia Search</h3><p>Application ID:   OHIM1HOSW9<br>Search-Only API Key:  c7106ccb9558345987ab72136d36caed<br>Admin API Key:   5fd4b81f76fbba2edfb3fff37aa97212</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-algolia</span><br><span class="line"><span class="keyword">export</span> HEXO_ALGOLIA_INDEXING_KEY=5fd4b81f76fbba2edfb3fff37aa97212</span><br><span class="line">hexo algolia</span><br><span class="line">hexo algolia --flush <span class="literal">true</span> --layouts post</span><br></pre></td></tr></table></figure>
<h4 id="4-开启博客之旅"><a href="#4-开启博客之旅" class="headerlink" title="4.开启博客之旅"></a>4.开启博客之旅</h4><p>以前的学习笔记都记录在本子上，或者其他文档里，之后将会慢慢整理在自己的博客上，来完善自己的学习体系，同时搭建自己的博客，让自己的博客更炫酷。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>关于操作系统相关问题</title>
    <url>/2021/03/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="linux进程间的通信方式"><a href="#linux进程间的通信方式" class="headerlink" title="linux进程间的通信方式"></a>linux进程间的通信方式</h3><p>1、管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。<br>2、信号(signal) 。<br>3、消息队列。<br>4、共享内存。<br>5、信号量。<br>6、套接字(socket) 。</p>
<h3 id="linux的硬链接和软连接"><a href="#linux的硬链接和软连接" class="headerlink" title="linux的硬链接和软连接"></a>linux的硬链接和软连接</h3><p>inode储存文件的元组信息， Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1</p>
<p>软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接</p>
<h3 id="linux调优相关"><a href="#linux调优相关" class="headerlink" title="linux调优相关"></a>linux调优相关</h3><p>cpu相关：程序调整优先级，不重要的优先级相对低一些，更新cpu</p>
<p>内存相关： free内存，swap分区，buffcache，调整page大小，降低page-out速度</p>
<p>网络相关：内核中调整网络参数<br>   通过调整net.ipv4.tcp_tw_reuse参数让处于TIME_WAIT状态的Socket对新连接可重用<br>   通过调整tcp_fin_timeout参数，让处于FIN-WAIT-2状态的Socket可以早一些关闭，进而节省内存<br>   通过调整tcp_keepalive_time参数，调整keepalive连接的关闭时间<br>   通过调整tcp_max_syn_backlog参数来调整最大能够容纳的处于半连接状态的socket的数量</p>
<p>关闭一些不需要的服务以及端口号</p>
<h3 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h3><p>cd， pwd， ls， ll(更详细) -a，touch创建文件，mkdir 创建目录， cat 查看日志文件， more分页查看， less可定位到最后一页</p>
<p>tail -f， cp复制，mv移动， rm 删除，grep 字符串模糊搜索， find查找文件， | 管道命令， tar解压缩， ps -ef -aux查看系统进程</p>
<p>netstat 显示网络状态， ping 测试连通， top查看正在执行的进程， free查看内存相关， sar -n DEV 显示网口统计数据（吞吐率，PPS）</p>
<p>sar -n TCP 显示tcp统计数据 netstat -nlp socket信息  ss -ltnp socket信息   ss -s连接数 netstat -s 查连接数</p>
<p>ping 查看连通性和延时  kill -1 查看所有信号  kill -9 杀死进程</p>
<h3 id="linux调整优先级"><a href="#linux调整优先级" class="headerlink" title="linux调整优先级"></a>linux调整优先级</h3><p>ps -ef， top查看进程信息，PR值和NI值</p>
<p>NI是优先级，用户态的概念，PR是内核态的优先级，一般情况下，PR=NI+20, 如果一个进程的优先级PR是20， 那么它的NI(nice)值就是20-20=0</p>
<p>可以通过改变NI来改变PR</p>
<p>NI的调整范围是-20到19</p>
<p>renice [number] PID</p>
<p>renice -n (nice值) -p (process进程值) :改单一进程优先级；</p>
<p>renice -n (nice值) -g (group组名）:改整个组员的优先级；</p>
<p>renice -n (nice值) -u (user用户名）:改用户的优先级；</p>
<h3 id="linux-内核态，用户态"><a href="#linux-内核态，用户态" class="headerlink" title="linux 内核态，用户态"></a>linux 内核态，用户态</h3><p>内核态：控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行</p>
<p>用户态：提供应用程序运行的空间，为了使应用程序访问到内核管理的资源例如CPU，内存，I/O。内核必须提供一组通用的访问接口，这些接口就叫系统调用</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是系统进行资源分配和调度的一个独立单位，程序段、数据段、PCB三部分组成了进程实体，PCB是唯一标识符（进程标识符，进程控制信息，状态）</p>
<h4 id="进程五个状态"><a href="#进程五个状态" class="headerlink" title="进程五个状态"></a>进程五个状态</h4><p>创建态： 操作系统为进程分配资源，初始化PCB</p>
<p>就绪态：运行资源等条件都满足，存储在就绪队列中，等待CPU调度</p>
<p>运行态：CPU正在执行进程</p>
<p>阻塞态：等待某些条件满足，等待消息回复，等待同步锁，sleep等，阻塞队列</p>
<p>终止态 ：回收进程拥有的资源，撤销PCB</p>
<h4 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h4><p>非剥夺调度方式（非抢占方式），只允许进程主动放弃，主动要求进入阻塞才会终止</p>
<p>剥夺调度方式（又称抢占方式）当一个进程正在处理机上执行时，如果有一个优先级更高的进程需要处理机，则立即开中断暂停正在执行的进程，将处理机饭呢陪给优先级高的那个进程</p>
<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>1、对原来的进程数据保存</p>
<p>2、对新的进程数据恢复</p>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p><img src="/2021/03/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/1.png" alt="1"></p>
<p>时间片轮询</p>
<p>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</p>
<p>适用于分时操作系统，由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度</p>
<p>优先级调度</p>
<p>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</p>
<p>适用于实时操作系统，用优先级区分紧急程度，可灵活地调整对各种作业/及进程的偏好程度</p>
<p>多级反馈队列调度</p>
<p>设置多级优先队列各级别队列优先级从高到底，时间片从小到大</p>
<h4 id="进程死锁"><a href="#进程死锁" class="headerlink" title="进程死锁"></a>进程死锁</h4><p>多个进程因循环等待而造成的无法执行的现象</p>
<p>互斥使用，不可抢占，请求保持，循环等待</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><img src="/2021/03/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/2.png" alt="2"></p>
<p>线程的是实现方式：</p>
<p>用户级线程：用户级线程由应用程序通过线程库是实现如python (import thread), 线程的管理工作由应用程序负责。</p>
<p>内核级线程：内核级线程的管理工作由操作系统内核完成，线程调度，切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成</p>
<h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p>独占锁-共享锁：当一个共享资源只有一份的时候，通常我们使用独占锁</p>
<p>互斥锁-自旋锁：</p>
<p>如果一个线程已经锁定了一个互斥锁，第二个线程又试图去获取这个互斥锁，则第二个线程将会被挂起（即休眠、不占用 CPU 资源）</p>
<p>指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环</p>
<p>当资源等待的时间较长，用互斥锁让线程休眠，会消耗更少的资源，当资源等待的时间较短时，使用自旋锁将减少线程的切换，获得更高的性能</p>
<p>重入锁：也叫作递归锁，指的是同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁</p>
<p>读写锁：读写锁允许同一时刻被多个读线程访问，但是在写线程访问时，所有读线程和其他的写线程都会被阻塞。简单可以总结为，读读不互斥，读写互斥，写写互斥，可针对场景升级降级锁</p>
<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><p>进程和线程的关系：一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。CPU的最小调度单元是线程，所以单进程多线程是可以利用多核CPU的</p>
<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<ol>
<li><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</p>
</li>
<li><p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p>
</li>
<li><p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
</li>
<li><p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
</li>
<li><p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别</p>
</li>
</ol>
<p><img src="/2021/03/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/3.png" alt="3"></p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p> Coroutines 是一种比线程更加轻量级的微线程。类比一个进程可以拥有多个线程，一个线程也可以拥有多个协程</p>
<p>协程通过在线程中实现调度，避免了陷入内核级别的上下文切换造成的性能损失，进而突破了线程在IO上的性能瓶颈。</p>
<p>完全由用户实现控制，有自己的上下文及寄存器和栈</p>
<p>python的协程源于yield指令</p>
<p>yield item 用于产出一个值，反馈给next()的调用方法<br>让出处理机，暂停执行生成器，让调用方继续工作，直到需要使用另一个值时再调用next()<br>协程式对线程的调度，yield类似惰性求职方式可以视为一种流程控制工具，实现协作式多任务，python3.5引入了async/await表达式，使得协程证实在语言层面得到支持和优化，大大简化之前的yield写法。线程正式在语言层面得到支持和优化。线程是内核进行抢占式调度的，这样就确保每个线程都有执行的机会。而coroutine运行在同一个线程中，有语言层面运行时中的EventLoop（事件循环）来进行调度。在python中协程的调度是非抢占式的，也就是说一个协程必须主动让出执行机会，其他协程才有机会运行。让出执行的关键字 await， 如果一个协程阻塞了，持续不让出CPU处理机，那么整个线程就卡住了，没有任何并发。</p>
<p>goalng协程模型</p>
<h3 id="cpu的使用率与负载"><a href="#cpu的使用率与负载" class="headerlink" title="cpu的使用率与负载"></a>cpu的使用率与负载</h3><p>local average，平均负载，1分钟，5分钟，15分钟</p>
<p>负载高利用率低：说明io密集型任务，，任务较多，查看是否有p+状态的进程，睡眠不可终止的进程，重启，恢复依赖资源</p>
<p>负载低利用率高：说明任务执行时间长，根据任务看代码， top操作</p>
]]></content>
      <categories>
        <category>环境运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库设计</title>
    <url>/2024/02/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="数据库模式"><a href="#数据库模式" class="headerlink" title="数据库模式"></a>数据库模式</h2><p>内模式：简单点说就是管理如何存储物理的数据 ， 对应具体物理存储文件</p>
<p>模式 ： 又称为概念模式，简单点说就是我们通常使用的基本表 ， 根据应用 、 需求将物理数据划分成一 张张表</p>
<p>外模式：也称用户模式或子模式，对应数据库中的视图这个级别 ， 将表进行一定的处理后再提供给用户使用，外模式可以有很多，内模式，模式只有一个</p>
<p>外模式/概念模式映像：是表和视图之间的映射 ， 存在于概念级和外部级之间 ， 若表中数据发生了修改 ， 只需要修改此映射 ， 而无需修改应用程序 ，修改逻辑独立性。</p>
<p>概念模式/内模式映像：是表和数据的物理存储之间的映射 存在于概念级和内部级之间 ， 若修改了数据存储方式 ， 只需要修改此映射 ，而不需要去修改应用程序，修改物理独立性。</p>
<h2 id="数据库设计步骤"><a href="#数据库设计步骤" class="headerlink" title="数据库设计步骤"></a>数据库设计步骤</h2><p>1、需求分析<br>产出物有数据流图 DFD、数据字典DD 、需求说明书SRS 。 获得用户对系统的三个要求 ： 信息要求 、处理要求 、 系统要求<br>2、概念结构设计<br>设计E-R图， 也即实体-联系图，产出ER模型<br>3、逻辑结构设计<br>将 E-R 图，转换成关系模式，产出关系模型<br>4、物理设计<br>步骤包括确定数据分布 、存储结构和访问方式</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="概念数据模型（实体—联系模型）"><a href="#概念数据模型（实体—联系模型）" class="headerlink" title="概念数据模型（实体—联系模型）"></a>概念数据模型（实体—联系模型）</h3><p>按照用户的观点来对数据和信息建模，主要用于数据 库设计。概念模型主要用实体—联系方法（Entity-Relationship Approach）表示，所以也称 E-R 模型</p>
<p>概念模型是从用户的角度进行建模的</p>
<p>在E-R模型中，使用椭圆表示属性 ( 一般没有) 、长方形表示实体（强实体）、长方形里两道竖岗表示弱实体 、菱形表示联系 ， 联系的两端要填写联系类型</p>
<h3 id="基本数据模型（结构数据模型）"><a href="#基本数据模型（结构数据模型）" class="headerlink" title="基本数据模型（结构数据模型）"></a>基本数据模型（结构数据模型）</h3><p>是按照计算机系统的观点来对数据和信息建模，主要用于 DBMS 的实现。基本数据模型是数据库系统的核心和基础</p>
<p>关系模型是二维表的形式表示的实体-联系模型</p>
<p>网状模型表示实体类型及其实体之间的联系</p>
<p>面向对象模型是采用面向对象的方法设计数据库，以对象为单位，每个对象包括属性和方法 ， 具有类和继承等特点</p>
<p>数据模型三要素： </p>
<p>数据结构 (所研究的对象类型的集合) </p>
<p>数据操作 (对数据库中各种对象的实例允许执行的操作的集合) </p>
<p>数据的约束条件 ( 一组完整性规则的集合)</p>
<h4 id="数据的约束条件"><a href="#数据的约束条件" class="headerlink" title="数据的约束条件"></a>数据的约束条件</h4><p>实体完整性。实体完整性是指实体的主属性不 能取空值</p>
<p>参照完整性。在关系数据库中主要是值得外键参照的 完整性。若A关系中的某个或者某些属性参照B或其他几个关系中的属性，那么在关系A中该属性要么为空，要么必须出现B或者其他的关系的对应属性中</p>
<p>用户定义完整性。用户定义完整性反映的某一个具 体应用所对应的数据必须满足一定的约束条件</p>
<h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>优点 ：建立在严格的数学概念基础上； 概念单一、结构简单 、清晰 ， 用户易懂易用 ； 存取路径对用户透明 ， 从而数据独立性 、 安全性好 ， 简化数据库开发工作 。<br>缺点： 由于存取路径透明，查询效率往往不如非关系数据模型</p>
<p>关系：可以理解为一张二维表，每个关系都具有一个关系名， 就是通常说的表名。<br>元组：可以理解为二维表中的一行，在数据库中经常被称为记 录。<br>属性：可以理解为二维表中的一列，在数据库中经常被称为字 段。<br>域：属性的取值范围，也就是数据库中某一列的取值限制。<br>关键字：一组可以唯一标识元组的属性，数据库中常称为主键， 由一个或多个列组成。<br>关系模式：指对关系的描述。其格式为：关系名（属性1，属性<br>2 ，……，属性N），在数据库中成为表结构。</p>
<h3 id="模型转换"><a href="#模型转换" class="headerlink" title="模型转换"></a>模型转换</h3><p>ER图是全局设计概念，不适合计算机处理，为了适应关系型数据库处理，必须将ER图转换为关系模型</p>
<p>E-R模型转换为关系模型 ：每个实体都对应一个关系模式，实体名对应关系模型的名称，实体属性对应关系模型的属性，实体标识符（联系）对应关系模型的码</p>
<p>1:1联系中 ，联系可以放到任意的两端实体中， 作为一个属性 (要保证1:1 的两端关联) ， 也可以转换为一个单独的关系模式；<br>1:N 的联系中 ， 联系可以单独作为一个关系模式， 也可以在N端中加入1端实体的主键；<br>M:N的联系中 ，联系必须作为 一个单独的关系模式 ，其主键是M和N端的联合主键</p>
<h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><p><img src="/2024/02/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/1.jpg" alt="1"></p>
<p>并：S1 U S2， 结果是两张表中所有记录数合并 ，相同记录只显示一次。<br>交：S1 ∩ S2 ,结果是两张表中相同的记录 。<br>差：S1 - S2 ，结果是S1表中有而S2表中没有的那些记录。</p>
<p>笛卡尔积 ：S1<em>S2 ，产生的结果包括S1和S2的所有属性列 ，并且S1 中每条记录依次和S2 中所有记录组合成一条记录，最终属性列为S1+S2属性列，记录数为 S1</em>S2记录数<br><img src="/2024/02/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/2.jpg" alt="1"></p>
<p>查询年龄小于22岁的学生 σSage&lt;22(student)<br>查询学生的姓名和所在系πSname,Sdept(Student)</p>
<p>自然连接的结果显示全部的属性列 ， 但是相同属性列只显示一次 ， 显示两个关系模式中属性相同且值相同的记录。<br>设有关系R、S如下左图所示， 自然连接结果如下右图所示：<br><img src="/2024/02/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/3.jpg" alt="1"></p>
<p>注意RxS，和R自然连接S</p>
<h2 id="函数依赖范式"><a href="#函数依赖范式" class="headerlink" title="函数依赖范式"></a>函数依赖范式</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>给定一个X， 能唯一确定一个Y， 就称X确定Y，或者说Y依赖于X ，例如Y=X*X 函数 。<br>函数依赖又可扩展以下两种规则 :<br>部分函数依赖 ：A可确定C，(A,B)也可确定C，(A,B)中的一部分 (即A ) 可以确定C ，称为部分函数依赖。<br>传递函数依赖：当A和B不等价时，A可确定B，B可确定C，则A可确定C，是传递函数依赖；<br>若A和B等价，则不存在传递，直接就可确定C</p>
<p>设关系模式R&lt;U，F&gt; ,U是关系模式R 的属性全集，F是关系模式R的一个函数依赖集 。<br>对于R&lt;U，F&gt;来说有以下的：<br><img src="/2024/02/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/4.jpg" alt="1"></p>
<p>超键 ： 能唯一标识此表的属性的组合 。<br>候选键： 超键中去掉冗余的属性 ， 剩余的属性就是候选键。<br>主键 ：任选一 个候选键 ， 即可作为主键。<br>外键 ： 其他表中的主键。<br>主属性和非主属性： 候选键内的属性为主属性 ， 其他属性为非主属性</p>
<p>候选键：候选码，可以作为主键的字段<br>根据依赖集，没有出现在右边的字段，且能推导出所有的字段的是候选码<br>然后确定主属性，非主属性</p>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>关系中的每一个分量必须是一个不可分的数据项 。通俗地说 ，第一范式就是表中不允许有小表的存在</p>
<h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>如果关系R属于1NF， 且每一个非主属性完全函数依赖于任何一个候选码 ，则R属于2NF。<br>2NF就是在1NF的基础上 ，表中的每一个非主属性不会依赖复合主键中的某一个列，</p>
<p>通俗的说就是表中不能存在联合主键</p>
<h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>在满足1NF的基础上 ， 表中不存在非主属性对码的传递依赖。每一列都和主键直接相关</p>
<h4 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h4><p>在第三范式的基础上进一步消除主属性对于码的部分函数依赖和传递依赖。<br>通俗的来说 ，就是在每一种情况下 每一个依赖的左边决定因素都必然包含候选键 </p>
<h2 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h2><p>把一个关系模式分解成若干个关系模式的过程，也就是由低范式转换为高范式的过程，称为关系模式的分解，简称模式分解。<br>模式分解具体是通过将原关系模式的属性集进行拆分来实现 ，拆分后的关系模式包含新的属性集，以及新的函数依赖集。<br>为使分解后的模式与原模式等价，一般要求模式分解具有无损连接性（属性）与保持依赖性（函数依赖）</p>
<p>对于关系模式R， 有依赖集F ，若对R进行分解， 分解出来的多个关系模式，都有对应的函<br>数依赖集。</p>
<h3 id="保持函数依赖"><a href="#保持函数依赖" class="headerlink" title="保持函数依赖"></a>保持函数依赖</h3><p>所谓的保持函数依赖就是将分解之后的函数依赖集合并起来（令其等于G），与原来的函数依赖集F是保持等价的，也就是我们就会说是保持函数依赖的。</p>
<p>判断函数依赖集等价公式为：G+（函数依赖集G的闭包） = F+（函数依赖集F的闭包）。注意：拆分前后的函数依赖集判断是否等价时，不需要考虑冗余依赖(如传递依赖) 。</p>
<p>闭包：说属性的闭包就是由一个属性直接或间接推导出的所有属性的集合。<br>例如： f={a-&gt;b,b-&gt;c,a-&gt;d,e-&gt;f} 由a可直接得到b和d，间接得到c，则a的闭包就是{a,b,c,d}，<br>可以写出a+={a,b,c,d}</p>
<p>完整的判断保持函数依赖的方法：<br>① 先求函数依赖集投影到分解后的Ri上的函数依赖子集Fi。<br>② 求分解后关系模式函数依赖集的并集，并令其等于G。<br>③ 判断F是否包含在G的闭包中。（此处不需要判断G是否包含在F的闭包中，因为G中的每个函数依赖都是由F根据Armstrong公理推导出来的，所以G必定包含于F闭包）</p>
<p>关系模式R(U,F),其中U={A,B,C,D},F={A→B,B→C,C→D,D→A},分解<br>ρ={R1(A,B),R2(B,C),R3(C,D)}是否具有函数依赖保持性?<br>解：<br>① 求函数依赖子集<br>F1 = πU1(F)=(A→B,B→A);<br>F2 = πU2(F)=(B→C,C→B);<br>F3 = πU3(F)=(C→D,D→C);<br>② 求分解后函数依赖的并集，令其等于G<br>G=F1∪F2∪F3={A→B,B→A,B→C,C→B,C→D,D→C};<br>F={A→B,B→C,C→D,D→A}。<br>③ 判断F是否包含在G的闭包中<br>经过初步观察，F中的{D-&gt;A}不包含在G中，但是通过求G的闭包后，也就是根据G中的依<br>赖集D-&gt;C，C-&gt;B，B-&gt;A，得出G中是包含{D-&gt;A}这个依赖的，所以F包含于G的闭包中。<br>因此，有G+=F+，即ρ具有函数依赖保持性。</p>
<h3 id="无损连接分解"><a href="#无损连接分解" class="headerlink" title="无损连接分解"></a>无损连接分解</h3><p>分解后的关系模式能够还原出原关系模式，就是无损连接分解 ，不能还原就是有损连接分解</p>
<p>如何判断是否无损连接？<br>公式法：判断分解为两个关系模式的情况：如果R 的分解为ρ={R1，R2} ，F为R所<br>满足的函数依赖集合，分解ρ具有无损连接性的充分必要条件是：R1∩R2-&gt;(R1- R2)或者R1∩R2-&gt;(R2-R1)。<br>表格法：当分解为三个及以上关系模式时 ， 可以通过表格法求解<br><img src="/2024/02/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/5.jpg" alt="1"></p>
<p><img src="/2024/02/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/6.jpg" alt="1"></p>
<h2 id="反规范技术"><a href="#反规范技术" class="headerlink" title="反规范技术"></a>反规范技术</h2><p>反规范化技术：规范化设计后，会导致关系的概念愈来愈单一化，在查询时往往需要涉及更多表的关联操作，导致查询性能下降。数据库设计者希望牺牲部分规范化设计（比如对部分影响性能的关系模式进行处理，包括分解、合并、增加冗余属性等）来提高读操作性能 。<br>采用反规范化技术的益处：降低过多连接操作的需求、 降低外码和索引的数目，还可能减少表的数目，进而能够提高查询效率 。<br>采用反规范化技术的问题： 数据的重复存储， 浪费了磁盘空间； 可能出现数据的完整性问题 ， 为了保障数据的一致性， 增加了数据维护的复杂性， 会降低修改速度</p>
<p>增加冗余列<br>增加派生列<br>重新组表<br>分割表<br>水平分割：根据一列或多列数据的值把数据行放到两个独立的表中<br>垂直分割:  把主码和一些列放到一个表，然后把主码和另外的列放到另一个表中</p>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>原子性，一致性，隔离性，持续性</p>
<p>并发问题：丢失更新，不可重复读，脏读</p>
<h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><h4 id="排他型封锁"><a href="#排他型封锁" class="headerlink" title="排他型封锁"></a>排他型封锁</h4><p>（简称 X 封锁，也叫写锁）。若事务T对数据对象A加上X锁 ，则只允许T读取和修改A ， 其他事务都不能再对A加任何类型的锁，直到T释放A上的锁。可见 X 封锁只允许一个事务独锁某个数据，有排他性。</p>
<h4 id="共享型封锁"><a href="#共享型封锁" class="headerlink" title="共享型封锁"></a>共享型封锁</h4><p>（简称 S 封锁，也叫读锁）。若事务T对数据对象A加上S锁，则只允许T读取A ，但不能修改A ，其他事务只能再对A加S锁 (也即能读不能修改) ，直到T释放A上的S锁</p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>共分为三级封锁协议 ， 分别是：一级封锁协议 ，二级封锁协议和三级封锁协议<br><img src="/2024/02/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/7.jpg" alt="1"></p>
<p>一级封锁协议 ：事务在修改数据R之前必须先对其加X锁， 直到事务结束才释放。<br>可解决丢失更新问题</p>
<p>二级封锁协议 ：一级封锁协议的基础上加上事务T在读数据R之前必须先对其加S锁 ，读<br>完后即可释放S锁。<br>可解决丢失更新 、读脏数据问题</p>
<p>三级封锁协议 ：一级封锁协议加上事务T在读取数据R之前先对其加S锁， 直到事务结束<br>才释放。<br>可解决丢失更新、读脏数据、数据重复读问题</p>
<h2 id="数据库安全备份与恢复"><a href="#数据库安全备份与恢复" class="headerlink" title="数据库安全备份与恢复"></a>数据库安全备份与恢复</h2><p>静态转储：即冷备份 ，指在转储期间不允许对数据库进行任何存取 、修改操作；<br>优点是非常快速的备份方法 、容易归档 (直接物理复制操作)<br>缺点是只能提供到某一时间点上的恢复， 不能做其他工作， 不能按表或按用户恢复。</p>
<p>动态转储：即热备份，在转储期间允许对数据库进行存取、修改操作， 因此转储和用户事务可并发执行；<br>优点是可在表空间或数据库文件级备份，数据库扔可使用，可达到秒级恢复；<br>缺点是不能出错，否则后果严重， 若热备份不成功， 所得结果几乎全部无效。</p>
<p>完全备份 ： 备份所有数据 。<br>差量备份： 仅备份上一次完全备份之后变化的数据。<br>增量备份： 备份上一次备份之后变化的数据。</p>
<h2 id="数据库扩展"><a href="#数据库扩展" class="headerlink" title="数据库扩展"></a>数据库扩展</h2><h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><p>分片模式<br>水平分片：将表中水平的记录分别存放在不同的地方。<br>垂直分片：将表中垂直的列值分别存放在不同的地方。</p>
<p>分布透明性<br>分片透明性： 用户或应用程序不需要知道逻辑上访问的表具体是如何分块存储的。<br>位置透明性：应用程序不关心数据存储物理位置的改变。<br>逻辑透明性： 用户或应用程序无需知道局部使用的是哪种数据模型。<br>复制透明性： 用户或应用程序不关心复制的数据从何而来。</p>
<h3 id="数据仓库技术"><a href="#数据仓库技术" class="headerlink" title="数据仓库技术"></a>数据仓库技术</h3><p>数据仓库是一个面向主题的、集成的、 非易失的、 且随时间变化的数据集合， 用于支持管理决策</p>
<p>数据仓库的结构通常包含四个层次，</p>
<ol>
<li>数据源 ：是数据仓库系统的基础 ，是整个系统的数据源泉。</li>
<li>数据的存储与管理 ：是整个数据仓库系统的核心。</li>
<li>OLAP (联机分析处理) 服务器：对分析需要的数据进行有效集成 ，按多维模型组织 ，以便进行多角度 、多层次的分析 ， 并发现趋势。</li>
<li>前端工具 ：主要包括各种报表工具 、查询工具 、数据分析工具 、数据挖掘工具以及各种基于数据仓库或数据集市的应用开发工具。</li>
</ol>
<p>BI系统主要包括数据预处理 、建立数据仓库 、数据分析和数据展现四个主要阶段</p>
<p>1、数据预处理是整合企业原始数据的第一步 ， 它包括数据的抽取(Extraction) 、转换 (Transformation) 和加载 (Load) 三个过程 (ETL过程) ；<br>2、建立数据仓库则是处理海量数据的基础；<br>3、数据分析是体现系统智能的关键， 一般采用联机分析处理 (OLAP) 和数据挖掘两大技术 。<br>1）联机分析处理不仅进行数据汇总/聚集， 同时还提供切片、切块、下钻、上卷和旋转等数据分析功能 ， 用户可以方便地对海量数据进行多维分析 。<br>2）数据挖掘的目标则是挖掘数据背后隐藏的知识 ， 通过关联分析 、聚类和分类等方法建立分析模型 ， 预测企业未来发展趋势和将要面临的问题；<br>4、在海量数据和分析手段增多的情况下， 数据展现则主要保障系统分析结果的可视化</p>
<h3 id="大数据技术"><a href="#大数据技术" class="headerlink" title="大数据技术"></a>大数据技术</h3><p>特点： 大量化、多样化、价值密度低、快速化</p>
<p>要处理大数据 ， 一般使用集成平台 ， 称为大数据处理系统 ， 其特征为：高度可扩展性 、高性能 、高度容错 、支持异构环境 、较短的分析延迟、易用且开放的接口 、较低成本 、 向下兼容性</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库设计规范与原则</title>
    <url>/2018/03/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E4%B8%8E%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="MYSQL数据库设计规范"><a href="#MYSQL数据库设计规范" class="headerlink" title="MYSQL数据库设计规范"></a>MYSQL数据库设计规范</h2><h3 id="1、数据库命名规范"><a href="#1、数据库命名规范" class="headerlink" title="1、数据库命名规范"></a>1、数据库命名规范</h3><p>采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’_’组成;<br>命名简洁明确(长度不能超过30个字符);<br>例如:user, stat, log, 也可以wifi_user, wifi_stat, wifi_log给数据库加个前缀;<br>除非是备份数据库可以加0-9的自然数:user_db_20151210;</p>
<h3 id="2、数据库表名命名规范"><a href="#2、数据库表名命名规范" class="headerlink" title="2、数据库表名命名规范"></a>2、数据库表名命名规范</h3><p>采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’<em>‘组成;<br>命名简洁明确,多个单词用下划线’</em>‘分隔;<br>例如:user_login, user_profile, user_detail, user_role, user_role_relation,<br>user_role_right, user_role_right_relation<br>表前缀’user_’可以有效的把相同关系的表显示在一起;</p>
<h3 id="3、数据库表字段名命名规范"><a href="#3、数据库表字段名命名规范" class="headerlink" title="3、数据库表字段名命名规范"></a>3、数据库表字段名命名规范</h3><p>采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’<em>‘组成;<br>命名简洁明确,多个单词用下划线’</em>‘分隔;<br>例如:user_login表字段 user_id, user_name, pass_word, eamil, tickit, status, mobile, add_time;<br>每个表中必须有自增主键,add_time(默认系统时间)<br>表与表之间的相关联字段名称要求尽可能的相同;</p>
<h3 id="4、数据库表字段类型规范"><a href="#4、数据库表字段类型规范" class="headerlink" title="4、数据库表字段类型规范"></a>4、数据库表字段类型规范</h3><p>用尽量少的存储空间来存数一个字段的数据;<br>例如:能使用int就不要使用varchar、char,能用varchar(16)就不要使用varchar(256);<br>IP地址最好使用int类型;<br>固定长度的类型最好使用char,例如:邮编;<br>能使用tinyint就不要使用smallint,int;<br>最好给每个字段一个默认值,最好不能为null;</p>
<h3 id="5、数据库表索引规范"><a href="#5、数据库表索引规范" class="headerlink" title="5、数据库表索引规范"></a>5、数据库表索引规范</h3><p>命名简洁明确,例如:user_login表user_name字段的索引应为user_name_index唯一索引;<br>为每个表创建一个主键索引;<br>为每个表创建合理的索引;<br>建立复合索引请慎重;</p>
<h3 id="6、简单熟悉数据库范式"><a href="#6、简单熟悉数据库范式" class="headerlink" title="6、简单熟悉数据库范式"></a>6、简单熟悉数据库范式</h3><p>第一范式(1NF):字段值具有原子性,不能再分(所有关系型数据库系统都满足第一范式);<br>例如:姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;<br>第二范式(2NF):一个表必须有主键,即每行数据都能被唯一的区分;<br>备注:必须先满足第一范式;<br>第三范式(3NF):一个表中不能包涵其他相关表中非关键字段的信息,即数据表不能有沉余字段;<br>备注:必须先满足第二范式;<br>备注:往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询;<br>例如:相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段;</p>
<h2 id="MYSQL数据库设计原则"><a href="#MYSQL数据库设计原则" class="headerlink" title="MYSQL数据库设计原则"></a>MYSQL数据库设计原则</h2><h3 id="1、核心原则"><a href="#1、核心原则" class="headerlink" title="1、核心原则"></a>1、核心原则</h3><p>不在数据库做运算;<br>cpu计算务必移至业务层;<br>控制列数量(字段少而精,字段数建议在20以内);<br>平衡范式与冗余(效率优先;往往牺牲范式)<br>拒绝3B(拒绝大sql语句:big sql、拒绝大事物:big transaction、拒绝大批量:big batch);</p>
<h3 id="2、字段类原则"><a href="#2、字段类原则" class="headerlink" title="2、字段类原则"></a>2、字段类原则</h3><p>用好数值类型(用合适的字段类型节约空间);<br>字符转化为数字(能转化的最好转化,同样节约空间、提高查询性能);<br>避免使用NULL字段(NULL字段很难查询优化、NULL字段的索引需要额外空间、NULL字段的复合索引无效);<br>少用text类型(尽量使用varchar代替text字段);</p>
<h3 id="3、索引类原则"><a href="#3、索引类原则" class="headerlink" title="3、索引类原则"></a>3、索引类原则</h3><p>合理使用索引(改善查询,减慢更新,索引一定不是越多越好);<br>字符字段必须建前缀索引;<br>不在索引做列运算;<br>innodb主键推荐使用自增列(主键建立聚簇索引,主键不应该被修改,字符串不应该做主键)(理解Innodb的索引保存结构就知道了);<br>不用外键(由程序保证约束);</p>
<h3 id="4、sql类原则"><a href="#4、sql类原则" class="headerlink" title="4、sql类原则"></a>4、sql类原则</h3><p>sql语句尽可能简单(一条sql只能在一个cpu运算,大语句拆小语句,减少锁时间,一条大sql可以堵死整个库);<br>简单的事务;<br>避免使用trig/func(触发器、函数不用客户端程序取而代之);<br>不用select <em>(消耗cpu,io,内存,带宽,这种程序不具有扩展性);<br>OR改写为IN(or的效率是n级别);<br>OR改写为UNION(mysql的索引合并很弱智);<br>select id from t where phone = ’159′ or name = ‘john’;<br>=&gt;<br>select id from t where phone=’159′<br>union<br>select id from t where name=’jonh’<br>慎用count(</em>);<br>limit高效分页(limit越大,效率越低);<br>使用union all替代union(union有去重开销);<br>少用连接join;<br>使用group by;</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>sql进程锁表问题</title>
    <url>/2019/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E8%A1%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h4 id="解决锁表问题，杀进程"><a href="#解决锁表问题，杀进程" class="headerlink" title="解决锁表问题，杀进程"></a>解决锁表问题，杀进程</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.processlist</span><br><span class="line"># 查询正在进行的进程，然后kill掉</span><br><span class="line"></span><br><span class="line">show processlist 命令行操作</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数组、链表和跳表</title>
    <url>/2021/02/01/%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8%E5%92%8C%E8%B7%B3%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表是最常用且最简单的一种数据结构，它是n个数据元素的有限序列。</p>
<p>实现线性表的方式一般有两种，一种是使用数组存储线性表的元素，即用一组连续的存储单元依次存储线性表的数据元素。另一种是使用链表存储线性表的元素，即用一组任意的存储单元存储线性表的数据元素（存储单元可以是连续的，也可以是不连续的）</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>golang 数组  slice</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []int</span><br></pre></td></tr></table></figure>

<p>每当申请数组时，计算机在内存中开辟了一段连续的地址，每一个地址直接可以通过内存管理器进行访问</p>
<p>所以无论访问哪个元素，时间复杂度是一样的，常数O(1)的</p>
<p>添加，删除时的操作，插入，删除元素都需要移动后面的元素，复杂度是O(n)</p>
<p>prepend: O(1), append: O(1), insert：O(n), del: O(n), lookup:O(1)</p>
<p>prepend正常情况下是O(n),可以特殊化到O(1)，申请稍大一些的内存空间，在前面预留一些，操作的时候把头下标前移一个位置即可</p>
<p><img src="/2021/02/01/%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8%E5%92%8C%E8%B7%B3%E8%A1%A8/1.png" alt="1"></p>
<p>空间复杂度</p>
<p>O(n)</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>1.每个元素有Value、Next，next指向下一个元素</p>
<p>2.头指针用head表示，尾指针用tail表示</p>
<p>3.最后一个元素next指向空</p>
<p>4.增加或删除节点的话，没有引起整个链表的群移操作，也不需要复制元素，挪动元素到新的位置，所以它移动的效率和修改的操作效率非常高，复杂度为O(1)</p>
<p>5.这个结构导致了访问链表中的任何一个位置，操作就不再简单了，复杂度为O(n)</p>
<p>prepend: O(1), append: O(1), insert：O(1), del: O(1), lookup:O(n)</p>
<p><img src="/2021/02/01/%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8%E5%92%8C%E8%B7%B3%E8%A1%A8/5.png" alt="5"></p>
<p><img src="/2021/02/01/%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8%E5%92%8C%E8%B7%B3%E8%A1%A8/2.png" alt="2"></p>
<p>空间复杂度</p>
<p>O(n)</p>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListNode ...</span></span><br><span class="line">type ListNode struct &#123;</span><br><span class="line">    Val int</span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由各个内存结构通过一个 Next 指针链接在一起组成，每一个内存结构都存在后继内存结构【链尾除外】，内存结构由数据域和 Next 指针域组成</p>
<p>1.Data 数据 + Next 指针，组成一个单链表的内存结构</p>
<p>2.第一个内存结构称为 链头，最后一个内存结构称为 链尾</p>
<p>3.链尾的 Next 指针设置为 NULL [指向空]</p>
<p>4.单链表的遍历方向单一【只能从链头一直遍历到链尾】</p>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DNode ...</span></span><br><span class="line">type DNode struct &#123;</span><br><span class="line">	data interface&#123;&#125;</span><br><span class="line">	prev *DNode</span><br><span class="line">	next *DNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由各个内存结构通过指针 Next 和指针 Prev 链接在一起组成，每一个内存结构都存在前驱内存结构和后继内存结构【链头没有前驱，链尾没有后继】，内存结构由数据域、Prev 指针域和 Next 指针域组成</p>
<p>1.Data 数据 + Next 指针 + Prev 指针，组成一个双向链表的内存结构</p>
<p>2.第一个内存结构称为 链头，最后一个内存结构称为 链尾</p>
<p>3.链头的 Prev 指针设置为 NULL， 链尾的 Next 指针设置为 NULL</p>
<p>4.Prev 指向的内存结构称为 前驱， Next 指向的内存结构称为 后继</p>
<p>5.双向链表的遍历是双向的，即如果把从链头的 Next 一直到链尾的[NULL] 遍历方向定义为正向，那么从链尾的 Prev 一直到链头 [NULL ]遍历方向就是反向</p>
<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>在单向链表和双向链表的基础上</p>
<p>单向循环链表 [Circular Linked List] : 由各个内存结构通过一个指针 Next 链接在一起组成，每一个内存结构都存在后继内存结构，内存结构由数据域和 Next 指针域组成。</p>
<p>双向循环链表 [Double Circular Linked List] : 由各个内存结构通过指针 Next 和指针 Prev 链接在一起组成，每一个内存结构都存在前驱内存结构和后继内存结构，内存结构由数据域、Prev 指针域和 Next 指针域组成。</p>
<p>1.循环链表分为单向、双向两种</p>
<p>2.单向的实现就是在单链表的基础上，把链尾的 Next 指针直接指向链头，形成一个闭环</p>
<p>3.双向的实现就是在双向链表的基础上，把链尾的 Next 指针指向链头，再把链头的 Prev 指针指向链尾，形成一个闭环</p>
<p>4.循环链表没有链头和链尾的说法，因为是闭环的，所以每一个内存结构都可以充当链头和链尾</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>链表在增加删除都很快，都是O(1)操作</p>
<p>但是查询很慢，是O(n)那么如何给链表的查询加速呢</p>
<p>升维</p>
<p>增加多级索引</p>
<p><img src="/2021/02/01/%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8%E5%92%8C%E8%B7%B3%E8%A1%A8/3.png" alt="3"></p>
<p>由于节点的增删改查，会导致索引不工整，维护成本相对较高。</p>
<p>在redis里面，就是使用的跳表。</p>
<p>时间复杂度</p>
<p><img src="/2021/02/01/%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8%E5%92%8C%E8%B7%B3%E8%A1%A8/4.png" alt="4"></p>
<p>索引的高度：logn，每层索引遍历的结点个数：3</p>
<p>在跳表中查询任意数据的时间复杂度就是 O(logn)</p>
<p>空间复杂度</p>
<p>O(n)</p>
<p>每层节点，每两个节点抽1个 n/2, 每3个节点抽一个 3/n</p>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列</title>
    <url>/2020/12/09/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h2 id="Fib"><a href="#Fib" class="headerlink" title="Fib"></a>Fib</h2><p>0, 1, 1, 2, 3, 5, 8, 13, 21 ……</p>
<p>数学公式： F(n) = F(n - 1) + F(n - 2)</p>
<h2 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>类似：青蛙跳台阶</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>f(x)=f(x−1)+f(x−2)</p>
<p>每次只能爬1级或2级，所以f(x)只能从f(x−1)和f(x−2)转移过来，而这里要统计方案总数，我们就需要对这两项的贡献求和。</p>
<p>以上是动态规划的转移方程，下面我们来讨论边界条件。我们是从第0级开始爬的，所以从第0级爬到第0级我们可以看作只有一种方案，即f(0)=1从第0级到第1级也只有一种方案，即爬一级，f(1)=1。这两个作为边界条件就可以继续向后推导出第n 级的正确结果。我们不妨写几项来验证一下，根据转移方程得到f(2)=2，f(3)=3，f(4)=5……我们把这些情况都枚举出来，发现计算的结果是正确的。</p>
<p>符合斐波那契数列规律,这里形成的数列正好是斐波那契数列，答案要求的f(n 即是斐波那契数列的第n项（下标从0开始）</p>
<p>我们不难通过转移方程和边界条件给出一个时间复杂度和空间复杂度都是(n) 的实现，但是由于这里的f(x) 只和f(x−1)与f(x−2) 有关，所以我们可以用「滚动数组思想」把空间复杂度优化成 O(1)</p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func Fib(n int) []int &#123;</span><br><span class="line">  dp := make([]int, n+<span class="number">1</span>)</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">2</span>; i&lt;=n; i++ &#123;</span><br><span class="line">    dp[i] = dp[i-<span class="number">2</span>] + dp[i-<span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h4 id="常数-优化"><a href="#常数-优化" class="headerlink" title="常数(优化)"></a>常数(优化)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func Fib(n int) int &#123;</span><br><span class="line">    p, q, <span class="attr">r</span> := <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        p = q</span><br><span class="line">        q = r</span><br><span class="line">        r = p + q</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用常数作辅助中间变量，时间复杂度为O(n),空间复杂度为(1)</p>
<p>该方法适用于n比较小的时候，n比较大的时候，复杂度就会比较高</p>
<h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><h4 id="直接递归"><a href="#直接递归" class="headerlink" title="直接递归"></a>直接递归</h4><p>直接利用斐波那契公式即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func Fib(i int) int &#123;</span><br><span class="line">	<span class="keyword">if</span> i &lt;= <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Fib(i-<span class="number">1</span>) + Fib(i-<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归方法虽然可以得到斐波那契数列，但是分析它的时间复杂度，</p>
<p>画出递归树(状态树)</p>
<p><img src="/2020/12/09/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/1.png" alt="1"></p>
<p>直接递归的时间复杂度是2^n次方<br>空间复杂度为递归深度是O(n)<br>可以发现有很多重复的计算部分，有些结果不只计算了一次</p>
<h4 id="记忆化递归"><a href="#记忆化递归" class="headerlink" title="记忆化递归"></a>记忆化递归</h4><p>将中间结果进行缓存,可以加速程序执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = map[int]int&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">func Fib(n int, a map[int]int) int &#123;</span><br><span class="line">  <span class="keyword">if</span> _, <span class="attr">ok</span> := a[n]; !ok &#123;</span><br><span class="line">    a[n] = Fib(n-<span class="number">1</span>, a) + Fib(n-<span class="number">2</span>, a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>申请了一块长度为n的map<br>所以<br>时间复杂度:O(n)<br>空间复杂度:O(n)<br>相比直接递归，缩短了程序执行时间</p>
<h2 id="最小花费爬楼梯"><a href="#最小花费爬楼梯" class="headerlink" title="最小花费爬楼梯"></a>最小花费爬楼梯</h2><p>数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost<a href="%E7%B4%A2%E5%BC%95%E4%BB%8E0%E5%BC%80%E5%A7%8B">i</a>。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p>
<p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p>
<h3 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h3><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>理解：<br>第i级台阶是第i-1级台阶的阶梯顶部。<br>踏上第i级台阶花费cost[i]，直接迈一大步跨过而不踏上去则不用花费。</p>
<p><img src="/2020/12/09/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/2.png" alt="2"></p>
<p>到达第i级台阶的阶梯顶部的最小花费，有两个选择：</p>
<p>1、从i往上到达i的顶部，花费为:到达第i的花费cost[i] + 到达i-1的最小花费minCost[i-1]<br>2、从i往上到达i的顶部，花费为:到达第i-1的花费cost[i-1] + 到达i-2的最小花费minCost[i-2]</p>
<p>从i往上到达i的顶部，需要花费minCost[i]</p>
<p>则为上面两种情况的最小值</p>
<p>minCost[i] = min(cost[i-1] + minCost[i-2], cost[i] + minCost[i-1])</p>
<p>则往前递推，归纳法，这是为n的情况，从0,1的情况开始， -1为地面，花费为0<br>minCost[0] = min(cost[-1], cost[0]) = min(0, cost[0]) = 0<br>minCost[1] = min(cost[0], cost[1])</p>
<h5 id="python"><a href="#python" class="headerlink" title="python"></a>python</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def minCostClimbingStairs(self, cost):</span><br><span class="line">        n = len(cost)</span><br><span class="line">        minCost = [<span class="number">0</span>] * n</span><br><span class="line">        minCost[<span class="number">1</span>] = min(cost[<span class="number">0</span>], cost[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            minCost[i] = min(cost[i-<span class="number">1</span>] + minCost[i-<span class="number">2</span>], cost[i] + minCost[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> minCost[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>相比于解法一，则往下挪了一阶梯，到达第i层，i到顶部不需要花费,或者从i-1到达顶部也不需要花费<br>则，最小花费为min(dp[i], dp[i-1]) + 0, 0为到达顶部的最小花费</p>
<p><img src="/2020/12/09/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/3.png" alt="3"></p>
<p>1、到达i阶，花费cost[i]<br>2、从i-1到达i阶:dp[i-1] + cpst[i]<br>3、从i-2到达i阶:dp[i-2] + cost[i]</p>
<p>则最小花费： dp[i] = min(dp[i-1] + dp[i-2]) + cost[i]</p>
<h5 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def minCostClimbingStairs(self, cost):</span><br><span class="line">        n = len(cost)</span><br><span class="line">        dp[<span class="number">0</span>] = [<span class="number">0</span>] * n</span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = cost[<span class="number">0</span>], cost[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            dp[i] = min(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]) + cost[i]</span><br><span class="line">        <span class="keyword">return</span> min(dp[-<span class="number">2</span>], dp[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def minCostClimbingStairs(self, cost):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(cost)):</span><br><span class="line">            cost[i] = min(cost[i-<span class="number">1</span>], cost[i-<span class="number">2</span>]) + cost[i]</span><br><span class="line">        <span class="keyword">return</span> min(cost[-<span class="number">2</span>], cost[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，其中 n 是数组 cost 的长度。需要依次计算每个 dp 值，每个值的计算需要常数时间，因此总时间复杂度是 O(n)。</p>
<p>空间复杂度：O(n)。</p>
<h4 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h4><p>使用滚动数组的思想，只需要使用有限的额外空间，优化空间复杂度为O[1]。</p>
<p>cost 的长度为 n，则 n 个阶梯分别对应下标 0 到 n−1，楼层顶部对应下标 n</p>
<p>则求达到下标n的花费，是cost[n-1]</p>
<p>创建长度为 n+1 的数组 dp，其中 dp[i] 表示达到下标 i 的最小花费</p>
<p>遍历到n+1</p>
<p>cost[(n+1)-1] 表示爬上i的花费</p>
<p>则到达第i阶的最小花费，为遍历 n+1 的数组 dp，for j ，往上要爬的j-1的花费，及爬上j-2的最小花费，与要爬上j-2的 花费，及爬j-3的最小花费</p>
<p>dp[i]=min(dp[i−1]+cost[i−1],dp[i−2]+cost[i−2])</p>
<h5 id="python-2"><a href="#python-2" class="headerlink" title="python"></a>python</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def minCostClimbingStairs(self, cost):</span><br><span class="line">        # 指定当前阶的最小花费，pre表示地面-1， cur表示地面0</span><br><span class="line">        pre, cur = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        # 遍历到 len(cost)，即达到下标n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(cost)+<span class="number">1</span>):</span><br><span class="line">           next = min(cost[i-<span class="number">1</span>] + cur, cost[i-<span class="number">2</span>] + pre)</span><br><span class="line">           # pre就是差2阶到n阶之前的最小花费，cur就是差1阶到n之前的最小花费</span><br><span class="line">           # 最后遍历完，cur = next就是最后的结果 </span><br><span class="line">           pre, cur = cur, next</span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度与空间复杂度</title>
    <url>/2020/12/08/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法：解决特定问题的步骤的描述<br>特性：<br>—输入：有零个输入或者多个输<br>—输出：只有一个或者多个输出<br>—有穷型性：算法在执行有限个步骤时，会自动结束而不会陷入无限循环里面<br>—确定性：算法的每一步都有确定的含义而不会出现二义性<br>—可行性：算法的每一步都可以通过有限次数完成。</p>
<p>要求：<br>正确性、可读性、健壮性、时间效率高而且空间使用率低、简单性。<br>算法的复杂度分为时间复杂度和空间复杂度。</p>
<h2 id="时间复杂度Big-O-Notation"><a href="#时间复杂度Big-O-Notation" class="headerlink" title="时间复杂度Big O Notation"></a>时间复杂度Big O Notation</h2><p>时间复杂度实际上是一个函数，代表基本操作重复执行的次数，进而分析函数虽变量的变化来确定数量级，数量级用O表示</p>
<p>「 大O符号表示法 」，即 T(n) = O(f(n))</p>
<p>其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度</p>
<p>常见的时间复杂度量级有：</p>
<p>常数阶O(1)<br>对数阶O(logN)<br>线性阶O(n)<br>线性对数阶O(nlogN)<br>平方阶O(n²)<br>立方阶O(n³)<br>K次方阶O(n^k)<br>指数阶(2^n)</p>
<p>PS： 并列运行的为同级复杂度</p>
<p><img src="/2020/12/08/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/1.png" alt="1"></p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>是对一个算法在运行过程中临时占用存储空间的度量，一个算法在计算机存储器上所占用的存储空间包括存储算法本身所占用的空间，算数和输入输出所占用的存储空间以及临时占用存储空间三个部分。</p>
<p>算法的输入输出数据所占用的存储空间是由待解决的问题来决定的，通过参数表由调用函数而来，它随本算法的不同而改变，存储算法本身所占用的存储空间有算法的书写长短成正比。算法在运行过程中占用的临时空间由不同的算法决定。</p>
<p>1、数组</p>
<p>2、递归深度</p>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小栈</title>
    <url>/2021/02/01/%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type MinStack struct &#123;</span><br><span class="line">    Val        []int</span><br><span class="line">    Min        int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">func Constructor() MinStack &#123;</span><br><span class="line">    <span class="keyword">return</span> MinStack&#123;<span class="attr">Val</span>: []int&#123;&#125;, <span class="attr">Min</span>: <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (<span class="built_in">this</span> *MinStack) <span class="function"><span class="title">Push</span>(<span class="params">x int</span>)</span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="built_in">this</span>.GetMin() || len(<span class="built_in">this</span>.Val) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.Min = x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.Val = append(<span class="built_in">this</span>.Val, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (<span class="built_in">this</span> *MinStack) <span class="function"><span class="title">Pop</span>(<span class="params"></span>)</span>  &#123;</span><br><span class="line">    top := <span class="built_in">this</span>.Top()</span><br><span class="line">    <span class="built_in">this</span>.Val = <span class="built_in">this</span>.Val[:len(<span class="built_in">this</span>.Val)-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> top &gt; <span class="built_in">this</span>.Min &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.Min = <span class="built_in">this</span>.Top()</span><br><span class="line">    <span class="keyword">for</span> _, <span class="attr">v</span> := range <span class="built_in">this</span>.Val &#123;</span><br><span class="line">        <span class="keyword">if</span> v &lt; <span class="built_in">this</span>.Min &#123;</span><br><span class="line">            <span class="built_in">this</span>.Min = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (<span class="built_in">this</span> *MinStack) Top() int &#123;</span><br><span class="line">    <span class="keyword">if</span> len(<span class="built_in">this</span>.Val) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.Val[len(<span class="built_in">this</span>.Val)-<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (<span class="built_in">this</span> *MinStack) GetMin() int &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.Min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Top();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.GetMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>维护一个最小值变量，min，push和pop的时候更新min，获取直接返回，但是pop的复杂度不为O(1)了</p>
<p>优化： 空间换时间，每个元素都维护一个最小值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type MinStack struct &#123;</span><br><span class="line">    s []Node</span><br><span class="line">&#125;</span><br><span class="line">type Node struct &#123;</span><br><span class="line">	d int <span class="comment">//data</span></span><br><span class="line">	m int <span class="comment">//current min</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护两个结构体，一个栈，一个值，每个值都加上当前最小值这个元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">func Constructor() MinStack &#123;</span><br><span class="line">   <span class="keyword">return</span> MinStack&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (<span class="built_in">this</span> *MinStack) <span class="function"><span class="title">Push</span>(<span class="params">x int</span>)</span>  &#123;</span><br><span class="line">	<span class="comment">// 设置最小值</span></span><br><span class="line">	d := Node&#123;<span class="attr">d</span>:x,<span class="attr">m</span>:x&#125;</span><br><span class="line">	<span class="comment">// 如果当前栈里有值了，则进行最小值比较，更新最小值</span></span><br><span class="line">	<span class="comment">// 也就是说新加入的元素，栈顶元素保存的最小值就是当前最小的</span></span><br><span class="line">	<span class="keyword">if</span> len(<span class="built_in">this</span>.s)&gt;<span class="number">0</span> &amp;&amp;<span class="built_in">this</span>.s[len(<span class="built_in">this</span>.s)-<span class="number">1</span>].m&lt; x&#123;</span><br><span class="line">		d.m=<span class="built_in">this</span>.s[len(<span class="built_in">this</span>.s)-<span class="number">1</span>].m</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="built_in">this</span>.s = append(<span class="built_in">this</span>.s,d)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (<span class="built_in">this</span> *MinStack) <span class="function"><span class="title">Pop</span>(<span class="params"></span>)</span>  &#123;</span><br><span class="line">	<span class="built_in">this</span>.s = <span class="built_in">this</span>.s[:len(<span class="built_in">this</span>.s)-<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (<span class="built_in">this</span> *MinStack) Top() int &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.s[len(<span class="built_in">this</span>.s)-<span class="number">1</span>].d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (<span class="built_in">this</span> *MinStack) GetMin() int &#123;</span><br><span class="line">	<span class="comment">// 获取最小值只需要返回栈顶保存的最小值</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.s[len(<span class="built_in">this</span>.s)-<span class="number">1</span>].m</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>有效括号</title>
    <url>/2020/12/29/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isValid(self, <span class="attr">s</span>: str) -&gt; bool:</span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> len(s) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> False</span><br><span class="line">        a = [<span class="string">&quot;?&quot;</span>]</span><br><span class="line">        dic = &#123;<span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>, <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;?&quot;</span>: <span class="string">&quot;?&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&quot;(&quot;</span> or i == <span class="string">&quot;[&quot;</span> or i == <span class="string">&quot;&#123;&quot;</span>:</span><br><span class="line">                a.append(i)</span><br><span class="line">            elif a.pop() != dic[i]:</span><br><span class="line">                <span class="keyword">return</span> False</span><br><span class="line">        <span class="keyword">if</span> len(a) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> False</span><br><span class="line">        <span class="keyword">return</span> True</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，其中 n 是字符串 s 的长度。</p>
<p>空间复杂度：O(n+∣Σ∣)，其中Σ 表示字符集，本题中字符串只包含 6 种括号，∣Σ∣=6。栈中的字符数量为 O(n)，而哈希映射使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度。</p>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>未来信息综合技术</title>
    <url>/2024/04/18/%E6%9C%AA%E6%9D%A5%E4%BF%A1%E6%81%AF%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="信息物理系统CPS"><a href="#信息物理系统CPS" class="headerlink" title="信息物理系统CPS"></a>信息物理系统CPS</h3><p>信息物理系统(CPS)是控制系统、嵌入式系统的扩展与延伸，其涉及的相关底层理论技术源于对嵌入式技术的应用与提升。CPS的核心概念是将数字和物理系统融合在一起，以实现更好的协同工作和决策</p>
<p>CPS的体系架构</p>
<p>单元级CPS：是具有不可分割性的CPS最小单元，是具备可感知、可计算、可交互、可延展、自决策功能的CPS最小单元，一个智能部件、一个工业机器人或一个智能机床都可能是一个CPS最小单元。</p>
<p>系统级CPS：多个最小单元(单元级)通过工业网络(如工业现场总线、工业以太网等)，实现更大范围、更宽领域的数据自动流动，实现了多个单元级CPS的互联、互通和互操作，进一步提高制造资源优化配置的广度、深度和精度。包含互联互通、即插即用、边缘网关、数据互操作、协同控制、监视与诊断等功能。</p>
<p>SoS级：多个系统级CPS的有机组合构成SoS级CPS。比如在一个智能城市中，多个系统级CPS（例如交通管理系统、能源管理系统、环境监测系统）可以组成SoS级CPS。这些系统级CPS共享数据</p>
<p>CPS的技术体系</p>
<p>CPS技术体系主要分为：CPS总体技术、CPS支撑技术、CPS核心技术。</p>
<p>CPS总体技术就是CPS的顶层设计技术，主要包括：系统架构、异构系统集成、安全技术、试验验证技术等</p>
<p>CPS支撑技术就是基于CPS应用的支撑技术，主要包括：智能感知、嵌入式软件、数据库、人机交互、中间件、SDN(软件定义网络)、物联网、大数据等</p>
<p>CPS核心技术就是是CPS的基础技术，主要包括：虚实融合控制、智能装备、MBD、数字孪生技术、现场总线、工业以太网、</p>
<p>CAX\MES\ERP\PLM\CRM\SCM等</p>
<p>上述技术体系可以分为四大核心技术要素即“一硬”(感知和自动控制)、“一软”(工业软件)、“一网”(工业网络)，“一平台”(工业云和智能服务平台)，工业云和智能服务平台是CPS 数据汇聚和支撑上层解决方案的基础，对外提供资源管控和能力服务。</p>
<p>CPS的典型应用场景：智能设计，智能生产，智能服务，智能应用</p>
<p>CPS建设路径：CPS体系设计、单元级CPS建设、系统级CPS建设和SoS级CPS建设阶段</p>
<h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p>人工智能(Al)是利用数字计算机或者数字计算机控制的机器模拟、延伸和扩展人的智能，感知环境、获取知识并使用知识获得最佳结果的理论、方法、技术及应用系统。</p>
<p>人工智能的目标是了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器。该领域的研究包括机器人、自然语言处理、计算机视觉和专家系统等。</p>
<p>人工智能关键技术：</p>
<p>自然语言处理(NLP)，计算机视觉，知识图谱，人机交互(HCI)，虚拟现实或增强现实(VR/AR)，</p>
<p>机器学习(ML)。是以数据为基础，通过研究样本数据寻找规律，并根据所得规律对未来数据进行预测</p>
<p>按照学习模式的不同，机器学习可分为监督学习、无监督学习、半监督学习、强化学习。其中，监督学习需要提供标注的样本集，无监督学习不需要提供标注的样本集，半监督学习需要提供少量标注的样本，而强化学习需要反馈机制。</p>
<p>按照学习方法的不同，机器学习可分为传统机器学习和深度学习。区别在于，传统机器学习的领域特征需要手动完成，且需要大量领域专业知识；深度学习不需要人工特征提取，但需要大量的训练数据集以及强大的GPU服务器来提供算力。</p>
<p>传统机器学习从一些观测(训练)样本出发，试图发现不能通过原理分析获得的规律，实现对未来数据行为或趋势的准确预测</p>
<p>深度学习是一种基于多层神经网络并以海量数据作为输入规则的自学习方法，依靠提供给它的大量实际行为数据(训练数据集)，进行参数和规则调整</p>
<h3 id="机器人"><a href="#机器人" class="headerlink" title="机器人"></a>机器人</h3><p>机器人技术已经准备进入4.0时代。所谓机器人4.0时代，就是把云端大脑分布在各个地方，充分利用边缘计算的优势，提供高性价比的服务，把要完成任务的记忆场景的知识和常识很好地组合起来，实现规模化部署。特别强调机器人除了具有感知能力实现智能协作，还应该具有一定的理解和决策能力，进行更加自主的服务</p>
<p>机器人4.0的核心技术：云-边-端的无缝协同计算，持续学习与协同学习，知识图谱，场景自适应，数据安全</p>
<h3 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h3><p>边缘计算是一种分布式计算模型，其中计算资源和数据存储被放置在物理世界的边缘，靠近数据源和终端设备，以降低延迟、提高性能，并更好地满足实时性要求</p>
<p>边缘计算的业务本质是云计算在数据中心之外汇聚节点的延伸和演进，主要包括云边缘、边缘云和云化网关三类落地形态；以“边云协同”和“边缘智能”为核心能力发展方向</p>
<p>边缘计算具有以下特点：</p>
<p>联接性：联接性是边缘计算的基础。所联接物理对象的多样性及应用场景的多样性，需要边缘计算具备丰富的联接功能。</p>
<p>数据第一入口：边缘计算作为物理世界到数字世界的桥梁，是数据的第一入口，拥有大量、实时、完整的数据，可基于数据全生命周期进行管理与价值创造，将更好的支撑预测性维护、资产效率与管理等创新应用。</p>
<p>约束性：边缘计算产品需适配工业现场相对恶劣的工作条件与运行环境，如防电磁、防尘.防爆、抗振动、抗电流/电压波动等。在工业互联场景下，对边缘计算设备的功耗、成本、空间也有较高的要求。</p>
<p>分布性：边缘计算实际部署天然具备分布式特征。这要求边缘计算支持分布式计算与存储、实现分布式资源的动态调度与统一管理、支撑分布式智能、具备分布式安全等能力</p>
<p>边云协同：边缘计算与云计算各有所长，云计算擅长全局性、非实时、长周期的大数据处理与分析，能够在长周期维护、业务决策支撑等领域发挥优势：边缘计算更适用局部性、实时、短周期数据的处理与分析，能更好地支撑本地业务的实时智能化决策与执行。</p>
<p>边缘计算既靠近执行单元，更是云端所需高价值数据的采集和初步处理单元，可以更好地支撑云端应用，而云计算则是通过大数据分析优化输出的业务规则或模型可以下发到边缘侧，边缘计算基于新的业务规则或模型运行，两者相辅相成，主要包括六种协同：</p>
<p>资源协同：边缘节点提供计算、存储、网络、虚拟化等基础设施资源、具有本地资源调度管理能力，同时可与云端协同，接受并执行云端资源调度管理策略，包括边缘节点的设备管理、资源管理以及网络连接管理。</p>
<p>数据协同：边缘节点主要负责现场/终端数据的采集，按照规则或数据模型对数据进行初步处理与分析，并将处理结果以及相关数据上传给云端：云端提供海量数据的存储、分析与价值挖掘。</p>
<p>智能协同：边缘节点按照A模型执行推理，实现分布式智能；云端开展AI 的集中式模型训练，并将模型下发边缘节点。</p>
<p>应用管理协同：边缘节点提供应用部署与运行环境，并对本节点多个应用的生命周期进行管理调度：云端主要提供应用开发、测试环境，以及应用的生命周期管理能力。</p>
<p>业务管理协同：边缘节点提供模块化、微服务化的应用/数字孪生/网络等应用实例：云端主要提供按照客户需求实现应用、数字孪生、网络等的业务编排能力。</p>
<p>服务协同：边缘节点按照云端策略实现部分ECSaaS服务，通过ECSaas与云端Saas的协同实现面向客户的按需Saas服务：云端主要提供Saas服务在云端和边缘节点的服务分布策略，以及云端承担的Saas服务能力。 </p>
<p>边缘计算的应用场合(既有中央控制中心，又有分支设备)：智慧园区、安卓云与云游戏、视频监控、工业互联网、智慧医疗。</p>
<p>边云协同架构通常包括以下几层：</p>
<p>• 边缘层：位于网络边缘，负责收集数据、进行初步处理和存储。</p>
<p>• 雾层：位于边缘层和云层之间，负责数据的聚合、转发和处理。</p>
<p>• 云层：位于网络中心，负责提供强大的计算、存储和网络资源。</p>
<p>边云协同架构设计面临以下几个挑战：</p>
<p>• 异构性：边缘设备、网络和云平台存在异构性，需要统一管理和调度。</p>
<p>• 延迟：边缘计算需要满足低延迟要求，需要优化网络架构和数据处理流程。</p>
<p>• 安全性：边云协同系统需要保障数据安全和隐私。</p>
<p>针对上述挑战，可以采取以下解决方案：</p>
<p>• 虚拟化：将边缘计算资源虚拟化，以便于统一管理和调度。</p>
<p>• 容器化：将应用打包成容器，以便于在不同平台上部署和运行。</p>
<p>• 微服务：将应用拆解成微服务，以便于弹性扩展和故障处理。</p>
<p>• 软件定义网络 (SDN)：使用 SDN 技术可以灵活控制网络流量，降低延迟。</p>
<p>• 安全技术：使用安全技术保障数据安全和隐私，例如加密、身份认证、访问控制等</p>
<h3 id="数字孪生体"><a href="#数字孪生体" class="headerlink" title="数字孪生体"></a>数字孪生体</h3><p>数字孪生体技术是跨层级、跨尺度的现实世界和虚拟世界建立沟通的桥梁。</p>
<p>数字孪生体是现有或将有的物理实体对象的数字模型，通过实测、仿真和数据分析来实时感知、诊断、预物理实体对象的状态，通过优化和指令来调控物理实体对象的行为，通过相关数字模型间的相互学习来进化自身，同时改进利益相关方在物理实体对象生命周期内的决策</p>
<p>关键技术：</p>
<p>建模。建模的目的是将我们对物理世界的理解进行简化和模型化</p>
<p>仿真。是将包含了确定性规律和完整机理的模型转化成软件的方式来模拟物理世界的一种技术。只要模型正确，并拥有了完整的输入信息和环境数据，就可以基本准确地反映物理世界的特性和参数。</p>
<h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><p>云计算概念的内涵包含两个方面：平台和应用</p>
<p>云计算的服务方式</p>
<p>基础设施即服务(laaS)。在laaS模式下，服务提供商将多台服务器组成的“云端”基础设施作为计量服务提供给客户。具体来说，服务提供商将内存、IO设备、存储和计算能力等整合为一个虚拟的资源池，为客户提供所需要的存储资源、虚拟化服务器等服务。比如选择云端的不同配置的服务器</p>
<p>平台即服务(PaaS)。在PaaS模式下，服务提供商将分布式开发环境与平台作为一种服务来提供。这是一种分布式平台服务，厂商提供开发环境、服务器平台、硬件资源等服务给客户，客户在服务提供商平台的基础上定制开发自己的应用程序，并通过其服务器和互联网传递给其他客户。比如在线编程、在线办公软件</p>
<p>软件即服务(Saas)。在Saas的服务模式下，服务提供商将应用软件统一部署在云计算平台上，客户根据需要通过互联网向服务提供商订购应用软件服务，服务提供商根据客户所订购软件的数量、时间的长短等因素收费，并且通过标准浏览器、向客户提供应用服务。比如百度云盘之类的</p>
<p>三者比较：</p>
<p>在灵活性方面, Saas &lt;PaaS &lt;laas灵活性依次增强。</p>
<p>在方便性方面, laas &lt;PaaS&lt;Saas方便性依次增强。</p>
<p>部署方式：</p>
<p>公有云。在公有云模式下，云基础设施是公开的，可以自由地分配给公众。企业、学术界与政府机构都可以拥有和管理公用云，并实现对公有云的操作。公有云能够以低廉的价格为最终用户提供有吸引力的服务，创造新的业务价值。</p>
<p>社区云。在社区云模式下，云基础设施分配给一些社区组织所专有，这些组织共同关注任务、安全需求、政策等信息。云基础设施被社区内的一个或多个组织所拥有、管理及操作。“社区云”是”公有云”范畴内的一个组成部分。</p>
<p>私有云。在私有云模式下，云基础服务设施分配给由多种用户组成的单个组织。它可以被这个组织或其他第三方组织所拥有、管理及操作。</p>
<p>混合云。混合云是公有云、私有云和社区云的组合。由于安全和控制原因，并非所有的企业信息都能放置在公有云上，因此企业将会使用混合云模式。</p>
<h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><p>大数据的特点：大规模、高速度、多样化、可变性、复杂性等</p>
<p>大数据分析的分析步骤，大致分为数据获取╱记录、信息抽取/清洗/注记、数据集成/聚集/表现、数据分析/建模和数据解释5个主要阶段。</p>
<p>大数据的应用领域：制造业、服务业、交通行业、医疗行业</p>
<h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>区块链是一种分布式数据库技术，以区块的形式按时间顺序链接在一起，形成了一个不断增长的、不可篡改的记录链</p>
<p>它的核心特性包括：</p>
<p>• 去中心化：区块链的数据不存储在单一的中心服务器上，而是分布在网络的各个节点上，每个节点都有该链的完整副本。这意味着没有一个中心机构能够控制或篡改整个数据库。</p>
<p>• 不可篡改性：一旦数据被写入区块链，就几乎不可能被修改或删除。这是因为每个区块都包含了前一个区块的哈希值，形成了一个不可逆的链条结构，任何篡改都会立即被其他节点检测出来。</p>
<p>• 透明性：区块链中的数据是公开可见的，所有参与者都可以查看和验证数据，从而增加了数据的透明度和可信度。</p>
<p>• 安全性：区块链使用了加密技术确保数据的安全性，使得交易和信息在传输和存储过程中更加安全可靠。</p>
<p>• 智能合约：智能合约是基于区块链的自动化合约，能够自动执行合约条款，无需中介机构，提高了交易的效率和可靠性</p>
<p>区块链的原理：</p>
<p>• 安全性：区块链的安全性是建立在密码学原理上的，包括哈希函数、非对称加密等技术，确保数据的完整性和不可篡改性。</p>
<p>• 共识机制：共识机制确保了网络中各个节点对交易记录的一致性认可，从而防止了双重支付等问题。</p>
<p>• 分布式存储：区块链采用分布式存储方式，数据存储在多个节点上，避免了单点故障和数据丢失的风险。</p>
<p>• 智能合约：智能合约是一种在区块链上执行的自动化合约，其中包含了预先编写好的代码逻辑，可以自动执行合约条款</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>架构的演化和维护</title>
    <url>/2024/04/18/%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8C%96%E5%92%8C%E7%BB%B4%E6%8A%A4/</url>
    <content><![CDATA[<h3 id="架构演化"><a href="#架构演化" class="headerlink" title="架构演化"></a>架构演化</h3><p>软件架构的演化和维护就是对架构进行修改和完善的过程，目的就是为了使软件能够适应环境的变化而进行的纠错性修改和完善性修改等，是一个不断迭代的过程，直至满足用户需求</p>
<p>软件架构的演化就是软件整体结构的演化，演化过程涵盖软件架构的全生命周期，包括软件架构需求的获取、软件架构建模、软件架构文档、软件架构实现以及软件架构维护等阶段。</p>
<p>一是架构是整个系统的骨架，是软件系统具备诸多好的特性的保障;二是软件架构作为软件蓝图为人们宏观管控软件系统的整体复杂性和变化性提供了一条有效途径</p>
<p>软件架构的定义包含组件、连接件、约束三大要素，这类软件架构演化主要关注的就是这三者之间的添加、修改和删除等</p>
<h3 id="面向对象架构演化"><a href="#面向对象架构演化" class="headerlink" title="面向对象架构演化"></a>面向对象架构演化</h3><p>面向对象软件架构演化主要分为以下四种演化：对象演化、消息演化、复合片段演化和约束演化</p>
<p>对象演化：在顺序图中，组件的实体是对象，会对架构设计的动态行为产生影响的演化只包括Add Object (AO)和DeleteObject(DO)两种。</p>
<p>消息演化：将消息演化分为AddMessage(AM)、 DeleteMessage (DM)、SwapMessageOrder (SMO)、OverturnMessage(OM)、ChangeMessageModule (CMM)5种。</p>
<p>复合片段演化：复合片段是对象交互关系的控制流描述，表示可能发生在不同场合的交互，与消息同属于连接件范畴。复合片段的演化分为AddFragment (AF)、Deletefragment(DF)、FragmentTypeChange (FTC)和FragmentConditionChange (FCC)。</p>
<p>约束演化：顺序图中的约束信息以文字描述的方式存储于对象或消息中，约束演化就是直接对约束信息进行添加和删除。</p>
<h3 id="演化分类"><a href="#演化分类" class="headerlink" title="演化分类"></a>演化分类</h3><p>针对软件架构的演化过程是否处于系统运行时期，可以将软件架构演化分为静态演化和动态演化</p>
<p>软件架构的演化时期包括：设计时演化、运行前演化、有限制运行时演化、运行时演化</p>
<p>软件架构静态演化主要是在设计时演化以及运行前演化。与此相对应的维护方法有<strong>3类：更正性维护、适应性维护和完善性维护</strong>。</p>
<p>动态演化是在系统运行期间的演化，需要在不停止系统功能的情况下完成演化，较之静态演化更加困难。具体发生在有限制的运行时演化和运行时演化阶段。</p>
<p>软件的动态性分为3个级别：</p>
<p>交互动态性，要求数据在固定的结构下动态交互;</p>
<p>结构动态性，允许对结构进行修改，通常的形式是组件和连接件实例的添加和删除，这种动态性是研究和应用的主流;</p>
<p>架构动态性，允许软件架构的基本构造的变动，即结构可以被重定义，如新的组件类型的定义。</p>
<p>目前，实现软件架构动态演化的技术主要有两种：采用动态软件架构(DSA)和进行动态重配置(DR)。</p>
<p>DSA是指在运行时刻会发生变化的系统框架结构，允许在运行过程中通过框架结构的动态演化实现对架构的修改;</p>
<p>DR从组件和连接件的配置入手，允许在运行过程中增删组件，增删连接件，修改连接关系等操作。</p>
<p>系统必须提供SA动态演化的一些相关功能：保存当前软件架构信息的功能、设置监控机制监视系统有无需求变化、保证演化操作原子性。</p>
<p>DSA实施动态演化大体遵循以下4步：①捕捉并分析需求变化；②获取或生成体系结构演化策略；③根据步骤2得到的演化策略，选择适</p>
<p>当的演化策略并实施演化；④演化后的评估与检测。</p>
<p>动态重配置模式：主从模式、中央控制模式、客户端/服务器模式、分布式控制模式</p>
<h3 id="演化评估"><a href="#演化评估" class="headerlink" title="演化评估"></a>演化评估</h3><p>演化过程己知的评估（正向）和演化过程未知的评估（逆向）</p>
<p>演化过程己知的评估其目的在于通过对架构演化过程进行度量，比较架构内部结构上的差异以及由此导致的外部质量属性上的变化，对该演化过程中相关质量属性进行评估。</p>
<p>基于度量的架构演化评估方法，其基本思路在于通过对演化前后的软件架构进行度量，比较架构内部结构上的差异以及由此导致的外部质量属性上的变化。具体包括：架构修改影响分析、监控演化过程、分析关键演化过程。</p>
<p>当演化过程未知时，我们无法像演化过程已知时那样追踪架构在演化过程中的每一步变化，只能根据架构演化前后的度量结果逆向推测出架构发生了哪些改变，并分析这些改变与架构相关质量属性的关联关系。</p>
<h3 id="架构维护"><a href="#架构维护" class="headerlink" title="架构维护"></a>架构维护</h3><p>软件架构维护过程一般涉及架构知识管理、架构修改管理和架构版本管理</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列和堆</title>
    <url>/2021/02/03/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/</url>
    <content><![CDATA[<h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h2><p>栈是一种非常基础的线性结构，一种FILO类型的数据结构，FILO 即 Fisrt In Last Out</p>
<p>也就是先进后出，也可以说是后进先出</p>
<p>栈只支持三个操作， pop, top, push。</p>
<p>pop取出栈中最上层元素(8)，栈的最上层元素变为早先进入的元素(9)， 出栈</p>
<p>top查看栈的最上层元素(8)。</p>
<p>push将一个新的元素(5)放在栈的最上层， 入栈</p>
<p>通过数组实现的叫顺序栈， 通过链表实现的叫链式栈</p>
<h3 id="golang实现栈"><a href="#golang实现栈" class="headerlink" title="golang实现栈"></a>golang实现栈</h3><p>通过golang实现简单的栈</p>
<h4 id="slice实现"><a href="#slice实现" class="headerlink" title="slice实现"></a>slice实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Item 接口</span></span><br><span class="line">type Item interface&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ItemStack 栈结构体，加锁，保证协程安全</span></span><br><span class="line">type ItemStack struct &#123;</span><br><span class="line">	items []Item</span><br><span class="line">	lock  sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewStack 创建一个新栈</span></span><br><span class="line">func NewStack() *ItemStack &#123;</span><br><span class="line">	s := &amp;ItemStack&#123;&#125;</span><br><span class="line">	s.items = []Item&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pirnt 打印栈的元素</span></span><br><span class="line">func (s *ItemStack) <span class="function"><span class="title">Print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	fmt.Println(s.items)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push 入栈，加锁</span></span><br><span class="line">func (s *ItemStack) <span class="function"><span class="title">Push</span>(<span class="params">t Item</span>)</span> &#123;</span><br><span class="line">	s.lock.Lock()</span><br><span class="line">	defer s.lock.Unlock()</span><br><span class="line">	s.items = append(s.items, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop 出栈，返回栈顶元素</span></span><br><span class="line">func (s *ItemStack) Pop() Item &#123;</span><br><span class="line">	s.lock.Lock()</span><br><span class="line">	defer s.lock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> len(s.items) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line">	item := s.items[len(s.items)-<span class="number">1</span>]</span><br><span class="line">	s.items = s.items[<span class="number">0</span> : len(s.items)-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.slice相对简单</p>
<p>2.interface类型，允许添加任意类型元素</p>
<p>3.Push和Pop有加锁处理，线程安全</p>
<p>问题：slice的pop并不是真正意义上的pop，slice[:]只是一个新的引用，底层的内存并没有减少</p>
<h4 id="container-list内置包"><a href="#container-list内置包" class="headerlink" title="container/list内置包"></a>container/list内置包</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack 栈结构体，读写锁</span></span><br><span class="line">type Stack struct &#123;</span><br><span class="line">	list *list.List</span><br><span class="line">	lock *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewStack 初始化栈</span></span><br><span class="line">func NewStack() *Stack &#123;</span><br><span class="line">	list := list.New()</span><br><span class="line">	l := &amp;sync.RWMutex&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;Stack&#123;list, l&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Push 入栈 加锁 </span></span><br><span class="line">func (stack *Stack) <span class="function"><span class="title">Push</span>(<span class="params">value interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">	stack.lock.Lock()</span><br><span class="line">	defer stack.lock.Unlock()</span><br><span class="line">	stack.list.PushBack(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop 出栈</span></span><br><span class="line">func (stack *Stack) Pop() interface&#123;&#125; &#123;</span><br><span class="line">	stack.lock.Lock()</span><br><span class="line">	defer stack.lock.Unlock()</span><br><span class="line">	e := stack.list.Back()</span><br><span class="line">	<span class="keyword">if</span> e != nil &#123;</span><br><span class="line">		stack.list.Remove(e)</span><br><span class="line">		<span class="keyword">return</span> e.Value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Peak 返回栈顶元素</span></span><br><span class="line">func (stack *Stack) Peak() interface&#123;&#125; &#123;</span><br><span class="line">	e := stack.list.Back()</span><br><span class="line">	<span class="keyword">if</span> e != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> e.Value</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 长度</span></span><br><span class="line">func (stack *Stack) Len() int &#123;</span><br><span class="line">	<span class="keyword">return</span> stack.list.Len()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Empty 判断是否为空</span></span><br><span class="line">func (stack *Stack) Empty() bool &#123;</span><br><span class="line">	<span class="keyword">return</span> stack.list.Len() == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>container/list 是一个双向链表 </p>
<p>用链表模拟栈，要么都向链表的最后做push和pop，要么都向链表的起点做push和pop</p>
<h4 id="单链表自定义实现栈"><a href="#单链表自定义实现栈" class="headerlink" title="单链表自定义实现栈"></a>单链表自定义实现栈</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type (</span><br><span class="line">	<span class="comment">// Stack 栈结构体</span></span><br><span class="line">	Stack struct &#123;</span><br><span class="line">		top    *node</span><br><span class="line">		length int</span><br><span class="line">		lock   *sync.RWMutex</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// node 节点，先前指针</span></span><br><span class="line">	node struct &#123;</span><br><span class="line">		value interface&#123;&#125;</span><br><span class="line">		prev  *node</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewStack 初始化栈</span></span><br><span class="line">func NewStack() *Stack &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Stack&#123;nil, <span class="number">0</span>, &amp;sync.RWMutex&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 返回栈的长度</span></span><br><span class="line">func (<span class="built_in">this</span> *Stack) Len() int &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Peek 栈顶元素返回</span></span><br><span class="line">func (<span class="built_in">this</span> *Stack) Peek() interface&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">this</span>.length == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.top.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop 删除栈顶，新栈顶元素等于该栈顶的先前指向元素，再减少长度</span></span><br><span class="line">func (<span class="built_in">this</span> *Stack) Pop() interface&#123;&#125; &#123;</span><br><span class="line">	<span class="built_in">this</span>.lock.Lock()</span><br><span class="line">	defer <span class="built_in">this</span>.lock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">this</span>.length == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="built_in">this</span>.top</span><br><span class="line">	<span class="built_in">this</span>.top = n.prev</span><br><span class="line">	<span class="built_in">this</span>.length--</span><br><span class="line">	<span class="keyword">return</span> n.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push 入栈，新建一个节点，长度加一，先前指针指向当前的top节点，然后 新建的节点等于top</span></span><br><span class="line">func (<span class="built_in">this</span> *Stack) <span class="function"><span class="title">Push</span>(<span class="params">value interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.lock.Lock()</span><br><span class="line">	defer <span class="built_in">this</span>.lock.Unlock()</span><br><span class="line">	n := &amp;node&#123;value, <span class="built_in">this</span>.top&#125;</span><br><span class="line">	<span class="built_in">this</span>.top = n</span><br><span class="line">	<span class="built_in">this</span>.length++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.允许添加任意类型的元素</p>
<p>2.Push和Pop是线程安全的</p>
<h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><p><img src="/2021/02/03/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/1.png" alt="1"></p>
<h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h2><p>队列是一种先进先出，后进后出的线性表</p>
<p>先进入队列的先出去，后进入队列的后出去。必须从队尾插入新元素，队列中的元素只能从队首出</p>
<p>队列也可以通过数组，链表实现</p>
<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>1.初始化一个数组，及两个指针，一个队头指针，一个队尾指针，都指向0的位置</p>
<p>2.队列总是从队头取元素，队尾插入元素</p>
<p>3.入队，判断队列是否已满，队尾指针是否等于长度，不等可以插入，新元素放在队尾位置，指针加一后移</p>
<p>4.出队，头指针和尾指针指向同一个位置，则队列为空，不为空可以出队，出队则头指针的元素出队，头指针加一后移</p>
<p>出队和入队的时间复杂度都是O(1)</p>
<h4 id="golang-实现顺序队列"><a href="#golang-实现顺序队列" class="headerlink" title="golang 实现顺序队列"></a>golang 实现顺序队列</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayQueue</span></span><br><span class="line">type ArrayQueue struct &#123;</span><br><span class="line">    q []interface&#123;&#125;</span><br><span class="line">    capacity int <span class="comment">// 队列容量</span></span><br><span class="line">    head int <span class="comment">// 队头指针</span></span><br><span class="line">    tail int <span class="comment">// 队尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建队列</span></span><br><span class="line">func NewArrayQueue(n int) *ArrayQueue &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ArrayQueue&#123;</span><br><span class="line">        q:        make([]interface&#123;&#125;, n),</span><br><span class="line">        capacity: n,</span><br><span class="line">        head:     <span class="number">0</span>,</span><br><span class="line">        tail:     <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 入队操作</span></span><br><span class="line">func (<span class="built_in">this</span> *ArrayQueue) EnQueue(v interface&#123;&#125;) bool &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">this</span>.tail == <span class="built_in">this</span>.capacity &#123; <span class="comment">// 队列已满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.q[<span class="built_in">this</span>.tail] = v</span><br><span class="line">    <span class="built_in">this</span>.tail++</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 出队操作</span></span><br><span class="line">func (<span class="built_in">this</span> *ArrayQueue) DeQueue() interface&#123;&#125;  &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">this</span>.head == <span class="built_in">this</span>.tail &#123; <span class="comment">// 队列已空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    v := <span class="built_in">this</span>.q[<span class="built_in">this</span>.head]</span><br><span class="line">    <span class="built_in">this</span>.head++</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 队列不为空返回所有元素，否则返回空</span></span><br><span class="line">func (<span class="built_in">this</span> *ArrayQueue) <span class="built_in">String</span>() string  &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">this</span>.head == <span class="built_in">this</span>.tail &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&quot;empty queue!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    result := <span class="string">&quot;head&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">this</span>.head; i &lt;= <span class="built_in">this</span>.tail - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        result += fmt.Sprintf(<span class="string">&quot;&lt;-%+v&quot;</span>, <span class="built_in">this</span>.q[i])</span><br><span class="line">    &#125;</span><br><span class="line">    result += <span class="string">&quot;&lt;-tail&quot;</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line">func (<span class="built_in">this</span> *ArrayQueue) Empty() bool &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">this</span>.head == <span class="built_in">this</span>.tail &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回队列长度</span></span><br><span class="line">func (<span class="built_in">this</span> *ArrayQueue) Len() int &#123;</span><br><span class="line">    <span class="keyword">return</span> len(<span class="built_in">this</span>.q)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回队头元素</span></span><br><span class="line">func (<span class="built_in">this</span> *ArrayQueue) GetHead() interface&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">this</span>.Empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> nil</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.q[<span class="built_in">this</span>.head]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 判断队列是否已满</span></span><br><span class="line">func (<span class="built_in">this</span> *ArrayQueue) Full() bool &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">this</span>.tail == <span class="built_in">this</span>.head &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 清空队列 并没有释放内存</span></span><br><span class="line">func (<span class="built_in">this</span> *ArrayQueue)  <span class="function"><span class="title">Clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.head = <span class="number">0</span></span><br><span class="line">    <span class="built_in">this</span>.tail = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><p>1.初始化也需要两个指针，队头指针，队尾指针</p>
<p>2.入队，让新节点的Next指向队尾节点的Next，也就是nil，再让队尾节点的Next指向新节点，队尾指针加一后移，空队列单独处理</p>
<p>3.出队，头指针指向的元素出队，头指针加一后移，队列长度为1的情况，单独处理</p>
<h4 id="golang-实现链式队列"><a href="#golang-实现链式队列" class="headerlink" title="golang 实现链式队列"></a>golang 实现链式队列</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列的数据结构</span></span><br><span class="line">type queueNode struct &#123;</span><br><span class="line">    data interface&#123;&#125; <span class="comment">// 存放数据</span></span><br><span class="line">    next *queueNode <span class="comment">// 存放指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type queueList struct &#123;</span><br><span class="line">    length int <span class="comment">//存储链表长度</span></span><br><span class="line">    front *queueNode <span class="comment">// 指向队头</span></span><br><span class="line">    rear *queueNode <span class="comment">// 指向队尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链队初始化</span></span><br><span class="line">func initQueue() *queueList &#123;</span><br><span class="line">    L := &amp;queueList&#123;</span><br><span class="line">        length: <span class="number">0</span>,</span><br><span class="line">        front: nil,</span><br><span class="line">        rear: nil,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链队的入队</span></span><br><span class="line">func (queue *queueList) <span class="function"><span class="title">push</span>(<span class="params">val interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">    node := &amp;queueNode&#123;</span><br><span class="line">        data: val,</span><br><span class="line">        next: nil,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理空队</span></span><br><span class="line">    <span class="keyword">if</span> queue.isNull() &#123;</span><br><span class="line">        queue.front = node <span class="comment">// 指向队头</span></span><br><span class="line">        queue.rear = node</span><br><span class="line">        queue.length ++</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue.rear.next = node</span><br><span class="line">    queue.rear = queue.rear.next</span><br><span class="line">    queue.length ++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//链队的出队</span></span><br><span class="line">func (queue *queueList) <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断队空</span></span><br><span class="line">    <span class="keyword">if</span> queue.isNull() &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;队列为空&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理链队中只有一个结点的特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> queue.length == <span class="number">1</span> &#123;</span><br><span class="line">        queue.front = nil</span><br><span class="line">        queue.rear = nil</span><br><span class="line">        queue.length --</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue.front = queue.front.next</span><br><span class="line">    queue.length --</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队空</span></span><br><span class="line">func (queue queueList) isNull() bool &#123;</span><br><span class="line">    <span class="keyword">return</span> queue.length == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (queue *queueList) Traverse() (arr []interface&#123;&#125;) &#123;</span><br><span class="line">    pre := queue.front</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; queue.length; i++ &#123;</span><br><span class="line">        arr = append(arr, pre.data, <span class="string">&quot;--&gt;&quot;</span>)</span><br><span class="line">        pre = pre.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>循环队列是指队列是前后连成一个圆圈，它以循环的方式去存储元素，但还是会按照队列的先进先出的原则去操作</p>
<p>循环队列是基于数组实现的，相比于顺序队列，更好的利用数组空间</p>
<p>普通的数组队列在经过了一段时间的入队和出队以后，尾指针就指向了数组的最后位置了，没法再往队列里插入数据了，但是数组的前面部分（头指针的前面）由于旧的数据曾经出队了，所以会空出来一些空间，这些空间就没法利用起来</p>
<p>即使可以单独处理顺序队列，整体移动，也需要消耗额外的操作</p>
<p>循环队列也是一种线性结构</p>
<p>1.最后一个位置并不是结束位。对于循环队列，头指针始终指向队列的前面，尾指针始终指向队列的末尾</p>
<p>2.初始化队列，头指针和尾指针指向相同位置，此时队列是空</p>
<p>3.入队，新元素插入队尾指针位置，队尾指针加一后移</p>
<p>4.出队，头指针元素出队，头指针加一后移，该元素并不删除，只是不属于队列的一部分</p>
<p>5.继续入队，尾指针到达队列尾部时候，尾指针的下标重新变成0，而之前出队的元素则空出来</p>
<p>6.继续出队，则队列又有空间了，就可以继续入队，头指针的下标已经大于尾指针的下标了，这也是正式循环队列的特性导致的</p>
<p>7.判断队列为空的条件是：head==tail</p>
<p>8.判断队列满的情况：(tail+1)%n=head，取余数等于head，则表示满了，因为是循环</p>
<p>9.会浪费一个空间（length+1）== capacity 表示队列为满</p>
<p>PS：循环队列为什么用空一个元素的位置呢</p>
<p>循环队列中，由于入队时尾指针向前追赶头指针；出队时头指针向前追赶尾指针，造成队空和队满时头尾指针均相等。<br>因此，无法通过条件front==rear来判别队列是”空”还是”满”。<br>解决这个问题的方法至少有三种：<br>1.另设一布尔变量以区别队列的空和满</p>
<p>2.少用一个元素的空间。约定入队前，测试尾指针在循环意义下加1后是否等于头指针，若相等则认为队满（注意：rear所指的单元始终为空）</p>
<p>3.使用一个计数器记录队列中元素的总数（即队列长度）。</p>
<h4 id="golang-实现"><a href="#golang-实现" class="headerlink" title="golang 实现"></a>golang 实现</h4><p>预留了一个空间</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环队列实现方法</span></span><br><span class="line">type loopQueue struct &#123;</span><br><span class="line">    queues   []interface&#123;&#125;</span><br><span class="line">    front    int <span class="comment">//队首</span></span><br><span class="line">    tail     int <span class="comment">//队尾</span></span><br><span class="line">    length   int <span class="comment">//队伍长度</span></span><br><span class="line">    capacity int <span class="comment">//队伍容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLoopQueue 可以自己传参数，初始化队列</span></span><br><span class="line">func NewLoopQueue() *loopQueue &#123;</span><br><span class="line">    loop := &amp;loopQueue&#123;</span><br><span class="line">        queues:   make([]interface&#123;&#125;, <span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">        front:    <span class="number">0</span>,</span><br><span class="line">        tail:     <span class="number">0</span>,</span><br><span class="line">        length:   <span class="number">0</span>,</span><br><span class="line">        capacity: <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化队列，加入初始数据</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        loop.queues = append(loop.queues, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 返回循环队列的长度</span></span><br><span class="line">func (q *loopQueue) Len() int &#123;</span><br><span class="line">    <span class="keyword">return</span> q.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cap 返回循环队列的容量</span></span><br><span class="line">func (q *loopQueue) Cap() int &#123;</span><br><span class="line">    <span class="keyword">return</span> q.capacity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsEmpty 判断队列是否为空</span></span><br><span class="line">func (q *loopQueue) IsEmpty() bool &#123;</span><br><span class="line">    <span class="keyword">return</span> q.length == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsFull 判断队列是否满的</span></span><br><span class="line">func (q *loopQueue) IsFull() bool &#123;</span><br><span class="line">    <span class="keyword">return</span> (q.length + <span class="number">1</span>) == q.capacity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetFront 获取队头元素</span></span><br><span class="line">func (q *loopQueue) GetFront() (interface&#123;&#125;, error) &#123;</span><br><span class="line">    <span class="keyword">if</span> q.Len() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nil, errors.New(</span><br><span class="line">            <span class="string">&quot;failed to getFront,queues is empty.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q.queues[q.front], nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enqueue 入队，放在队尾</span></span><br><span class="line">func (q *loopQueue) <span class="function"><span class="title">Enqueue</span>(<span class="params">elem interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果队列满了，队列扩容</span></span><br><span class="line">    <span class="keyword">if</span> q.IsFull() &#123;</span><br><span class="line">    	<span class="comment">// 创建一个新队列</span></span><br><span class="line">        buffer := <span class="keyword">new</span>(loopQueue)</span><br><span class="line">        <span class="comment">//初始化队列，2倍容量</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>*q.capacity; i++ &#123;</span><br><span class="line">            buffer.queues = append(buffer.queues, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搬运元素</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; q.length; i++ &#123;</span><br><span class="line">            buffer.queues[i] = q.queues[q.front]</span><br><span class="line">            q.front = (q.front + <span class="number">1</span>) % q.capacity</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换当前的queues为扩容后的队列，length不变</span></span><br><span class="line">        q.queues = buffer.queues</span><br><span class="line">        q.front = <span class="number">0</span></span><br><span class="line">        q.tail = q.length</span><br><span class="line">        q.capacity = <span class="number">2</span> * q.capacity</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q.queues[q.tail] = elem</span><br><span class="line">    <span class="comment">// 因为是循环队列，下标会重新设定，循环求法</span></span><br><span class="line">    q.tail = (q.tail + <span class="number">1</span>) % q.capacity</span><br><span class="line">    q.length++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dequeue 出队</span></span><br><span class="line">func (q *loopQueue) Dequeue() (interface&#123;&#125;, error) &#123;</span><br><span class="line">    <span class="keyword">if</span> q.IsEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> nil, errors.New(</span><br><span class="line">            <span class="string">&quot;failed to dequeue,queues is empty.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当队列长度小于容量1/4时，队列容量缩短一半</span></span><br><span class="line">    <span class="keyword">if</span> q.length &lt;= q.capacity/<span class="number">4</span> &#123;</span><br><span class="line">    	<span class="comment">// 创建一个新的队列</span></span><br><span class="line">        buffer := <span class="keyword">new</span>(loopQueue)</span><br><span class="line">        <span class="comment">//初始化队列</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; q.capacity/<span class="number">2</span>; i++ &#123;</span><br><span class="line">            buffer.queues = append(buffer.queues, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搬运元素</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; q.length; i++ &#123;</span><br><span class="line">            buffer.queues[i] = q.queues[q.front]</span><br><span class="line">            q.front = (q.front + <span class="number">1</span>) % q.capacity</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// length不变，缩小其他元素</span></span><br><span class="line">        q.queues = buffer.queues</span><br><span class="line">        q.fron1t = <span class="number">0</span></span><br><span class="line">        q.tail = q.length</span><br><span class="line">        q.capacity = q.capacity / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出队头元素，更新头指针</span></span><br><span class="line">    queue := q.queues[q.front]</span><br><span class="line">    q.front = (q.front + <span class="number">1</span>) % q.capacity</span><br><span class="line">    <span class="comment">// 减少长度</span></span><br><span class="line">    q.length--</span><br><span class="line">    <span class="keyword">return</span> queue, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环双端队列"><a href="#循环双端队列" class="headerlink" title="循环双端队列"></a>循环双端队列</h3><p>双端队列，就是可在头部入队出队，也可在尾部入队出队</p>
<p>leetcode 641 设计循环双端队列</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package lt641</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设计实现双端队列。</span></span><br><span class="line"><span class="comment">//你的实现需要支持以下操作：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    MyCircularDeque(k)：构造函数,双端队列的大小为k。</span></span><br><span class="line"><span class="comment">//    insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。</span></span><br><span class="line"><span class="comment">//    insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。</span></span><br><span class="line"><span class="comment">//    deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。</span></span><br><span class="line"><span class="comment">//    deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。</span></span><br><span class="line"><span class="comment">//    getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。</span></span><br><span class="line"><span class="comment">//    getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。</span></span><br><span class="line"><span class="comment">//    isEmpty()：检查双端队列是否为空。</span></span><br><span class="line"><span class="comment">//    isFull()：检查双端队列是否满了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    所有值的范围为 [1, 1000]</span></span><br><span class="line"><span class="comment">//    操作次数的范围为 [1, 1000]</span></span><br><span class="line"><span class="comment">//    请不要使用内置的双端队列库。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 来回顾下队列。</span></span><br><span class="line"><span class="comment">// 顺序队列（基于数组，每次取数据需要进行数据搬迁，优化是等位置不够了再一次搬迁）、</span></span><br><span class="line"><span class="comment">// 链式队列（容易实现，无限扩展，但不太常用）、</span></span><br><span class="line"><span class="comment">// 循环队列（基于数组，head/tail循环移动，多占用一个数据空间）、</span></span><br><span class="line"><span class="comment">// 阻塞队列（取空队列头部阻塞至有值入队）、</span></span><br><span class="line"><span class="comment">// 并发队列(最简单的就是入队出队操作加锁)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列的应用</span></span><br><span class="line"><span class="comment">// 线程池等资源池，通常有最大数量限制，不适合链式队列</span></span><br><span class="line"><span class="comment">// 银行等业务排队系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双端队列就是队头队尾都可以进行出入队操作</span></span><br><span class="line"><span class="comment">// 直接上手干咯，没什么巧的</span></span><br><span class="line"><span class="comment">// 循环队列的难点就在于队满的判定条件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外题给所有值的范围是[1~1000]这是否要我使用而更小的数据表示类型呢？</span></span><br><span class="line"><span class="comment">// 搞不明白</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始队空，f=0=l， 尽管此时一个数据都没有</span></span><br><span class="line"><span class="comment">// fl					// f == l 判空</span></span><br><span class="line"><span class="comment">//[0, 0, 0, 0, 0, 0]	// 为了方便表示，0代表没填充数据</span></span><br><span class="line"><span class="comment">// 插入一个数据， f不变， l后移一位，指向末尾数据的下一位。（如果此时是设计非循环队列，那么 l==n(n为容量)就是判满条件 ）</span></span><br><span class="line"><span class="comment">// f  l</span></span><br><span class="line"><span class="comment">//[1, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">// 数据已满 (暂且按照非循环来看，数据满时 l == n (l==6))</span></span><br><span class="line"><span class="comment">// f			     l</span></span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment">// 头部取出数据,这时候左边空出了一个位置，l应该挪到那里去</span></span><br><span class="line"><span class="comment">// l  f</span></span><br><span class="line"><span class="comment">//[0, 2, 3, 4, 5, 6]		// 这里是为了演示需要，置0了，其实不用管，移动f/l就行，后面只能取出f~l区间里的数据</span></span><br><span class="line"><span class="comment">// 头部再取一个数据</span></span><br><span class="line"><span class="comment">// l	 f</span></span><br><span class="line"><span class="comment">//[0, 0, 3, 4, 5, 6]		// 这里是为了演示需要，置0了，其实不用管，移动f/l就行，后面只能取出f~l区间里的数据</span></span><br><span class="line"><span class="comment">// 尾部插入一个数据</span></span><br><span class="line"><span class="comment">//    l	 f</span></span><br><span class="line"><span class="comment">//[1, 0, 3, 4, 5, 6]		// 这里是为了演示需要，置0了，其实不用管，移动f/l就行，后面只能取出f~l区间里的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 前面这个流程存在问题：</span></span><br><span class="line"><span class="comment">// 当l到数组尾部后，l == 7，但是要按循环处理的话， l就得回到0， 那么此时 f==l！导致该条件下不知道是满是空</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 为了实现循环队列，留一个位置让 l 指向，不填充数据，以使在队中有数据时 l != f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重塑后的流程如下：</span></span><br><span class="line"><span class="comment">// 队列有效容量变成了5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始队空，f=0=l， 此时第一个位置就是 l 的占空位</span></span><br><span class="line"><span class="comment">// fl					// f == l 判空</span></span><br><span class="line"><span class="comment">//[0, 0, 0, 0, 0, 0]	// 为了方便表示，0代表没填充数据</span></span><br><span class="line"><span class="comment">// 插入一个数据， f不变， l后移一位，指向末尾数据的下一位。</span></span><br><span class="line"><span class="comment">// f  l</span></span><br><span class="line"><span class="comment">//[1, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">// 数据已满 （1） f=0, l=5=n (n为队列真实容量)</span></span><br><span class="line"><span class="comment">// f			  l</span></span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 0]</span></span><br><span class="line"><span class="comment">// 头部取出数据,这时候左边空出了一个位置，l应该挪到那里去</span></span><br><span class="line"><span class="comment">//    f	 	      l</span></span><br><span class="line"><span class="comment">//[0, 2, 3, 4, 5, 0]		// 这里是为了演示需要，置0了，其实不用管，移动f/l就行，后面只能取出 [f, l) 区间里的数据</span></span><br><span class="line"><span class="comment">// 头部再取一个数据</span></span><br><span class="line"><span class="comment">//  	 f	      l</span></span><br><span class="line"><span class="comment">//[0, 0, 3, 4, 5, 0]</span></span><br><span class="line"><span class="comment">// 尾部插入一个数据. l = (l+1)%n=(5+1)%6=0回到最左边</span></span><br><span class="line"><span class="comment">// l	 f</span></span><br><span class="line"><span class="comment">//[0, 0, 3, 4, 5, 1]</span></span><br><span class="line"><span class="comment">// 尾部再插入一个数据. 队列满（2） f=2, l=1</span></span><br><span class="line"><span class="comment">//    l	 f</span></span><br><span class="line"><span class="comment">//[2, 0, 3, 4, 5, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面有两种队列满的情况。怎么合并在一起来普适性地判断队满呢</span></span><br><span class="line"><span class="comment">// (2)中 l+1 = f</span></span><br><span class="line"><span class="comment">// (1)中 l+1 = 6, f=0, (l+1)%6 = f</span></span><br><span class="line"><span class="comment">// 合并起来就是 (l+1)%6 == f 为队满条件， 6为实际数组容量，5为有效数据容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑好了循环队列（单向）后，再来看看循环双端队列。</span></span><br><span class="line"><span class="comment">// 就是加上队尾删除和队头插入的情况。</span></span><br><span class="line"><span class="comment">// 一般情况下很好理解，队尾删除就l前移， 队头插入就f前移。 （除非队已满）</span></span><br><span class="line"><span class="comment">// 但是如果是 f发生了循环左移至数组最末呢</span></span><br><span class="line"><span class="comment">// 其实并不会对队空队满条件产生影响</span></span><br><span class="line"><span class="comment">// 来试着看下这个场景：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时队列还剩一个位置可用，front左移一位，在新的front上插入一个数据</span></span><br><span class="line"><span class="comment">//    f	 	      l</span></span><br><span class="line"><span class="comment">//[0, 2, 3, 4, 5, 0]</span></span><br><span class="line"><span class="comment">// f   	 	      l</span></span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环右移操作 l = (l + 1) % n</span></span><br><span class="line"><span class="comment">// 循环左移操作 l = (l - 1) % n ? x  这样会使索引越界，因为真正循环的那一次是由 0 -&gt; -1 -&gt; n-1, 所以应该先加一个 n</span></span><br><span class="line"><span class="comment">// l = (n+l-1) % n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面给出我的程序的操作实验结果</span></span><br><span class="line"><span class="comment">//		obj := Constructor(5)</span></span><br><span class="line"><span class="comment">//		param_1 := obj.InsertFront(99)</span></span><br><span class="line"><span class="comment">//		param_2 := obj.InsertLast(88)</span></span><br><span class="line"><span class="comment">//		param_5 := obj.GetFront()</span></span><br><span class="line"><span class="comment">//		param_6 := obj.GetRear()</span></span><br><span class="line"><span class="comment">//		param_3 := obj.DeleteFront()</span></span><br><span class="line"><span class="comment">//		param_4 := obj.DeleteLast()</span></span><br><span class="line"><span class="comment">//		param_7 := obj.IsEmpty()</span></span><br><span class="line"><span class="comment">//		param_8 := obj.IsFull()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录的队列状态为：</span></span><br><span class="line"><span class="comment">// data=[0 0 0 0 0 0], front=0, last=0</span></span><br><span class="line"><span class="comment">//data=[0 0 0 0 0 99], front=5, last=0</span></span><br><span class="line"><span class="comment">//data=[88 0 0 0 0 99], front=5, last=1</span></span><br><span class="line"><span class="comment">//data=[88 0 0 0 0 99], front=5, last=1</span></span><br><span class="line"><span class="comment">//data=[88 0 0 0 0 99], front=5, last=1</span></span><br><span class="line"><span class="comment">//data=[88 0 0 0 0 0], front=0, last=1</span></span><br><span class="line"><span class="comment">//data=[0 0 0 0 0 0], front=0, last=0</span></span><br><span class="line"><span class="comment">//data=[0 0 0 0 0 0], front=0, last=0</span></span><br><span class="line"><span class="comment">//data=[0 0 0 0 0 0], front=0, last=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好了，开始实现循环双端队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//51/51 cases passed (20 ms)</span></span><br><span class="line"><span class="comment">//Your runtime beats 61.36 % of golang submissions</span></span><br><span class="line"><span class="comment">//Your memory usage beats 100 % of golang submissions (6.1 MB)</span></span><br><span class="line"><span class="comment">// 占用内存少是因为很多地方没有去用局部变量，而是以计算式传入。</span></span><br><span class="line"><span class="comment">// 运行时间却很一般。稍后分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个可以提升效率的地方就是可以通过添加容量字段来减少计算容量的运算。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 奇怪的是，重新提交之后运行效率却击败了百分之九十多....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环双端队列 CircularDoubleEndedQueue</span></span><br><span class="line">type MyCircularDeque struct &#123;</span><br><span class="line">	data []int	<span class="comment">// 数组(切片)存储数据</span></span><br><span class="line">	<span class="comment">// 实际容量为data容量减1，可以在这里记录也可以不记录，我选择不记录</span></span><br><span class="line">	front int	<span class="comment">// “头指针”数组下标</span></span><br><span class="line">	last int	<span class="comment">// “尾指针”数组下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    MyCircularDeque(k)：构造函数,双端队列的大小为k。</span></span><br><span class="line">func Constructor(k int) MyCircularDeque &#123;</span><br><span class="line">	<span class="keyword">return</span> MyCircularDeque&#123;</span><br><span class="line">		<span class="comment">// 构造长度容量都为k+1的切片；当然也可以初始化为长度为0，容量为k+1；</span></span><br><span class="line">		data: make([]int, k+<span class="number">1</span>, k+<span class="number">1</span>),	<span class="comment">// 初始值全0</span></span><br><span class="line">		front:<span class="number">0</span>,</span><br><span class="line">		last:<span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。</span></span><br><span class="line">func (<span class="built_in">this</span> *MyCircularDeque) InsertFront(value int) bool &#123;</span><br><span class="line">	<span class="comment">// 检查队列是否已满</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">this</span>.IsFull() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入元素。</span></span><br><span class="line">	<span class="built_in">this</span>.front = (len(<span class="built_in">this</span>.data) + <span class="built_in">this</span>.front - <span class="number">1</span>) % len(<span class="built_in">this</span>.data)	<span class="comment">// 先循环左移一位</span></span><br><span class="line">	<span class="built_in">this</span>.data[<span class="built_in">this</span>.front] = value	<span class="comment">// 填入数据</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。</span></span><br><span class="line">func (<span class="built_in">this</span> *MyCircularDeque) InsertLast(value int) bool &#123;</span><br><span class="line">	<span class="comment">// 检查队列是否已满</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">this</span>.IsFull() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入元素</span></span><br><span class="line">	<span class="built_in">this</span>.data[<span class="built_in">this</span>.last] = value	<span class="comment">// 填入数据</span></span><br><span class="line">	<span class="built_in">this</span>.last = (<span class="built_in">this</span>.last + <span class="number">1</span>) % len(<span class="built_in">this</span>.data)	<span class="comment">// 循环右移一位</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。</span></span><br><span class="line">func (<span class="built_in">this</span> *MyCircularDeque) DeleteFront() bool &#123;</span><br><span class="line">	<span class="comment">// 检查队列是否为空</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">this</span>.IsEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除头部元素</span></span><br><span class="line">	<span class="comment">//this.data[this.front] = 0	// 置0，这一部完全不是必须，只是为了方便输出调试。可以将这句直接注释</span></span><br><span class="line">	<span class="built_in">this</span>.front = (<span class="built_in">this</span>.front + <span class="number">1</span>) % len(<span class="built_in">this</span>.data)	<span class="comment">// 循环右移一位</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。</span></span><br><span class="line">func (<span class="built_in">this</span> *MyCircularDeque) DeleteLast() bool &#123;</span><br><span class="line">	<span class="comment">// 检查队列是否为空</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">this</span>.IsEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除头部元素</span></span><br><span class="line">	<span class="built_in">this</span>.last = (len(<span class="built_in">this</span>.data) + <span class="built_in">this</span>.last - <span class="number">1</span>) % len(<span class="built_in">this</span>.data)	<span class="comment">// 循环左移一位</span></span><br><span class="line">	<span class="comment">//this.data[this.last] = 0	// 置0，这一部完全不是必须，只是为了方便输出调试。可以将这句直接注释</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。</span></span><br><span class="line">func (<span class="built_in">this</span> *MyCircularDeque) GetFront() int &#123;</span><br><span class="line">	<span class="comment">// 检查队列是否为空</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">this</span>.IsEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取头部元素</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.data[<span class="built_in">this</span>.front]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。</span></span><br><span class="line">func (<span class="built_in">this</span> *MyCircularDeque) GetRear() int &#123;</span><br><span class="line">	<span class="comment">// 检查队列是否为空</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">this</span>.IsEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取尾部元素。这里要注意下，last应该循环左移一位得到数据下标</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.data[(len(<span class="built_in">this</span>.data) + <span class="built_in">this</span>.last - <span class="number">1</span>) % len(<span class="built_in">this</span>.data)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    isEmpty()：检查双端队列是否为空，两个指针在一个位置。</span></span><br><span class="line">func (<span class="built_in">this</span> *MyCircularDeque) IsEmpty() bool &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.last == <span class="built_in">this</span>.front</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    isFull()：检查双端队列是否满了。</span></span><br><span class="line">func (<span class="built_in">this</span> *MyCircularDeque) IsFull() bool &#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">this</span>.last + <span class="number">1</span>) % len(<span class="built_in">this</span>.data) == <span class="built_in">this</span>.front</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>优先队列分为两种，一种是最大优先队列，一种是最小优先队列</p>
<p>最大优先队列，出队时最大值先出</p>
<p>有序数组的入队时间复杂度为 O(n)，出队时间复杂度为 O(1)</p>
<p>无序数组的入队时间复杂度为 O(1)，出队时间复杂度为 O(n)</p>
<p>总的来说出入队都是O(n)</p>
<p>利用堆来实现优先队列</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/heap&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Item 是优先队列中包含的元素。</span></span><br><span class="line">type Item struct &#123;</span><br><span class="line">	value    string <span class="comment">// 元素的值，可以是任意字符串。</span></span><br><span class="line">	priority int    <span class="comment">// 元素在队列中的优先级。</span></span><br><span class="line">	<span class="comment">// 元素的索引可以用于更新操作，它由 heap.Interface 定义的方法维护。</span></span><br><span class="line">	index int <span class="comment">// 元素在堆中的索引。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个实现了 heap.Interface 接口的优先队列，队列中包含任意多个 Item 结构。</span></span><br><span class="line">type PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line">func (pq PriorityQueue) Len() int &#123; <span class="keyword">return</span> len(pq) &#125;</span><br><span class="line"></span><br><span class="line">func (pq PriorityQueue) Less(i, j int) bool &#123;</span><br><span class="line">	<span class="comment">// 我们希望 Pop 返回的是最大值而不是最小值，</span></span><br><span class="line">	<span class="comment">// 因此这里使用大于号进行对比。</span></span><br><span class="line">	<span class="keyword">return</span> pq[i].priority &gt; pq[j].priority</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (pq PriorityQueue) <span class="function"><span class="title">Swap</span>(<span class="params">i, j int</span>)</span> &#123;</span><br><span class="line">	pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">	pq[i].index = i</span><br><span class="line">	pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push 入队，尾部入队</span></span><br><span class="line">func (pq *PriorityQueue) <span class="function"><span class="title">Push</span>(<span class="params">x interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">	n := len(*pq)</span><br><span class="line">	item := x.(*Item)</span><br><span class="line">	item.index = n</span><br><span class="line">	*pq = append(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop 出队，尾部出队</span></span><br><span class="line">func (pq *PriorityQueue) Pop() interface&#123;&#125; &#123;</span><br><span class="line">	old := *pq</span><br><span class="line">	n := len(old)</span><br><span class="line">	item := old[n-<span class="number">1</span>]</span><br><span class="line">	item.index = -<span class="number">1</span> <span class="comment">// 为了安全性考虑而做的设置</span></span><br><span class="line">	*pq = old[<span class="number">0</span> : n-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新函数会修改队列中指定元素的优先级以及值。</span></span><br><span class="line">func (pq *PriorityQueue) <span class="function"><span class="title">update</span>(<span class="params">item *Item, value string, priority int</span>)</span> &#123;</span><br><span class="line">	item.value = value</span><br><span class="line">	item.priority = priority</span><br><span class="line">	heap.Fix(pq, item.index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个示例首先会创建一个优先队列，并在队列中包含一些元素</span></span><br><span class="line"><span class="comment">// 接着将一个新元素添加到队列里面，并对其进行操作</span></span><br><span class="line"><span class="comment">// 最后按优先级有序地移除队列中的各个元素。</span></span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 一些元素以及它们的优先级。</span></span><br><span class="line">	items := map[string]int&#123;</span><br><span class="line">		<span class="string">&quot;banana&quot;</span>: <span class="number">3</span>, <span class="string">&quot;apple&quot;</span>: <span class="number">2</span>, <span class="string">&quot;pear&quot;</span>: <span class="number">4</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个优先队列，并将上述元素放入到队列里面，</span></span><br><span class="line">	<span class="comment">// 然后对队列进行初始化以满足优先队列（堆）的不变性。</span></span><br><span class="line">	pq := make(PriorityQueue, len(items))</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> value, <span class="attr">priority</span> := range items &#123;</span><br><span class="line">		pq[i] = &amp;Item&#123;</span><br><span class="line">			value:    value,</span><br><span class="line">			priority: priority,</span><br><span class="line">			index:    i,</span><br><span class="line">		&#125;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	heap.Init(&amp;pq)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入一个新元素，然后修改它的优先级。</span></span><br><span class="line">	item := &amp;Item&#123;</span><br><span class="line">		value:    <span class="string">&quot;orange&quot;</span>,</span><br><span class="line">		priority: <span class="number">1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	heap.Push(&amp;pq, item)</span><br><span class="line">	pq.update(item, item.value, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以降序形式取出并打印队列中的所有元素。</span></span><br><span class="line">	<span class="keyword">for</span> pq.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		item := heap.Pop(&amp;pq).(*Item)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%.2d:%s &quot;</span>, item.priority, item.value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆 heap"></a>堆 heap</h2><p>分为大顶堆，小顶堆</p>
<p>查找最大或最小：O(1)</p>
<p>删除最大或最小：O（logn）</p>
<p>插入： O（logn）或O（1）</p>
<p>golang 标准库，实现的是小顶堆， “container/heap”包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过小顶堆实现，列表里是一个2个数字的列表嵌套</span></span><br><span class="line">type IHeap []interface&#123;&#125;</span><br><span class="line"><span class="comment">// 返回长度</span></span><br><span class="line">func (h IHeap) Len() int &#123; </span><br><span class="line">    <span class="keyword">return</span> len(h) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 小的值</span></span><br><span class="line">func (h IHeap) Less(i, j int) bool &#123; </span><br><span class="line">    <span class="keyword">return</span> h[i] &lt; h[j] </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line">func (h IHeap) <span class="function"><span class="title">Swap</span>(<span class="params">i, j int</span>)</span> &#123; </span><br><span class="line">    h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入堆</span></span><br><span class="line">func (h *IHeap) <span class="function"><span class="title">Push</span>(<span class="params">x interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">    *h = append(*h, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出堆，得到最小元素</span></span><br><span class="line">func (h *IHeap) Pop() interface&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := len(old)</span><br><span class="line">    x := old[n-<span class="number">1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><p>1.是一颗完全二叉树，根节点都是满的，除了最后一层</p>
<p>2.树中任意节点的值大于等于或小于等于（二叉大顶，小顶）其子节点的值</p>
<p>3.二叉堆一般都是通过数组实现</p>
<p>4.父节点，子节点位置关系，索引为i</p>
<pre><code>左子节点：2*i+1
右子节点：2*i+2
父节点：floor((i-1)/2)</code></pre>
<p>5.插入元素：插入堆尾部，重新维护堆，向上调整</p>
<p>6。删除元素：向下调整</p>
<h4 id="golang实现二叉堆"><a href="#golang实现二叉堆" class="headerlink" title="golang实现二叉堆"></a>golang实现二叉堆</h4><p>通过数组实现一个二叉大顶堆</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大堆的定义和实现：</span></span><br><span class="line"><span class="comment">// 最大堆</span></span><br><span class="line">type maxHeap struct &#123;</span><br><span class="line">    size int</span><br><span class="line">    nums []int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父节点索引</span></span><br><span class="line">func parent(i int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取左节点索引</span></span><br><span class="line">func leftChild(i int) int &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右节点索引</span></span><br><span class="line">func rightChild(i int) int &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">func NewMaxHeap() *maxHeap &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;maxHeap&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取大小</span></span><br><span class="line">func (heap *maxHeap) GetSize() int &#123;</span><br><span class="line">    <span class="keyword">return</span> heap.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line">func (heap *maxHeap) IsEmpty() bool &#123;</span><br><span class="line">    <span class="keyword">return</span> heap.size == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素，并向上调整</span></span><br><span class="line">func (heap *maxHeap) <span class="function"><span class="title">SiftUp</span>(<span class="params">i int</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 小于则赋值</span></span><br><span class="line">    <span class="keyword">if</span> heap.size &lt; <span class="function"><span class="title">len</span>(<span class="params">heap.nums</span>)</span> &#123;</span><br><span class="line">        heap.nums[heap.size] = i</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 大于则扩容</span></span><br><span class="line">        heap.nums = append(heap.nums, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入的是堆尾，此时的heap.size还没更新，也就是索引</span></span><br><span class="line">    parI := parent(heap.size)</span><br><span class="line">    childI := heap.size</span><br><span class="line">    <span class="comment">// 父节点小于子节点，则交换</span></span><br><span class="line">    <span class="keyword">for</span> heap.nums[parI] &lt; heap.nums[childI] &#123;</span><br><span class="line">        heap.nums[parI], heap.nums[childI] = heap.nums[childI], heap.nums[parI]</span><br><span class="line">        childI = parI</span><br><span class="line">        parI = parent(parI)</span><br><span class="line">    &#125;</span><br><span class="line">    heap.size++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下调整</span></span><br><span class="line">func <span class="function"><span class="title">siftDown</span>(<span class="params">heap *maxHeap, parI int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxI int</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        leftI := leftChild(parI)</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="comment">// 左索引超出size</span></span><br><span class="line">        <span class="keyword">case</span> leftI+<span class="number">1</span> &gt; heap.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左索引不超,右索引超出size,说明左索引是最后索引</span></span><br><span class="line">        <span class="keyword">case</span> leftI+<span class="number">2</span> &gt; heap.size:</span><br><span class="line">            <span class="keyword">if</span> heap.nums[parI] &lt; heap.nums[leftI] &#123;</span><br><span class="line">                heap.nums[parI], heap.nums[leftI] = heap.nums[leftI], heap.nums[parI]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> heap.nums[leftI] &gt;= heap.nums[leftI+<span class="number">1</span>]:</span><br><span class="line">            maxI = leftI</span><br><span class="line">        <span class="keyword">case</span> heap.nums[leftI] &lt; heap.nums[leftI+<span class="number">1</span>]:</span><br><span class="line">            maxI = leftI + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比左右子节点的值都大,返回</span></span><br><span class="line">        <span class="keyword">if</span> heap.nums[parI] &gt;= heap.nums[maxI] &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        heap.nums[parI], heap.nums[maxI] = heap.nums[maxI], heap.nums[parI]</span><br><span class="line">        parI = maxI</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出对中最大元素,即root节点值</span></span><br><span class="line">func (heap *maxHeap) SiftDown() (int, error) &#123;</span><br><span class="line">    <span class="keyword">if</span> heap.IsEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;maxHeap is empty.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    vTop := heap.nums[<span class="number">0</span>]</span><br><span class="line">    heap.size--</span><br><span class="line">    heap.nums[<span class="number">0</span>], heap.nums[heap.size] = heap.nums[heap.size], <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    siftDown(heap, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vTop, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看堆中最大元素</span></span><br><span class="line">func (heap *maxHeap) GetMax() (int, error) &#123;</span><br><span class="line">    <span class="keyword">if</span> heap.IsEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;maxHeap is empty.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap.nums[<span class="number">0</span>], nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树，二叉树，二叉搜索树专题</title>
    <url>/2020/12/15/%E6%A0%91%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树有多个节点(node)，用以储存元素。某些节点之间存在一定的关系，用连线表示，连线称为边(edge)。边的上端节点称为父节点，下端称为子节点。树像是一个不断分叉的树根</p>
<p><img src="/2020/12/15/%E6%A0%91%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/1.png" alt="1"></p>
<p>树的深度为层次数</p>
<ol>
<li><p>树是元素的集合。</p>
</li>
<li><p>该集合可以为空。这时树中没有元素，我们称树为空树 (empty tree)。</p>
</li>
<li><p>如果该集合不为空，那么该集合有一个根节点，以及0个或者多个子树。根节点与它的子树的根节点用一个边(edge)相连</p>
</li>
</ol>
<p>树的实现：<br>每个节点储存元素和多个指向子节点的指针。然而，子节点数目是不确定的。一个父节点可能有大量的子节点，而另一个父节点可能只有一个子节点，而树的增删节点操作会让子节点的数目发生进一步的变化。这种不确定性就可能带来大量的内存相关操作，并且容易造成内存的浪费</p>
<h2 id="二叉树与二叉搜索树"><a href="#二叉树与二叉搜索树" class="headerlink" title="二叉树与二叉搜索树"></a>二叉树与二叉搜索树</h2><p>二叉树(binary)是一种特殊的树。二叉树的每个节点最多只能有2个子节点</p>
<p>由于二叉树的子节点数目确定，所以可以直接采用上图方式在内存中实现。每个节点有一个左子节点(left children)和右子节点(right children)。左子节点是左子树的根节点，右子节点是右子树的根节点。</p>
<p>如果我们给二叉树加一个额外的条件，就可以得到一种被称作二叉搜索树(binary search tree)的特殊二叉树。二叉搜索树要求：每个节点都不比它左子树的任意元素小，而且不比它的右子树的任意元素大。</p>
<p>二叉搜索树可以方便的实现搜索算法。在搜索元素x的时候，我们可以将x和根节点比较:</p>
<ol>
<li><p>如果x等于根节点，那么找到x，停止搜索 (终止条件)</p>
</li>
<li><p>如果x小于根节点，那么搜索左子树</p>
</li>
<li><p>如果x大于根节点，那么搜索右子树</p>
</li>
</ol>
<p>二叉搜索树所需要进行的操作次数最多与树的深度相等。n个节点的二叉搜索树的深度最多为n，最少为log(n)</p>
<h2 id="树模板"><a href="#树模板" class="headerlink" title="树模板"></a>树模板</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val=<span class="number">0</span>, left=None, right=None):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>

<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type TreeNode struct &#123;</span><br><span class="line">      Val int</span><br><span class="line">      Left *TreeNode</span><br><span class="line">      Right *TreeNode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>根左右</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type TreeNode struct &#123;</span><br><span class="line">    Val int</span><br><span class="line">    Left *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//preorderTraversal 前序遍历，递归方法，时间O(n),空间O(n)</span></span><br><span class="line">func preorderTraversal(root *TreeNode) []int &#123;</span><br><span class="line">    res := []int&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> handle func(*TreeNode)</span><br><span class="line">    handle = <span class="function"><span class="title">func</span>(<span class="params">root *TreeNode</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == nil &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = append(res, root.Val)</span><br><span class="line">        handle(root.Left)</span><br><span class="line">        handle(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    handle(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// preorderTraversal 迭代法，手动维护一个栈， 时间O(n),空间O(n)</span></span><br><span class="line"><span class="comment">// 1.初始都为空</span></span><br><span class="line"><span class="comment">// 2.先加入值，根，然后根入栈，node=node.left</span></span><br><span class="line"><span class="comment">// 3.左边全入栈，并加入结果，</span></span><br><span class="line"><span class="comment">// 4.从下往上出栈，node=node.right</span></span><br><span class="line">func preorderTraversal(root *TreeNode) []int &#123;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    node := root</span><br><span class="line">    res := []int&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node != nil || len(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> node != nil &#123;</span><br><span class="line">        	<span class="comment">// 加入节点值</span></span><br><span class="line">            res = append(res, node.Val)</span><br><span class="line">            <span class="comment">// 入栈</span></span><br><span class="line">            stack = append(stack, node)</span><br><span class="line">            <span class="comment">// 根左右顺序</span></span><br><span class="line">            node = node.Left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出栈，往右边走</span></span><br><span class="line">        node = stack[len(stack) - <span class="number">1</span>].Right</span><br><span class="line">        <span class="comment">// 减小栈</span></span><br><span class="line">        stack = stack[:len(stack) - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>左根右</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type TreeNode struct &#123;</span><br><span class="line">    Val int</span><br><span class="line">    Left *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inorderTraversal 中序遍历，递归 时间O(n),空间O(n)</span></span><br><span class="line">func inorderTraversal(root *TreeNode) []int &#123;</span><br><span class="line">    res := []int&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> handle func(*TreeNode)</span><br><span class="line">    handle = <span class="function"><span class="title">func</span>(<span class="params">root *TreeNode</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == nil &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        handle(root.Left)</span><br><span class="line">        res = append(res, root.Val)</span><br><span class="line">        handle(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    handle(root)</span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inorderTraversal 迭代法 时间O(n),空间O(n)</span></span><br><span class="line"><span class="comment">// 1.初始都为空</span></span><br><span class="line"><span class="comment">// 2.先根入栈，node=node.left</span></span><br><span class="line"><span class="comment">// 3.左边全入栈，没有加入结果，</span></span><br><span class="line"><span class="comment">// 4.从下往上出栈，出来的是左节点，加入结果 然后node=node.right</span></span><br><span class="line">func inorderTraversal(root *TreeNode) []int &#123;</span><br><span class="line">   stack := []*TreeNode&#123;&#125;</span><br><span class="line">   node := root</span><br><span class="line">   res := []int&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> node != nil || len(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 先把左节点都入栈，左 根 右 顺序</span></span><br><span class="line">       <span class="keyword">for</span> node != nil &#123;</span><br><span class="line">           stack = append(stack, node)</span><br><span class="line">           node = node.Left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出栈，将节点值加入结果</span></span><br><span class="line">        node = stack[len(stack) - <span class="number">1</span>]</span><br><span class="line">        stack = stack[:len(stack) - <span class="number">1</span>]</span><br><span class="line">        res = append(res, node.Val)</span><br><span class="line">        <span class="comment">// 右边节点</span></span><br><span class="line">        node = node.Right</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func postorderTraversal(root *TreeNode) []int &#123;</span><br><span class="line">    res := []int&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> handle func(root *TreeNode)</span><br><span class="line">    handle = <span class="function"><span class="title">func</span>(<span class="params">root *TreeNode</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == nil &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        handle(root.Left)</span><br><span class="line">        handle(root.Right)</span><br><span class="line">        res = append(res, root.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    handle(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代后序遍历</span></span><br><span class="line"><span class="comment">// 遍历本质就是内存的访问顺序，可以通过前序根左右变成根右左，再反转，但是不符合遍历本质</span></span><br><span class="line"><span class="comment">// 按照左右根的顺序，先把左节点都入栈，然后出栈取最下层的左节点，栈减少</span></span><br><span class="line"><span class="comment">// 判断这个节点的有节点是不是有值，没有的话就是最低左节点，加入结果，并标记当前节点</span></span><br><span class="line"><span class="comment">// 取其上一层的左节点继续，右节点有值，则遍历右节点，并标记</span></span><br><span class="line"><span class="comment">// 左右根，继续往上</span></span><br><span class="line"><span class="comment">// 1.初始都为空</span></span><br><span class="line"><span class="comment">// 2.先根入栈，node=node.left</span></span><br><span class="line"><span class="comment">// 3.左边全入栈，没有加入结果，</span></span><br><span class="line"><span class="comment">// 4.从下往上出栈，出来的是左节点</span></span><br><span class="line"><span class="comment">// 5.如果右节点不为空，则root=root.right  然后node=node.right</span></span><br><span class="line"><span class="comment">// 6.然后下一个循环，root.Right为空，基本都为空了，加入结果。并将root加入标记</span></span><br><span class="line"><span class="comment">// 7.继续出队</span></span><br><span class="line">func postorderTraversal(root *TreeNode) []int &#123;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> prev *TreeNode</span><br><span class="line">    res := []int&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> root != nil || len(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> root != nil &#123;</span><br><span class="line">            stack = append(stack, root)</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack[len(stack) - <span class="number">1</span>]</span><br><span class="line">        stack = stack[:len(stack) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> root.Right == nil || root.Right == prev &#123;</span><br><span class="line">            res = append(res, root.Val)</span><br><span class="line">            prev = root</span><br><span class="line">            root = nil</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack = append(stack, root)</span><br><span class="line">            root = root.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从前序中序构造二叉树"><a href="#从前序中序构造二叉树" class="headerlink" title="从前序中序构造二叉树"></a>从前序中序构造二叉树</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type TreeNode struct &#123;</span><br><span class="line">    Val int</span><br><span class="line">    Left *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buildTree 递归法</span></span><br><span class="line"><span class="comment">// 1.前序遍历的第一个节点，就是根节点，根左右，根节点后面跟的是左子树，然后是右子树</span></span><br><span class="line"><span class="comment">// 2.中序遍历的根节点在中间，根节点的位置左边就是左子树，右边就是右子树</span></span><br><span class="line"><span class="comment">// 3.因为都是一个树，所以中序和前序的左子树长度相等，同理右子树，所以中序的根节点以前长度在前序根节点以后的长度就是左子树</span></span><br><span class="line"><span class="comment">// 4.重复子问题就是，前序得到根节点，中序找到根节点，根节点之前就是左子树，左子树出左节点，根节点之后就是右子树，右子树出右节点</span></span><br><span class="line">func buildTree(preorder []int, inorder []int) *TreeNode &#123;</span><br><span class="line">	<span class="comment">// 终止条件，前序长度为0，说明已经递归完</span></span><br><span class="line">    <span class="keyword">if</span> len(preorder)==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nil</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序的第一个节点就是根节点</span></span><br><span class="line">    root:=&amp;TreeNode&#123;</span><br><span class="line">        Val:preorder[<span class="number">0</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到根节点在中序的位置</span></span><br><span class="line">    <span class="keyword">var</span> num int</span><br><span class="line">    <span class="keyword">for</span> k, <span class="attr">v</span> := range inorder&#123;</span><br><span class="line">        <span class="keyword">if</span> v == preorder[<span class="number">0</span>]&#123;</span><br><span class="line">            num = k</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理左右子树，前序是出去第一个元素，包含num的元素，中序是包含第一个元素，不包含num的元素</span></span><br><span class="line">    root.Left = buildTree(preorder[<span class="number">1</span>:num+<span class="number">1</span>],inorder[:num])</span><br><span class="line">    root.Right = buildTree(preorder[num+<span class="number">1</span>:],inorder[num+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="N叉树的前序"><a href="#N叉树的前序" class="headerlink" title="N叉树的前序"></a>N叉树的前序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type Node struct &#123;</span><br><span class="line">    Val int</span><br><span class="line">    Children []*Node</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> res []int</span><br><span class="line"></span><br><span class="line"><span class="comment">//preorder 递归方法</span></span><br><span class="line">func preorder(root *Node) []int &#123;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    res = []int&#123;&#125;</span><br><span class="line">    handle(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数</span></span><br><span class="line">func <span class="function"><span class="title">handle</span>(<span class="params">root *Node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root != nil &#123;</span><br><span class="line">        res = append(res, root.Val)</span><br><span class="line">        <span class="comment">// 子节点</span></span><br><span class="line">        <span class="keyword">for</span> _, <span class="attr">v</span> := range root.Children &#123;</span><br><span class="line">            handle(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//preorder 迭代法</span></span><br><span class="line">func preorder(root *Node) []int &#123;</span><br><span class="line">    <span class="keyword">var</span> res []int</span><br><span class="line">    <span class="comment">// 辅助栈</span></span><br><span class="line">    <span class="keyword">var</span> stack = []*Node&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="number">0</span> &lt; <span class="function"><span class="title">len</span>(<span class="params">stack</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 节点遍历，for更新root</span></span><br><span class="line">        <span class="keyword">for</span> root != nil &#123;</span><br><span class="line">            <span class="comment">//前序输出，根左右，将根节点加入结果</span></span><br><span class="line">            res = append(res, root.Val)</span><br><span class="line">            <span class="comment">// 子节点为0，就跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> == <span class="function"><span class="title">len</span>(<span class="params">root.Children</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历子节点，子节点入栈，当做下次循环的根节点，倒序加入，不加入第一个，栈先入后出</span></span><br><span class="line">            <span class="keyword">for</span> i := len(root.Children) - <span class="number">1</span>; <span class="number">0</span> &lt; i; i-- &#123;</span><br><span class="line">                stack = append(stack, root.Children[i]) <span class="comment">//入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新root，为子节点的第一个，根-&gt;左</span></span><br><span class="line">            root = root.Children[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有子节点则跳出循环，出栈，最底层的右，根-&gt;左-&gt;右</span></span><br><span class="line">        root = stack[len(stack)-<span class="number">1</span>]</span><br><span class="line">        stack = stack[:len(stack)-<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func preorder(root *Node) []int &#123;</span><br><span class="line">    res := []int&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    stack := []*Node&#123;root&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> len(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := stack[len(stack) - <span class="number">1</span>]</span><br><span class="line">        stack  = stack[:len(stack) - <span class="number">1</span>]</span><br><span class="line">        res = append(res, node.Val)</span><br><span class="line">        <span class="keyword">for</span> i := len(node.Children) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">            stack = append(stack, node.Children[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type TreeNode struct &#123;</span><br><span class="line">    Val int</span><br><span class="line">    Left *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lowestCommonAncestor 递归方法</span></span><br><span class="line"><span class="comment">// 转化为最小重复子问题，根左右节点的几种情况如下：</span></span><br><span class="line"><span class="comment">// 1.若root中只包含p则返回p</span></span><br><span class="line"><span class="comment">// 2.若root中只包含q则返回q</span></span><br><span class="line"><span class="comment">// 3.若root中不包含p也不包含q则返回NULL</span></span><br><span class="line"><span class="comment">// 4.若root中同时包含p和q，则返回root（此时root为最近公共祖先）</span></span><br><span class="line">func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123;</span><br><span class="line">    <span class="comment">// 不同层。，如果该节点找到了p，q则返回该节点</span></span><br><span class="line">    <span class="keyword">if</span> root == nil || p == root || q == root &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归就是判断当前节点是不是等于p或q，不是就一直往下找，找到就返回，或者找到nil也返回</span></span><br><span class="line">    left := lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">    right := lowestCommonAncestor(root.Right, p, q)</span><br><span class="line">    <span class="comment">// 如果存在nil则向上返回另一个节点</span></span><br><span class="line">    <span class="keyword">if</span> left == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> right == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右不等于nil，说明左右等于p，q，则root根就是最近公共祖先</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lowestCommonAncestor 递归+迭代法</span></span><br><span class="line"><span class="comment">// 1.通过递归遍历，记录所有父节点</span></span><br><span class="line"><span class="comment">// 2.通过map记录p节点的访问路径</span></span><br><span class="line"><span class="comment">// 3.然后看另一节点是否有相同的父节点，有为最近公共祖先</span></span><br><span class="line">func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123;</span><br><span class="line">    <span class="comment">// 用于记录所有的父节点路径</span></span><br><span class="line">    parent := map[int]*TreeNode&#123;&#125;</span><br><span class="line">    <span class="comment">// 用于记录p节点的访问路径，并判断q的相同父节点</span></span><br><span class="line">    visited := map[int]bool&#123;&#125;</span><br><span class="line">    <span class="comment">// 递归遍历树，只记录父节点</span></span><br><span class="line">    <span class="keyword">var</span> dfs func(*TreeNode)</span><br><span class="line">    dfs = <span class="function"><span class="title">func</span>(<span class="params">r *TreeNode</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r == nil &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只看左右节点是否为空，因为只记录父节点</span></span><br><span class="line">        <span class="keyword">if</span> r.Left != nil &#123;</span><br><span class="line">            parent[r.Left.Val] = r</span><br><span class="line">            dfs(r.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r.Right != nil &#123;</span><br><span class="line">            parent[r.Right.Val] = r</span><br><span class="line">            dfs(r.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录p节点的访问路径，从下向上</span></span><br><span class="line">    <span class="keyword">for</span> p != nil &#123;</span><br><span class="line">        visited[p.Val] = <span class="literal">true</span></span><br><span class="line">        p = parent[p.Val]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看另一节点是否有相同值，有则返回就是结果</span></span><br><span class="line">    <span class="keyword">for</span> q != nil &#123;</span><br><span class="line">        <span class="keyword">if</span> visited[q.Val] &#123;</span><br><span class="line">            <span class="keyword">return</span> q</span><br><span class="line">        &#125;</span><br><span class="line">        q = parent[q.Val]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func maxDepth(root *TreeNode) int &#123;</span><br><span class="line">    <span class="keyword">if</span> root == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(maxDepth(root.Left), maxDepth(root.Right)) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a, b int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历求最大深度</span></span><br><span class="line">func maxDepth(root *TreeNode) int &#123;</span><br><span class="line">    <span class="keyword">var</span> res int</span><br><span class="line">    <span class="keyword">if</span> root == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> dfs func(*TreeNode, int)</span><br><span class="line">    dfs = <span class="function"><span class="title">func</span>(<span class="params">root *TreeNode, l int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> l == res &#123;</span><br><span class="line">            res++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Left != nil &#123; dfs(root.Left, l+<span class="number">1</span>) &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Right != nil &#123; dfs(root.Right, l+<span class="number">1</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func maxDepth(root *TreeNode) int &#123;</span><br><span class="line">    <span class="keyword">if</span> root == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> len(q) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        l := len(q)</span><br><span class="line">        <span class="keyword">for</span> l &gt; <span class="number">0</span> &#123;</span><br><span class="line">            node := q[<span class="number">0</span>]</span><br><span class="line">            q = q[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> node.Left != nil &#123;</span><br><span class="line">                q = append(q, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != nil &#123;</span><br><span class="line">                q = append(q, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            l--</span><br><span class="line">        &#125;</span><br><span class="line">        res++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="N叉树的层序遍历"><a href="#N叉树的层序遍历" class="headerlink" title="N叉树的层序遍历"></a>N叉树的层序遍历</h3><p>第一层循环的是每一层，获取当前层的长度，初始化临时结果，然后下一层遍历这个结果</p>
<p>然后出队，取出节点，遍历节点的children下一层，下一层的入队，上一层会遍历完按顺序出队</p>
<p>下一层的都入队之后，上一层的都出队，加入结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// levelOrder 迭代法， 队列实现</span></span><br><span class="line">func levelOrder(root *Node) [][]int &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]int</span><br><span class="line">    <span class="keyword">if</span> root == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化队列，将根节点加入</span></span><br><span class="line">    q := []*Node&#123;root&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> len(q) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    	<span class="comment">// 记录当前队列的长度</span></span><br><span class="line">        l := len(q)</span><br><span class="line">        levelRes := []int&#123;&#125;</span><br><span class="line">        <span class="comment">// 不断出队，遍历</span></span><br><span class="line">        <span class="keyword">for</span> l &gt; <span class="number">0</span> &#123;</span><br><span class="line">        	<span class="comment">// 队首出队</span></span><br><span class="line">            node := q[<span class="number">0</span>]</span><br><span class="line">            q = q[<span class="number">1</span>:]</span><br><span class="line">            <span class="comment">// 遍历节点的子节点，下一层</span></span><br><span class="line">            <span class="keyword">if</span> len(node.Children) != <span class="number">0</span> &#123;</span><br><span class="line">            	<span class="comment">// 子节点入队，队尾入队</span></span><br><span class="line">                <span class="keyword">for</span> _, <span class="attr">v</span> := range node.Children &#123;</span><br><span class="line">                    q = append(q, v)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 出队，记录值，放入结果，这是一层的结果</span></span><br><span class="line">            levelRes = append(levelRes, node.Val)</span><br><span class="line">            l--</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 将每一层的结果放入最终结果</span></span><br><span class="line">    res = append(res, levelRes)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a Node.</span></span><br><span class="line"><span class="comment"> * type Node struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Children []*Node</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">func levelOrder(root *Node) [][]int &#123;</span><br><span class="line">    res := [][]int&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs func(int, *Node)</span><br><span class="line">    dfs = <span class="function"><span class="title">func</span>(<span class="params">l int, root *Node</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 先加层，相等时候加一个，加入之后就大于了，只有到下一层才继续加</span></span><br><span class="line">        <span class="comment">// 没有终止条件</span></span><br><span class="line">        <span class="keyword">if</span> l == <span class="function"><span class="title">len</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line">            res = append(res, []int&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每层加入值</span></span><br><span class="line">        res[l] = append(res[l], root.Val)</span><br><span class="line">        <span class="comment">// 终止条件是root.Children为nil，不再遍历了</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(root.Children); i++ &#123;</span><br><span class="line">            dfs(l+<span class="number">1</span>, root.Children[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始递归从0开始</span></span><br><span class="line">    <span class="keyword">if</span> root != nil &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, root)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dfs 递归，注意判断递归终止条件，层序终止条件，是节点为nil，进入下层遍历要判断节点不是nil</span></span><br><span class="line">func levelOrder(root *TreeNode) [][]int &#123;</span><br><span class="line">    res := [][]int&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs func(*TreeNode, int)</span><br><span class="line">    dfs = <span class="function"><span class="title">func</span>(<span class="params">root *TreeNode, l int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> l == <span class="function"><span class="title">len</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line">            res = append(res, []int&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        res[l] = append(res[l], root.Val)</span><br><span class="line">        <span class="keyword">if</span> root.Left != nil &#123;dfs(root.Left, l+<span class="number">1</span>)&#125;</span><br><span class="line">        <span class="keyword">if</span> root.Right != nil &#123;dfs(root.Right, l+<span class="number">1</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 别忘了判断nil，添加队列时候判断</span></span><br><span class="line">func levelOrder(root *TreeNode) [][]int &#123;</span><br><span class="line">    res := [][]int&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == nil &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> len(q) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        l := len(q)</span><br><span class="line">        lCur := []int&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l; i++ &#123;</span><br><span class="line">            node := q[<span class="number">0</span>]</span><br><span class="line">            q = q[<span class="number">1</span>:]</span><br><span class="line">            lCur = append(lCur, node.Val)</span><br><span class="line">            <span class="keyword">if</span> node.Left != nil &#123;q = append(q, node.Left)&#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != nil &#123;q = append(q, node.Right)&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = append(res, lCur)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>表格模型类字段属性</title>
    <url>/2018/03/17/%E6%A8%A1%E5%9E%8B%E7%B1%BB%E5%AD%97%E6%AE%B5%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="Django创建模型类，表格字段属性"><a href="#Django创建模型类，表格字段属性" class="headerlink" title="Django创建模型类，表格字段属性"></a>Django创建模型类，表格字段属性</h2><h3 id="导入models"><a href="#导入models" class="headerlink" title="导入models"></a>导入models</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># django要导入models</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"># 创建模型类要继承models.Mode</span><br></pre></td></tr></table></figure>
<p>Django自带一个user模型类，创建user模型类的时候可以继承django的</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> AbstractUser</span><br><span class="line">class User(AbstractUser):</span><br></pre></td></tr></table></figure>
<p>之后就可以在这个类下面自定添加新的字段属性。</p>
<h3 id="创建模型类"><a href="#创建模型类" class="headerlink" title="创建模型类"></a>创建模型类</h3><p>在models.py文件中，编写如下代码：<br>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class 类名(models.Model):</span><br><span class="line">    字段一 = models.CharField(max_length=<span class="number">20</span>, verbose_name=<span class="string">&#x27;名称&#x27;</span>)</span><br><span class="line">    日期 = models.DateField(verbose_name=<span class="string">&#x27;日期&#x27;</span>)</span><br><span class="line">    数字类型= models.IntegerField(<span class="keyword">default</span>=<span class="number">0</span>, verbose_name=<span class="string">&#x27;整型&#x27;</span>)</span><br><span class="line">    is_delete = models.BooleanField(<span class="keyword">default</span>=False, verbose_name=<span class="string">&#x27;逻辑删除&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        db_table = &#x27;表名&#x27;  # 指明数据库表名</span><br><span class="line">        verbose_name = &#x27;名称&#x27;  # 在admin站点中显示的名称</span><br><span class="line">        verbose_name_plural = verbose_name  # 显示的复数名称</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;定义每个数据对象的显示信息&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.字段一</span><br></pre></td></tr></table></figure>
<p>如示例所示即可创建一个模型类</p>
<h3 id="字段属性"><a href="#字段属性" class="headerlink" title="字段属性"></a>字段属性</h3><p>1） 数据库表名</p>
<p>模型类如果未指明表名，Django默认以 小写app应用名_小写模型类名 为数据库表名。</p>
<p>可通过db_table 指明数据库表名。</p>
<p>2） 关于主键</p>
<p>django会为表创建自动增长的主键列，每个模型只能有一个主键列，如果使用选项设置某属性为主键列后django不会再创建自动增长的主键列。</p>
<p>默认创建的主键列属性为id，可以使用pk代替，pk全拼为primary key。</p>
<p>3） 属性命名限制</p>
<p>不能是python的保留关键字。<br>不允许使用连续的下划线，这是由django的查询方式决定的。<br>定义属性时需要指定字段类型，通过字段类型的参数指定选项，语法如下：</p>
<p>属性=models.字段类型(选项)</p>
<p>4） 外键</p>
<p>在设置外键时，需要通过on_delete选项指明主表删除数据时，对于外键引用表数据如何处理，在django.db.models中包含了可选常量：</p>
<p>CASCADE 级联，删除主表数据时连通一起删除外键表中数据</p>
<p>PROTECT 保护，通过抛出ProtectedError异常，来阻止删除主表中被外键应用的数据</p>
<p>SET_NULL 设置为NULL，仅在该字段null=True允许为null时可用</p>
<p>SET_DEFAULT 设置为默认值，仅在该字段设置了默认值时可用</p>
<p>SET() 设置为特定值或者调用特定方法，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> get_user_model</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line">def get_sentinel_user():</span><br><span class="line">    <span class="keyword">return</span> get_user_model().objects.get_or_create(username=<span class="string">&#x27;deleted&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">class MyModel(models.Model):</span><br><span class="line">    user = models.ForeignKey(</span><br><span class="line">        settings.AUTH_USER_MODEL,</span><br><span class="line">        on_delete=models.SET(get_sentinel_user),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>DO_NOTHING 不做任何操作，如果数据库前置指明级联性，此选项会抛出IntegrityError异常。</p>
<p>5） 字段类型<br><img src="/2018/03/17/%E6%A8%A1%E5%9E%8B%E7%B1%BB%E5%AD%97%E6%AE%B5%E5%B1%9E%E6%80%A7/1.jpg" alt="1"><br>6） 选项<br><img src="/2018/03/17/%E6%A8%A1%E5%9E%8B%E7%B1%BB%E5%AD%97%E6%AE%B5%E5%B1%9E%E6%80%A7/2.jpg" alt="2"></p>
<h2 id="Flask创建模型类，表格字段属性"><a href="#Flask创建模型类，表格字段属性" class="headerlink" title="Flask创建模型类，表格字段属性"></a>Flask创建模型类，表格字段属性</h2><h3 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h3><p>连接数据库需要安装pymysql和flask-sqlalchemy</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pip install Flask-MySQLdb==<span class="number">0.2</span><span class="number">.0</span></span><br><span class="line">pip install Flask-SQLAlchemy==<span class="number">2.3</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>
<p>然后进行设置，数据库使用url指定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">&#x27;mysql://root:mysql@localhost:3306/数据库名&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后在mysql创建你要连接的数据库<br>其他配置<br><img src="/2018/03/17/%E6%A8%A1%E5%9E%8B%E7%B1%BB%E5%AD%97%E6%AE%B5%E5%B1%9E%E6%80%A7/3.jpg" alt="3"></p>
<h3 id="定义模型类"><a href="#定义模型类" class="headerlink" title="定义模型类"></a>定义模型类</h3><p>定义模型类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class 类名(db.Model):</span><br><span class="line">    属性<span class="number">1</span>=db.Column(类型,约束)</span><br><span class="line">    属性<span class="number">2</span>=db.Column(类型,约束)</span><br><span class="line">    属性<span class="number">3</span>=db.Column(类型,约束)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>创建表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.create_all()</span><br></pre></td></tr></table></figure>

<h3 id="字段属性和选项"><a href="#字段属性和选项" class="headerlink" title="字段属性和选项"></a>字段属性和选项</h3><p>常用的SQLAlchemy字段类型<br><img src="/2018/03/17/%E6%A8%A1%E5%9E%8B%E7%B1%BB%E5%AD%97%E6%AE%B5%E5%B1%9E%E6%80%A7/4.jpg" alt="4"><br>常用的SQLAlchemy列选项<br><img src="/2018/03/17/%E6%A8%A1%E5%9E%8B%E7%B1%BB%E5%AD%97%E6%AE%B5%E5%B1%9E%E6%80%A7/5.jpg" alt="5"><br>常用的SQLAlchemy关系选项<br><img src="/2018/03/17/%E6%A8%A1%E5%9E%8B%E7%B1%BB%E5%AD%97%E6%AE%B5%E5%B1%9E%E6%80%A7/6.jpg" alt="6"></p>
<h2 id="SKU与SPU"><a href="#SKU与SPU" class="headerlink" title="SKU与SPU"></a>SKU与SPU</h2><p>SPU = Standard Product Unit （标准产品单位）</p>
<p>SPU是商品信息聚合的最小单位，是一组可服用、易检索的标准化信息的集合，该集合描述了一个产品的特性。</p>
<p>个人理解，属性值特性类似相同，可归为一起的商品类就是spu</p>
<p>SKU = Stock Keeping Unit （库存量单位）</p>
<p>SKU即库存进出计量的单位，可以是以件、盒、托盘等为单位，是物理上不可分割的最小存货单元。在使用时要根据不同业态，不同管理模式来处理。在服装、鞋类商品中使用最多最普遍。</p>
<p>个人理解，有具体属性值，具体规格的商品就是sku</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>求和计算累加</title>
    <url>/2020/12/09/%E6%B1%82%E5%92%8C%E8%AE%A1%E7%AE%97%E7%B4%AF%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>计算： 1+2+3+4+5…..+n</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>;i &lt;= n; i++ &#123;</span><br><span class="line">	a += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环n次，时间复杂度为O(n)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = n*(n+<span class="number">1</span>)/<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>执行1次，时间复杂度为O(1)</p>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列的消息处理</title>
    <url>/2023/01/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="消息处理阶段"><a href="#消息处理阶段" class="headerlink" title="消息处理阶段"></a>消息处理阶段</h3><p>一共有三个阶段，分别是生产消息、存储消息和消费消息<br><img src="/2023/01/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/1.jpg" alt="1"></p>
<h3 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h3><h4 id="生产消息"><a href="#生产消息" class="headerlink" title="生产消息"></a>生产消息</h4><p>生产者发送消息至 Broker ，需要处理 Broker 的响应，不论是同步还是异步发送消息，同步和异步回调都需要做好 try-catch ，妥善的处理响应，如果 Broker 返回写入失败等错误消息，需要重试发送。当多次发送失败需要作报警，日志记录等。<br>这样就能保证在生产消息阶段消息不会丢失。</p>
<h4 id="存储消息"><a href="#存储消息" class="headerlink" title="存储消息"></a>存储消息</h4><p>存储消息阶段需要在消息刷盘之后再给生产者响应，假设消息写入缓存中就返回响应，那么机器突然断电这消息就没了，而生产者以为已经发送成功了。<br>如果 Broker 是集群部署，有多副本机制，即消息不仅仅要写入当前 Broker ,还需要写入副本机中。那配置成至少写入两台机子后再给生产者响应。这样基本上就能保证存储的可靠了。</p>
<h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><p>应该在消费者真正执行完业务逻辑之后，再发送给 Broker 消费成功，这才是真正的消费成功。<br>所以只要我们在消息业务逻辑处理完成之后再给 Broker 响应，那么消费阶段消息就不会丢失</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>消息可靠性增强，性能就会下降，等待消息刷盘、多副本同步后返回都会影响性能。<br>要看业务逻辑</p>
<h3 id="如何保证消息不重复"><a href="#如何保证消息不重复" class="headerlink" title="如何保证消息不重复"></a>如何保证消息不重复</h3><h4 id="什么情况下会出现重复消息"><a href="#什么情况下会出现重复消息" class="headerlink" title="什么情况下会出现重复消息"></a>什么情况下会出现重复消息</h4><p>1、业务方因为网络抖动，发过来的消息，就是重复的，会要求处理重复<br>2、为了保证消息可靠性，我们的基本需求是消息至少得发到Broker 上，那就得等 Broker 的响应，那么就可能存在 Broker 已经写入了，当时响应由于网络原因生产者没有收到，然后生产者又重发了一次，此时消息就重复了<br>3、消费者消费的时候，假设我们消费者拿到消息消费了，业务逻辑已经走完了，事务提交了，此时需要更新 Consumer offset 了，然后这个消费者挂了，另一个消费者顶上，此时 Consumer offset 还没更新，于是又拿到刚才那条消息，业务又被执行了一遍。于是消息又重复</p>
<p>正常业务而言消息重复是不可避免的，因此我们只能从另一个角度来解决重复消息的问题。<br>关键点就是幂等。既然我们不能防止重复消息的产生，那么我们只能在业务上处理重复消息所带来的影响</p>
<h4 id="幂等消息处理"><a href="#幂等消息处理" class="headerlink" title="幂等消息处理"></a>幂等消息处理</h4><p>保证同样的参数多次调用同一个接口和调用一次产生的结果是一致的，看具体的业务细节</p>
<h3 id="如何保证消息有序"><a href="#如何保证消息有序" class="headerlink" title="如何保证消息有序"></a>如何保证消息有序</h3><h4 id="全局有序"><a href="#全局有序" class="headerlink" title="全局有序"></a>全局有序</h4><p>如果要保证消息的全局有序，首先只能由一个生产者往 Topic 发送消息，并且一个 Topic 内部只能有一个队列（分区）。消费者也必须是单线程消费这个队列。这样的消息就是全局有序的<br><img src="/2023/01/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/2.jpg" alt="1"><br>但是这样就会导致消费进程变慢，一般来说我们不需要全局有序，只需要保证部分有序即可</p>
<h4 id="部分有序"><a href="#部分有序" class="headerlink" title="部分有序"></a>部分有序</h4><p>部分有序我们就可以将 Topic 内部划分成我们需要的队列数，把消息通过特定的策略发往固定的队列中，然后每个队列对应一个单线程处理的消费者。这样即完成了部分有序的需求，又可以通过队列数量的并发来提高消息处理效率</p>
<p><img src="/2023/01/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/3.jpg" alt="1"></p>
<h3 id="如何保证消息不堆积"><a href="#如何保证消息不堆积" class="headerlink" title="如何保证消息不堆积"></a>如何保证消息不堆积</h3><p>消息的堆积往往是因为生产者的生产速度与消费者的消费速度不匹配。有可能是因为消息消费失败反复重试造成的，也有可能就是消费者消费能力弱，渐渐地消息就积压了。<br>因此我们需要先定位消费慢的原因，如果是 bug 则处理 bug ，如果是因为本身消费能力较弱，我们可以优化下消费逻辑，比如之前是一条一条消息消费处理的，这次我们批量处理，比如数据库的插入，一条一条插和批量插效率是不一样的。<br>假如逻辑我们已经都优化了，但还是慢，那就得考虑水平扩容了，增加 Topic 的队列数和消费者数量，注意队列数一定要增加，不然新增加的消费者是没东西消费的。一个Topic中，一个队列只会分配给一个消费者。<br>当然你消费者内部是单线程还是多线程消费那看具体场景。不过要注意上面提高的消息丢失的问题，如果你是将接受到的消息写入内存队列之后，然后就返回响应给 Broker ，然后多线程向内存队列消费消息，假设此时消费者宕机了，内存队列里面还未消费的消息也就丢了。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列的一些基本总结</title>
    <url>/2023/01/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>消息队列常常指代的是消息中间件</p>
<h2 id="消息队列的用处"><a href="#消息队列的用处" class="headerlink" title="消息队列的用处"></a>消息队列的用处</h2><p>随着业务不断扩张，用来异步处理，服务解耦，流量控制<br>异步处理：调用链路长，响应慢，为了减少请求的等待，还能让服务异步并发处理，提升系统总体性能<br>服务解耦：解决系统之间的耦合问题，避免互相影响<br>流量控制：流量洪峰的削峰，有一些服务特别是某些后台任务，不需要及时地响应，并且业务处理复杂且流程长，那么过来的请求先放入消息队列中，后端服务按照自己的节奏处理</p>
<p>PS：多引入一个中间件系统的稳定性就下降一层，运维的难度抬高一层。因此要权衡利弊，系统是演进的</p>
<h2 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h2><h3 id="队列模型"><a href="#队列模型" class="headerlink" title="队列模型"></a>队列模型</h3><p>生产者往某个队列里面发送消息，一个队列可以存储多个生产者的消息，一个队列也可以有多个消费者，但是消费者之间是竞争关系，即每条消息只能被一个消费者消费。<br><img src="/2023/01/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%80%BB%E7%BB%93/1.jpg" alt="1"></p>
<h3 id="发布-订阅模型"><a href="#发布-订阅模型" class="headerlink" title="发布/订阅模型"></a>发布/订阅模型</h3><p>该模型是将消息发往一个Topic 即主题中，所有订阅了这个 Topic 的订阅者都能消费这条消息<br><img src="/2023/01/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%80%BB%E7%BB%93/2.jpg" alt="1"></p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>队列模型每条消息只能被一个消费者消费，而发布/订阅模型就是为让一条消息可以被多个消费者消费而生的，当然队列模型也可以通过消息全量存储至多个队列来解决一条消息被多个消费者消费问题，但是会有数据的冗余。<br>发布/订阅模型兼容队列模型，即只有一个消费者的情况下和队列模型基本一致。<br>RabbitMQ 采用队列模型， RocketMQ 和 Kafka 采用发布/订阅模型。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列的事务消息</title>
    <url>/2023/04/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<h2 id="分布式事务消息"><a href="#分布式事务消息" class="headerlink" title="分布式事务消息"></a>分布式事务消息</h2><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>2PC 就是二阶段提交，分别有协调者和参与者两个角色，二阶段分别是准备阶段和提交阶段。<br>准备阶段就是协调者向各参与者发送准备命令，这个阶段参与者除了事务的提交啥都做了，而提交阶段就是协调者看看各个参与者准备阶段都 o 不 ok，如果有 ok 那么就向各个参与者发送提交命令，如果有一个不 ok 那么就发送回滚命令。</p>
<p>这里的重点就是 2PC 只适用于数据库层面的事务，就是你想在数据库里面写一条数据同时又要上传一张图片，这两个操作 2PC 无法保证两个操作满足事务的约束。</p>
<p>而且 2PC 是一种强一致性的分布式事务，它是同步阻塞的，即在接收到提交或回滚命令之前，所有参与者都是互相等待，特别是执行完准备阶段的时候，此时的资源都是锁定的状态，假如有一个参与者卡了很久，其他参与者都得等它，产生长时间资源锁定状态下的阻塞。</p>
<p>总体而言效率低，并且存在单点故障问题，协调者是就是那个单点，并且在极端条件下存在数据不一致的风险，例如某个参与者未收到提交命令，此时宕机了，恢复之后数据是回滚的，而其他参与者其实都已经执行了提交事务的命令了。</p>
<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>TCC 能保证业务层面的事务，也就是说它不仅仅是数据库层面，上面的上传图片这种操作它也能做。<br>TCC 分为三个阶段 try - confirm - cancel，简单的说就是每个业务都需要有这三个方法，先都执行 try方法，这一阶段不会做真正的业务操作，只是先占个坑，比如打算加 10 个积分，那先在<br>预添加字段加上这 10 积分，这个时候用户账上的积分其实是没有增加的。<br>然后如果都 try 成功了那么就执行 confirm 方法，大家都来做真正的业务操作，如果有一个 try 失败了那么大家都执行 cancel 操作，来撤回刚才的修改。<br>可以看到 TCC 其实对业务的耦合性很大，因为业务上需要做一定的改造才能完成这三个方法，这其实就是 TCC 的缺点，并且 confirm 和 cancel 操作要注意幂等，因为到执行这两步的时候没有退路，是务必要完成的，因此需要有重试机制，所以需要保证方法幂等。</p>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>事务消息主要是适用于异步更新的场景，并且对数据实时性要求不高的地方。它的目的是为了解决消息生产者与消息消费者的数据一致性问题</p>
<h3 id="RocketMQ事务消息"><a href="#RocketMQ事务消息" class="headerlink" title="RocketMQ事务消息"></a>RocketMQ事务消息</h3><p>RocketMQ 的事务消息也可以被认为是一个两阶段提交，简单的说就是在事务开始的时候会先发送一个半消息给 Broker。</p>
<p>半消息的意思就是这个消息此时对 Consumer 是不可见的，而且也不是存在真正要发送的队列中，而是一个特殊队列。</p>
<p>发送完半消息之后再执行本地事务，再根据本地事务的执行结果来决定是向 Broker 发送提交消息，还是发送回滚消息。</p>
<p>如果这一步发送提交或者回滚消息失败了怎么办，Broker会定时的向 Producer 来反查这个事务是否成功，具体的就是 Producer 需要暴露一个接口，通过这个接口 Broker 可以得知事务到底有没有执行成功，没成功就返回未知，因为有可能事务还在执行，会进行多次查询。</p>
<p>如果成功那么就将半消息恢复到正常要发送的队列中，这样消费者就可以消费这条消息了</p>
<p>看一下代码：<br><img src="/2023/04/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/1.jpg" alt="1"></p>
<p>可以看到使用起来还是很简便直观的，无非就是多加个反查事务结果的方法，然后把本地事务执行的过程写在 TransationListener 里面。</p>
<p>整体流程如下：<br><img src="/2023/04/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/2.jpg" alt="1"></p>
<p>分析一下源码：<br><img src="/2023/04/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/3.jpg" alt="1"><br>流程也就是我们上面分析的，将消息塞入一些属性，标明此时这个消息还是半消息，然后发送至<br>Broker，然后执行本地事务，然后将本地事务的执行状态发送给 Broker</p>
<p>Broker如何处理：</p>
<p>在 Broker 的 SendMessageProcessor#sendMessage 中会处理这个半消息请求， sendMessage 中查到接受来的消息的属性里面MessageConst.PROPERTY_TRANSACTION_PREPARED 是 true ，那么可以得知这个消息是事务消息，然后再判断一下这条消息是否超过最大消费次数，是否要延迟，Broker 是否接受事务消息等操作后，将这条消息真正的 topic 和队列存入属性中，然后重置消息的 topic 为 RMQ_SYS_TRANS_HALF_TOPIC ，并且队列是 0 的队列中，使得消费者无法读取这个消息。<br><img src="/2023/04/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/4.jpg" alt="1"></p>
<p>其实延时消息也是这么实现的，最终将换了皮的消息入盘</p>
<p>Broker 处理提交或者回滚消息的处理方法是 EndTransactionProcessor#processRequest<br><img src="/2023/04/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/5.jpg" alt="1"></p>
<p>可以看到，如果是提交事务就是把皮再换回来写入真正的topic所属的队列中，供消费者消费，如果是回滚则是将半消息记录到一个 half_op 主题下，到时候后台服务扫描半消息的时候就依据其来判断这个消息已经处理过了。</p>
<p>那个后台服务就是 TransactionalMessageCheckService 服务，它会定时的扫描半消息队列，去请<br>求反查接口看看事务成功了没，具体执行的就是 TransactionalMessageServiceImpl#check 方法</p>
<p>首先取半消息 topic 即 RMQ_SYS_TRANS_HALF_TOPIC 下的所有队列，如果还记得上面内容的话，就知道半消息写入的队列是 id 是 0 的这个队列，然后取出这个队列对应的 half_op 主题下的队列，即RMQ_SYS_TRANS_OP_HALF_TOPIC 主题下的队列。</p>
<p>这个 half_op 主要是为了记录这个事务消息已经被处理过，也就是说已经得知此事务消息是提交的还是回滚的消息会被记录在 half_op 中。</p>
<p>然后调用 fillOpRemoveMap 方法，从 half_op 取一批已经处理过的消息来去重，将那些没有记录在<br>half_op 里面的半消息调用 putBackHalfMsgQueue 又写入了 commitlog 中，然后发送事务反查请<br>求，这个反查请求也是 oneWay，即不会等待响应。当然此时的半消息队列的消费 offset 也会推进。</p>
<p>然后producer中的 ClientRemotingProcessor#processRequest 会处理这个请求，会把任务扔到<br>TransactionMQProducer 的线程池中进行，最终会调用上面我们发消息时候定义的<br>checkLocalTransactionState 方法，然后将事务状态发送给 Broker，也是用 oneWay 的方式</p>
<p>为什么已经有一个半消息队列，坏会有一个half_op</p>
<p>首先 RocketMQ 的设计就是顺序追加写入，所以说不会更改已经入盘的消息，那事务消息又需要更新反查的次数，超过一定反查失败就判定事务回滚。</p>
<p>因此每一次要反查的时候就将以前的半消息再入盘一次，并且往前推进消费进度。而 half_op 又会记录每一次反查的结果，不论是提交还是回滚都会记录，因此下一次还循环到处理此半消息的时候，可以从half_op 得知此事务已经结束了，因此就被过滤掉不需要处理了。</p>
<p>如果得到的反查的结果是 UNKNOW，那 half_op 中也不会记录此结果，因此还能再次反查，并且更新反查次数。</p>
<p>Broker处理流程：<br><img src="/2023/04/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/6.jpg" alt="1"></p>
<h3 id="Kafka事务消息"><a href="#Kafka事务消息" class="headerlink" title="Kafka事务消息"></a>Kafka事务消息</h3><p>Kafka 的事务消息和 RocketMQ 的事务消息又不一样了，RocketMQ 解决的是本地事务的执行和发消息这两个动作满足事务的约束。</p>
<p>而 Kafka 事务消息则是用在一次事务中需要发送多个消息的情况，保证多个消息之间的事务约束，即多条消息要么都发送成功，要么都发送失败</p>
<p>Kafka 的事务基本上是配合其幂等机制来实现 Exactly Once 语义的，所以说 Kafka 的事务消息不是我们想的那种事务消息，RocketMQ 的才是。</p>
<p>和我们在业务上实现的一样通过一个唯一 Id， 然后记录下来，如果已经记录过了就不写入，这样来保证恰好一次。</p>
<p>所以说 Kafka 实现的是在特定场景下的恰好一次，不是我们所想的利用 Kafka 来发送消息，那么这条消息只会恰巧被消费一次</p>
<p>Kafka 的事务有事务协调者角色，事务协调者其实就是 Broker 的一部分。<br>在开始事务的时候，生产者会向事务协调者发起请求表示事务开启，事务协调者会将这个消息记录到特殊的日志-事务日志中，然后生产者再发送真正想要发送的消息，这里 Kafka 和 RocketMQ 处理不一样，Kafka 会像对待正常消息一样处理这些事务消息，由消费端来过滤这个消息。</p>
<p>然后发送完毕之后生产者会向事务协调者发送提交或者回滚请求，由事务协调者来进行两阶段提交，如果是提交那么会先执行预提交，即把事务的状态置为预提交然后写入事务日志，然后再向所有事务有关的分区写入一条类似事务结束的消息，这样消费端消费到这个消息的时候就知道事务好了，可以把消息放出来了。</p>
<p><img src="/2023/04/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/7.jpg" alt="1"></p>
<h3 id="比-RocketMQ-更好的事务消息实现"><a href="#比-RocketMQ-更好的事务消息实现" class="headerlink" title="比 RocketMQ 更好的事务消息实现"></a>比 RocketMQ 更好的事务消息实现</h3><p>在 RocketMQ 中，事务消息的实现方案是先发半消息（半消息对消费者不可见），待半消息发送成功之后，才能执行本地事务，等本地事务执行成功之后，再向 Broker 发送请求将半消息转成正常消息，这样消费者就可以消费此消息。</p>
<p>这种顺序等于先得成功写入 mq，然后再写入数据库，这样的模式会出现一个问题：即 mq 集群挂了，事务就无法继续进行了，等于整个应用无法正常执行了</p>
<h4 id="本地消息事务表"><a href="#本地消息事务表" class="headerlink" title="本地消息事务表"></a>本地消息事务表</h4><p>先看一下本地消息事务表的原理</p>
<p>本地消息就是利用了关系型数据库的事务能力，会在数据库中存放一张本地事务消息表，在进行本地事务操作中加入了本地消息表的插入，即将业务的执行和将消息放入到消息表中的操作放在同一个事务中提交。</p>
<p>这样本地事务执行成功的话，消息肯定也插入成功，然后再调用其他服务，如果其他服务调用成功就修改这条本地消息的状态。</p>
<p>如果失败也不要紧，会有一个后台线程扫描，发现这些状态的消息，会一直调用相应的服务，一般会设置重试的次数，如果一直不行则特殊记录，待人工介入处理</p>
<p><img src="/2023/04/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/8.jpg" alt="1"></p>
<h4 id="qmq消息事务"><a href="#qmq消息事务" class="headerlink" title="qmq消息事务"></a>qmq消息事务</h4><p>qmq的核心思想就是本地事务表</p>
<p>利用关系型数据库的事务能力，将业务的写入和消息表的写入融在一个事务中，这样业务成功则消息表肯定写入成功。</p>
<p>然后在事务提交之后，立刻发送事务消息，如果发送成功，则删除本地消息表中的记录</p>
<p>如果消息发送失败，也就是比如 mq 集群挂了，并不会影响事务的执行，业务的执行和事务消息的插入都已经成功了，那此时待消息已经安安静静的在消息库里等着，后台能会有一个补偿任务，会将这些消息捞出来重新发送，直到发送成功。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列的推拉模式</title>
    <url>/2023/03/10/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8E%A8%E6%8B%89%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="推拉模式"><a href="#推拉模式" class="headerlink" title="推拉模式"></a>推拉模式</h2><p>推拉模式的时候指的是 Comsumer 和 Broker 之间的交互。<br>默认的认为 Producer 与 Broker 之间就是推的方式，即 Producer 将消息推送给 Broker，而不是Broker 主动去拉取消息</p>
<p>如果需要 Broker 去拉取消息，那么 Producer 就必须在本地通过日志的形式保存消息来等待 Broker 的拉取，如果有很多生产者的话，那么消息的可靠性不仅仅靠 Broker 自身，还需要靠成百上千的 Producer。</p>
<h3 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h3><p>推模式指的是消息从 Broker 推向 Consumer，即 Consumer 被动的接收消息，由 Broker 来主导消息的发送</p>
<h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><p>1、消息实时性高， Broker 接受完消息之后可以立马推送给 Consumer。<br>2、对于消费者使用来说更简单，就等着，反正有消息来了就会推过来</p>
<h4 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h4><p>推送速率难以适应消费速率，推模式的目标就是以最快的速度推送消息，当生产者往 Broker 发送消息的速率大于消费者消费消息的速率时，消费者服务就容易崩溃，并且不同的消费者的消费速率还不一样，身为 Broker 很难平衡每个消费者的推送速率，如果要实现自适应的推送速率那就需要在推送的时候消费者告诉 Broker ，然后 Broker 需要维护每个消费者的状态进行推送速率的变更。<br>这其实就增加了 Broker 自身的复杂度。</p>
<p>所以说推模式难以根据消费者的状态控制推送速率，适用于消息量不大、消费能力强要求实时性高的场景</p>
<h3 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h3><p>拉模式指的是 Consumer 主动向 Broker 请求拉取消息，即 Broker 被动的发送消息给 Consumer</p>
<h4 id="优势：-1"><a href="#优势：-1" class="headerlink" title="优势："></a>优势：</h4><p>1、拉模式主动权就在消费者身上，消费者可以根据自身的情况来发起拉取消息的请求。假设当前消费者觉得自己消费不过来了，它可以根据一定的策略停止拉取，或者间隔拉取<br>2、 Broker 就相对轻松，它只管存生产者发来的消息，至于消费的时候自然由消费者主动发起，不需要关注消息的消费<br>3、根据消费者的消费能力，可以参考消费者请求的信息来决定缓存多少消息之后批量发送</p>
<h4 id="劣势：-1"><a href="#劣势：-1" class="headerlink" title="劣势："></a>劣势：</h4><p>1、消息延迟，消费者去拉取消息，但是消费者怎么知道消息到了呢？所以它只能不断地拉取，但是又不能很频繁地请求，太频繁了就变成消费者在攻击 Broker 。因此需要降低请求的频率，比如隔个2 秒请求一次，你看着消息就很有可能延迟 2 秒<br>2、消息忙请求，忙请求就是比如消息隔了几个小时才有，那么在几个小时之内消费者的请求都是无效的</p>
<p>我个人觉得拉模式更加的合适，因为现在的消息队列都有持久化消息的需求，也就是说本身它就有个存储功能，它的使命就是接受消息，保存好消息使得消费者可以消费消息即可。<br>虽说一般而言 Broker 不会成为瓶颈，因为消费端有业务消耗比较慢，但是 Broker 毕竟是一个中心点，能轻量就尽量轻量</p>
<h2 id="RocketMq和kafka的处理"><a href="#RocketMq和kafka的处理" class="headerlink" title="RocketMq和kafka的处理"></a>RocketMq和kafka的处理</h2><p>RocketMQ 和 Kafka 都选择了拉模式，通过长轮询来减轻拉模式的劣势影响</p>
<p>基于推模式的消息队列如 ActiveMQ。</p>
<h3 id="RocketMQ-中的长轮询"><a href="#RocketMQ-中的长轮询" class="headerlink" title="RocketMQ 中的长轮询"></a>RocketMQ 中的长轮询</h3><p>RocketMQ 中的 PushConsumer 其实是披着拉模式的方法，<strong>只是看起来像推模式而已</strong>。</p>
<p>因为 RocketMQ 在被背后偷偷的帮我们去 Broker 请求数据了</p>
<p>如图所示：</p>
<p><img src="/2023/03/10/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8E%A8%E6%8B%89%E6%A8%A1%E5%BC%8F/1.jpg" alt="1"></p>
<p>后台会有个 RebalanceService 线程，这个线程会根据 topic 的队列数量和当前消费组的消费者个数做</p>
<p>负载均衡，每个队列产生的 pullRequest 放入阻塞队列 pullRequestQueue 中。然后又有个</p>
<p>PullMessageService 线程不断的从阻塞队列 pullRequestQueue 中获取 pullRequest，然后通过网络</p>
<p>请求 broker，这样实现的准实时拉取消息</p>
<p>然后 Broker 的 PullMessageProcessor 里面的 processRequest 方法是用来处理拉消息请求的，有消</p>
<p>息就直接返回，如果没有消息怎么办呢</p>
<p><img src="/2023/03/10/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8E%A8%E6%8B%89%E6%A8%A1%E5%BC%8F/2.jpg" alt="1"></p>
<p>suspendPullRequest 方法</p>
<p><img src="/2023/03/10/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8E%A8%E6%8B%89%E6%A8%A1%E5%BC%8F/3.jpg" alt="1"></p>
<p>而 PullRequestHoldService 这个线程会每 5 秒从 pullRequestTable 取PullRequest请求，然后看看待</p>
<p>拉取消息请求的偏移量是否小于当前消费队列最大偏移量，如果条件成立则说明有新消息了，则会调用</p>
<p>notifyMessageArriving ，最终调用 PullMessageProcessor 的 executeRequestWhenWakeup() 方法</p>
<p>重新尝试处理这个消息的请求，也就是再来一次，整个长轮询的时间默认 30 秒。</p>
<p><img src="/2023/03/10/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8E%A8%E6%8B%89%E6%A8%A1%E5%BC%8F/4.jpg" alt="1"></p>
<p>简单的说就是 5 秒会检查一次消息时候到了，如果到了则调用 processRequest 再处理一次</p>
<p>但是这样看起来并不太实时，所以还有个 ReputMessageService 线程，这个线程用来不断地从 commitLog 中解析数据并分发请求，构建出 ConsumeQueue 和 IndexFile 两种类型的数据，<strong>并且也会有唤醒请求的操作，来弥补每</strong> <strong>5s</strong>一次这么慢的延迟，就是消息写入并且会调用 pullRequestHoldService#notifyMessageArriving</p>
<p>最终的流程就如上面的流程图所示</p>
<h3 id="Kafka的长轮询"><a href="#Kafka的长轮询" class="headerlink" title="Kafka的长轮询"></a>Kafka的长轮询</h3><p>像 Kafka 在拉请求中有参数，可以使得消费者请求在 “长轮询” 中阻塞等待。</p>
<p>简单的说就是消费者去 Broker 拉消息，定义了一个超时时间，也就是说消费者去请求消息，如果有的</p>
<p>话马上返回消息，如果没有的话消费者等着直到超时，然后再次发起拉消息请求。</p>
<p>并且 Broker 也得配合，如果消费者请求过来，有消息肯定马上返回，没有消息那就建立一个延迟操</p>
<p>作，等条件满足了再返回。</p>
<p><img src="/2023/03/10/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8E%A8%E6%8B%89%E6%A8%A1%E5%BC%8F/10.jpg" alt="1"></p>
<p>消费者：</p>
<p><img src="/2023/03/10/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8E%A8%E6%8B%89%E6%A8%A1%E5%BC%8F/5.jpg" alt="1"></p>
<p><img src="/2023/03/10/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8E%A8%E6%8B%89%E6%A8%A1%E5%BC%8F/6.jpg" alt="1"></p>
<p><img src="/2023/03/10/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8E%A8%E6%8B%89%E6%A8%A1%E5%BC%8F/7.jpg" alt="1"></p>
<p>最后<strong>调用的就是</strong> <strong>Kafka</strong> <strong>包装过的</strong> <strong>selector**</strong>，而最终会调用** <strong>Java nio</strong> <strong>的</strong> <strong>select(timeout)</strong></p>
<p>Broker:</p>
<p>就在 KafkaApis.scala 文件的 handle 方法下，handleFetchRequest 。</p>
<p>这个方法进来后</p>
<p><img src="/2023/03/10/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8E%A8%E6%8B%89%E6%A8%A1%E5%BC%8F/8.jpg" alt="1"></p>
<p><img src="/2023/03/10/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8E%A8%E6%8B%89%E6%A8%A1%E5%BC%8F/9.jpg" alt="1"></p>
<p>这个延迟操作都需要实现哪些方法，首先构建的延迟操作需要有检查机制，来查看</p>
<p>消息是否已经到了，然后呢还得有个消息到了之后该执行的方法，还需要有执行完毕之后该干啥的方</p>
<p>法，当然还得有个超时之后得干啥的方法。</p>
<p>这几个方法其实对应的就是代码里的 DelayedFetch ，这个类继承了 DelayedOperation 内部有：</p>
<p>isCompleted 检查条件是否满足的方法</p>
<p>tryComplete 条件满足之后执行的方法</p>
<p>onComplete 执行完毕之后调用的方法</p>
<p>onExpiration 过期之后需要执行的方法</p>
<p>判断是否过期就是由时间轮来推动判断的，但是总不能等过期的时候再去看消息到了没吧？</p>
<p>这里 Kafka 和 RocketMQ 的机制一样，也会在消息写入的时候提醒这些延迟请求消息来了</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到 RocketMQ 和 Kafka 都是采用“长轮询”的机制，具体的做法都是通过消费者等待消息，当有</p>
<p>消息的时候 Broker 会直接返回消息，如果没有消息都会采取延迟处理的策略，并且为了保证消息的及</p>
<p>时性，在对应队列或者分区有新消息到来的时候都会提醒消息来了，及时返回消息。</p>
<p>消费者和 Broker 相互配合，拉取消息请求不满足条件的时候 hold 住，避免了多次频繁的</p>
<p>拉取动作，当消息一到就提醒返回。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口最大值</title>
    <url>/2021/03/22/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h3 id="暴力优化法"><a href="#暴力优化法" class="headerlink" title="暴力优化法"></a>暴力优化法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func maxSlidingWindow(nums []int, k int) []int &#123;</span><br><span class="line">    res := []int&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    curMax := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; k; i++  &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; curMax &#123;</span><br><span class="line">            curMax = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res =append(res, curMax)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(nums) - k + <span class="number">1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i - <span class="number">1</span>] == curMax &#123;</span><br><span class="line">            curMax = nums[i]</span><br><span class="line">            <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; i + k - <span class="number">1</span>; j++ &#123;</span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; curMax &#123;</span><br><span class="line">                    curMax = nums[j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[i + k - <span class="number">1</span>] &gt; curMax &#123;</span><br><span class="line">            curMax = nums[i + k - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        res = append(res, curMax)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func maxSlidingWindow(nums []int, k int) []int &#123;</span><br><span class="line">	<span class="comment">// 初始化队列</span></span><br><span class="line">    queue := []int&#123;&#125;</span><br><span class="line">    res := []int&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(nums); i++ &#123;</span><br><span class="line">    	<span class="comment">// 保证队列头部是最大值</span></span><br><span class="line">        <span class="keyword">for</span> len(queue) &gt; <span class="number">0</span> &amp;&amp; queue[len(queue)-<span class="number">1</span>] &lt; nums[i] &#123;</span><br><span class="line">            queue = queue[: len(queue)-<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        queue = append(queue, nums[i])</span><br><span class="line">        <span class="comment">// 形成滑动窗口， 出去的是最大值，则队头出队</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= k &amp;&amp; queue[<span class="number">0</span>] == nums[i-k] &#123;</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i是滑动窗口的最后一位</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= k-<span class="number">1</span> &#123;</span><br><span class="line">            res = append(res, queue[<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现堆</span></span><br><span class="line"><span class="keyword">var</span> a []int</span><br><span class="line"><span class="comment">// 存储索引，a是值数组，i，j是索引</span></span><br><span class="line">type hp struct&#123; sort.IntSlice &#125;</span><br><span class="line"><span class="comment">// 大根</span></span><br><span class="line">func (h hp) Less(i, j int) bool  &#123; <span class="keyword">return</span> a[h.IntSlice[i]] &gt; a[h.IntSlice[j]] &#125;</span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">func (h *hp) <span class="function"><span class="title">Push</span>(<span class="params">v interface&#123;&#125;</span>)</span> &#123; h.IntSlice = append(h.IntSlice, v.(int)) &#125;</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">func (h *hp) Pop() interface&#123;&#125;   &#123; <span class="attr">a</span> := h.IntSlice; v := a[len(a)-<span class="number">1</span>]; h.IntSlice = a[:len(a)-<span class="number">1</span>]; <span class="keyword">return</span> v &#125;</span><br><span class="line"></span><br><span class="line">func maxSlidingWindow(nums []int, k int) []int &#123;</span><br><span class="line">    <span class="comment">// a赋值数组</span></span><br><span class="line">    a = nums</span><br><span class="line">    <span class="comment">// 初始化优先队列</span></span><br><span class="line">    q := &amp;hp&#123;make([]int, k)&#125;</span><br><span class="line">    <span class="comment">// 初始化前k个索引</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        q.IntSlice[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化堆</span></span><br><span class="line">    heap.Init(q)</span><br><span class="line"></span><br><span class="line">    n := len(nums)</span><br><span class="line">    <span class="comment">// 结果</span></span><br><span class="line">    ans := make([]int, <span class="number">1</span>, n-k+<span class="number">1</span>)</span><br><span class="line">    ans[<span class="number">0</span>] = nums[q.IntSlice[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> i := k; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="comment">// 插入堆</span></span><br><span class="line">        heap.Push(q, i)</span><br><span class="line">        <span class="comment">// 根位置的索引，找到窗口的最大值</span></span><br><span class="line">        <span class="keyword">for</span> q.IntSlice[<span class="number">0</span>] &lt;= i-k &#123;</span><br><span class="line">            heap.Pop(q)</span><br><span class="line">        &#125;</span><br><span class="line">        ans = append(ans, nums[q.IntSlice[<span class="number">0</span>]])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>盛水容器问题</title>
    <url>/2020/12/10/%E7%9B%9B%E6%B0%B4%E5%AE%B9%E5%99%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器。<br><img src="/2020/12/10/%E7%9B%9B%E6%B0%B4%E5%AE%B9%E5%99%A8%E9%97%AE%E9%A2%98/1.png" alt="1"></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>设两个坐标a,b,分别从列表的起始端和结束端向中间移动，起始面积为0，每移动一次，即得到新的面积，与上一次移动的面积进行比较，取最大值，移动到ab相等时结束移动，如果a板高于b板，则以b板算面积，算完进行比较然后，缩减b的长度，a板小于b板，则以a板算面积，进行比较，增加a。最后a&gt;=b跳出循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func maxArea(height []int) int &#123;</span><br><span class="line">    a, b, <span class="attr">res</span> := <span class="number">0</span>, len(height)-<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> height[a] &gt; height[b]&#123;</span><br><span class="line">            <span class="keyword">if</span>  height[b]*(b-a) &gt; res &#123;</span><br><span class="line">                res = height[b]*(b-a)</span><br><span class="line">            &#125;</span><br><span class="line">            b--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>  height[a]*(b-a) &gt; res &#123;</span><br><span class="line">                res = height[a]*(b-a)</span><br><span class="line">            &#125;</span><br><span class="line">            a++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>移动零</title>
    <url>/2021/01/27/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">input = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">res = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>双指针</p>
<p>一个指针不动，遍历另一个指针，从第一位开始遍历，如果这个数字不为0，则往前放，跟i指针的交换位置，并且i指针往前移1位</p>
<p>为0的话，i指针保持不动</p>
<p>i指针是从前开始一点点加，碰到不为0的就放到i这个位置，并把i往后移，最终不为0的都会放到i上，则后面的都是0</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func moveZeroes(nums []int) []int  &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; len(nums); j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[j] != <span class="number">0</span> &#123;</span><br><span class="line">            a := nums[i]</span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">            nums[j] = a</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python一行解法</p>
<p>匿名函数排序：lambda x:x==0，匿名函数，x是否==0，是的话，返回true，不是的话返回false</p>
<p>sort排序：key为false，ture， false在true前面，所以，不等于0的就排到了前面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def moveZeroes(self, <span class="attr">nums</span>: List[int]) -&gt; None:</span><br><span class="line">        nums.sort(key=lambda x:x==<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>系统工程与多媒体</title>
    <url>/2024/01/20/%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%A4%9A%E5%AA%92%E4%BD%93/</url>
    <content><![CDATA[<h3 id="计算机语言"><a href="#计算机语言" class="headerlink" title="计算机语言"></a>计算机语言</h3><p>计算机语言主要由一套指令组成，而这种指令一般包括表达式、流程控制和集合三大部分<br>内容</p>
<p>包括机器语言、汇编语言和高级语言</p>
<h4 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h4><p>机器语言指令必须包括:操作码、操作数的地址、操作结果的存储地址、下条指令的地址</p>
<p>三地址指令：这种指令格式通常包括两个操作数地址和一个结果地址。在三地址指令中，<br>第一个地址（A1）确定第一个操作数，第二个地址（A2）确定第二个操作数，第三个地址<br>（A3）则用于存储执行操作后的结果。执行完指令后，下一条指令的地址通常由程序计数<br>器按顺序给出。<br>二地址指令：这种指令格式只包括一个操作数地址和一个结果地址。第一个地址（A1）确<br>定第一个操作数，而第二个地址（A2）同时确定第二个操作数和结果。这类指令隐含了第<br>二操作数和结果的地址，所以其操作码部分通常较短<br>单地址指令：这类指令只包括一个操作数地址。操作数被存储在指定地址（A）中，而结果<br>则通常被隐含在特定的寄存器中。为了执行操作，需要使用一个指定的寄存器来存储第二<br>个操作数和操作结果。<br>四地址指令：这种指令格式包括四个地址码字段，分别为两个操作数地址和一个结果地址。<br>这种格式的操作码部分通常比较长，可以表示更多的操作类型。四地址指令的第一个地址<br>（A1）确定第一个操作数，第二个地址（A2）确定第二个操作数，第三个地址（A3）和第<br>四个地址（A4）用于存储执行操作后的结果</p>
<h4 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h4><p>汇编语言3种语句:指令、伪指令、宏指令</p>
<h4 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h4><p>高级语言可以分为面向过程、面向对象和泛型等类型</p>
<h3 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h3><p>媒体是承载信息的载体，即信息的表现形式(或者传播形式)，如文字、声音、图像、动画和视频等<br>媒体可分为感觉媒体、表示媒体、显示媒体、存储媒体和传输媒体</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>多媒体有4个重要的特征。<br>多维化、集成性、交互性、实时性</p>
<h4 id="多媒体技术"><a href="#多媒体技术" class="headerlink" title="多媒体技术"></a>多媒体技术</h4><p>视音频技术<br>通信技术：<br>是多媒体系统中的一项关键技术<br>1、即时压缩和非即时压缩。<br>2、数据压缩和文件压缩。<br>3、无损压缩与有损压缩。<br>虚拟现实 (VR) /增强现实 (AR) 技术</p>
<h3 id="系统工程"><a href="#系统工程" class="headerlink" title="系统工程"></a>系统工程</h3><p>系统工程是利用计算机作为工具，对系统的结构、元素、信息和反馈等进行分析，以达到最优规划、最优设计、最优管理和最优控制的目的</p>
<h4 id="霍尔的三维结构"><a href="#霍尔的三维结构" class="headerlink" title="霍尔的三维结构"></a>霍尔的三维结构</h4><p>霍尔三维结构是将系统工程整个活动过程分为前后紧密衔接的7 个阶段和7 个步骤</p>
<p>由时间维、逻辑维和知识维组成的三维空间结构</p>
<h4 id="切克兰德方法"><a href="#切克兰德方法" class="headerlink" title="切克兰德方法"></a>切克兰德方法</h4><p>社会经济系统中的问题往往很难和工程技术系统中的问题一样，事先将需求确定清楚，难以按价值系统的评价准则设计出符合这种需求的最优系统方案。<br>核心是比较与探寻<br>7个步骤：<br>1、认识问题。<br>2、根底定义<br>3、建立概念模型<br>4、比较及探寻<br>5、选择<br>6、设计与实施<br>7、评估与反馈</p>
<h4 id="并行工程方法"><a href="#并行工程方法" class="headerlink" title="并行工程方法"></a>并行工程方法</h4><p>是对产品及其相关过程进行并行、集成化处理的系统方法和综合技术</p>
<p>并行工程的目标是提高质量、降低成本、缩短产品开发周期和产品上市时间</p>
<p>并行工程核心点：<br>1、在产品的设计开发期间，将概念设计、结构设计、工艺设计、最终需求等结合起来，保证以最快<br>的速度按要求的质量完成。<br>2、各项工作由与此相关的项目小组完成。进程中小组成员各自安排自身的工作， 但可以随时或定期<br>反馈信息，并对出现的问题协调解决。<br>3、依据适当的信息系统工具，反馈与协调整个项目的进行。利用现代CIM 技术，在产品的研制与开<br>发期间，辅助项目进程的并行化</p>
<h4 id="综合集成法"><a href="#综合集成法" class="headerlink" title="综合集成法"></a>综合集成法</h4><p>是从整体上考虑并解决问题的方法论<br>一、整体论原则;<br>二、相互联系原则;<br>三、是有序性原则;<br>四、动态原则。<br>开放的复杂巨系统主要性质:开放性、复杂性、进化与涌现性、层次性、巨量性。</p>
<h4 id="WSR-物理-事理-人理）-系统方法"><a href="#WSR-物理-事理-人理）-系统方法" class="headerlink" title="WSR(物理-事理-人理） 系统方法"></a>WSR(物理-事理-人理） 系统方法</h4><p>WSR 是物理、事理和人理三者如何巧妙配置、有效利用以解决问题的一种系统方法论。<br>“懂物理、明事理、通人理”就是WSR 方法论的实践准则</p>
<h4 id="生命周期法"><a href="#生命周期法" class="headerlink" title="生命周期法"></a>生命周期法</h4><p>系统工程生命周期7阶段<br>1、探索性研究阶段:目的是识别利益攸关者的需求，探索创意和技术。<br>2、概念阶段:目的是细化利益攸关者的需求，探索可行概念，提出有望实现的解决方案<br>3、开发阶段:目的是细化系统需求，创建解决方案的描述，构建系统，验证并确认系统<br>4、生产阶段:目的是生产系统并进行检验和验证。<br>5、使用阶段:目的是运行系统以满足用户需求。<br>6、保障阶段:目的是提供持续的系统能力。<br>7、退役阶段:目的是存储、归档或退出系统<br>生命周期方法<br>(1)计划驱动方法<br>(2) 渐进迭代式开发<br>(3) 精益开发<br>(4)敏捷开发</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>系统性能评价</title>
    <url>/2024/01/21/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7/</url>
    <content><![CDATA[<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><h4 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h4><p>时钟频率，运算速度(数据处理速率)，运算精度，内存的存储容量，存储器的存储周期，数据处理速率PDR，吞吐率，各种响应时间</p>
<h4 id="路由器性能指标"><a href="#路由器性能指标" class="headerlink" title="路由器性能指标"></a>路由器性能指标</h4><p>设备吞吐量、端口吞吐量、丢包率、时延、时延抖动</p>
<p>全双工线速转发能力、背靠背帧数、路由表能力、背板能力等</p>
<h4 id="网络性能指标"><a href="#网络性能指标" class="headerlink" title="网络性能指标"></a>网络性能指标</h4><p>设备级性能指标、网络级性能指标、应用级性能指标、用户级性能指标</p>
<h4 id="操作系统的性能指标"><a href="#操作系统的性能指标" class="headerlink" title="操作系统的性能指标"></a>操作系统的性能指标</h4><p>系统的可靠性、系统的吞吐率(量)、系统响应时间、系统资源利用率、可移植性</p>
<h5 id="计算机可靠性模型"><a href="#计算机可靠性模型" class="headerlink" title="计算机可靠性模型"></a>计算机可靠性模型</h5><p>串联系统可靠性：R=R1xR2</p>
<p>并联系统可靠性：R= 1- (1-R1)(1-R2),[不可靠性：1-R]</p>
<h4 id="数据库系统的性能指标"><a href="#数据库系统的性能指标" class="headerlink" title="数据库系统的性能指标"></a>数据库系统的性能指标</h4><p>数据库的大小、数据库中表的数量、单个表的大小、表中允许的记录 (行)数量、单个记录(行) 的大小、表上所允许的索引数量、数据库所允许的索引数量、最大并发事务处理能力、负载均衡能力、最大连接数等</p>
<h4 id="web服务器的性能指标"><a href="#web服务器的性能指标" class="headerlink" title="web服务器的性能指标"></a>web服务器的性能指标</h4><p>最大并发连接数、响应延迟、吞吐量</p>
<h3 id="性能评价方法"><a href="#性能评价方法" class="headerlink" title="性能评价方法"></a>性能评价方法</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>时钟频率：主频越高，速度越快</p>
<p>指令执行速度：KIPS，MIPS</p>
<p>等效指令速度发：各类指令在程序中所占比例</p>
<p>数据处理速率PDR：PDR越大，性能越好</p>
<h4 id="基准测试程序"><a href="#基准测试程序" class="headerlink" title="基准测试程序"></a>基准测试程序</h4><p>把应用程序中应用最频繁的那部分核心程序作为评价计算机性能的标准程序</p>
<p>1、整数测试程序。</p>
<p>2、浮点测试程序。</p>
<p>3、SPEC 基准程序 (SPEC Benchmark) 。重点面向处理器性能的基准程序集将被测计算机的执行时间标准化，即将被测计算机的执行时间除以一个参考处理器的执行时间。</p>
<p>4、TPC 基准程序。用于评测计算机在事务处理、数据库处理、企业管理与决策支持系统等方面的性能。</p>
<p>TPC-C 是在线事务处理 (On-line TransactionProcessing，OLTP) 的基准程序，</p>
<p>TPC-D 是决策支持的基准程序。</p>
<p>TPC-E 作为大型企业信息服务的基准程序大多数情况下，为测试新系统的性能，用户必须依靠评价程序来评价机器的性能。</p>
<p>下面列出了4种评价程序，它们评测的准确程度依次递减: 真实的程序、核心程序、小型基准程序、合成基准程序</p>
<h3 id="阿姆达尔-Amdahl-定律"><a href="#阿姆达尔-Amdahl-定律" class="headerlink" title="阿姆达尔(Amdahl)定律"></a>阿姆达尔(Amdahl)定律</h3><p>主要用于系统性能改进的计算中。阿姆达尔定律是指计算机系统中对某一部件采用某种更快的执行方式所获得的系统性能改变程度取决于这种方式被使用的频率，或所占总执行时间的比例<br><img src="/2024/01/21/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7/1.jpg" alt="1"></p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>系统架构设计</title>
    <url>/2024/04/14/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h3><p>一个程序和计算系统软件体系结构是指系统的一个或者多个结构。结构中包括软件的构件，构件的外部可见属性以及它们之间的相互关系</p>
<p>软件架构指从需求分析到软件设计之间的过渡过程。只要软件架构设计好了，整个软件就不会出现坍塌性的错误，即不会崩溃</p>
<p>数据设计和体系结构设计。数据设计为软件体系结构设计提供了数据基础，而体系结构设计则为软件系统的整体结构提供了规划和设计</p>
<p>软件架构为软件系统提供了一个结构、行为和属性的高级抽象，由构件的描述、构件的相互作用(连接件)、指导构件集成的模式以及这些模式的约束组成</p>
<p>软件架构就是软件的总体设计方案，它决定了软件如何组织和工作，规定了软件系统的整体结构和各个部分之间的关系，以满足用户需求和业务目标。好的架构是构建可靠软件的基础</p>
<p>需求分析-架构设计-系统设计</p>
<p><strong>1、软件架构设计贯穿于软件开发生命周期的各个阶段</strong>，软件架构设计并非只在开发初期进行，而是贯穿于软件开发生命周期的各个阶段，包括需求分析、设计、实现、测试、部署和维护等</p>
<p><strong>2.</strong> <strong>需求分析阶段。</strong>需求分析和SA（架构）设计面临的是不同的对象：一个是问题空间；另一个是解空间。从软件需求模型向SA模型的转换主要关注两个问题：如何根据需求模型构建SA模型。如何保证模型转换的可追踪性。</p>
<p>简单来说，该阶段关注的是如何将用户需求转换为软件架构模型，并确保模型的可追踪性。</p>
<p><strong>3.</strong> <strong>设计阶段。</strong>是SA研究关注的最早和最多的阶段，这一阶段的SA研究主要包括：SA模型的描述、SA模型的设计与分析方法，以及对SA设计经验的总结与复用等。有关SA模型描述的研究分为3个层次：SA的基本概念(构件和连接件)、体系结构描述语言ADL、SA模型的多视图表示。</p>
<p>简单来说，该阶段关注的是软件架构模型的描述、设计与分析方法，以及设计经验的总结与复用。</p>
<p><strong>4.</strong> <strong>实现阶段。</strong>最初SA研究往往只关注较高层次的系统设计、描述和验证。为了有效实现SA设计向实现的转换，实现阶段的体系结构研究表现在对开发过程的支持、开发语言和构件的选择以及相关测试技术。</p>
<p>简单来说，该阶段关注的是如何将软件架构设计转换为代码，以及如何进行测试</p>
<p><strong>5.</strong> <strong>构件组装阶段。</strong>在SA设计模型的指导下，可复用构件的组装可以在较高层次上实现系统，并能够提高系统实现的效率。在构件组装的过程中，SA设计模型起到了系统蓝图的作用。</p>
<p>简单来说，该阶段关注的是如何在架构设计模型的指导下，进行可复用构件的组装，提高系统实现效率，并解决组装过程中的相关问题。</p>
<p><strong>6.</strong> <strong>部署阶段。</strong>提供高层的体系结构视图来描述部署阶段的软硬件模型，以及基于SA模型可以分析部署方案的质量属性，从而选择合理的部署方案。</p>
<p>简单来说，该阶段关注的是如何根据软件架构模型进行部署，并分析部署方案的质量属性。</p>
<p><strong>7.</strong> <strong>后开发阶段。</strong>是指软件部署安装之后的阶段。这一阶段的SA研究主要围绕维护、演化、复用等方面来进行。典型的研究方向包括动态软件体系结构、体系结构恢复与重建等。</p>
<p>简单来说，该阶段关注的是如何根据软件架构模型进行维护和演化</p>
<h3 id="构件"><a href="#构件" class="headerlink" title="构件"></a>构件</h3><p>构件(Component)是指系统的重要部分，它们是功能上独立且可以被替代或扩展的模块或单元，外界通过接口访问其提供的服务</p>
<p>这些构件代表了系统中的不同功能区域，每个构件都可以独立开发、测试和维护。它们通过明确定义的接口和通信方式相互连接，以协同工作来实现整个电子商务网站的功能。</p>
<p>可以独立部署，没有外部的可见状态，不可拆分</p>
<p>类：类是面向对象编程中的基本概念，它描述了一种对象的属性和行为。类定义了对象的结构和行为模板，它可以包括属性(数据成员)和方法(函数成员)。类用于创建对象，对象是类的实例</p>
<p>模块：模块是一组相关的函数、类、变量或代码块的集合，模块用于划分代码，将相关功能或类放在一个地方，以便更好地组织和维护代码。它还可以支持代码的复用和封装</p>
<p>构件：是指软件系统中的可复用组件。构件可以是代码、数据、文档或其他任何类型的软件资产。构件通常是松散耦合的，并且可以组合起来形成更大的软件系统。构件的典型示例包括类、模块、组件和框架</p>
<p>服务：是指提供特定功能的软件单元。服务通常是独立的、可复用的，并且可以通过网络进行访问。服务的典型示例包括 Web服务、REST API 和微服务</p>
<p><strong>服务和构件之间的主要区别如下：</strong></p>
<p>服务侧重于功能，而构件侧重于结构。 服务提供特定的功能，而构件是软件系统的组成部分。</p>
<p>服务通常是独立的和可访问的，而构件通常是松散耦合的和可复用的。 服务可以独立运行并通过网络进行访问，而构件可以组合起来形成更大的软件系统。</p>
<p>服务通常用于面向服务的架构 (SOA)，而构件通常用于组件化开发。 SOA 是一种将软件系统构建为松散耦合的服务的架构风格。组件化开发是一种将软件系统构建为可复用构件的方法。</p>
<p>构件技术就是利用某种编程手段，将一些人们所关心的，但又不便于让最终用户去直接操作的细节进行了封装，同时对各种业务逻辑规则进行了实现，用于处理用户的内部操作细节。</p>
<p>目前，国际上常用的构件标准主要有三大流派。</p>
<p>EJB(Enterprise Java Bean)规范由Sun公司制定，有三种类型的EJB：</p>
<p>• 会话Bean(Session Bean)：用于管理会话和业务逻辑，有不同的类型适应不同的需求</p>
<p>• 实体Bean(Entity Bean)：用于与持久化数据交互，将对象映射到数据库表。</p>
<p>• 消息驱动Bean(Message-driven Bean)：用于异步消息处理，响应来自消息队列的消息</p>
<p> COM、DCOM、COM+：COM是微软公司的。DCOM是COM的进一步扩展，具有位置独立性和语言无关性。COM+并不是COM的新版本，是COM的新发展或是更高层次的应用：</p>
<p> CORBA标准主要分为三个层次：对象请求代理、公共对象服务和公共设施</p>
<p>• 最底层是对象请求代理ORB,规定了分布对象的定义(接口)和语言映射，实现对象间的通讯和互操作，是分布对象系统中的“软总线”; </p>
<p>• 在ORB之上定义了很多公共服务，可以提供诸如并发服务、名字服务、事务(交易)服务、安全服务等各种各样的服务；</p>
<p>• 最上层的公共设施则定义了组件框架，提供可直接为业务对象使用的服务，规定业务对象有效协作所需的协定规则。</p>
<p>EJB和COM+较为适用于应用服务器</p>
<h3 id="软件架构风格"><a href="#软件架构风格" class="headerlink" title="软件架构风格"></a>软件架构风格</h3><p>是描述某一特定应用领域中系统组织方式的<strong>惯用模式</strong>。架构风格定义一个系统家族，即一个<strong>架构定义</strong>、一个<strong>词汇表</strong>和一组<strong>约束</strong>。架构定义描述了系统的整体结构和组织方式。词汇表中包含一些构件和连接件类型，而这组约束指出系统是如何将这些构件和连接件组合起来的。</p>
<p>简单来说，软件体系结构风格就是一个模板，它规定了特定应用领域中软件系统应该如何构建</p>
<p>软件架构风格的作用：反映了领域中众多系统所<strong>共有的结构</strong>和<strong>语义特性</strong>，并指导如何将各个模块和子系统有效地组织成一个完整的系统</p>
<p>架构设计的一个核心问题是能否达到架构级的软件复用，强调对架构设计的重用。</p>
<p>架构风格定义了用于描述系统的术语表和一组指导构建系统的规则</p>
<h4 id="数据流风格"><a href="#数据流风格" class="headerlink" title="数据流风格"></a>数据流风格</h4><p>面向数据流，按照<strong>一定的顺序从前向后执行程序</strong>，代表的风格有批处理序列、管道-过滤器</p>
<p>批处理序列：构件为一系列固定顺序的计算单元，多件事情<strong>同步顺序</strong>执行，构件之间<strong>只通过数据传递交互</strong>。每个处理步骤是一个独立的程序，<strong>每一步必须在其前一步结束后才能开始</strong>，<strong>数据必须是完整的</strong>，<strong>以整体的方式传递</strong>。比如批量图像处理：一次性处理大量图像，例如调整大小、添加水印或转换格式。</p>
<p>管道-过滤器：每个构件都有一组输入和输出，构件读取输入的数据流，经过内部处理，产生输出数据流。<strong>前一个构件的输出作为后一个构件的输入</strong>，前后数据流关联。过滤器就是构件，连接件就是管道。比如文本处理管道：在文本分析中，可以将文本处理划分为分词、词干提取、情感分析等多个阶段，每个阶段是一个过滤器</p>
<p><strong>早期编译器</strong>就是采用的这种架构，要一步一步处理的，均可考虑此架构风格。</p>
<p>二者区别：</p>
<p>批处理风格通常一次性处理大量数据，离线执行，适用于批量处理任务。</p>
<p>管道过滤器风格将任务分解为多个阶段，每个阶段逐个处理数据，通常是实时或近实时执行，适用于可组合和可扩展的任务。</p>
<h4 id="调用返回风格"><a href="#调用返回风格" class="headerlink" title="调用返回风格"></a>调用返回风格</h4><p>构件之间存在<strong>互相调用</strong>的关系，一般是显式的调用，代表的风格有主程序/子程序、面向对象、层次结构、客户端服务器</p>
<p>主程序/子程序：单线程控制，把问题划分为若干个处理步骤，构件即为主程序和子程序，子程序通常可合成为模块。过程调用作为交互机制，充当连接件的角色</p>
<p>面向对象：构件是对象，对象是抽象数据类型的实例。连接件即使对象间交互的方式，对象是通过函数和过程的调用来交互的。</p>
<p>层次结构：构件组成一个层次结构，连接件通过决定层间如何交互的协议来定义。每层为上一层提供服务，使用下一层的服务，只能见到与自己邻接的层。修改某一层，最多影响其相邻的两层(通常只能影响上层)。</p>
<p>优点是可以将一个复杂问题分解成一个增量步骤序列的实现。</p>
<p>缺点是并不是每个系统都可以很容易的划分为分层的模式，并且因为进行层次调用，会影响效率。</p>
<p>客户端服务器(C/S)：早期是两层C/S架构模式，由三个部分组成：数据库服务器、客户端服务器和网络，其中服务器负责数据管理，客户端完成用户交互，称之为“胖客户机，瘦服务器”，后期又增加了一个应用服务器，称之为三层C/S架构,分别是表示层、功能层和数据层，表示层就是用户交互、功能层就是业务逻辑处理、数据层就是数据库处理，以上三层独立</p>
<h4 id="独立构件风格"><a href="#独立构件风格" class="headerlink" title="独立构件风格"></a>独立构件风格</h4><p>构件之间是<strong>互相独立</strong>的，不存在显式的调用关系，而是通过某个事件触发、异步的方式来执行，代表的风格有进程通信、事件驱动系统(隐式调用)</p>
<p>进程通信：构件是独立的<strong>进程</strong>，连接件是<strong>消息传递</strong>。构件通常是命名过程，消息传递的方式可以是点对点、异步或同步方式，以及远程过程(方法)调用等。进程通信涉及不同的进程或线程之间的通信和数据共享。这些进程可以运行在同一台计算机上，也可以分布在不同的计算机上。</p>
<p>事件驱动系统(隐式调用)：构件不直接调用一个过程，而是触发或广播一个或多个事件。构件中的过程在一个或多个事件中注册，当某个事件被触发时，系统自动调用在这个事件中注册的所有过程。</p>
<p>主要优点是为软件复用提供了强大的支持，为构件的维护和演化带来了方便；</p>
<p>缺点是构件放弃了对系统计算的控制，只能被动的控制</p>
<h4 id="虚拟机风格"><a href="#虚拟机风格" class="headerlink" title="虚拟机风格"></a>虚拟机风格</h4><p>自定义了一套新规则供使用者使用，使用者基于这个规则来开发构件，能够跨平台适配，代表的风格有解释器、基于规则的系统</p>
<p>解释器：通常包括一个完成解释工作的解释引擎、一个包含将被解释的代码的存储区、一个记录解释引擎当前工作状态的数据结构，以及一个记录源代码被解释执行的进度的数据结构。涉及解析和执行一系列指令或命令，通常通过解释器来实现。解释器将文本或代码解析成可执行的操作。缺点是执行效率低</p>
<p>基于规则的系统：包括规则集、规则解释器、规则/数据选择器和工作内存，一般用在人工智能领域和DSS(决策支持系统)中。适用于根据一组事先定义的规则或条件来控制系统的行为。这种风格通常用于实现灵活的业务规则和决策逻辑。</p>
<h4 id="以数据为中心风格"><a href="#以数据为中心风格" class="headerlink" title="以数据为中心风格"></a>以数据为中心风格</h4><p>以数据为中心，所有的操作都是围绕建立的数据中心进行的，代表的风格有数据库系统、仓库系统、黑板系统</p>
<p>仓库风格的架构将数据存储在一个中央仓库或数据库中，各个组件可以从仓库中读取和写入数据。组件之间通过共享数据仓库进行通信和协作。</p>
<p>仓库超文本：网状连接，多用于互联网</p>
<p>黑板风格的架构类似于一个黑板或公告板，多个独立的组件称为”专家”共享一个公共存储区(黑板)，它们可以读取和写入数据。专家根据黑板上的信息进行推断和决策，适用于解决复杂的非结构化问题。</p>
<p>总之，仓库风格强调数据的集中存储和共享，组件通过访问共享的仓库来交互。</p>
<p>而黑板风格侧重于多个独立的组件共享一个中央知识存储区，根据共享的信息进行推断和决策。</p>
<p>这两种风格在处理复杂问题和协作方面都具有一定的优势。</p>
<h4 id="闭环控制"><a href="#闭环控制" class="headerlink" title="闭环控制"></a>闭环控制</h4><p>当软件被用来操作一个物理系统时，软件与硬件之间可以粗略的表示为一个反馈循环，这个反馈循环通过接受一定的输入，确定一系列的输出，最终使环境达到一个新的状态，适合于嵌入式系统，涉及连续的动作与状态。</p>
<h4 id="C2风格"><a href="#C2风格" class="headerlink" title="C2风格"></a>C2风格</h4><p>通过连接件绑定在一起的按照一组规则运作的并行构件网络。C2风格中的系统组织规则如下：</p>
<p>系统中的构件和连接件都有一个顶部和一个底部；</p>
<p>构件的顶部应连接到某连接件的底部，构件的底部则应连接到某连接件的顶部，而构件与构件之间的直接连接是不允许的；</p>
<p>一个连接件可以和任意数目的其它构件和连接件连接；</p>
<p>当两个连接件进行直接连接时，必须由其中一个的底部到另一个的顶部。</p>
<p>构件中间要有连接件</p>
<h3 id="软件架构复用"><a href="#软件架构复用" class="headerlink" title="软件架构复用"></a>软件架构复用</h3><p>软件产品线是指一组（<strong>多个</strong>）软件密集型系统，它们共享一个公共的、可管理的特性集，满足某个特定市场或任务的具体需要，是以规定的方式用公共的核心资产集成开发出来的。即围绕核心资产库进行管理、复用、集成新的系统</p>
<p>软件架构复用根据复用的时机包括机会复用和系统复用。</p>
<p>机会复用是指开发过程中，只要发现有可复用的资产，就对其进行复用。</p>
<p>系统复用是指在开发之前，就要进行规划，以决定哪些需要复用</p>
<p>复用的基本过程主要包括3个阶段：</p>
<p>首先构造/获取可复用的软件资产，</p>
<p>其次管理这些资产(把它们放入到构件库)，</p>
<p>最后针对特定的需求，从这些资产中选择可复用的部分，以开发满足需求的应用系统</p>
<h3 id="特定领域软件架构（DSSA）"><a href="#特定领域软件架构（DSSA）" class="headerlink" title="特定领域软件架构（DSSA）"></a>特定领域软件架构（DSSA）</h3><p>DSSA就是专用于一类特定类型的任务(领域)的、在整个领域中能有效地使用的、为成功构造应用系统限定了标准的组合结构的软件构件的集合。它旨在满足该领域的独特需求和约束</p>
<p>DSSA就是一个特定的问题领域中支持一组应用的领域模型、参考需求、参考架构等组成的开发基础，其目标就是支持在一个特定领域中多个应用的生成</p>
<p><strong>垂直域：</strong>在一个特定领域中的通用的软件架构，是一个完整的架构</p>
<p><strong>水平域</strong>：在多个不同的特定领域之间的相同的部分的小工具</p>
<p>DSSA的三个基本活动：领域分析、领域设计和领域实现</p>
<p>领域分析：这个阶段的主要目标是获得领域模型**(领域需求)**，在此基础上就可以分析领域中系统的需求，确定哪些需求是领域中的系统广泛共享的，从而建立领域模型</p>
<p>领域设计：这个阶段的目标是获得DSSA</p>
<p>领域实现：这个阶段的主要目标是依据领域模型和DSSA开发和组织可重用信息</p>
<p>领域分析用于确定需求，领域设计用于提供通用架构，而领域实现用于将该架构转化为具体的应用程序模块。这个过程有助于确保系统能够满足特定领域的需求，并具备可维护和可重用的特性</p>
<p>DSSA的四种角色：领域专家、领域分析人员、领域设计人员和领域实现人员</p>
<p>三层次模型：领域开发环境、领域特定的应用开发环境、应用执行环境</p>
<h3 id="基于架构的软件开发（ABSD）"><a href="#基于架构的软件开发（ABSD）" class="headerlink" title="基于架构的软件开发（ABSD）"></a>基于架构的软件开发（ABSD）</h3><p>基于架构的软件开发(Architecturally Based Software Development，ABSD)是一种软件开发方法，强调在开发过程中首先定义系统的体系结构，然后根据这个体系结构来实现系统。它有助于确保系统的结构和设计与业务需求保持一致</p>
<p>ABSD方法是架构驱动，强调由<strong>业务、质量和功能需求的组合驱动架构设计</strong>。它强调采用<strong>视角</strong>和<strong>视图</strong>来描述软件架构，用例描述的是功能需求，质量（属性）<strong>场景</strong>描述的是质量需求(或侧重于非功能需求)</p>
<p>ABSD方法有三个基础。</p>
<p>第一个基础是功能的分解，使用已有的基于模块的内聚和耦合技术;</p>
<p>第二个基础是通过选择架构风格来实现质量和业务需求;</p>
<p>第三个基础是软件模板的使用，软</p>
<p>件模板利用了一些软件系统的结构进行复用。</p>
<p>ABSD方法是递归的，且迭代的每一个步骤都是清晰定义的。因此，不管设计是否完成，架构总是清晰的，有助于降低架构设计的随意性。</p>
<p>ABSD六步：</p>
<p>  1 . 架构需求：重在掌握标识构件的三步，生成类图，对类进行分组，把类打包成构件</p>
<ol start="2">
<li>架构设计：将需求阶段的标识构件映射成构件</li>
<li>架构(体系结构)文档化：主要产出两种文档，即架构(体系结构)规格说明，测试架构(体系结构)需求的质量设计说明书。文档是至关重要的，是所有人员通信的手段，关系开发的成败</li>
<li>架构复审：由外部人员(独立于开发组织之外的人，如用户代表和领域专家等)参加的复审，复审架构是否满足需求，质量问题，构件划分合理性等。若复审不过，则返回架构设计阶段进行重新设计、文档化，再复审</li>
<li>架构实现：用实体来显示出架构。实现构件，构件组装成系统</li>
<li>架构演化：对架构进行改变，按需求增删构件，使架构可<strong>复用</strong></li>
</ol>
<h3 id="层次架构风格"><a href="#层次架构风格" class="headerlink" title="层次架构风格"></a>层次架构风格</h3><h4 id="两层C-S架构"><a href="#两层C-S架构" class="headerlink" title="两层C/S架构"></a>两层C/S架构</h4><p>开发成本较高、客户端程序设计复杂、信息内容和形式单一、用户界面风格不一、软件移植困难、软件维护和升级困难、新技术不能轻易应用、安全性问题、服务器端压力大难以复用</p>
<h4 id="三层C-S架构"><a href="#三层C-S架构" class="headerlink" title="三层C/S架构"></a>三层C/S架构</h4><p>将处理功能独立出来，<strong>表示层和数据层</strong>都变得简单。表示层在客户机上，<strong>功能层</strong>在应用服务器上，数据层在数据库服务器上</p>
<h4 id="三层B-S架构"><a href="#三层B-S架构" class="headerlink" title="三层B/S架构"></a>三层B/S架构</h4><p>是三层C/S架构的变种，将客户端变为用户客户端上的浏览器，将应用服务器变为网络上的WEB服务器，又称为0客户端架构</p>
<h4 id="富互联网应用RIA"><a href="#富互联网应用RIA" class="headerlink" title="富互联网应用RIA"></a>富互联网应用RIA</h4><p>弥补三层B/S架构存在的问题，RIA是一种用户接口，比用HTML实现的接口更加健壮，且有可视化内容，本质还是网站模式，其优点如下：</p>
<p>RIA结合了C/S架构反应速度快、交互性强的优点与B/S架构传播范围广及容易传播的特性；</p>
<p>RIA简化并改进了B/S架构的用户交互；</p>
<p>数据能够被缓存在客户端，从而可以实现一个比基于HTML的响应速度更快且数据往返于服务器的次数更少的用户界面。</p>
<p>本质还是0客户端，借助于高速网速实现必要插件在本地的快速缓存，增强页面对动态页面的支持能力，典型的如小程序</p>
<h4 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h4><p>控制器(Controller) ：是应用程序中处理用户交互的部分</p>
<p>模型(Model)：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。模型表示业务数据和业务逻辑。</p>
<p>视图(View)：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。是用户看到并与之交互的界面。</p>
<h4 id="MVP架构"><a href="#MVP架构" class="headerlink" title="MVP架构"></a>MVP架构</h4><p>MVP是把MVC中的Controller换成了Presenter(呈现)，目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离</p>
<p>MVP特点：</p>
<p>M、V、P之间双向通信。</p>
<p>View 与Model不通信，都通过Presenter传递。Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。</p>
<p>View非常薄，不部署任何业务逻辑，称为”被动视图”(PassiveView)，即没有任何主动性，而Presenter非常厚，所有逻辑都部署在那里。</p>
<p>Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。</p>
<h4 id="MVVM架构"><a href="#MVVM架构" class="headerlink" title="MVVM架构"></a>MVVM架构</h4><p>MVVM模式和MVC模式类似，主要目的是分离视图(View)和模型(Model)，实现双向绑定，有几大优点：</p>
<p>低耦合，视图(vView)可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p>
<p>可重用性，可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p>
<p>独立开发，开发人员可以专注于业务逻辑和数据的开发(ViewModel) ，设计人员可以专注于页面设计。</p>
<p>可测试，界面向来是比较难于测试的，而现在测试可以针对ViewModel来写。</p>
<h3 id="面向服务的架构风格（SOA）"><a href="#面向服务的架构风格（SOA）" class="headerlink" title="面向服务的架构风格（SOA）"></a>面向服务的架构风格（SOA）</h3><p>SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通信，不涉及底层编程接口和通信模型</p>
<p>服务是一种为了满足某项业务需求的操作、规则等的逻辑组合，它包含一系列有序活动的交互，为实现用户目标提供支持。</p>
<p>实施SOA的关键目标是实现企业IT资产重用的最大化，在实施SOA过程中要牢记以下特征：可从企业外部访问、随时可用(服务请求能被及时响应)、粗粒度接口(粗粒度提供一项特定的业务功能，而细粒度服务代表了技术构件方法)、服务分级、松散耦合(服务提供者和服务使用者分离)、可重用的服务及服务接口设计管理、标准化的接口(WSDL、SOAP、XML是核心)、支持各种消息模式、精确定义的服务接口</p>
<p>从基于对象到基于构件再到基于服务，架构越来越松散耦合，粒度越来越粗，接口越来越标准</p>
<p>关键技术：</p>
<p>UDDI：用于WEB服务注册统一描述、发现，查找。</p>
<p>WSDL (Web Service描述语言)∶将Web服务描述定义为一组服务访问点，用于描述服务</p>
<p>SOAP(简单对象访问协议)：用于传递信息。</p>
<p>XML (可扩展标记语言)︰是WebService平台中表示数据的基本格式，用于数据交换</p>
<p>BPEL：将多个服务组合成一个新的复合服务</p>
<p>SOA的三种实现方式：WEB Service、服务注册表和企业服务总线ESB</p>
<p>WEB Service<strong>：</strong>服务提供者、服务注册中心(中介，提供交易平台，可有可无)、服务请求者</p>
<p>企业服务总线ESB：简单来说是一根管道，用来连接各个服务节点。</p>
<p>ESB的存在是为了集成基于不同协议的不同服务，ESB做了消息的转化、解释以及路由的工作，以此来让不同的服务互联互通。</p>
<p>包括：客户端(服务请求者)、基础架构服务(中间件)、核心集成服务(提供服务)。</p>
<p>ESB特点：</p>
<p> SOA的一种实现方式，ESB在面向服务的架构中起到的是总线作用，将各种服务进行连接与整合;</p>
<p>描述服务的元数据和服务注册管理;</p>
<p>在服务请求者和提供者之间传递数据，以及对这些数据进行转换的能力，并支持由实践中总结出来的一些模式如同步模式、异步模式等;</p>
<p>发现、路由、匹配和选择的能力，以支持服务之间的动态交互，解耦服务请求者和服务提供者。高级一些的能力，包括对安全的支持、服务质量保证、可管理性和负载平衡等</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>系统测试</title>
    <url>/2024/03/11/%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>系统测试：为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试</p>
<h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><h3 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h3><p>指被测试程序不在机器上运行，而采用人工检测和计算机辅助静态分析的手段对程序进行检测，包括对文档的静态测试和对代码的静态测试。包括桌前检查、代码审查、代码走查的方式。使用这种方法能够有效地发现30%-70%的逻辑设计和编码错误</p>
<p>静态分析五个阶段：</p>
<p>1、控制流分析：找出并突出显示那些带有多重入口和出口的循环以及不可达的代码片段</p>
<p>2、数据使用分析：突出程序中的变量使用情况</p>
<p>3、接口分析：检查子程序过程说明和他们的使用的一致性</p>
<p>4、信息流分析：找出输入变量和输出变量的一致性关系</p>
<p>5、路径分析：找出程序中所有可能的路径，并画出此路径的执行语句</p>
<h3 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h3><p>指在计算机上实际运行程序进行软件测试，一般采用白盒测试和黑盒测试方法(还有灰盒和自动化)</p>
<h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><p>黑盒测试关注于测试软件的功能(功能性测试)，而不考虑内部实现细节。测试人员不需要知道代码的具体结构，而是根据软件的需求规格和功能来设计测试用例</p>
<h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>白盒测试关注于测试软件的内部逻辑和代码结构(结构性测试)，以确保代码按照预期方式执行。测试人员需要了解软件的代码，以设计测试用例，以覆盖不同的代码路径和分支情况，以及验证代码是否满足质量标准和最佳实践</p>
<h2 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>也称为模块测试，测试的对象是可独立编译或汇编的程序模块、软件构件或OO软件中的类(统称为模块),测试依据是软件详细设计说明书。</p>
<p>驱动模块用来模拟被测试模块的上一级模块，相当于被测模块的主程序</p>
<p>桩模块（sub）指模拟被测模块所调用的模块，不是产品软件的组成部分</p>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>目的是检查模块之间，以及模块和已集成的软件之间的接口关系，并验证已集成的软件是否符合设计要求。测试依据是软件概要设计文档</p>
<h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><p>测试对象是完整的、集成的计算机系统；测试的目的是在真实系统工作环境下，验证完成的软件配置项能否和系统正确连接，并满足系统/子系统设计文档和软件开发合同规定的要求。测试依据是用户需求或开发合同。主要内容包括功能测试、健壮性测试、性能测试、用户界面测试、安全性测试、安装与反安装测试等，其中，最重要的工作是进行功能测试与性能测试。</p>
<p>功能测试主要采用黑盒测试方法；性能测试主要指标有响应时间、吞吐量、并发用户数和资源利用率等。系统测试通常由独立的测试团队执行，他们并不直接参与软件的开发过程</p>
<p>安全测试：检测系统的安全机制和保密措施是否完善，检测系统的防范能力</p>
<p>可靠性测试：平均失效时间MTBF是否超过规定时限，故障停机时间MTTR在一年中不应超过多少时间</p>
<p>恢复测试：检测系统的容错能力</p>
<p>性能测试：满足系统设计方案说明书对系统的性能要求</p>
<p>强度测试：是在系统资源特别低的情况下考查软件系统的极限运行情况</p>
<p>负载测试：用于测试超负荷环境中程序是否能够承担，确定在各种工作负载下系统的性能，测试当负载逐渐增加的时候，系统各项性能指标的变化</p>
<p>压力测试：通过确定系统的瓶颈或不能接收的性能点，来获得系统能够提供的最大服务级别测试，可以和负载测试结合进行</p>
<p>容量测试：并发测试，主要用于测试系统可同时处理的在线最大用户数量</p>
<h3 id="确认测试"><a href="#确认测试" class="headerlink" title="确认测试"></a>确认测试</h3><p>主要用于验证软件的功能、性能和其他特性是否与用户需求一致。测试依据是需求文档，确认测试是软件或产品开发的最后一个阶段，在系统测试完成后进行。它的主要目标是确保软件或产品已经满足最终用户的期望和需求。在确认测试中，最终用户（或其代表）将根据他们的实际使用情境，验证软件是否符合他们的业务流程和预期目标根据用户的参与程度，通常包括以下类型：</p>
<p>内部确认测试：主要由软件开发组织内部按照SRS进行测试。</p>
<p>Alpha测试：用户在开发环境下进行测试。</p>
<p>Beta测试：用户在实际使用环境下进行测试，通过改测试后，产品才能交付用户。</p>
<p>验收测试：针对SRS,在交付前以用户为主进行的测试。其测试对象为完整的、集成的计算机系统。验收测试的目的是，在真实的用户工作环境下，检验软件系统是否满足开发技术合同或SRS。验收测试的结论是用户确定是否接收该软件的主要依据。除应满足一般测试的准入条件外，在进行验收测试之前，应确认被测软件系统已通过系统测试。</p>
<h3 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h3><p>测试目的是测试软件变更之后，变更部分的正确性和对变更需求的符合性，以及软件原有的、正确的功能、性能和其他规定的要求的不损害性(不能把其他好的模块改错)</p>
<h2 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h2><h3 id="黑盒测试用例"><a href="#黑盒测试用例" class="headerlink" title="黑盒测试用例"></a>黑盒测试用例</h3><p>将程序看做一个黑盒子，只知道输入输出，不知道内部代码，由此设计出测试用例，分为下面几类：</p>
<p>等价类划分：通过将输入值分成不同的类别，从而减少测试用例的数量，同时确保测试覆盖各种可能的情况。这样可以更高效地测试软件，而不必为每个可能的输入值都编写一个测试用例。会分为有效等价类和无效等价类，都要设计测试用例</p>
<p>边界值划分：将每类的边界值作为测试用例，边界值一般为范围的两端值以及在此范围之外的与此范围间隔最小的两个值</p>
<p>错误推测：没有固定的方法，凭经验而言，来推测有可能产生问题的地方，作为测试用例进行测试。</p>
<p>因果图：由一个结果来反推原因的方法，具体结果具体分析，没有固定方法</p>
<h3 id="白盒测试用例"><a href="#白盒测试用例" class="headerlink" title="白盒测试用例"></a>白盒测试用例</h3><p>知道程序的代码逻辑，按照程序的代码语句，来设计覆盖代码分支的测试用例，覆盖级别从低至高分为下面几种：</p>
<p>语句覆盖SC:逻辑代码中的所有语句都要被执行一遍，覆盖层级最低，因为执行了所有的语句，不代表执行了所有的条件判断</p>
<p>判定覆盖DC:逻辑代码中的所有判断语句的条件的真假分支都要覆盖一次</p>
<p>条件覆盖CC: 针对每一个判断条件内（if）的每一个独立条件内都要执行一遍真假</p>
<p>条件判定组合覆盖CDC：同时满足判定覆盖和条件覆盖</p>
<p>路径覆盖：逻辑代码中的所有可行路径都覆盖了，覆盖层级最高</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>测试是发现错误，调试是找出错误的代码和原因</p>
<p>调试需要确定错误的准确位置；确定问题的原因并设法改正；改正后要进行回归测试。</p>
<p>调试的方法有：蛮力法、回溯法(从出错的地方开始，向回找)、原因排除法(找出所有可能的原因，逐一进行排除)。</p>
<p>软件的两种属性：外部属性指面向管理者和用户的属性，可直接测量，一般为性能指标。内部属性指软件产品本身的的属性，如可靠性等，只能间接测量。</p>
<p>McCabe度量法：又称为环路复杂度，假设有向图中有向边数为m,节点数为n,则此有向图的环路复杂度为m-n+2.</p>
<p>注意m和n代表的含义不能混淆，可以用一个最简单的环路来做特殊值记忆此公式，另外，针对一个程序流程图，每一个分支边(连线)就是一条有向边，每一条语句(语句框)就是一个顶点。</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>系统维护，净室工程</title>
    <url>/2024/04/12/%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4%EF%BC%8C%E5%87%80%E5%AE%A4%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="系统维护"><a href="#系统维护" class="headerlink" title="系统维护"></a>系统维护</h3><p>系统维护是整个系统开发过程中耗时最长的，系统的可维护性可以定义为维护人员理解、改正、改动和改进这个软件的难易程度，其评价指标如下：</p>
<p>易分析性：软件产品诊断软件中的缺陷或失效原因或识别待修改部分的能力。</p>
<p>易改变性：软件产品使指定的修改可以被实现的能力，实现包括编码、设计和文档的更改。</p>
<p>稳定性：软件产品避免由于软件修改而造成意外结果的能力。</p>
<p>易测试性：软件产品使已修改软件能被确认的能力。</p>
<p>系统维护包括硬件维护、软件维护和数据维护，其中软件维护类型如下：</p>
<p>正确性维护：发现了bug而进行的修改。</p>
<p>适应性维护：由于外部环境发生了改变，被动进行的对软件的修改和升级。</p>
<p>完善性维护：基于用户主动对软件提出更多的需求，修改软件，增加更多的功能，使其比之前的软件功能、性能更高，更加完善。</p>
<p>预防性维护：对未来可能发生的问题进行预防性的修改。</p>
<h4 id="遗留系统"><a href="#遗留系统" class="headerlink" title="遗留系统"></a>遗留系统</h4><p>是指任何基本上不能进行修改和演化以满足新的变化了的业务需求的信息系统</p>
<p>高水平低价值：集成</p>
<p>高水平高价值：改造</p>
<p>低水平低价值：淘汰</p>
<p>低水平高价值：继承</p>
<h4 id="系统转换"><a href="#系统转换" class="headerlink" title="系统转换"></a>系统转换</h4><p>是指新系统开发完毕，投入运行，取代现有系统的过程，有下面三种转换计划：</p>
<p>直接转换：现有系统被新系统直接取代了，风险很大，适用于新系统不复杂，或者现有系统已经不能使用的情况。优点是节省成本，只适合小系统</p>
<p>并行转换：新系统和老系统并行工作一段时间，新系统经过试运行后再取代，若新系统在试运行过程中有问题，也不影响现有系统的运行，风险极小，在试运行过程中还可以比较新老系统的性能，适用于大型系统。缺点是耗费人力和时间资源，难以控制两个系统间的数据转换。</p>
<p>分段转换：分期分批逐步转换，是直接和并行转换的集合，将大型系统分为多个子系统，依次试运行每个子系统，成熟一个子系统，就转换一个子系统。同样适用于大型项目，只是更耗时，而且现有系统和新系统间混合使用，需要协调好接口等问题。</p>
<h4 id="数据转换与迁移"><a href="#数据转换与迁移" class="headerlink" title="数据转换与迁移"></a>数据转换与迁移</h4><p>系统切换前通过工具迁移、系统切换前采用手工录入、系统切换后通过新系统生成</p>
<h3 id="净室软件工程（CSE）"><a href="#净室软件工程（CSE）" class="headerlink" title="净室软件工程（CSE）"></a>净室软件工程（CSE）</h3><p>一种应用数学与统计学理论以经济的方式生产高质量软件的工程技术，力图通过严格的工程化的软件过程达到开发中的零缺陷或接近零缺陷，强调的是预防大于检查。净室方法不是先制作一个产品，再去消除缺陷，而是要求在规约和设计中消除错误，然后以“净”的方式制作，可以降低软件开发中的风险，以合理的成本开发出高质量的软件</p>
<p>在净室软件工程背后的哲学是：通过在第1次正确地书写代码增量，并在测试前验证它们的正确性，来避免对成本很高的错误消除过程的依赖。它的过程模型是在代码增量积聚到系统的过程的同时，进行代码增量的统计质量验证。它甚至提倡开发者不需要进行单元测试，而是进行正确性验证和统计质量控制。</p>
<p>净室软件工程(CSE)的理论基础主要是函数理论和抽样理论。</p>
<p>净室软件工程应用技术手段：</p>
<p> 统计过程控制下的增量式开发。</p>
<p>基于函数的规范与设计。</p>
<p>正确性验证（CSE的核心）</p>
<p>统计测试和软件认证。</p>
<p>净室软件工程在使用过程的一些缺点：</p>
<p>CSE太理论化，需要更多的数学知识。其正确性验证的步骤比较困难且比较耗时。</p>
<p>CSE开发小组不进行传统的模块测试，这是不现实的。</p>
<p>CSE也会带有传统软件工程的一些弊端</p>
<h3 id="基于构件的软件工程（CBES）"><a href="#基于构件的软件工程（CBES）" class="headerlink" title="基于构件的软件工程（CBES）"></a>基于构件的软件工程（CBES）</h3><p>一种基于分布对象技术、强调通过可复用构件设计与构造软件系统的软件复用途径。CBSE体现了“购买而不是重新构造”的哲学，将软件开发的重点从程序编写转移到了基于己有构件的组装。用于CBSE的构件应该具备以下特征：</p>
<p>可组装型</p>
<p>可部署性</p>
<p>文档化</p>
<p>独立性</p>
<p>标准化</p>
<p>CBSE过程是支持基于构件组装的软件开发过程，过程中的6个主要活动：系统需求概览、识别候选构件、根据发现的构件修改需求、体系结构设计、构件定制与适配、组装构件创建系统。</p>
<p>CBSE过程与传统软件开发过程不同点：</p>
<p>CBSE早期需要完整的需求(即需求明确)，以便尽可能多地识别出可复用的构件。</p>
<p>在过程早期阶段根据可利用的构件来细化和修改需求。如果可利用的构件不能满足用户需求，就应该考虑由复用构件支持的相关需求。</p>
<p>在系统体系结构设计完成后，会有一个进一步的对构件搜索及设计精化的活动。可能需要为某些构件寻找备用构件，或者修改构件以适合功能和架构的要求。</p>
<p>开发就是将己经找到的构件集成在一起的组装过程。</p>
<p>构件组装是指构件相互直接集成或是用专门编写的“胶水代码”将它们整合在一起来创造一个系统或另一个构件的过程。常见的组装构件有以下3种组装方式：</p>
<p>顺序组装，层次组装，叠加组装</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>系统软件过程模型</title>
    <url>/2024/03/04/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="软件开发生命周期"><a href="#软件开发生命周期" class="headerlink" title="软件开发生命周期"></a>软件开发生命周期</h3><p>软件定义时期：包括可行性研究和详细需求分析过程，任务是确定软件开发工程必须完成的总目标，具体可分成问题定义、可行性研究、需求分析等</p>
<p>软件开发时期：就是软件的设计与实现，可分成概要设计、详细设计、编码、测试等。</p>
<p>软件运行和维护：就是把软件产品移交给用户使用</p>
<p>软件系统文档</p>
<p>用户文档主要描述系统功能和使用方法，并不关系这些功能是怎样实现的；</p>
<p>系统文档描述系统设计、实现和测试等各方面的内容</p>
<h3 id="软件工程设计"><a href="#软件工程设计" class="headerlink" title="软件工程设计"></a>软件工程设计</h3><h4 id="软件工程过程"><a href="#软件工程过程" class="headerlink" title="软件工程过程"></a>软件工程过程</h4><p>P(Plan)：软件规格说明。规定软件的功能及其运行时的限制。</p>
<p>D(Do)：软件开发。开发出满足规格说明的软件。</p>
<p>C(Check)：软件确认。确认开发的软件能够满足用户的需求。</p>
<p>A(Action)：软件演进。软件在运行过程中不断改进以满足客户新的需求。</p>
<h4 id="软件设计活动"><a href="#软件设计活动" class="headerlink" title="软件设计活动"></a>软件设计活动</h4><p>数据设计、架构(体系结构)设计、人机界面(接口)设计和过程(功能)设计</p>
<h4 id="能力成熟度模型CMM"><a href="#能力成熟度模型CMM" class="headerlink" title="能力成熟度模型CMM"></a>能力成熟度模型CMM</h4><table>
<thead>
<tr>
<th>能力等级</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>初始级</td>
<td>软件过程的特点是杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤，项目的成功完全依赖个人的努力和英雄式核心人物的作用。</td>
</tr>
<tr>
<td>可重复级</td>
<td>建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性，有必要的过程准则来重复以前在同类项目中的成功</td>
</tr>
<tr>
<td>已定义级</td>
<td>管理和工程两方面的软件过程已经文档化、标准化</td>
</tr>
<tr>
<td>已管理级</td>
<td>制定了软件过程和产品质量的详细度量标准。对软件过程和产品质量有定量的理解和控制</td>
</tr>
<tr>
<td>优化级</td>
<td>加强了定量分析，通过来自过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进</td>
</tr>
</tbody></table>
<h4 id="能力成熟度集成模型CMMI"><a href="#能力成熟度集成模型CMMI" class="headerlink" title="能力成熟度集成模型CMMI"></a>能力成熟度集成模型CMMI</h4><p>是若干过程模型的综合和改进，不仅仅软件，而是支持多个工程学科和领域的、系统的、一致的过程改进框架，能适应现代工程的特点和需要，能提高过程的质量和工作效率</p>
<p>阶段式模型：</p>
<table>
<thead>
<tr>
<th>能力等级</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>初始级</td>
<td>过程不可预测且缺乏控制</td>
</tr>
<tr>
<td>已管理级</td>
<td>过程为项目服务</td>
</tr>
<tr>
<td>已定义级</td>
<td>过程为组织服务</td>
</tr>
<tr>
<td>定量管理</td>
<td>过程已度量和控制</td>
</tr>
<tr>
<td>优化级</td>
<td>集中于过程改进和优化</td>
</tr>
</tbody></table>
<p>连续式模型：关注每个过程域的能力，一个组织对不同的过程域可以达到不同的过程域能力等级</p>
<h3 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h3><p>软件过程模型是一种规划和组织软件开发过程的方法，过程模型通常由一系列阶段和任务组成，这些任务在软件开发的不同阶段中都有特定的目标。每个阶段都有自己的任务和产出物，这些产出物构成了软件开发的不同部分，最终汇总成完整的软件产品</p>
<h4 id="瀑布模型（SDLC）"><a href="#瀑布模型（SDLC）" class="headerlink" title="瀑布模型（SDLC）"></a>瀑布模型（SDLC）</h4><p>是一个经典的软件生命周期模型，一般将软件开发分为：可行性分析(计划)、需求分析、软件设计(概要设计、详细设计)、编码、测试、运行维护等几个阶段</p>
<p><img src="/2024/03/04/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/1.jpg" alt="1"></p>
<p>模型特点：</p>
<p>从上一项开发活动接受该项活动的工作对象作为输入。利用这一输入，实施该项活动应完成的工作内容。</p>
<p>给出该项活动的工作成果，作为输出传给下一项开发活动</p>
<p>对该项活动的实施工作成果进行评审。若其工作成果得到确认，则继续进行下一项开发活动；否则返回前一项，甚至更前项的活动。尽量减少多个阶段间的反复。以相对来说较小的费用来开发软件，适用于需求明确的情况</p>
<h4 id="原型化模型"><a href="#原型化模型" class="headerlink" title="原型化模型"></a>原型化模型</h4><p>第一步就是创建一个快速原型，能够满足项目干系人与未来的用户可以与原型进行交互，再通过与相关干系人进行充分的讨论和分析，最终弄清楚当前系统的需求，进行了充分的了解之后，在原型的基础上开发出用户满意的产品。适合于需求不明确的情况</p>
<p>模型特点：</p>
<p>实际可行</p>
<p>具有最终系统的基本特征</p>
<p>构造方便、快速，造价低。原型法的特点在于原型法对用户的需求是动态响应、逐步纳入的</p>
<h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><p>螺旋模型是一个演化软件过程模型，将原型实现的迭代特征与线性顺序(瀑布)模型中控制的和系统化的方面结合起来。在螺旋模型中，软件开发是一系列的增量发布</p>
<p><img src="/2024/03/04/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/2.jpg" alt="1"></p>
<p>模型特点：</p>
<p>重点是风险控制分析</p>
<p>开发过程具有周期性重复的螺旋线状。四个象限分别标志每个周期所划分的四阶段：制订计划、风险分析、实施工程和客户评估。螺旋模型强调了风险分析，特别适用于庞大而复杂的、高风险的系统</p>
<h4 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h4><p>V模型从整体上看起来，就是一个V字型的结构，由左右两边组成。左边的下画线分别代表了需求分析、概要设计、详细设计、编码。右边的上画线代表了单元测试、集成测试、系统测试与验收测试</p>
<p><img src="/2024/03/04/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/3.jpg" alt="1"></p>
<p>模型特点：</p>
<p>单元测试的主要目的是针对编码过程中可能存在的各种错误；</p>
<p>集成测试的主要目的是针对详细设计中可能存在的问题</p>
<p>系统测试主要针对概要设计，检查系统作为一个整体是否有效地得到运行；</p>
<p>验收测试通常由业务专家或者用户进行，以确认产品能真正符合用户业务上的需要。</p>
<p>V模型适用于需求明确和需求变更不频繁的情形</p>
<h4 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h4><p>首先开发核心模块功能，而后与用户确认，之后再开发次核心模块的功能，即每次开发一部分功能，并与用户需求确认，最终完成项目开发，优先级最高的服务最先交付</p>
<p><img src="/2024/03/04/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/4.jpg" alt="1"></p>
<p>模型特点：</p>
<p>但由于并不是从系统整体角度规划各个模块，因此不利于模块划分。难点在于如何将客户需求划分为多个增量。与原型不用的是增量模型的每一次增量版本都可作为独立可操作的作品，而原型的构造一般是为了演示</p>
<h4 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h4><p>是一种以用户需求为动力，以对象作为驱动的模型，适合于面向对象的开发方法。使开发过程具有迭代性和无间隙性</p>
<h4 id="基于构件的开发模型（CBSD）"><a href="#基于构件的开发模型（CBSD）" class="headerlink" title="基于构件的开发模型（CBSD）"></a>基于构件的开发模型（CBSD）</h4><p>也称之为快速开发模型，主要是利用预先包装的构件来构造应用系统。构件可以是组织内部开发的构件，也可以是商品化成品软</p>
<p>件构件。特点是增强了复用性，在系统开发过程中，会构建一个构件库，供其他系统复用，因此可以提高可靠性，节省时间和成本</p>
<h4 id="形式化方法模型"><a href="#形式化方法模型" class="headerlink" title="形式化方法模型"></a>形式化方法模型</h4><p>建立在严格数学基础上的一种软件开发方法，主要活动是生成计算机软件形式化的数学规格说明</p>
<h4 id="敏捷模型"><a href="#敏捷模型" class="headerlink" title="敏捷模型"></a>敏捷模型</h4><p>个体和交互胜过过程和工具、可以工作的软件胜过面面俱到的文档、客户合作胜过合同谈判、响应变化胜过遵循计划</p>
<p>模型特点：</p>
<p>是“适应性”而非“预设性”。</p>
<p>是“面向人的”而非“面向过程的”。</p>
<p>敏捷方法是适应型，而非可预测型。拥抱变化，适应变化。</p>
<p>敏捷方法是以人为本，而非以过程为本。发挥人的特性。</p>
<p>迭代增量式的开发过程。以原型开发思想为基础，采用法代增量式开发，发行版本小型化</p>
<p>模型方法：</p>
<p>极限编程(XP)：基础和价值观是交流、朴素、反馈和勇气，即任何一个软件项目都可以从4个方面入手进行改善：加强交流：从简单做起：寻求反馈；勇于实事求是。</p>
<p>• XP是一种近螺旋式的开发方法，它将复杂的开发过程分解为一个个相对比较简单的小周期：通过积极的交流、反馈以及其他一系列的方法，开发人员和客户可以非常清楚开发进度、变化、待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程。</p>
<p>• XP提倡测试先行，为了将以后出现bug的几率降到最低</p>
<p>水晶系列方法。与XP方法一样，都有以人为中心的理念，但在实践上有所不同。其目的是发展一种提倡“机动性的”方法，包含具有共性的核心元素，每个都含有独特的角色、过程模式、工作产品和实践。</p>
<p>并列争球法(Scrum)。是一种迭代的增量化过程，把每段时间(如30天)一次的迭代称为个“冲刺”(Sprint),并按需求的优先级别来实现产品，多个自组织和自治的小组并行地递增实现产品。</p>
<p>特性驱动开发方法(FDD)。是一个迭代的开发模型。认为有效的软件开发需要3个要素：人、过程和技术。有5个核心过程：开发整体对象模型、构造特征列表、计划特征开发、特征设计和特征构建</p>
<h4 id="统一过程模型（RUP）"><a href="#统一过程模型（RUP）" class="headerlink" title="统一过程模型（RUP）"></a>统一过程模型（RUP）</h4><p>RUP描述了如何有效地利用商业的、可靠的方法开发和部署软件，是一种重量级过程。RUP类似一个在线的指导者，它可以为所有方面和层次的程序开发提供指导方针、模版以及事例支持</p>
<p>RUP软件开发生命周期是一个二维的软件开发模型，RUP中有9个核心工作流：</p>
<p>业务建模</p>
<p>需求</p>
<p>分析设计</p>
<p>实现</p>
<p>测试</p>
<p>部署</p>
<p>配置与变更</p>
<p>项目管理</p>
<p>环境</p>
<p>RUP把软件开发生命周期划分为多个循环，每个循环生成产品的一个新的版本，每个循环依次由4个连续的阶段组成，每个阶段完成确定的任务。这4个阶段如下。</p>
<p>初始阶段：定义最终产品视图和业务模型，并确定系统范围。</p>
<p>细化阶段：设计及确定系统的体系结构，制订工作计划及资源要求。</p>
<p>构造阶段：构造产品并继续演进需求、体系结构、计划直至产品提交。</p>
<p>移交阶段：把产品提交给用户使用</p>
<p>模型特点：</p>
<p>用例驱动：需求分析、设计、实现和测试等活动都是用例驱动的。</p>
<p>以体系结构为中心：包括系统的总体组织和全局控制、通信协议等。是一个多维的结构，会采用多个视图来描述</p>
<p>迭代与增量：把整个项目开发分为多个迭代过程。在每次选代中，只考虑系统的一部分需求，进行分析、设计、实现、测试和部署等过程；每次迭代是在己完成部分的基础上进行的，每次增加一些新的功能实现，以此进行下去，直至最后项目的完成</p>
<p>4+1 视图模型：</p>
<p><img src="/2024/03/04/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/5.jpg" alt="1"></p>
<p>分析人员和测试人员关心的是系统的行为，会侧重于用例视图；</p>
<p>最终用户关心的是系统的功能，会侧重于逻辑视图；</p>
<p>程序员关心的是系统的配置、装配等问题，会侧重于实现视图；</p>
<p>系统集成人员关心的是系统的性能、可伸缩性、吞吐率等问题，会侧重于进程视图；</p>
<p>系统工程师关心的是系统的发布、安装、拓扑结构等问题，会侧重于部署视图</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>系统设计</title>
    <url>/2024/03/09/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>软件设计包括四个独立，又联系的活动：数据设计软件结构设计，人机界面设计，过程设计</p>
<h3 id="业务流程设计"><a href="#业务流程设计" class="headerlink" title="业务流程设计"></a>业务流程设计</h3><h4 id="图工具"><a href="#图工具" class="headerlink" title="图工具"></a>图工具</h4><p>程序流程图(Program Flow Diagram,PFD)：它独立于任何一种程序设计语言，比较直观、清晰，易于学习掌握。任何复杂的程序流程图都应该由顺序、选择和循环结构组合或嵌套而成</p>
<p>IPO图：也是流程描述工具，用来描述构成软件系统的每个模块的输入、输出和数据加工。数据流图其实就是一种IPO图</p>
<p>N-S图：比较容易表示嵌套和层次关系，并具有强烈的结构化特征。但是当问题很复杂时，N-S图可能很大，因此不适合于复杂程序的设计</p>
<p>问题分析图（PAD）：是一种支持结构化程序设计的图形工具。PAD具有清晰的逻辑结构、标准化的图形等优点，更重要的是，它引导设计人员使用结构化程序设计方法，从而提高程序的质量</p>
<h4 id="设计分类"><a href="#设计分类" class="headerlink" title="设计分类"></a>设计分类</h4><p>业务流程管理（BPM）：是一种方法论，用于优化、管理和自动化组织内的业务流程。它涉及识别、建模、分析和优化业务流程，以实现更高效、灵活和协调的运作。BPM关注整个业务流程的管理，包括流程的执行、监控、优化和自动化</p>
<p>业务流程重组（BPR）：BPR是更为激进的方法，它着眼于对现有业务流程进行彻底的重新设计和改造，以实现质的飞跃的改进，是对企业的业务流程进行根本性的再思考和彻底性的再设计，从而获得可以用诸如成本、质量、服务和速度等方面的业绩来衡量的显著性的成就</p>
<p>流程管理包含三个层面：规范流程、优化流程和再造流程</p>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><h4 id="系统设计主要目的"><a href="#系统设计主要目的" class="headerlink" title="系统设计主要目的"></a>系统设计主要目的</h4><p>为系统制定蓝图，在各种技术和实施方法中权衡利弊，精心设计，合理地使用各种资源，最终勾画出新系统的详细设计方法。简单点说，系统设计就是告诉你该怎么做，需求分析就是找到你要做什么，系统设计就是告诉你怎么做</p>
<h4 id="系统设计方法"><a href="#系统设计方法" class="headerlink" title="系统设计方法"></a>系统设计方法</h4><p>结构化设计方法，面向对象设计方法。</p>
<h4 id="系统设计的主要内容"><a href="#系统设计的主要内容" class="headerlink" title="系统设计的主要内容"></a>系统设计的主要内容</h4><p>概要设计、详细设计。</p>
<p>概要设计基本任务：外部设计，又称为系统总体结构设计，是将系统的功能需求分配给软件模块，确定每个模块的功能和调用关系，形成软件的<strong>模块结构图</strong>，即<strong>系统结构图</strong>。还需要产出<strong>概要设计说明书</strong></p>
<p>详细设计的基本任务：内部设计，模块内详细算法设计、模块内数据结构设计、数据库的物理设计、其他设计(代码、输入/输出格式、用户界面)、编写<strong>详细设计说明书</strong>、评审</p>
<h4 id="系统设计基本原理"><a href="#系统设计基本原理" class="headerlink" title="系统设计基本原理"></a>系统设计基本原理</h4><p>抽象化： 系统设计中也会将复杂的问题分成更小、更易管理的部分。这样做能让我们关注重要的细节，同时不被不必要的复杂性所困扰。</p>
<p>自顶而下，逐步求精： 先考虑整体框架，然后逐步添加细节，以确保每个部分都被仔细设计和优化。</p>
<p>信息隐蔽：在系统设计中，我们可以隐藏复杂的内部细节，只暴露必要的信息给其他部分。这样能够降低不同模块之间的相互影响，使系统更易于管理和维护。</p>
<p>模块独立（<strong>高内聚</strong>，<strong>低耦合</strong>）： 系统设计中的各个部分应该是独立的，即每个模块都有自己的功能并且尽可能不依赖其他模块。高内聚表示模块内部的元素彼此紧密相关，低耦合表示模块之间的依赖尽可能降低</p>
<p>衡量模块独立程度的标准有两个：耦合性和内聚性</p>
<p>内聚程度，模块内</p>
<table>
<thead>
<tr>
<th>偶然内聚</th>
<th>无直接关系</th>
</tr>
</thead>
<tbody><tr>
<td>逻辑内聚</td>
<td>逻辑相似，参数决定</td>
</tr>
<tr>
<td>时间内聚</td>
<td>同时执行动作</td>
</tr>
<tr>
<td>过程内聚</td>
<td>指定的过程顺序</td>
</tr>
<tr>
<td>通信内聚</td>
<td>相同的数据结构，相同输入输出</td>
</tr>
<tr>
<td>顺序内聚</td>
<td>顺序执行，前一个输出是下一个输入</td>
</tr>
<tr>
<td>功能内聚</td>
<td>共同作用，缺一不可</td>
</tr>
</tbody></table>
<p>耦合程度，模块之间</p>
<table>
<thead>
<tr>
<th>无直接耦合</th>
<th>无直接关系</th>
</tr>
</thead>
<tbody><tr>
<td>数据耦合</td>
<td>模块间调用关系，传递数据值调用</td>
</tr>
<tr>
<td>标记耦合</td>
<td>传递数据结构</td>
</tr>
<tr>
<td>控制耦合</td>
<td>传递的是控制变量，执行另一个模块内部的某一功能</td>
</tr>
<tr>
<td>外部耦合</td>
<td>软件外部环境</td>
</tr>
<tr>
<td>公共耦合</td>
<td>公共数据结构</td>
</tr>
<tr>
<td>内容耦合</td>
<td>模块内部关联</td>
</tr>
</tbody></table>
<h4 id="系统设计基本原则"><a href="#系统设计基本原则" class="headerlink" title="系统设计基本原则"></a>系统设计基本原则</h4><p>保持模块的大小适中： 系统中的模块也应该适中，不要太大也不要太小。这样做可以使每个模块的功能清晰，并且易于理解、测试和维护。</p>
<p>尽可能减少调用的深度： 在系统设计中，减少调用深度意味着尽量减少程序的层层嵌套，以避免复杂的调用关系，使代码更清晰和高效。</p>
<p>多扇入，少扇出： 在系统设计中，模块应该允许多个模块调用它（多扇入），但它本身应尽量少调用其他模块（少扇出），以减少模块</p>
<p>之间的复杂关系。</p>
<p>单入口，单出口：这样可以使模块的功能和接口更清晰，不容易引入混淆和错误。</p>
<p>模块的作用域应该在模块之内： 模块的功能应该限制在模块内部，不要让外部模块直接访问内部的细节。这有助于封装和隐藏内部逻辑，防止外部干扰。</p>
<p>功能应该是可预测的： 使用者在调用一个模块时应该能够合理地预期它会发生什么，从而避免产生混淆和不可预知的结果</p>
<h3 id="人机界面设计"><a href="#人机界面设计" class="headerlink" title="人机界面设计"></a>人机界面设计</h3><p>三大黄金原则：</p>
<p>置于用户的控制之下</p>
<p>减少用户的记忆负担</p>
<p>保持界面的一致性</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>组合</title>
    <url>/2021/02/18/%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合</p>
<p>示例， n=4， k=2</p>
<h4 id="递归回溯，剪枝"><a href="#递归回溯，剪枝" class="headerlink" title="递归回溯，剪枝"></a>递归回溯，剪枝</h4><p>再递归遍历的时候，从1开始，进行组合，1用过之后，下一层遍历则排除1,234进行递归，手动控制递归范围，进行剪枝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func combine(n int, k int) [][]int &#123;</span><br><span class="line">    res := [][]int&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> n &lt; k &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> handle func(start int, path []int)</span><br><span class="line">    handle = <span class="function"><span class="title">func</span>(<span class="params">start int, path []int</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 得到结果的长度，加入结果，加入后进行回溯</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == k &#123;</span><br><span class="line">        	<span class="comment">// 后续会修改path，需要拷贝</span></span><br><span class="line">            tmp := make([]int, len(path))</span><br><span class="line">            copy(tmp, path)</span><br><span class="line">            res = append(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt;= n; i++ &#123;</span><br><span class="line">            <span class="comment">// 1加入</span></span><br><span class="line">            path = append(path, i)</span><br><span class="line">            <span class="comment">// 从2开始，判断是否到回溯条件，如果符合，加入最终结果</span></span><br><span class="line">            handle(i+<span class="number">1</span>, path)</span><br><span class="line">            <span class="comment">// 去掉最后一位，继续递归。2完了3</span></span><br><span class="line">            path = path[:len(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    handle(<span class="number">1</span>, []int&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间复杂度O(n)<br>时间复杂度O(<br>(k<br>n)×k)</p>
]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>系统架构基础一些问题</title>
    <url>/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="零散问题"><a href="#零散问题" class="headerlink" title="零散问题"></a>零散问题</h3><p>1、在冯诺依曼结构中，程序指令和娄数据存在同一个存储器中</p>
<p>2、全局队列调度优点是CPU核心利用率较高而且平均，局部队列调度优点是任务无需在多个CPU核心间切换，提高了CPU核心局部缓存命中率;缺点是CPU利用率较低</p>
<p>3、采用不同的寻址方式可以扩展操作码，但是并不会降低指令译码难度，反而会增加难度。</p>
<p>采用不同寻址方式可缩短指令字长（如果使用立即寻址，长度会很长，但是使用寄存器寻址，指令长度就会变短），扩大寻址空间（立即寻址和间接寻址就可以看出来），提高编程的灵活性（可以按照需要采取直接或间接寻址方式）</p>
<p>实现程序控制是通过转移指令来实现的</p>
<p>4、PC保存的是当前欲执行的指令的地址</p>
<p>地址码字段指出的是操作数所在的地址</p>
<p>程序员可以修改指令执行的顺序，但不能给出指令的地址。</p>
<p>操作系统编译为CPU指令，在CPU架构上执行，并不是决定指令的地址的。</p>
<p>5、在计算机设计时，围绕的中心是指令，指令是一种基本的操作。一台计算机处理功能的大小与指令的功能以及指令的多少有关。所有指令的集合称为指令系统，也就是机器语言</p>
<p>6、全相联映像块冲突最小，其次为组相联映像，直接映像块冲突最大。</p>
<p>7、CISC的主要缺点如下：复杂，周期长，成本高，成品率低，降低速度，优化编译难</p>
<p>①微程序技术是CISC的重要支柱，每条复杂指令都要通过执行一段解释性微程序才能完成，这就需要多个CPU周期，从而降低了机器的处理速度；②指令系统过分庞大，从而使高级语言编译程序选择目标指令的范围很大，并使编译程序本身冗长而复杂，从而难以优化编译使之生成真正高效的目标代码；③CISC强调完善的中断控制，势必导致动作繁多，设计复杂，研制周期长；</p>
<p>④CISC给芯片设计带来很多困难，使芯片种类增多，出错几率增大，成本提高而成品率降低。</p>
<p>8、地址总线由单向多根信号线组成，可用于CPU向主存、外设传送地址信息；<br>数据总线由双向的多根信号线组成，CPU可以沿看这些线从主存或外设读入数据也可发送数据；<br>控制总线上传输控制信息，包括控制命令和反馈信号等。<br>访问内存所得到的信息是数据信息，通过数据总线传送至CPU</p>
<p>9、浮点数中尾数是纯小数</p>
<p>10、把符号位和数值位一起进行编码来表示的数叫做机器数。</p>
<p>真值是指在机器数编码的基础上，将符号位和数值位分开进行运算得到的数值</p>
<p>11、原码，反码，补码：</p>
<p>在现代计算机中，数值型数据一般采用二进制数的补码形式表示。原码、 反码和补码都是机器数的不同表示形式。其中</p>
<p>原码最高位表示符号位， 其余位表示数值。</p>
<p>反码是在原码的基础上，将负数的表示方法取反， 即负数的符号位为1， 其余为取反的原码。</p>
<p>补码是在反码的基础上再加1， <strong>对于正数和0， 补码和原码相同， 而对于负数，补码是其绝对值的原码取反加1</strong>。补码的优点是， 可以用同一套加法规则处理加减法，且没有溢出的问题</p>
<p>12、机器字长为n，最高位符号位，定点整数最大值2的n-1次方-1</p>
<p>13、原码乘法：将被乘数和乘数的符号位和数值部分单独处理<br>对被乘数和乘数的数值部分取绝对值相乘， 得到乘积。<br>如果被乘数和乘数的符号位相同 则乘积为正；如果符号位不同， 则乘积为负。将乘积的符号位和数值部分合并得到最终结果。</p>
<p>14、原码，反码有0和-0之分，补码没有，移码也没有，移码是补码符号位取反</p>
<p>15、n位补码表示范围-2的n-1次方到2的n-1次方-1</p>
<p>16、正数的原码，反码都一样，只有负数的反码取反</p>
<p>17、总能保证除数的首位为1，则模2除法运算的商是由余数首位与除数首位的模2除法运算结果确定。因为除数首位总是1，按照模2除法运算法， 那么余数首位是1就商1，是0就商0</p>
<p>18、模2除法原则：被除数的首位为1，商为1。被除数的首位为0，商为0。模2除法等同于按位异或， 要保证每次除完首位都为0，才能进行石移。计算时每次右移一位， 当被除数的位数小于除数，其为余数。</p>
<p>19、存储器常用的存取方式：</p>
<p>（1）顺序存取：存储器的数据以记录的形式进行组织。<strong>对数据的访问必须按特定的线性顺序进行</strong>。<strong>磁带存储器</strong>采用顺序存取的方式<br> （2）直接存取：与顺序存取相似，直接存取也使用一个共享的读写装置对所有的数据进行访问。但是，<strong>每个数据块都拥有唯一的地址标识</strong>， 读写装置可以直接移动到目的数据块的所在位置进行访问。存取时间也是可变的。<strong>磁盘存储器</strong>采用直接存取的方式。<br>  3）随机存取：存储器的每一个可寻址单元都具有自己唯一的地址和读写装置，<strong>系统可以在相同的时间内对任意一个存储单元的数据进行访问</strong>， 而与先前的访问序列无关。<strong>主存储器</strong>采用随机存取的方式<br>  （4） 相联存取：相联存取也是一种随机存取的形式，<strong>但是选择某一单元进行读写是取决于其内容而不是其地址</strong>。与普通的随机存取方式一样，每个单元都有自己的读写装置，读写时间也是一个常数。使用相联存取方式，可以对所有的存储单元的特定位进行比较，选择符合条件的单元进行访问。为了提高地址映射的速度，<strong>Cache采取相联存取</strong>的方式</p>
<p>20、DRAM:动态随机存取存储器；计算机系统主存主要由DRAM构成，又叫主存，是与CPU直接交换数据的内部存储器。它可以随时读写 （刷新时除外），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储媒介，通过周期性刷新来保持数据的存储器件，断电丢失。<br>SRAM:静态随机存取存储器；指这种存储器只要保持通电，里面储存的数据就可以恒常保持，Cache构成<br>EEPROM： 电可擦可编程只读存储器。与EPROM相似， EEPROM中的内容既可以读出，也可以进行改写</p>
<p>FLASH：闪存，也可以使用电信号进行信息的擦除操作。整块闪存可以在数秒内删除</p>
<p>21、高速缓冲存储器是存在于主存与CPU之间的一级存储器，由静态存储芯片 （SRAM） 组成，容量比较小但速度比主存高得多，接近于CPU的速度。Cache通常保存看一份内存储器中部分内容的副本，该内容副本是最近曾被CPU使用过的数据和程序代码</p>
<p>22、Cache是一种介于主存和微处理器 （CPU）之间的高速存储器， 用于主存和CPU之间的缓冲存储。其命中率必须很高， 一般要达90%~95%以上， 才能使访存的速度跟得上CPU的速度</p>
<p>23、cpu对其访问速度最快，题目中的存储设备按访问速度排序为：通用寄存器&gt;Cache&gt;内存&gt;硬盘</p>
<p>24、中断向量就是中断服务程序的入口地址， 因此中断向量的地址就是中断服务程序的入口地址的地址</p>
<p>25、直接存储器访问 Direct MemoryAccessDMA）是指数据在主存与I/O设备间的直接成块传送， 即在主存与V/O设备间传送数据块的过程中，不需要CPU作任何干涉，只需在过程开始启动  （即向设备发出“传送一块数据”的命令） 与过程结束 CPU通过轮询或中断得知过程是否结束和下次操作是否准备就绪）  时由CPU进行处理， 实际操作由DMA硬件直接完成， CPU在传送过程中可做其他事情。</p>
<p>26、对于a，数据格式的转换是接口应具有的功能，也是设置接口的原因之一</p>
<p>对于b，过程中错误与状态检测，对应反应I/O设备工作状态的功能</p>
<p>对于c，操作的控制与定时，对应传送命令功能。操作就是一些命令</p>
<p>对于d， 与主机和外设通信对应传送数据功能。通信就是要传送数据</p>
<p>27、在UNIX操作系统中，把输入/输出设备看作是特殊文件</p>
<p>28、影响计算机系统IO设备传输速度的主要因素，数据总线的宽度</p>
<p>29、指令周期（nstructionCycle):取出并执行一条指令的时间。<br>总线周期 （BUSCycle）：也就是一个访存储器或V/O端口操作所用的时间<br>时钟周期 （ClockCycle）：又称震荡周期，是处理操作的最基本单位。<br>指令周期、总线周期和时钟周期之间的关系：一个指令周期由若干个总线周期组成，而一个总线周期时间又包含有若干个时钟周期。<br>一个总线周期包含一个 （只有取址周期） 或多个机器周期<br>机器周期：在计算机中，为了便于管理，常把一条指令的执行过程划分为若个阶段，每一阶段完成一项工作。例如，取指令、存储器读、存储器写等，这每一项工作称为一个基本操作。完成一个基本操作所需要的时间称为机器周期。<br>DMA响应过程为：DMA控制器对DMA请求判别优先级及屏蔽，向总线裁决逻辑提出总线请求。 当CPU执行完当前总线周期即可释放总线控制权。此时总线裁决逻辑输出总线应答，表示DMA已经响应，通过DMA控制器通知/O接口开始DMA传输。</p>
<p>存储周期：通常指连续启动两次操作所需间隔的最小时间， 体现主存的速度DMA获得内存总线的控制权，单纯的是为了做内存访问， 所以仅需要一个存取周期</p>
<p>30、<img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/1.jpg" alt="1"></p>
<p>31、中断，程序现场信息保存在堆栈</p>
<p>32、磁盘驱动器是不是IO接口，可编程中断控制是IO接口</p>
<p>33、RISC精简指令系统CPU中的通用寄存器数量多，一般在32个以上，有的可达上个。优化编译，更好的支持高级语言</p>
<p>34、Flynn分类法根据指令流和数据流分为4类</p>
<p>35、突发传输：在一个总线周期内， 可以传输多个存储地址连续的数据，即一次传输一个地址和一批地址连续的数据。<br>并行传输：在传输中有多个数据位同时在设备之间进行的传输<br>串行传输：数据的二进制代码在一条物理信道上以位为单位按时间顺序逐位传输<br>同步传输：传输过程中由统一的时钟控制</p>
<p>36、计算机使用总线结构便于增减外设，同时减少信息传输线的条数。</p>
<p>37、串行总线适宜长距离传输数据。但串行总线有半双工、全双工之分，全双工是条线发一条线收。<br> 串行总线传输的波特率在使用中可以改变<br>串行总线的数据发送和接收可以使用多种方式， 程序查询方式和中断方式都可以</p>
<p>38、公钥加密，非对称加密：RSA，EIGAMA，背包算法，ECC，DSA</p>
<p>流加密：RC4，ORYX，SEAL</p>
<p>分组加密：对称密钥分组加密：DES，AES，IDEA</p>
<p>39、浏览器和服务器属于会话密钥+公钥加密</p>
<p>40、公钥体系，非对称加密，私钥用于解密加签名，公钥用于加密和认证</p>
<p>41、在PKI系统体系中，证书机构CA负责生成和签署数字证书，注册机构RA负责验证申请数学证书用户的身份。</p>
<p>42、我们可以通过验证CA对数字证书的签名来核实数字证书的有效性。如果证书有效， 说明此网站经过CA中心的认证，是可信的网站，所以这个动作是用来验证网站真伪的</p>
<p>43、消息摘要防止篡改，对消息摘要加密，防止抵赖</p>
<p>44、假设系统中有n个进程共享3台打印机， 意味着每次只允许3个进程进入互段，那么信号量的初值应为3。可见， 根据排除法只有选项B中含有3。第2空的正确答案为选项D。信号量S的物理意义为：当S0时，表示资源的可用数；当S&lt;0时，其绝对值表示等待资源的进程数。</p>
<p>45、矩阵A10011001总共有100行、100列， 若矩阵A按行序存放，那么每一个页面可以存放2行，也就是说矩阵的2行刚好放在1页内，  访问他们需要中断1次， 这样100行总共需要中断50次，若矩阵A按列序存放， 那么每一个页面可以存放2列，  也就是说矩阵的2列刚好放在1页内，由于内循环“FORi:=1toDo”是按照列序变化， 访问它们需要中断50次， 这样100行总共需要中断5000次。</p>
<p>46、若操作系统正在将修改后的系统目录文件写回磁盘时系统发生崩溃， 则对系统的影响相对较大</p>
<p>47、逻辑地址为十六进制5148H其页号为5， 页内地址为148H， 查页表后可知页顿号  （物理块号） 为3， 该地址经过变换后， 其物理地址应为页顿号3拼上页内地址148H  即十六进制3148H.</p>
<p>系统应该首先淘未被访问的页面， 因为根据程序的局部性原理，最近未被访问的页面下次被访问的概率更小 如果页面最近都被访问过，应该先淘汰未修改过的页面， 因为未修改过的页面内存与辅存一致，故淘汰时无须写回辅存，使系统页面置换代价更小</p>
<p>48、如果客户端发出一个请求，然后DNS服务器自己负责与其他服务器通信，最终将结果返回给客户端，这是递归查询。如果客户端在查询过程中多次收到指向不同DNS服务器的指引，并且需要自己去联系这些服务器，这是迭代查询。这里面你看箭头方向就能看出来</p>
<p>49、DNS服务器的IP地址都存放在/etc/resolv.conf文件中。</p>
<p>50、RAID5采取的是N+1的方案。1就是校验信息。以一共6个500G的盘，实际存原始数据的容量是：5*500=2500G<br>当一组盘的容量大小不一时，所有盘按最小容量进行计算。故5块500G的盘和1块250G的盘相当于5块250G的硬盘。</p>
<p>51、网络几余设计主要是通过重复设置网络链路和网络设备，以提高网络的可用性。</p>
<p>52、根据交换机的转发方式，交换机可以分为3类<br>  （1） 直接交换方式 （cut-throughswitching）；交换机只接收并检测目的地址，就立即将该顿转发出去， <strong>而不用判断这顿数据是否出错</strong>。顿出错检测任务由节点完成。这种交换方式的优点就是交换延退低；缺点就是缺乏差错检测能力，不支持不同速率端口之间的顿转发。<br> （2）存储转发交换方式 （Store-and-Forwardswitching）；交换机需要完成接收并进行差错检测。如果接收顿正确，则根据的地址确定输出端口，然后再转发出去。<strong>这种交换方式的优点是具有差错检测能力，并支持不同速率端口间的转发</strong>；缺点就是交换延迟会增长<br> （3）改进直接交换方式 （segment-freeswitching，无碎片转发方式）。改进的直接交换方式就是上述两种方式的结合。在接收到顿的前64B后，判断顿头字段是否正确，如果正确则转发出去。长度小于64字节。冲突碎片并不是有效的数据顿，应该被丢弃。这种方式对于短的顿来说，交换延退与直接交换方式比较接近；对于长的顿来说， 由于它只对的地址字段与控制字段进行差错检测， 因此交换延退将会减少。采用相关命令改变顿转发方式</p>
<p>53、SDN （Software Defined Network）  的网络架构中包含：控制层、转发层和应用层。</p>
<p>54、大型局域网通常划分为核心层、汇聚层和接入层，其中核心层在逻辑上只有一个，只负责高速转发以及出口路由；汇聚层定义的网络的访问策略，访问控制列表检查；接入层提供局域网络接入功能， 可以使用集线器代替交换机</p>
<p>55、配置DHCP服务器有如下优点<br>  （1） 管理员可以集中为某网段指定TCP/IP参数，并且可以定义使用保留地址的客户机的参数。<br>  （2） 客户机无须手工配置TCP/IP，提供安全可信的配置。DHCP避免了在每台计算机上手工输入数值引起的配置错误， 还能防止网络上计算机配置地址的冲突。<br>  （3） 使用DHCP服务器能大大减少配置花费的开销和重新配置网络上计算机的时间，服务器可以在指派地址租约时配置所有的附加配置值。<br>  （4） 客户机在子网间移动时，旧的IP地址自动释放以便再次使用。再次启动客户机时，DHCP服务器会自动为客户机重新配置TCP/IP<br>  （5） 大部分路由器可以转发DHCP配置请求，因此， 互联网的每个子网并不都需要DHCP服务器。</p>
<p>56、MPEG-1标准用于数字存储体上活动图像及其伴音的编码，其数码率为1.5Mb/s。为了提高压缩比，内/顿间图像数据压缩技术必须同时使用。帧内压缩算法与JPEG压缩算法大致相同， 采用基于DCT的变换编码技术，月用以减少空域几余信息。帧间压缩算法，采用预测法和插补法。预测误差可在通过DCT变幻码处理，进一步压缩。顿间编码技术可减少时间轴方向的余信息</p>
<p>57、H.261标准中，视频图像的顿序列包括顿内图像（I帧） 和预测图像（P顿），而在MPEG-1标准中，增加了插补图像 （B帧， 或称双向预测图像）I帧不参照任何过去的或者将来的其他图像顿，压缩编码直接采用类JPEG的压缩算法，P使用单向预测编码，而B使用双向预测编码。由此可知，I可以直接被索引和访问，其编码数据量最大；P顿和B顿不能作为直接访问点， B的编码数据量最小。</p>
<p>58、彩色视频信号数字化的过程中，利用图像子采样技术通过降低对色差信号的采样频率，以达到减少数据量的目的</p>
<p>59、总线是一个大家都能使用的数据传输通道，大家都可以使用这个通道，但<strong>发送数据时，是采用的分时机制，</strong>而接收数据时可以同时<br>接收，也就是说，同一个数据，可以并行的被多个客户收取。如果该数据不是传给自己的，数据包将被丢弃。</p>
<p>60、IO接口与CPU交换信息是异步的</p>
<p>61、嵌入式系统通常采用接口中的移位寄存器来实现数据的串/并和并/串转换操作</p>
<p>62、嵌入式操作系统特点：系统内核小，专用性强，高实时性，多任务的操作系统，需要开发工具和环境</p>
<p>63、JTAG （JointTestActionGroup，联合测试工作组）是一种国际标准测试协议（IEEE1149.1兼容），主要用于芯片内部测试。现在多数的高级器件都支持JTAG协议， 如DSP、FPGA器件等。标准的JTAG接口是4线：TMS、TCK、TDI、TDO.分别为模式选择、时钟、数据输入和数据输出线。</p>
<p>64、真实程序、核心程序、小型基准程序和合成基准程序，其评测准确程度依次递减。其中评测准确度最高的是真实程序</p>
<p>65、把应用程序中用得最多、最频繁的那部分<strong>核心程序</strong>作为评估计算机系统性能的标准程序，称为基准测试程序 （benchmark）。基准程序法是目前一致承认的测试系统性能的较好方法</p>
<p>66、业务处理系统包含的五个活动是数据输入、 业务处理、文件和数据库处理、文件和报告产生、查询处理活动。</p>
<p>67、BI关键是从许多来自不同的企业运作系统的数据中提取出有用的数据并进行清理， 以保证数据的正确性， 其核心是构建数据仓库<br>BI系统主要包括数据预处理、建立数据仓库、数据分析和数据展现四个主要阶段。</p>
<p>数据预处理是整合企业原始数据的第一步，它包括数据的抽取 （Extraction）、转换Transformation） 和加载 (Load） 三个过程 （ETL过程）；</p>
<p>建立数据仓库则是处理海量数据的基础；</p>
<p>数据分析是体现系统智能的关键，一般采用OLAP和数据挖掘两大技术。</p>
<p>OLAP不仅进行数据汇总/聚集，同时还提供切片、切块、下钻、上卷和旋转等数据分析功能，用户可以方便地对海量数据进行多维分析。数据挖掘的目标则是挖数据背后隐藏的知识， 通过关联分析、聚类和分类等方法建立分析模型，预测企业未来发展超势和将要面临的问题；在海量数据和分析手段增多的情况下，数据展现则主要保障系统分析结果的可视化</p>
<p>68、人口信息处理和采集属于政府对政府</p>
<p>69、ERP中的企业资源包括企业的*三流”资源，即物流资源、资金流资源和信息流资源。ERP实际上就是对这“三流”资源进行全面集成管理的管理信息系统。</p>
<p>70、现有的企业门户大致可以分为企业信息门户、企业知识门户和企业应用门户三种。</p>
<p>其中企业信息门户重点强调为访问结构数据和无结构数据提供统一入口，实现收集、访问、管理和无缝集成。</p>
<p>企业知识门户提供了一个创造、搜集和传播企业知识的平台，通过企业知识门户，员工可以与工作团队中的其他成员取得联系，寻找能够提供帮助的专家。</p>
<p>企业应用门户是一个用来提高企业的集中贸易能力、协同能力和信息管理能力的平台。它以商业流程和企业应用为核心，将商业流程中功能不同的应用模块通过门户集成在一起， 提高公司的集中贸易能力、协同能力和信息管理能力。</p>
<p>71、企业应用集成通过采用多种集成模式，构建统一标准的基础平台，将具有不同功能和目的而又独立运行的企业信息系统联合起来。目前市场上主流的集成模式有三种，分别是面向信息的集成、面向过程的集成和面向服务的集成。</p>
<p>其中面向过程的集成模式强调处理不同应用系统之间的交互逻辑，与核心业务逻辑相分离，并通过不同应用系统之间的协作共同完成某项业务功能</p>
<p>72、</p>
<p>1.关键成功因素法  （CSF）通过对关键成功因素的识别 找出实现目标所需的关键信息集合，从而确定系统开发的优先次序。<br>关键成功因素来自于组织的目标， 通过组织的目标分解和关键成功因素识别、性能指标识别， 一直到产生数据字典。</p>
<p>2.战略目标集转化法 （SST）战略目标集转化法从另一个角度识别管理目标，它反映了各种人的要求，而且给出了按这种要求的分层，然后转化为信息系统目标的结构化方法。它能保证目标比较全面，疏漏较少，但它在突出重点方面不如关键成功因素法。</p>
<p>3.企业系统规划法  （BSP）通过自上而下地识别企业目标、企业过程和数据，然后对数据进行分析，自下而上地设计信息系统。该管理信息系统支持企业目标的实现， 表达所有管理层次的要求，向企业提供一致性信息，对组织机构的变动具有适应性企业系统规划法虽然也首先强调目标，但它没有明显的目标导引过程。它通过识别企业“过程”引出了系统目标，企业目标到系统目标的转化是通过企业过程/数据类等矩的分析得到的。</p>
<p>73、</p>
<p>属性冲突：包括属性域冲突和属性取值冲突。<br>命名冲突：包括同名异义和异名同义。<br>结构冲突：包括同一对象在不同应用中具有不同的抽象，以及同一实体在不同局部E-R图中所包含的属性个数和属性排列次序不完全相同。</p>
<p>74、</p>
<p>数据库设计主要分为用户需求分析、概念结构、逻辑结构和物理结构设计四个阶段。</p>
<p>在用户需求分析阶段中，数据库设计人员采用一定的辅助工具对应用对象的功能、性能、限制等要求进行科学分析，并形成需求说明文档、数据字典和数据流程图。用户需求分析阶段形成的相关文档用以作为概念结构设计的设计依据。</p>
<p>逻辑设计阶段的任务是将概念模型设计阶段得到的基本E-R图，转换为与选用的DBMS产品所支持的数据模型相符合的逻辑结构，关系规范化</p>
<p>75、数据库运行的基本工作单位是事务</p>
<p>76、风险评估的基本要素为脆弱性、资产、威、风险和安全措施， 与这些要素相关的属性分别为业务战略、资产价值、安全需求、安全事件和残余风险，这些也是风险评估要素的一部分。</p>
<p>77、能力表：对应于访问控制表，这种实现技术实际上是按行保存访问矩阵。每个主体有一个能力表，是该主体对系统中每一个客体的访问权限信息。使用能力表实现的访问控制系统可以很方便地查询某一个主体的所有访问权限</p>
<p>78、访问控制表 (ACL)。 目前最流行、使用最多的访问控制实现技术。每个客体有一个访问控制表， 是系统中每一个有权访问这个客体的主体的信息。这种实现技术实际上是按列保存访问矩阵</p>
<p>79、一个密码系统至少由明文、密文、加密算法、 解密算法和密钥五个部分组成， 而在密码系统的设计中，有一条很重要的原则就是Kerckhoff原则，也就是密码系统的安全性只依赖于密钥</p>
<p>80、机密性是指网络信息不泄露给非授权的用户、实体或程序，能够防止非授权者获取信息。<br>完整性是指网络信息或系统未经授权不能进行更改的特性。<br>可用性是指合法许可的用户能够及时获取网络信息或服务的特性。<br>抗抵赖性是指防正网络信息系统相关用户否认其活动行为的特性。</p>
<p>81、实现数字签名最常见的方法：公钥密码体制和单向安全Hash函数算法相结合</p>
<p>82、X.509数字证书内容包括：版本号、序列号、签名算法标识、发行者名称、有效期、主体名称、主体公钥信息、发行者唯一标识符、主体唯一识别符、扩充域、CA的签名等，不包括加密算法标识</p>
<p>83、软件的维护并不只是修正错误。为了满足用户提出的增加新功能、修改现有功能以及一般性的改进要求和建议，需要进行完善性维护，它是软件维护工作的主要部分；软件测试不可能揭露旧系统中所有潜在的错误，所以这些程序在使用过程中还可能发生错误，诊断和更正这些错误的过程称为改正性维护；为了改进软件未来的可维护性或可靠性，或者为了给未来的改进提供更好的基础而对软件进行修改，这类活动称为预防性维护。</p>
<p>84、<img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/2.jpg" alt="1"></p>
<p>85、净室软件工程是软件开发的一种形式化方法， 可以开发较高质量的软件。它使用盒结构规约进行分析和建模，并将正确性验证作为发现和排除错误的主要机制，采用统计测试来获取验证软件可靠性所需要的信息</p>
<p>86、用例及用例图表示需求，利用包图和类图表示目标软件系统的总体框架结构</p>
<p>87、逻辑构件模型用功能包描述系统的抽象设计，用接口描述每个服务集合，以及功能之间如何交互以满足用户需求，  作为系统的设计蓝图以保证系统提供适当的功能。</p>
<p>物理构件模型用技术设施产品、硬件分布和拓扑结构、以及用于绑定的网络和通信协议描述系统的物理设计，这种架构用于了解系统的性能、吞吐率等许多非功能性属性</p>
<p>88、RUP统一过程把一个项目分为四个不同的阶段：<br>构思阶段 （初始/初启阶段）：定义最终产品视图和业务模型、确定系统范围。</p>
<p>细化阶段 （精化阶段）：设计及确定系统架构、制定工作计划及资源要求。<br>构造阶段：开发剩余构件和应用程序功能，把这些构件集成为产品，并进行详细测试。<br>移交阶段：确保软件对最终用户是可用的，进行测试，制作产品发布版本</p>
<p>6个核心过程工作流：业务建模、需求、分析与设计、实现、测试、部署。3个核心支持工作流：配置与变更管理、项目管理、环境。</p>
<p>其核心特点是：以架构为中心，用例驱动，送代与增量</p>
<p>89、结构化分析就是一种建立模型的活动，通常建立数据模型、功能模型和行为模型三种模型。</p>
<p>流程图一般用于描述活动流程或程序执行流程，程序流程图是设计阶段的工具，与结构化分析无关<br>买体-关系图（E-R图）：用于建立数据模型，其中包含了实体、关系、属性。<br>数据流图 （DFD）：描绘信息流和数据输入输出的移动过程。是结构化分析过程中使用的主要功能建模工具<br>状态转换图：通过描述系统的状态及引起系统状态转换的事件，表示系统的行为，提供了行为建模的机制<br>数据字典：描述在数据模型、功能模型和行为模型中出现的数据对象和控制信息的特征，给出这些对象的精确定义。数据字典是分析模型的核心，通常使用CASE工具来创建和维护数据字典数据字典是结构化分析方法 （SA方法） 的核心。它通常包括五个部分，即数据项、数据结构、数据流、数据存储、处理过程。</p>
<p>90、CBSE（Component-BasedSoftwareEngineering）是指用装配可重用软件构件的方法来构造应用程序。CBSE不仅仅是简单地应用对象要求代理建立一个代码库，或从Internet上下载相关控件，还需要策略而系统地进行全局考虑和规划。它包含了系统分析、构造、维护和扩展等各个方面。它具有即插即用，为接口为核心及标准化等特点。</p>
<p>91、功用驱动开发方法（FDD）中，会把编程开发人员分成两类：“首席”程序员和“类”程序员。</p>
<p>92、逆向工程导出的信息可分为如下4个抽象层次<br>实现级：包括程序的抽象语法树、符号表等信息<br>结构级：包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图等。</p>
<p>功能级：包括反映程序段功能及程序段之间关系的信息。<br>领域级： 包括反映程序分量或程序与应用领域概念之间对应关系的信息。</p>
<p>93、与逆向工程相关的概念有重构、设计恢复、再工程和正向工程<br>  （1） 重构 （restructuring）。重构是指在同一抽象级别上转换系统描述形式。<br>  （2） 设计恢复 （designrecovery）。设计恢复是指借助工具从已有程序中抽象出有关数据设计、总体结构设计和过程设计等方面的信息。<br>  （3） 逆向工程 （reverseengineering）：逆向工程是分析程序，力图在比源代码更高抽象层次上建立程序的表示过程， 逆向工程是设计的恢复过程<br>  （4） 正向工程 （fonwardengineering）。正向工程是指不仅从现有系统中恢复设计信息， 而且使用该信息去改变或重构现有系统， 以改善其整体质量。<br>  （5） 再工程（re-engineering）。再工程是对现有系统的重新开发过程， 包括逆向工程、新需求的考虑过程和正向工程三个步骤。</p>
<p>94、输入应该尽可能地简单，以降低错误发生的可能性，如对于范围可控的数据，使用选择的方式替代用户输入；只输入变化的数据等。输入应该尽可能使用已有含义明确的设计，需要采用模仿的方式而非创新</p>
<p>95、系统设计的主要内容包括概要设计和详细设计。</p>
<p>概要设计又称为系统总体结构设计它是系统开发过程中很关键的一步，其主要任务是将系统的功能需求分配给软件模块，确定每个模块的功能和调用关系，形成软件的模块结构图，即系统结构图。在要设计中，将系统开发的总任务分解成许多个基本的、具体的任务，为每个具体任务选择适当的技术手段和处理方法的过程称为详细设计。</p>
<p>根据任务的不同，详细设计可分为多种，例如，网络设计、代码设计、输入/输出设计、处理流程设计、数据存储设计、用户界面设计、安全性和可靠性设计等。</p>
<p>96、软件设计包括体系结构设计、接口设计、数据设计和过程设计</p>
<p>97、需求变更管理的过程主要包括问题分析和变更描述、变更分析和成本计算、变更实现</p>
<p>98、软件开发环境应支持多种集成机制，根据功能的不同，集成机制可以划分为环境信息库、过程控制与消息服务器、环境用户界面三个部分</p>
<p>99、只有java子类和父类是单继承，c++可以多继承</p>
<p>100、关于面向对象的开发阶段。<br>面向对象分析阶段：认定对象、组织对象、对象间的相互作用、基于对象的操作。</p>
<p>面向对象设计阶段：识别类及对象、定义属性、定义服务、识别关系、识别包。<br>面向对象程序设计：程序设计范型、选择一种OOPL<br>面向对象测试：算法层、类层、模板层、系统层。</p>
<p>101、策略模式（Strategy）：定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替换， 从而让算法可以独立于使用它的用户而变化。<br>抽象工厂模式 （AbstractFactory）：提供一个接口， 可以创建一系列相关或相互依赖的对象， 而无需指定它们具体的类。<br>观察者模式（有时又被称为发布-订阅Subscribe&gt;模式、模型-视图View&gt;模式、源-收听者Listener&gt;模式或从属者模式） 是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实作事件处理系统。<br>状态模式 （State）：允许一个对象在其内部状态改变时改变它的行为。</p>
<p>102、适配器模式将一个接口转换成客户希望的另一个接口， 从而使接口不兼容的那些类可以一起工作，将类自己的接口包裹在一个已存在的类中。适配器模式既可以作为类结构型模式， 也可以作为对象结构型模式</p>
<p>桥接 （bridge） 模式。桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。 它是一种对象结构型模式，又称为柄体 handleand body） 模式或interface） 模式。桥接模式类似于多重继承方案，但是多重继承方案往往违背了类的单一职责原则  其复用性比较差，桥接模式是比多重继承方案更好的解决方法。</p>
<p>组合（composite） 模式。组合模式又称为整体-部分  （part-whole） 模式，属于对象的结构模式。在组合模式中，通过组合多个对象形成树形结构以表示整体-部分的结构层次。组合模式对单个对象 （即叶子对象）和组合对象 （即容器对象）的使用具有一致性。<br>装饰（decorator）模式。装饰模式是一种对象结构型模式，可动态地给一个对象增加-些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。通过装饰模式， 可以在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责当需要动态地给一个对象增加功能，这些功能可以再动态地被撤销时可使用装饰模式；当不能采用生成子类的方法进行扩充时也可使用装饰模式</p>
<p>103、<img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/3.jpg" alt="1"></p>
<p>104、软件只有开发完成并固定下来才能享有软件著作权， 自复制成光盘出售，其行为是侵犯著作权</p>
<p>105、专利权仅在申请了专利权的国家受到法律保护，在其他地方并不受保护。题中提到未在中国和其他国家申请专利，所以中国销售不受法律保护。在中国不享有专利权，因此， 不能禁止他人在中国制造、使用、销售、进口、许诺销售。</p>
<p>106、著作权的保护范围不涵盖国家的法律法规及官方正式译文， 所以从2014年1月5日定为官方正式译文时，就不保护了</p>
<p>107、软件著作权属于自然人的，该自然人死亡后，在软件著作权的保护期内，软件著作权的继承人可以继承除名权的其他各项软件著作权</p>
<p>108、在著作权法中规定：署名权、修改权、保护作品完整权的保护期是不受时间限制的。而发表权、使用权和获得报酬权的保护期限为：作者终生及其死亡后的50年（第50年的12月31日）。</p>
<p>109、软件架构维护过程：</p>
<p>架构知识管理：架构设计+架构设计决策</p>
<p>架构修改管理：主要建立一个隔离区域</p>
<p>架构版本管理：版本维护</p>
<p>110、<img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/4.jpg" alt="1"></p>
<p>111、<img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/5.jpg" alt="1"></p>
<p>112、软件架构演化时期：<br>1.设计时演化：发生在体系结构模型和与之相关的代码编译之前的软件架构演化。2.运行前演化：发生在执行之前、编译之后的软件架构演化<br>3.有限制运行时演化：在某些特定约满足时，进行的一些规定好的演化操作。<br>4.运行时演化：系统的体系结构在运行时不能满足要求时发生的软件架构演化，此<br>时的演化是最难实现的</p>
<p>113、伺服对象 （Servant）：CORBA对象的真正实现， 负责完成客户端请求<br>对象适配器 ObjectAdapter）：用于屏蔽ORB内核的实现细节，为服务器对象的实现者提供抽象接口，  以便他们使用ORB内部的某些功能。<br>对象请求代理 （ObjectRequestBroker）：解释调用并负责查找实现该请求的对象，将参数传给找到的对象，并调用方法返回结果。客户方不需要了解服务对象的位置、通信方式、实现、激活或存储机制</p>
<p>114、成熟性是指系统避免因错误的发生而导致失效的能力；</p>
<p>容错性是指在系统发生故障或违反指定接口的情况下，系统维持规定的性能级别的能力；</p>
<p>易恢复性是指在系统发生失效的情况下，重建规定的性能级别并恢复受直接影响的数据的能力；</p>
<p>可靠性的依从性是指系统依附于与可靠性相关的标准、约定或规定的能力。</p>
<p>115、软件备份是属于软件冗余。信息冗余是在实现正常功能所需要的信息之外再添加一些信息，以保证运行的结果正确。所有的纠错码和检错码都属于信息余技术。</p>
<p>程序卷回是从出错的地方重新执行程序，属于时间冗余技术。指令复执也是时间冗余技术， 就是重新执行出错的指令。</p>
<p>116、MTTF/（1+MTTF）可靠性和可用性</p>
<p>117、可维护性指标，那么M=1/（1+MTTR）</p>
<p>118、构件组装技术大致可分为基于功能的组装技术、基于数据的组装技术和面向对象的组装技术</p>
<p>119、传统的编译器一般采用数据流架构风格，“管道-过滤器”和“顺序批处理”，这就需要进一步分析哪个更合适，由于题目中提到“程序源代码作为一个整体，依次在不同模快中进行传递”，而顺序批处理是强调把数据整体处理的</p>
<p>120、IDE是一种集成式的开发环境，在这种环境中，多种工具是围绕同一数据进行处理这种情况适合用数据共享架构风格</p>
<p>121、IDE环境是一种交互式编程  用户在修改程序代码后  会同时触发语法高亮显示、语法错误提示、程序结构更新等多种功能的调用与结果呈现。在做一件事情时， 同时触发一系列的行为，这是典型的隐式调用风格 （事件驱动系统）</p>
<p>122、使IDE能够生成符合新操作系统要求的运行代码”，这一要求是可以通过适配策略满足的，像设计模式中的适配器模式便是采用适配的方式，形成一致的接口</p>
<p>123、模拟新操作系统的运行环境”是典型的虚拟机架构风格的特长</p>
<p>124、多视图体现的是关注点分离的想法，“4+1”视图中的“4”，指的是：逻辑视图、开发视图、过程视图、 物理视图，“1”指的是场景视图。<br>场景视图又称为用例视图， 显示外部参与者观察到的系统功能<br>逻辑视图从系统的静态结构和动态行为角度显示系统内部如何实现系统的功能，对象和对象模型的关系<br>开发视图文称为实现视图，显示的是源代码以及实际执行代码的组织结构，模块的组织管理<br>处理视图又称为过程视图，显示程序执行时并发的状态<br>物理视图展示软件到硬件的映射</p>
<p>125、已有的构件分类方法可以分为三大类，分别是关键字分类法、刻面分类法和超文本组织方法。</p>
<p>关键字分类法：是一种最简单的构件库组织方法， 其基本思想是：根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树状或有向无回路图结构。每个概念用一个描述性的关键字表示。不可分解的原子级关键字包含隶属于它的某些构件。</p>
<p>刻面分类法：在刻面分类机制中，定义若干用于刻画构件特征的“面” （facet），每个面包含若干概念，这些概念表述构件在面上的特征。刻画可以描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征。</p>
<p>超文本组织方法：超文本组织方法与基于数据库系统的构件库组织方法不同， 它基于全文检索技术，主要思想是：所有构件必须辅以详尽的功能或行为说明文档；说明中出现的重要概念或构件以网状链接方式相互连接；检索者在阅读文档的过程中可按照人类的联系思维方式任意跳转到包含相关概念或构件的文档；全文检索系统将用户给出的关键字与说明文档中的文字进行匹配，实现构件的浏览式检索。</p>
<p>126、基于架构的软件设计 （ABSD） 强调由商业、质量和功能需求的组合驱动软件架构设计。</p>
<p>使用ABSD方法， 设计活动可以从项目总体功能框架明确就开始，并且设计活动的开始并不意味着需求抽取和分析活动可以终止， 而是应该与设计活动并行。<br>ABSD方法有三个基础：</p>
<p>第一个基础是功能分解，在功能分解中使用已有的基于模块的内聚和耦合技术。</p>
<p>第二个基础是通过选择体系结构风格来实现质量和商业需求。</p>
<p>第三个基础是软件模板的使用。ABSD方法是一个自顶向下，递归细化的过程，软件系统的架构通过该方法得到细化， 直到能产生软件构件的类。</p>
<p>127、由于Web服务在数据传输方面具有协议分层的特征，即底层协议会包装上层协议 （HTTP协议体中包含整个SOAP消息内容），因此需要数据内容的逐步分解与分阶段处理。比较选项中的架构风格，由于管道一过滤器的架构风格支持分阶段数据处理</p>
<p>128、 该软件系统特别强调用户定义系统中对象的关系和行为这一特性，这需要在软件架构层面提供一种运行时的系统行为定义与改变的能力，根据常见架构风格的特点和适用环境，可以知道最合适的架构设计风格应该是解释器风格</p>
<p>129、根据题目描述， 调温器需要实时获取外界的温度信息， 并与用户定义的温度进行比较并作出动作。根据该系统的应用领域实际需求， 可以看出这是一个典型的过程控制架构风格的应用场景</p>
<p>130、分布式表示架构是将表示层和表示逻辑层迁移到客户机， 应用逻辑层、数据处理层和数据层仍保留在服务器上；</p>
<p>分布式数据架构是将数据层和数据处理层放置于服务器，应用逻辑层、表示逻辑层和表示层放置于客户机；</p>
<p>分布式数据和应用架构数据层和数据处理层放置在数据服务器上，应用逻辑层放置在应用服务器上， 表示逻辑层和表示层放置在客户机。</p>
<p>131、管道过滤器风格常常用于实现编译器。以规则为中心的虚拟机风格适合于实现专家系统。黑板风格适合于自然语言处理、语音处理、模式识别、图像处理。</p>
<p>132、系统架构的给出必须建立在需求明确的基础上</p>
<p>133、横向重用是指重用不同应用领域中的软件元素，例如数据结构、分类算法和人机界面构建等。标准函数是一种典型的、原始的横向重用机制<br>纵向重用是指在一类具有较多公共性的应用领域之间进行软部件重用。纵向重用活动的主要关键点是域分析：根据应用领域的特征及相似性预测软部件的可重用性</p>
<p>134、需要将现有的业务功能进行多种组合，形成新的业务功能。而解释器在程序语言定义的计算和有效硬件操作确定的计算之间建立对应的联系。通过一个解析引擎进行解释和执行。所以可以用到解释器风格。</p>
<p>135、架构风格往往是从全局的角度来考虑问题，他是一种独立于实际问题的通用组织纪构，设计模式着眼于解决某一特定的局部问题，是一种局部解决方案的应用</p>
<p>136、ABSDM模型把整个基于体系结构的软件过程划分为体系结构需求、设计、文档化、复审、实现和演化等6个过程</p>
<p>137、特定领域软件架构（DSSA）是在一个特定应用领域为一组应用提供组织结构参考的标准软件架构。实施DSSA的过程中包括一系列基本的活动，其中领域设计活动的主要目的是为了获得DSSA。该活动参加人员中，领域专家的主要任务是提供关于领域中系统的需求规约和实现的知识</p>
<p>138、软件元素包括需求分析文档、设计过程、设计文档、程序代码、测试用例领域知识等</p>
<p>139、语音识别系统是一个十分典型的专家系统， 其特点是求解的正确结果不止一个，求解过程比较复杂， 需要通过专家知识和反馈逐步得到正确结果。因此对比4个候选项  黑板结构特别适合求解这类问题</p>
<p>140、现代编译器的集成开发环境一般采用数据仓储（即以数据为中心的架构风格）架构风格进行开发，其中心数据就是程序的语法树。</p>
<p>141、ATAM被分为四个主要的活动领域 （或阶段），分别是场景和需求收集、体系结构视图和场景实现、属性模型构造和分析、折中。</p>
<p>142、体系结构权衡分析方法 (Architecture TradeoffAnalysisMethod,ATAM） 是在SAAM的基础上发展起来的，主要针对性能、 可用性、 安全性和可修改性， 在系统开发之前，对这些质量属性进行评价和折中。</p>
<p>143、ADL即架构描述语言，其基本构成要素包括：组件、组件接口、 连接件、架构配置。</p>
<p>144、软件系统架构是关于软件系统的结构、行为和属性的高级抽象。在描述阶段，主要描述直接构成系统的抽象组件以及各个组件之间的连接规则， 特别是相对细致地描述组件之间的交互关系。在实现阶段，这些抽象组件被细化为实际的组件，比如具体类或者对象。软件系统架构不仅指定了软件系统的组织结构和拓扑结构， 而且显示了系统需求和构成组件之间的对应关系，  包括设计决策的基本方法和基本原理。</p>
<p>145、中间件基本功能包括，为客户机和服务器提供连接和通信，提供交易管理机制保证交易的一致性，提供应用的负载均衡和高可用性。</p>
<p>146、采用闭环结构的软件通常由几个协作构件共同构成，且其中的主要构件彼此分开能够进行替换与重用，但闭环结构通常适用于处理简单任务 （如机器装配等），并不适用于复杂任务。分层结构的特点是通过引入抽象层，在较低层次不确定的实现细节在较高层次会变得确定，并能够组织层间构件的协作，系统结构更加清晰</p>
<p>147、其中敏感点是实现一个特定质量属性的关键特征，该特征为一个或多个软件构件所共有。系统权衡点会影响一个或多个属性，并对于多个属性来说都是敏感点。基于该定义</p>
<p>148、Ping/Echo主要提高系统的可用性； </p>
<p>限制访问主要提高系统的安全性；</p>
<p>运行时注册主要提高系统的可修改性；</p>
<p>接口-实现分离主要提高系统的可修改性；</p>
<p>主动余提高系统的可用性；</p>
<p>队列调度主要提高系统的性能；</p>
<p>信息隐藏主要提高系统的可修改性，可测试性，可移植性；</p>
<p>记录-回放主要提高系统的可测试性，</p>
<p>149、从题干中*提高加密级别可以提高安全性，但可能要耗费更多的处理时间， 影响系统性能。”可以看出改变加密级别可能会对安全性和性能这两个质量属性产生非常重要的影响，注意题目的属性影响的个数</p>
<p>150、系统构件组装分为三个不同的层次：定制 （Customization）、集成（integration）、扩展 （Extension）。这三个层次对应于构件组装过程中的不同任务。</p>
<p>151、J2EE应用系统支持五种不同类型的构件模型：Applet、  Servlet、JSP、  EJB、  Application Client</p>
<p>152、IDL是一种接口定义语言，具体的定义会涉及接口以及相关部分。文件包含的主要元素有：接口描述、模块定义、类型定义、常量定义、异常、值类型。接口描述是IDL文件中最核心的内容。所以IDL的数据类型要与实现语言进行映射。以Java为例，IDL接口映射为Java类， 而该接口的操作映射为相应的成员函数。模块定义映射为Java语言中的包 （Package） 或C++中的Namespace</p>
<p>153、构件是一组通常需要同时部署的原子构件。构件和原子构件之间的区别在于，大多数原子构件永远都不会被单独部署，尽管它们可以被单独部署。相反，大多数原子构件都属于一个构件家族，一次部往往涉及整个家族。<br> 一个原子构件是一个模块和一组资源。<br>原子构件是部署、版本控制和替换的基本单位。原子构件通常成组地部署，但是它也能够被单独部署。</p>
<p>一个模块是不带单独资源的原子构件 （在这个严格定义下Java包不是模块一一在Java中部署的原子单元是类文件。一个单独的包被编译成多个单独的类文件一一每个公共类都有一个）模块是一组类和可能的非面向对象的结构体，比如过程或者函数。</p>
<p>154、在构件组装阶段失配问题主要包括<br>   （1） 由构件引起的失配，包括由于系统对构件基础设施、构件控制模型和构件数据模型的假设存在冲突引起的失配；<br>     （2） 由连接子引起的失配，包括由于系统对构件交互协议、连接子数据模型的假设存在冲突引起的失配；<br>     （3） 由于系统成分对全局体系结构的假设存在冲突引起的失配等。要解决失配问题， 首先需要检测出失配问题，并在此基础上通过适当的手段消除检测出的失配问题。</p>
<p>155、项目管理，变更控制过程：</p>
<p>①可以定义变更请求的数据项。<br>2可以定义变更请求生存期的状态转换图。<br>3可以加强状态转换图使经授权的用户仅能作出所允许的状态变更。<br>④记录每一种状态变更的数据，确认作出变更的人员。<br>5可以定义在提交新请求或请求状态被更新后应该自动通知的设计人员。<br>6可以根据需要生成标准的或定制的报告和图表。</p>
<p>156、项目时间管理中的过程包括：活动定义、活动排序、活动的资源估算、活动历时估算、制定进度计划以及进度控制。</p>
<p>157、为了得到工作分解结构 （Work Breakdown StructureWBS） 中最底层的交付物必须执行一系列的活动。对这些活动的识别以及归档的过程就是活动定义<br>鱼骨图（也称为lshikawa图） 是一种发现问题“根本原因”的方法， 通常用来进行因果分析。</p>
<p>158、成本估算工具就是一种典型的项目管理工具，项目管理工具不能指导设计工作</p>
<p>159、配置项是构成产品配置的主要元素， 配置项主要有以下两大类：<br>  （1） 属于产品组成部分的工作成果：如需求文档、设计文档、源代码和测试用例等；<br>  （2） 属于项目管理和机构支撑过程域产生的文档：如工作计划、项目质量报告和<br>项目跟踪报告等。</p>
<p>160、产品配置是指一个产品在其生命周期各个阶段所产生的各种形式 （机器可读或人工可读） 和各种版本的文档、计算机程序、部件及数据的集合。该集合中的每一个元素称为该产品配置的一个配置项，而工具操作手册是指导升发人员使用CASE工具操做升发的一个说明文档， 它与软件产品并无直接关联，不是配置项</p>
<p>161、软件质量保证是软件质量管理的重要组成部分。软件质量保证主要是从软件产品的过程规范性角度来保证软件的品质。其主要活动包括：质量审计 （包括软件评审和过程分析。</p>
<p>162、规划质量管理 提供了指导，以及如何在整个项目中管理和验证质量。</p>
<p>163、项目范围定义是生产项目计划的基础 ，在整个项目的生命周期中，会有多轮的精化，在进行其他方面分计划制定时，范围是基础。</p>
<p>164、控制图用于确定一个过程是否稳定，或者是否具有可预测的绩效。。控制图可用于监测各种类型的输出变量。虽然控制图最常用来跟踪批量生产中的重复性活动，但也可用来监测成本与进度偏差、产量、范围变更频率或其他管理工作成果，以便帮助确定项目管理过程是否受控。</p>
<p>165、HarmonyoS系统架构整体上遵从分层设计，从下向上分为内核层、系统服务层、框架层和应用层。HarmonyOS系统功能按照“系统-&gt;子系统-&gt;功能/模块”逐步逐级展开，在多设备部署场景下，支持根据实际需求裁剪或增加子系统或功能/模块。</p>
<p>内核层：鸿蒙系统分为内核子系统和驱动子系统。在内核子系统中鸿蒙系统采用多为核设计，支持针对不同资源受限设备选用合适的OS内核；鸿蒙系统驱动框架是鸿蒙系统硬件生态开放的基础，它提供统一外设访问能力和驱动开发、管理框架</p>
<p>系统服务层：系统服务层是鸿蒙系统的核心能力集合，通过框架层对应用程序提供服务。包含了系统基本能力子系统集、基础软件服务子系统集、增强软件服务子系统集、硬件服务子系统四个部分。<br>框架层：框架层为鸿蒙系统应用程序提供Java/c/C++/JS等多语言用户程序框架和Ability框架，及各种软硬件服务对外开放的多语言框架API，也为搭载鸿蒙系统的电子设备提供C/C++/JS等多语言框架API<br>应用层：应用层包括系统应用和第三方非系统应用，鸿蒙系统应用由一个或多个FA或PA组成。</p>
<p>系统安全：在搭载鸿蒙系统的分布式终端上课保证正确的人通过正确的电子设备正确地使用数据。通过分布式多段协同身份认证保证“正确的人”通过在分布式终端构筑可信运行环境保证“正确的电子设备”通过分布式数据在跨终端流动的过程中对数据进行分类分级管理来保证“正确地使用数据”</p>
<p>166、AI芯片主要有三种技术架构<br>第一种是GPU， 可以高效支持AI应用的通用芯片，但是相对于FPGA和ASIC来说价格和功耗过高<br>第二种是FPGA（现场可编程门阵列），可对芯片硬件层进行编程和配置，实现半定制化， 相对于GPU有更低的功耗<br>第三种是ASIC（专用集成电路），，专门为特定的AI产品或者服务而设计，主要是侧重加速机器学习（无其是神经网络、深度学习），它针对特定的计算网络结构采用了硬件电路实现的方式，  能够在很低的功耗下实现非常高的能效比，这也是自前A芯片中最多的形式。</p>
<p>167、POP3：110端口， 邮件收取<br>SMTP:25端口， 邮件发送<br>HTTP: 80端口，超文本传输协议，网页传输<br>IMAP：143端口，邮件客户端可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等</p>
<p>168、可靠性：指在规定的时间内和规定条件下能有效地实现规定功能的能力。它不仅取决于规定的使用条件等因素， 还与设计技术有关。常用的度量指标主要有故障率（或失效率）、平均失效等待时间、平均失效间隔时间和可靠度等。</p>
<p>其中，可靠度是系统在规定工作时间内无故障的概率。</p>
<p>可用性是系统能够正常运行的时间比例。经常用两次故障之间的时间长度或出现故障时系统能够恢复正常的速度来表示<br>可测试性：是指验证软件程序正确的难易程度。可测试性好的软件，通常意味看软件设计简单，复杂性低。因为软件的复杂性越大， 测试的难度也就越大。</p>
<p>可理解性：通过阅读源代码和相关文档  了解程序功能及其如何运行的容易程度。</p>
<p>169、DCMM定义了数据战、数据治理、数据架构、数据应用、数据安全、 数据质量、数据标准和数据生存周期等8个核心能力域，细分为28个过程域和445条能力等级标准，</p>
<p>将企业数据管理能力成熟度划分为五个等级， 自低向高依次为： 初始级（1级）、受管理级（2级）、稳健级（3级） 量化管理级（4级）和优化级（5级）。</p>
<p>170、在一个分布式系统中，中间件通常提供两种不同类型的支持：</p>
<p>1、交互支持，中间件协调系统中的不同组件之间的交互。</p>
<p>2、提供公共服务，即中间件提供对服务的可复用的实现。这些服务可能会被分布式系统中的很多组件所需要。公共服务是指被不同组件需求的服务，不管这些组件的功能是什么。这些服务，你可以把这些服务看做是中间件容器提供的。可以在这个容器中部署你的组件并且这些组件可以访问和使用这些公共服务。</p>
<p>171、配置管理工具的常见功能包括版本控制、变更管理、配置状态管理，访问控制和安全控制等。配置管理工具是包含了版本控制工具的。版本控制工具用来存储、更新、恢复和管理有个软件的多个版本</p>
<p>172、UML2.0基础结构的设计目标是定义一个元语言的核心 LnfrastructureLibrary通过对此核心的复用，除了可以定义一个自展的UML元模型， 也可以定义其他元模型，包括MOF和CWM （CommonWarehouseModel， 公共仓库模型）。</p>
<p>由于共用核心库， 所以UML和MOF、CWM在体系结构上更加一致。同时，InfrastructureLibrary还提供了定制UML更强有力的机制，允许用户定义针对不同平台 （如.NET、、J2EE等） 和领域 （如电信、金融、系统工程） 的语言。</p>
<p>173、序列图 （顺序图） 是用来显示参与者如何以一系列顺序的步骤与系统的对象交互的模型。</p>
<p>顺序图可以用来展示对象之间是如何进行交互的。顺序图将显示的重点放在消息序列上， 即强调消息是如何在对象之间被发送和接收的， 其中循环、选择等复杂交互使用序列片段表示，</p>
<p>对象之间的消息类型包括同步消息、异步消息、返回消息、参与者创建消息、参与者销毁消息，</p>
<p>同步消息的发送者等待消息接收对象将消息处理完成后再继续，</p>
<p>异步消息的发送者在发送完消息后不等待接收方就继续自己的处理。</p>
<p>返回消息是指当一个对象将消息发送给另一个对象后，另一个对象返回的虚线有向边， 表示原消息已处理的消息。</p>
<p>创建消息是表示对消息传递目标对象的创建。</p>
<p>销毁消息是表示对消息传递目标对象的删除。</p>
<p>174、构件的定义<br>定义1：软件构件是一种组装单元， 它具有规范的接口规约和显式的语境依赖。软件构件可以被独立地部署并由第三方任意地组装。<br>定义2： 构件是某系统中有价值的、几乎独立的并可替换的一个部分，它在良好定义的体系构语境内满足某清晰的功能。<br>定义3：构件是一个独立发布的功能部分，可以通过其接口访问它的服务。<br>构件的特性<br>1、独立部署单元<br>2、作为第三方的组装单元<br>3、没有（外部的） 可见状态。构件的特性只有以上三点</p>
<p>175、关于服务端构件模型的典型解决方案包括适用于应用服务器的EJB模型（Sun公司J2EE的一部分）和COM+模型（微软公司）， 以及适用于Web服务器的servlet模型（基于Sun公司JSP技术）和VisualBasic及其他技术（基于微软公司ASP技术）微软的NET框架还引入了一种新的同时适用于客户端和服务端的基于CL（CommandLineInterface）的构件模型。</p>
<p>176、基于架构的软件设计（Architecture-BasedSoftwareDesign，ABSD方法强调由<strong>商业、质量和功能需求</strong>的组合驱动软件架构设计。ABSD是  个<strong>自顶向下，递归细化</strong>的软件开发方法，软件系统的体系结构通过该方法得到细化，  直到能产生<strong>软件构件和</strong>类。它以软件系统功能的分解为基础，通过选择架构风格实现质量和商业需求，并强调在架构设计过程中使用软件架构模板。</p>
<p>ABSD方法有三个基础：</p>
<p>第一个基础是功能分解，在功能分解中使用已有的基于模块的内聚和耦合技术。</p>
<p>第二个基础是通过选择体系结构风格来实现质量和商业需求。</p>
<p>第三个基础是软件模板的使用。所以第一空答案为B选项， 第二空答案也为B选项</p>
<p>177、软件架构复用的类型包括机会复用和系统复用，机会复用是指开发过程中，只要发现有可复用的资产，就对其进行复用。系统复用是指在开发之前，就要进行规划，以决定哪些需要复用。</p>
<p>178、特定领域软件架构（Domain SpecificSoftwareArchitecture，DSSA）以一个特定问题领域为对象，形成由领域参考模型、参考需求、参考架构等组成的开发基础架构，其目标是支持一个特定领域中多个应用的生成。</p>
<p>DSSA的基本活动包括领域分析、领域设计和领域实现。</p>
<p>其中领域分析的主要目的是获得领域模型</p>
<p>领域模型描述领域中系统之间共同的需求，即领域需求：</p>
<p>领域设计的主要目标是获得DSSA，DSSA描述领域模型中表示需求的解决方案：</p>
<p>领域实现的主要目标是依据领域模型和DSSA开发和组织可重用信息，并对基础软件架构进行实现。</p>
<p>179、场景 （scenarios）：在进行体系结构评估时，一般首先要精确地得出具体的质量目标，并以之作为判定该体系结构优劣的标准。为得出这些自标而采用的机制叫做场景。场景是从<strong>风险承担者</strong>的角度对与系统的交互的简短描述。</p>
<p>在体系结构评估中一般采用刺激 （stimulus）、环境 （environment） 和响应 （response） 三方面来对场景进行描述。</p>
<p>180、项目管理问题：赶工最短天数，最少费用</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/30.jpg" alt="1"></p>
<p>先根据依赖关系得到关键路径的天数ACD是12天</p>
<p>然后计算：总成本=直接成本+间接成本</p>
<p>总成本是10+15+12+18=55万元，加上关键路径的天数x间接成本，12x5=60，总共是115</p>
<p>赶工的必要性：每压缩一天工期可以节约间接成本5万元，赶工会增加直接成本，只要赶工增加的成本不超过间接成本就可以安排赶工</p>
<p>赶工是要压缩项目工期，只有压缩关键路径上的才有用</p>
<p>根据关键路径A-C-D （12天），选择代价最小的作业进行压缩，也就是D活动， 当D活动压缩2天之后，  A-C-D工期为10天， 与A-B工期一样；<br>此时关键路径发生了改变，有2条关键路径，分别是A-C-D和A-B，此时若要压缩工期，必须2条路径同时压缩，那么此时的压缩方案有多种：压缩相交结点A， 每天增加直接成本4万元； 同时压缩B和D， 每天增加成本2+2-4万。由于A原本需要3天最少需要1天， 可压缩的空间是2天， B活动原本需要7天最少需要3天， 可压缩空间4天，D活<br>动原本需要5天最少需要2天，  可压缩空间是3天，之前已经对D压缩了2天，也就是说<br>B和D同时压缩的方案，由于D的限制， 还有1天可压缩。<br>此时可压缩方案分别是A压缩2天， B和D同时压缩1天， 项目工期为10-2-1=7天<br>综上：赶工的全部过程如下，  </p>
<p> （1D压缩2天；     （2） A压缩2天；    （3） B和D压缩1天。 </p>
<p>然后计算成本</p>
<p>181、Soc称为片上系统， 它是一个产品，是一个有专用目标的集成电路，其中包含完整系统并有嵌入软件的全部内容。SoC不是一块处理器芯片。同时它又是一种技术，用以实现从确定系统功能开始，到软/硬件划分，并完成设计的整个过程。<br>从狭义角度讲，它是信息系统核心的芯片集成，是将系统关键部件集成在一块芯片上；<br>从广义角度讲，SoC是一个微小型系统，如果说中央处理器（CPU）是大脑，那么SoC就是包括大脑、心脏、眼睛和手的系统。国内外学术界一般倾向将SoC定义为将微处理器、模拟IP核、数字IP核和存储器 （或片外存储控制接口） 集成在单一芯片上， 它通常是客户定制的， 或是面向特定用途的标准产品。  </p>
<p>182、基于网络的数据库系统 （NetwareDatabaseSystemNDB） 是基于4G/5G的移动通信之上，主要由客户端、 通信协议和远程服务器等三部分组成。NDB的客户端主要负责提供接口给嵌入式程序，在逻辑上可以把嵌入式设备看作远程服务器的一个客户端；通信协议负责规范客户端与远程服务器之间的通信；远程服务器负责维护服务器上的数据库数据。<br>基于文件的数据库一般以文件方式存储数据库数据。即数据按照一定格式储存在磁盘中这里描述的是基于文件的数据库的定义而不是基于网络的数据库系统。</p>
<p>183、信息化需求包含3个层次， 即战略需求、运作需求和技术需求<br>战略需求。组织信息化的目标是提升组织的竞争能力、为组织的可持续发展提供一个支持环境。从某种意义上来说，信息化对组织不仅仅是服务的手段和实现现有战路的辅助工具：信息化可以把组织战略提升到一个新的水平，为组织带来新的发展契机。特别是对于企业，信息化战略是企业竞争的基础。<br>运作需求。组织信息化的运作需求是组织信息化需求非常重要且关键的一环，它包含三方面的内容：<br>一是实现信息化战略目标的需要；<br>二是运作策略的需要。<br>三是人才培养的需要。<br>技术需求。由于系统开发时间过长等问题在信息技术层面上对系统的完善、升级、集成和整合提出了需求。也有的组织，原来基本上没有大型的信息系统项目，有的也只是一些单机应用，这样的组织的信息化需求，一般是从头开发新的系统。</p>
<p>184、根据软件产品管理办法第一章第四条：软件产品的开发、生产、销售、进出口等活动应遵守我国有关法律、法规和标准规范。任何单位和个人不得开发、生产、销售、进出口含有以下内容的软件产品<br>一）侵犯他人知识产权的：<br>二）含有计算机病毒的：<br>（三）可能危害计算机系统安全的<br>四）含有国家规定禁止传播的内容的<br>五）不符合我国软件标准规范的。<br>可以开发未经国家正式批准的软件。其中进口软件，是指在我国境外开发，以各种形式在我国生产、经营的软件产品</p>
<p>185、需求跟踪是将单个需求和其他系统元素之间的依赖关系和逻辑联系建立跟踪 这些元素包括各种类型的需求、业务规则、系统架构和构件、源代码、测试用例 以及帮助文件等。需求跟踪一般采用需求跟踪矩阵做跟进工作，跟踪矩阵将从需求源头一直跟进到最终的软件产品。</p>
<p>186、UML2.0中一共定义了14种图。<br>其中结构图 （静态图） 包括：用例图、类图、对象图、构件图、部署图、制品图、包图、组合结构图；</p>
<p>行为图 （动态图） 包括：顺序图、通信图 （协作图）、定时图、交互概览图、活动图、状态图。</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/32.jpg" alt="1"></p>
<p>用例图：静态图，展现了一组用例、参与者以及它们之间的关系。用例图中的参与者是人、硬件或其他系统可以扮演的角色;用例是参与者完成的一系列操作，用例之间的关系有扩展(extend)、包含(include)、泛化</p>
<p>类图：静态图，为系统的静态设计视图，展现一组对象、接口、协作和它们之间的关系</p>
<p>状态图：动态图，展现了一个状态机，描述单个对象在多个用例中的行为，包括简单状态和组合状态。转换可以通过事件触发器触发，事件触发后相应的监护条件会进行检查。状态图中转换和状态是两个独立的概念，如下：图中方框代表状态，箭头上的代表触发事件，实心圆点为起点和终点</p>
<p>活动图：动态图，是一种特殊的状态图，展现了在系统内从一个活动到另一个活动的流程。活动的分岔和汇合线是一条水平粗线。牢记下图中并发分岔、并发汇合、监护表达式、分支、流等名词及含义。每个分岔的分支数代表了可同时运行的线程数。活动图中能够并行执行的是在一个分岔粗线下的分支上的活动</p>
<p>序列图：即顺序图，动态图，是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。</p>
<p>• 同步消息（进行阻塞调用，调用者中止执行，等待控制权返回，需要等待返回消息，用实心三角箭头表示）</p>
<p>• 异步消息（发出消<strong>息后继</strong>续执行，不引起调用者阻塞，也不等待返回消息，由空心箭头表示）</p>
<p>• 返回消息（由从右到左的虚线箭头表示）</p>
<p>通信图：动态图，即协作图，强调参加交互的对象的组织。</p>
<p>187、COM不支持任何形式的实现继承<br>COM支持两种形式的对象组装：包含  Containment 和聚集 (Aggregation）<br>包含是一个对象拥有指向另一个对象的唯一引用。外部对象只是把请求转发给内部对象，所请转发就是调用内部对象的方法。<br>包含能重用内含于其他构件的实现，是完全透明的<br>如果包含层次较深， 或者被转发的方法本身相对简单，包含会存在性能上的问题因此COM定义第二类重用形式， 聚集。<br>聚集直接把内部对象接口引用传给外部对象的客户，而不是再转发请求。保持透明性是很重要的，因为外部对象的客户无法别哪个特定接口是从内部对象聚集而来的。</p>
<p>188、改编、翻译、注释、整理已有作品而产生的作品，其著作权由改编、翻译、注释、整理人享有，但行使著作权时不得侵犯原作品的著作权<br>B选项职务作品的作权不一定归属于企业法人，有可能归属于个人， 企业有优先使用权。<br>C选项委托作品的著作权可以由合同约定归属人，不一定都归属于委托人。<br>D选项合作作品的著作权归属于所有参与人不含组织创作的人。</p>
<p>189、三点估算法的公式是“活动历时均值（或估计值，期望值）=（乐观估计+4×最可能估计+悲观估计）/6</p>
<p>来计算项目作业完成期望天数，乐观估计5天，最多14天，保守17天，得到期望天数13天</p>
<p>190、软件开发生命周期（新版本）：</p>
<p>• 需求分析</p>
<p>• 软件设计</p>
<p>• 软件开发</p>
<p>• 运行维护</p>
<p>• 淘汰</p>
<p>软件系统工具通常可以按软件过程活动将软件工具分为软件开发工具、软件维护工具、软件管理和软件支持工具。</p>
<p>• 软件开发工具：需求分析工具、设计工具、编码与排错工具、测试工具等。</p>
<p>• 软件维护工具：版本控制工具、文档分析工具、开发信息库工具、逆向工程工具、再工程工具。</p>
<p>• 软件管理和软件支持工具：项目管理工具、配置管理工具、软件评价工具、软件开发工具的评价和选择。</p>
<p>191、软件活动主要如下一些。</p>
<p>软件描述。必须定义软件功能以及使用的限制。</p>
<p>软件开发。也就是软件的设计和实现，软件工程人员制作出能满足描述的软件。</p>
<p>软件有效性验证。软件必须经过严格的验证，以保证能够满足客户的需求。</p>
<p>软件进化。软件随着客户需求的变化不断改进。</p>
<p>192、(1)逻辑视图。逻辑视图也称为设计视图，它表示了设计模型中在架构方面具有重要意义的部分，即类、子系统</p>
<p>、包和用例实现的子集。主要支持系统的功能需求，即系统提供给最终用户的服务</p>
<p>(2)进程视图。进程视图是可执行线程和进程作为活动类的建模,它是逻辑视图的一次执行实例，描述了并发与同步结构。</p>
<p>(3)实现视图。实现视图对组成基于系统的物理代码的文件和构件进行建模。<strong>也叫开发视图</strong></p>
<p>(4)部署视图。部署视图把构件部署到一组物理节点上，表示软件到硬件的映射和分布结构。<strong>也叫物理视图</strong></p>
<p>(5)用例视图。用例视图是最基本的需求分析模型。<strong>也叫场景</strong></p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/31.jpg" alt="1"></p>
<p>194、(1)对象:由数据及其操作所构成的封装体，是系统中用来描述客观事务的一个实体，是构成系统的一个基本单位。一个对象通常</p>
<p>可以由对象名、属性和方法3个部分组成。</p>
<p>(2)类:现实世界中实体的形式化描述，类将该实体的属性（数据）和操作(函数）封装在一起。对象是类的实例，类是对象的模板。</p>
<p>类可以分为三种:实体类、接口类(边界类）和控制类。</p>
<p>实体类（Entity Class）：</p>
<p>实体类就像是描述真实世界中的事物一样。想象你在做一个图书馆管理系统，每本书都是一个实体，每本书都有自己的属性，</p>
<p>比如书名、作者和出版年份。在这个例子中，每本书就是一个实体类，它们描述了真实世界中的图书。</p>
<p>接口类（Interface Class，边界类）：</p>
<p>接口类就像是设定规则的地方，它定义了系统如何与外部世界进行交互。想象你在设计一个游戏，你需要一个玩家登录的功能</p>
<p>。这时候，你可以创建一个登录界面的接口，规定了登录应该有的方法和行为。这个接口就像是一份使用说明书，告诉其他部</p>
<p>分如何与登录界面进行通信。</p>
<p>控制类（Control Class）：</p>
<p>控制类就像是系统的大脑，它们负责协调和管理不同的活动。假设你正在开发一个点餐系统，你需要一个地方来处理用户下单</p>
<p>的过程。这时候，你可以创建一个点餐处理的控制类，它会负责接收用户的点餐请求，检查库存，然后通知厨房开始准备食物</p>
<p>。这个控制类就像是一个调度员，把不同的任务分配给不同的部门来完成。</p>
<p>195、面向对象设计原则：</p>
<p>单一责任原则：这个原则就是让一个类只做一件事情，不要把太多的任务放在一个类里。这样做的好处是，当你需要修改某个功能时，只需要关注一个类，而不用担心影响其他功能</p>
<p>开放封闭原则：这个原则意味着你可以扩展现有的代码，但不需要修改已有的代码。你应该允许新功能的添加，而不会影响到已经运行良好的功能。</p>
<p>里氏替换原则：这个原则强调子类应该能够替换父类而不会影响程序的正确性。换句话说，你应该能够使用子类的实例来替代父类的实例，而不引发错误</p>
<p>依赖倒置原则：这个原则强调抽象应该依赖于细节，而不是相反。高层模块不应该直接依赖于低层模块的细节，而应该通过抽象进行交互。</p>
<p>接口分离原则：这个原则强调客户端不应该被强制依赖它们不需要的方法。接口应该只包含客户端需要的方法，避免造成冗余和不必要的复杂性</p>
<p>196、组合和聚合是部分与整体的关系，组合是部分与整体同生命周期，聚合是不同生命周期，部分不会随着整体的消亡而消失，</p>
<p>组合是强关系，实心菱形， 聚合是弱关系，空心菱形</p>
<p>泛化：一般/特殊的关系，子类和父类之间的关系，空心三角</p>
<p>197、威胁可以看成从系统外部对系统产生的作用而导致系统功能及目标受阻的现象。用脆弱性可以看成是系统内部的薄弱点。脆弱性是客观存在的，但它本身没有实际伤害。B选项“层与层之间引入通信机制势必造成性能下降”是客观存在的系统薄弱点， 而A选项的描述是一种可能性，并不是客观存在的，所以B选项是系统脆弱性的体现。</p>
<p>198、从操作系统中去掉尽可能多的东西，而只留下一个最小的核心，称之为微内核。微内核技术的主要优点如下：<br>统一的接口，在用户态和核心态之间无需进程识别<br>可伸缩性好，能适应硬件更新和应用变化<br>可移植性好，所有与具体机器特征相关的代码，全部隔离在微内核中，如果操作系统要移植到不同的硬件平台上，只需修改微内核中极少代码即可<br>实时性好，微内核可以方便地支持实时处理<br>安全可靠性高，微内核将安全性作为系统内部特性来进行设计，对外仅使用少量应用编程接口。<br>支持分布式系统，支持多处理器的体系结构和高度并行的应用程序<br>微内核的缺点：</p>
<p>一是难以进行良好的整体优化，</p>
<p>二是进程间互相通信的开销大、内核功能代码不能被相互调用而带来服务的效率低。但总体而言，微内核在效率上的损小于其在结构上获得的收益</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><h4 id="架构风格"><a href="#架构风格" class="headerlink" title="架构风格"></a>架构风格</h4><p>1、<img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/6.jpg" alt="1"></p>
<p>2、<img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/7.jpg" alt="1"></p>
<h5 id="面向数据流风格的优缺点"><a href="#面向数据流风格的优缺点" class="headerlink" title="面向数据流风格的优缺点"></a>面向数据流风格的优缺点</h5><ol>
<li><strong>并行处理</strong>：面向数据流架构支持数据的并行处理，可以有效利用多核处理器和分布式系统的优势，提高系统的性能和吞吐量。</li>
<li><strong>实时处理</strong>：数据流架构适合实时处理场景，能够及时响应和处理数据流，适用于需要快速处理大量数据的应用。</li>
<li><strong>灵活性</strong>：数据流架构具有较高的灵活性，能够根据需求动态调整数据流的处理逻辑，适应不同的业务场景和需求变化。</li>
<li><strong>容错性</strong>：数据流架构通常具有较好的容错性，能够处理数据流中的异常情况，并具备一定程度的容错和恢复机制。</li>
<li><strong>资源利用率</strong>：数据流架构可以根据需求动态分配资源，提高资源的利用率，避免资源浪费和性能瓶颈。</li>
</ol>
<h5 id="面向对象风格的优缺点"><a href="#面向对象风格的优缺点" class="headerlink" title="面向对象风格的优缺点"></a>面向对象风格的优缺点</h5><ol>
<li><strong>模块化和可重用性</strong>：面向对象架构通过将系统分解为独立的对象，提高了模块化和组件化能力，使得代码更易于理解、维护和重用。</li>
<li><strong>封装性</strong>：对象封装了数据和行为，隐藏了内部实现细节，提供了良好的抽象层，使得对象可以独立地被使用和修改，增强了系统的安全性和可靠性。</li>
<li><strong>继承和多态</strong>：继承和多态是面向对象编程的两个重要特性，通过继承可以实现代码重用和扩展，通过多态可以实现接口的灵活性和可扩展性。</li>
<li><strong>易于维护和扩展</strong>：面向对象架构使得系统的各个部分相互独立，降低了模块之间的耦合度，使得系统更易于维护和扩展。</li>
<li><strong>可靠性和可重用性</strong>：面向对象编程强调代码的封装性和复用性，提高了代码的可靠性和可重用性，减少了重复编码的可能性。</li>
</ol>
<h5 id="层次架构的优缺点"><a href="#层次架构的优缺点" class="headerlink" title="层次架构的优缺点"></a>层次架构的优缺点</h5><ol>
<li><strong>模块化</strong>：层次架构通过将系统分解为多个独立的层次，提高了系统的模块化程度，使得各个部分相互独立，易于理解、维护和扩展。</li>
<li><strong>可扩展性</strong>：由于各个层次之间的松耦合性，层次架构具有较好的可扩展性，可以方便地添加新的功能或修改现有功能而不影响其他部分。</li>
<li><strong>易于测试</strong>：层次架构将系统分解为多个独立的层次，使得单元测试和集成测试更加容易进行，可以针对每个层次进行测试，保证系统的稳定性和质量。</li>
<li><strong>重用性</strong>：层次架构鼓励代码的重用，各个层次可以独立设计和实现，提高了代码的可重用性，减少了重复编码的可能性。</li>
<li><strong>分工明确</strong>：层次架构将系统分解为不同的层次，每个层次负责特定的功能，使得开发人员可以根据各自的专长和职责进行开发，提高了团队协作效率。</li>
</ol>
<h5 id="以数据为中心的架构风格的优缺点"><a href="#以数据为中心的架构风格的优缺点" class="headerlink" title="以数据为中心的架构风格的优缺点"></a>以数据为中心的架构风格的优缺点</h5><ol>
<li><strong>数据一致性</strong>：以数据为中心的架构风格可以确保数据的一致性，因为所有的业务逻辑都围绕着数据进行操作，避免了数据的分散和冗余。</li>
<li><strong>易于维护和管理</strong>：将数据放在系统设计的核心位置，使得系统的维护和管理更加简单，因为所有的操作都是围绕数据展开的，易于追踪和调试问题。</li>
<li><strong>数据共享</strong>：以数据为中心的架构可以促进数据的共享和重用，不同部分的系统可以共享同一份数据，避免了数据孤岛效应，提高了数据的利用率。</li>
<li><strong>性能优化</strong>：通过以数据为中心的架构，可以更好地优化数据的存储和访问方式，提高系统的性能和响应速度。</li>
<li><strong>适应复杂数据需求</strong>：对于需要处理复杂数据结构和关系的系统，以数据为中心的架构可以更好地应对这种复杂性，保证数据的完整性和准确性。</li>
</ol>
<h5 id="隐式调用架构风格的优缺点"><a href="#隐式调用架构风格的优缺点" class="headerlink" title="隐式调用架构风格的优缺点"></a>隐式调用架构风格的优缺点</h5><ol>
<li><strong>简化通信</strong>：降低通信复杂度。</li>
<li><strong>松耦合</strong>：各组件间耦合度低，独立演化。</li>
<li><strong>灵活性</strong>：系统更易适应需求变化。</li>
<li><strong>简化开发</strong>：减少开发量，提高效率。</li>
<li><strong>容易维护和修改</strong>：修改一个组件不影响其他组件。</li>
</ol>
<h5 id="解释器架构风格优缺点"><a href="#解释器架构风格优缺点" class="headerlink" title="解释器架构风格优缺点"></a>解释器架构风格优缺点</h5><ol>
<li>灵活性：解释器架构风格可以很容易地添加新的指令和功能，因此非常灵活。这意味着开发人员可以快速地修改和扩展软件，以满足客户的需求。</li>
<li>可移植性：解释器架构不需要编译器来将程序编译成特定平台上的机器码。相反，解释器可以在任何平台上直接运行。这样，开发人员就可以轻松地将应用程序移植到不同的平台上。</li>
<li>交互性：解释器架构非常适合实现交互式应用程序，例如控制台程序和脚本解释器。由于指令可以逐个执行，因此用户可以在执行期间与程序交互，输入或输出数据，或修改程序的行为。</li>
</ol>
<h5 id="基于规则的架构风格的优缺点"><a href="#基于规则的架构风格的优缺点" class="headerlink" title="基于规则的架构风格的优缺点"></a>基于规则的架构风格的优缺点</h5><ol>
<li><strong>灵活性</strong>：规则系统允许系统行为根据规则的变化而灵活调整，适应需求变化。</li>
<li><strong>易于维护和修改</strong>：规则的独立性使得系统的某个方面的修改不会影响整个系统，易于维护和扩展。</li>
<li><strong>逻辑清晰</strong>：规则系统的行为是由一系列规则组成，逻辑清晰，易于理解和管理。</li>
<li><strong>快速开发</strong>：通过定义规则，可以快速开发系统，而不需要从头开始编写代码。</li>
<li><strong>规则重用</strong>：规则可以被重复使用，提高了系统的可维护性和可重用性。</li>
</ol>
<h5 id="BS架构和CS架构的优缺点"><a href="#BS架构和CS架构的优缺点" class="headerlink" title="BS架构和CS架构的优缺点"></a>BS架构和CS架构的优缺点</h5><p>CS：</p>
<p>1、能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器，所以CS客户端响应速度快。</p>
<p>2、操作界面漂亮、形式多样，可以充分满足客户自身的个性化要求。  </p>
<p>3、C/S结构的管理信息系统具有较强的事务处理能力，能实现复杂的业务流程。</p>
<p>4、安全性能可以很容易保证，C/S一般面向相对固定的用户群，程序更加注重流程，它可以对权限进行多层次校验，提供了更安全的存取模式，对信息安全的控制能力很强。一般高度机密的信息系统采用C/S结构适宜。</p>
<p>BS：</p>
<p>1、分布性强，客户端零维护。只要有网络、浏览器，可以随时随地进行查询、浏览等业务处理。 </p>
<p>2、业务扩展简单方便，通过增加网页即可增加服务器功能。  </p>
<p>3、维护简单方便，只需要改变网页，即可实现所有用户的同步更新。 </p>
<p>4、开发简单，共享性强。</p>
<h4 id="CS架构，BS架构，RIA"><a href="#CS架构，BS架构，RIA" class="headerlink" title="CS架构，BS架构，RIA"></a>CS架构，BS架构，RIA</h4><p>两层C/S架构：客户端和服务器都有处理功能，现在已经不常用，原因有：开发成本较高、客户端程序设计复杂、信息内容和形式单一、用户界面风格不一、软件移植困难、软件维护和升级困难、新技术不能轻易应用、安全问题、服务器端压力大难以复用。</p>
<p>三层C/S架构：将处理功能独立出来，表示层和数据层都变得简单。表示层在客户机上，功能层在应用服务器上数据层在数据库服务器上。即将两层C/S架构中的数据从服务器中独立出来了。其优点下面四点：</p>
<p> 各层在逻辑上保持相对独立，整个系统的逻辑结构更为清晰，能提高系统和软件的可维护性和可扩展性；</p>
<p> 允许灵活有效的选用相应的平台和硬件系统，具有良好的可升级性和开放性；</p>
<p> 各层可以并行开发，各层也可以选择各自最适合的开发语言；</p>
<p> 功能层有效的隔离表示层与数据层，为严格的安全管理奠定了坚实的基础，整个系统的管理层次也更加合理和可控制。 </p>
<p>三层C/S架构设计的关键在于各层之间的通信效率，要慎重考虑三层间的通信方法、通信频度和数据量，否则即使分配给各层的硬件能力很强，性能也不高</p>
<p>三层B/S架构：是三层C/S架构的变种，将客户端变为用户客户端上的浏览器，将应用服务器变为网络上的WEB</p>
<p>服务器，又称为0客户端架构，虽然不用开发客户端，但有很多缺点：</p>
<p>• 使用浏览器作为客户端的话安全性难以控制；</p>
<p>• 在数据查询等响应速度上，要远远低于C/S架构，因为C/S架构有部分数据存储在本地；</p>
<p>• 数据提交一般以页面为单位，数据的动态交互性不强。 </p>
<p>混合架构风格</p>
<p>• 内外有别模型：企业内部使用C/S,外部人员访问使用B/S。</p>
<p>• 查改有别模型：采用B/S查询，采用C/S修改。</p>
<p>• 混合架构实现困难，且成本高</p>
<p>富互联网应用RIA：弥补三层B/S架构存在的问题，RIA是一种用户接口，比用HTML实现的接口更</p>
<p>加健壮，且有可视化内容，本质还是网站模式，其优点如下：</p>
<p> RIA结合了C/S架构反应速度快、交互性强的优点与B/S架构传播范围广及容易传播的特性；</p>
<p> RIA简化并改进了B/S架构的用户交互；</p>
<p> 数据能够被缓存在客户端，从而可以实现一个比基于HTML的响应速度更快且数据往返于服务器的次数更少的</p>
<p>用户界面。</p>
<p> 本质还是0客户端，借助于高速网速实现必要插件在本地的快速缓存，增强页面对动态页面的支持能力，典型</p>
<p>的如小程序。</p>
<h4 id="MVC，MVP架构"><a href="#MVC，MVP架构" class="headerlink" title="MVC，MVP架构"></a>MVC，MVP架构</h4><p>MVC：</p>
<p>控制器(Controller) ：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入,并向模型发送数据。</p>
<p>模型(Model)：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。模型表示业务数据和业务逻辑。</p>
<p>视图(View)：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。是用户看到并与之交互的界面。视图向用户显示相关的数据，并能接收用户的输入数据，但是它并不进行在何实际的业务处理：</p>
<p>软件架构设计-MVC架构</p>
<p>MVC分层的好处：</p>
<p>• MVC分层有助于管理复杂的应用程序，因为您可以在一个时间内专门关注一个方面。例如，您可以在不依赖业务逻辑的情况下专注于视图设计。同时也让应用程序的测试更加容易。</p>
<p>• MVC分层同时也简化了分组开发。不同的开发人员可同时开发视图、控制器逻辑和业务逻辑</p>
<p>MVP：</p>
<p>MVP<strong>是把MVC中的Controller换成了Presenter(呈现)，目的就是为了完全切断View跟Model之间的联系，由</strong>Presenter<strong>充当桥梁，做到View-Model之间通信的完全隔离。</strong></p>
<p>MVP特点：</p>
<p> M、V、P之间双向通信。</p>
<p> View 与Model不通信，都通过Presenter传递。Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。</p>
<p> View非常薄，不部署任何业务逻辑，称为”被动视图”(PassiveView)，即没有任何主动性，而Presenter非常厚，所有逻辑都部署在那里。</p>
<p> Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。</p>
<p>MVVM：</p>
<p>MVVM模式和MVC模式类似，主要目的是分离视图(View)和模型(Model)，实现双向绑定，有几大优点：</p>
<p> 低耦合，视图(View)可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p>
<p> 可重用性，可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p>
<p> 独立开发，开发人员可以专注于业务逻辑和数据的开发(ViewModel) ，设计人员可以专注于页面设计。</p>
<p> 可测试，界面向来是比较难于测试的，而现在测试可以针对ViewModel来写。</p>
<h4 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h4><h5 id="结构化分析方法"><a href="#结构化分析方法" class="headerlink" title="结构化分析方法"></a>结构化分析方法</h5><p>结构化特点：自顶向下，逐步分解，面向数据。</p>
<p>三大模型：功能模型(数据流图)、行为模型(状态转换图)、数据模型(E-R图)以及数据字典。</p>
<p>数据字典：数据字典是在DFD的基础上，对DFD中出现的所有命名元素都加以定义，使得每个图形元素的名字都有一个确切的解释。DFD和数据字典等工具相配合，就可以从图形和文字两个方面对系统的逻辑模型进行完整的描述</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/8.jpg" alt="1"></p>
<p>数据流：由一组固定成分的数据组成，表示数据的流向。在DFD中，数据流的流向必须经过加工。</p>
<p>加工：描述了输入数据流到输出数据流之间的变换，数据流图中常见的三种错误如图所示：</p>
<p> 加工3.1 .2有输入但是没有输出，称之为“黑洞”</p>
<p> 加工3.1 .3有输出但没有输入。称之为“奇迹”。</p>
<p> 加工3.1 .1 中输入不足以产生输出，我们称之为“灰洞”。 </p>
<p>数据存储：用来存储数据。</p>
<p>外部实体(外部主体):是指存在于软件系统之外的人员或组织，</p>
<p>它指出系统所需数据的发源地(源)和系统所产生的数据的归宿地(宿)。</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/9.jpg" alt="1"></p>
<h5 id="面向对象分析方法"><a href="#面向对象分析方法" class="headerlink" title="面向对象分析方法"></a>面向对象分析方法</h5><p>面向对象的分析:是为了确定问题域，理解问题。包含五个活动:认定对象、组织对象、描述对象间的相互作用、确定对象的操作、定义对象的内部信息。</p>
<p>面向对象需求建模：</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/10.jpg" alt="1"></p>
<p>依赖:一个事物的语义依赖于另一个事物的语义的变化而变化</p>
<p>关联:是一种结构关系，描述了一组链，链是对象之间的连接。分为组合和聚合，都是部分和整体的关系，其中组合事物之间关系更强，具有共通的生命周期，如果整体不存在，那么部分肯定也不存在，比如人和人的大脑。聚合就是整体和部分没有共同的生命周期，比如大雁和雁群之间的关系。两个类之间的关联，实际上是两个类所扮演角色的关联，因此，两个类之间可以有多个由不同角色标识的关联。</p>
<p>泛化:一般/特殊的关系,子类和父类之间的关系，比如学生和高中生、研究生、大学生的关系</p>
<p>实现:一个类元指定了另一个类元保证执行的契约。</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/11.jpg" alt="1"></p>
<p>UML图：尤其以用例图、类图、活动图、状态图最为重要。用例之间的关系有扩展(extend)、包含(include)、泛化。如下:</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/12.jpg" alt="1"></p>
<p>实体用于数据建模，而类用于面向对象建模。实体只有属性，而类有属性和操作，</p>
<p>Essential Use Cases 可翻译为抽象用例，而Real Use Cases可翻译为基础用例。他们是区别在于：基础用例是实实在在与用户需求有对应关系的用例，是从用户需求获取的渠道得到的，而抽象用例是从基础用例中抽取的用例的公共部分，是为了避免重复工作，优化结构而提出的用例</p>
<p>抽象，封装，基础</p>
<h4 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h4><p>进度安排的常用图形描述方法有：</p>
<p>• Gantt图(甘特图)：反应了任务与任务之间的并行关系。</p>
<p>• 项目计划评审技术(Program Evaluation&amp; Review Technique， PERT)图：反应了任务与任务之间的先后关系(依赖关系)</p>
<p>关键路径：是项目的最短工期，但却是<strong>从开始到结束时间最长的路径</strong>。进度网络图中可能有多条关键路径，因为活动会变化，因此关键路径也在不断变化中。</p>
<p>关键活动：关键路径上的活动，最早开始时间=最晚开始时间。通常，每个节点的活动会有如下几个时间：</p>
<p>(1)最早开始时间(ES)，某项活动能够开始的最早时间。</p>
<p>(2)最早结束时间(EF)，某项活动能够完成的最早时间。EF=ES+工期</p>
<p>(3)最迟结束时间(LF)。为了使项目按时完成，某项活动必须完成的最迟时间。</p>
<p>(4)最迟开始时间(LS)。为了使项目按时完成，某项活动必须开始的最迟时间。LS=LF-工期</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/13.jpg" alt="1"></p>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p>创建型：</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/14.jpg" alt="1"></p>
<p>结构型：</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/15.jpg" alt="1"></p>
<p>行为型：</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/16.jpg" alt="1"></p>
<h4 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h4><h5 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h5><p>• <strong>第一范式：</strong>要求数据库表中的所有字段都是不可分割的原子值<strong>。</strong>通俗地说，第一范式就是表中不允许有小表的存在。</p>
<p>• <strong>第二范式</strong>：在1NF的基础上，要求数据库表中的每个非主属性完全依赖于某一个候选键。通俗地说，就是表中不能存在联合主键</p>
<p>• <strong>第三范式：</strong>在2NF的基础上，要求数据库表中的每个非主属性不依赖于其它非主属性<strong>。</strong>也就是说，数据表中的每一列都和主键直接相关，而不依赖于其它列，即不能存在传递依赖</p>
<p>• <strong>BC范式：</strong>也称之为第三范式的补充范式，在3NF的基础上，要求数据库表中的所有属性都只依赖主键。也就是说，3nf要求每一个非主属性即不传递也不部分依赖于任一个码，而bcnf在此基础上要求主属性也不能传递或部分依赖于码，即：bcnf中不允许有除了码之外的其它元素之间存在任何函数关系</p>
<p>• <strong>第四范式：</strong>在3NF的基础上，要求一个表的主键只对应一个多值<strong>。</strong>例如，学生信息表(学生ID, 住址, 电话号码)，这个表中住址和电话号码表示学生可以有多个，它们与学生存在多值依赖关系。这个表不满足4NF，因为在这个表中，住址和电话号码是独立的多值依赖，这意味着它们各自都直接依赖于学生ID，并且彼此之间是独立的。解决办法有两种，一种是通过程序来控制，二种是拆成两张表，每张表里面只拥有一个多值。</p>
<h5 id="主从与读写分离"><a href="#主从与读写分离" class="headerlink" title="主从与读写分离"></a>主从与读写分离</h5><p>主从数据库架构是一种数据库冗余解决方案，它允许一个数据库服务器（称为“主”服务器）复制数据到一个或多个数据库服务器（称为“从”服务器）。在这种架构中，所有的数据更新操作（如INSERT、UPDATE、DELETE）首先在主服务器上执行，然后这些更改会被同步到从服务器。</p>
<p>特点包括：</p>
<p>• 数据冗余和读取负载均衡：通过部署多个从服务器，可以在从服务器上处理读取请求，从而减轻主服务器的负载。</p>
<p>• 高可用性：如果主服务器失败，可以快速将从服务器提升为新的主服务器，以确保服务继续运行。</p>
<p>• 备份和恢复：从服务器可以用于备份，避免在主服务器上执行备份操作影响性能。</p>
<p>读写分离是数据层面的一种优化工程，目的是将数据库的读操作和写操作分散到不同的服务器上。通常结合主从复制技术一起使用，其中主数据库处理写请求，而从数据库则处理读请求。</p>
<p>主要优势包括：</p>
<p>• 提高并发性能：分开处理读和写操作可以减少锁竞争，提高数据库的并发处理能力。</p>
<p>• 扩展性：能够通过添加更多的从数据库来水平扩展读取能力，适应大量的读请求。</p>
<p>• 降低延迟：读请求可以由最接近用户的服务器处理，减少了数据访问的延迟时间</p>
<p><strong>同步复制</strong>（Synchronous Replication）:在同步复制中，任何对主数据库的写操作都必须在从数据库上完成复制后才能确认完成。这确保了主数据库和从数据库始终保持一致。然而，这种方法可能会增加延迟，因为它要求在返回写操作成功之前，必须等待从数据库确认接收到数据。</p>
<p><strong>半同步复制</strong>（Semi-Synchronous Replication）:半同步复制是同步复制和异步复制之间的折衷方案，其中写操作在主数据库上完成后会立即返回成功，但是主数据库在执行下一个写操作之前必须确保至少一个从数据库已经收到了前一个操作的数据。这可以在保持较低延迟的同时提供较强的数据一致性保证。</p>
<p><strong>多版本并发控制</strong>（MVCC）:使用支持多版本并发控制的数据库系统可以减少读写冲突，每个读操作都可以访问到一致性时间点的数据快照，这样，读操作不会被写操作中的锁所阻塞，同时仍然能保证读取数据的一致性。</p>
<p><strong>事务级别的一致性读取</strong>:使用事务来确保一致性是另一种方法。应用可以启动一个事务，在此事务中进行的读取将会看到写事务的最终结果，即使读取实际上是在从服务器上进行的。</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/17.jpg" alt="1"></p>
<h5 id="数据库分类，缓存技术比较"><a href="#数据库分类，缓存技术比较" class="headerlink" title="数据库分类，缓存技术比较"></a>数据库分类，缓存技术比较</h5><p><strong>内存数据库：将数据库整体存储在内存中，提高性能。</strong></p>
<p> MemCache： Memcache是一个高性能的分布式的内存对象缓存系统，用于动态Web应用以减轻数据库负载。</p>
<p>Memcache通过在内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据，包括图像、规频、文件以及数</p>
<p>据库检索的结果等。</p>
<p> Redis： Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提</p>
<p>供多种语言的API。</p>
<p><strong>Redis与Memcache的差异</strong></p>
<p> Redis和Memcache都是将数据存放在内存中，都是内存数据库。他们都支持key-value数据类型。同时Memcache还可用</p>
<p>于缓存其他东西，例如图片、视频等等，Redis还支持list、set、hash等数据结构的存储。</p>
<p> Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcache相比一个最大的区别。当物理内存用完时，Redis</p>
<p>可以将一些很久没用到的value交换到磁盘。</p>
<p> Redis在很多方面支持数据库的特性，可以这样说他就是一个数据库系统，而Memcache只是简单地K/V缓存</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/18.jpg" alt="1"></p>
<h5 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h5><p>分布式数据库是一种将数据分布在多个节点或计算机上的数据库系统。这些节点通过网络连接，每个节点存储一部分数据，并可以独立运行，具有如下特点：</p>
<p> 可扩展性：分布式数据库可以通过添加更多的服务器（节点）来扩展系统的存储和计算能力。这种水平扩展性使得分布式数据库能够应对大数据量和高并发请求的挑战。</p>
<p> 高可用性和可靠性：由于数据分散存储在多个服务器上，即使其中一台或几台服务器出现故障，其他服务器仍可正常工作。通过备份和冗余策略，分布式数据库可提供更高的数据可用性和可靠性。</p>
<p> 分布式处理：分布式数据库可以并行处理多个查询和事务，提升系统性能，缩短响应时间。</p>
<p> 数据局部性：通过将数据存储在地理接近最常访问它的用户的服务器，分布式数据库可以减少网络延迟，提升性能。</p>
<p> 灵活性：分布式数据库允许在不同的服务器、操作系统和网络环境中存储和处理数据</p>
<h5 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h5><p>数据仓库集成是把多种来源的数据集中在一起，建立数据仓库，所有数据都驻留在单个数据库服务器上，配置大型处理器和存储容量。数据仓库主要用于决策支持，在数据处理过程中强调分析。其特点是：</p>
<p> 集成的数据：数据仓库中的数据来自多个来源，包括交易系统、运营系统、外部数据源等。这些数据经过清洗、整合和转换，使其具有统一的格式、结构和语义。数据集成是数据仓库建设的基础，它可以消除数据冗余和不一致，提高数据质量。</p>
<p> 面向主题：数据按照主题组织，例如销售、客户、产品等。每个主题的数据都存储在一个单独的维度表和事实表中。面向主题的组织方式使数据仓库更加易于理解和使用。</p>
<p> 数据相对稳定：数据一旦被加载，就不会经常更新。数据仓库主要用于分析历史数据，因此数据相对稳定是数据仓库的重要特征</p>
<p> 包含历史信息：数据仓库存储了大量历史数据，这些数据可以用于分析趋势、发现模式和做出决策。历史数据是数据仓库的核心价值所在。 </p>
<p>数据仓库的结构通常包含四个层次：</p>
<p> 数据源：是数据仓库系统的基础，是整个系统的数据源泉。</p>
<p> 数据的存储与管理：是整个数据仓库系统的核心。</p>
<p> OLAP(联机分析处理)服务器：对分析需要的数据进行有效集成，按多维模型组织，以便进行多角度、多层次的分析，并发现趋势。</p>
<p> 前端工具：主要包括各种报表工具、查询工具、数据分析工具、数据挖掘工具以及各种基于数据仓库或数据集市的应用开发工具。 </p>
<p>商业智能：</p>
<p> Bl系统主要包括数据预处理、建立数据仓库、数据分析和数据展现四个主要阶段</p>
<h5 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h5><p>一级封锁协议：事务T在修改数据A之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。 1级封锁协议可防止丢失修改，并保证事务T是可恢复的。在1级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读”脏”数据</p>
<p>二级封锁协议：一级封锁协议的基础上加上事务T2在读数据A之前必须先对其加S锁，读完后即可释放S锁。可解决丢失更新、读脏数据问题。</p>
<p>三级封锁协议：一级封锁协议加上事务T在读取数据A之前先对其加S锁，直到事务结束才释放。可解决丢失更新、读脏数据、数据重复读问题。</p>
<h5 id="反规范化技术"><a href="#反规范化技术" class="headerlink" title="反规范化技术"></a>反规范化技术</h5><p>反规范化技术：规范化设计后，数据库设计者希望牺牲部分规范化来提高性能。</p>
<p>采用反规范化技术的益处：降低连接操作的需求、降低外码和索引的数目，还可能减少表的数目，能够提高查询效率。</p>
<p>具体方法：</p>
<p> 增加冗余列：在多个表中保留相同的列，通过增加数据冗余减少或避免查询时勺连接操作。</p>
<p> 增加派生列：在表中增加可以由本表或其它表中数据计算生成的列，减少查询的连接操作并避免计算或使用集合函数。</p>
<p> 重新组表：如果许多用户需要查看两个表连接出来的结果数据，则把这两个表重新组成一个表来减少连接而提高性能。</p>
<p> 水平分割表：根据一列或多列数据的值，把数据放到多个独立的表中，主要用于表数据规模很大、表中数据相对独立或数据需要存放到多个介质上时使用。</p>
<p> 垂直分割表：对表进行分割，将主键与部分列放到一个表中，主键与其它列放到另一个表中，在查询时减少I/O次数</p>
<p>反规范化技术可能带来的问题：数据的重复存储，浪费了磁盘空间;可能出现数据的完整性问题，为了保障数据的一致性，增加了数据维护的复杂性，会降低修改速度。</p>
<p>反规范化带来的数据不一致性问题主要有以下两种：</p>
<p> 更新异常: 当需要更新冗余数据时，如果更新操作不同步，可能会导致数据不一致。</p>
<p> 插入异常: 当向冗余表中插入新数据时，如果插入操作不符合相关规则，也可能会导致数据不一致。</p>
<p>解决数据不一致性的几种常规解决方案：</p>
<p> 应用触发器: 触发器是一种存储过程，它会在对数据库中的数据进行增、删、改操作时自动执行。可以使用触发器来确保冗余数据的一致性。</p>
<p> 使用并发控制机制: 并发控制机制可以确保多个用户同时对数据库进行操作时数据的安全性一致性。</p>
<p> 采用应用程序逻辑: 应用程序逻辑也可以用来确保冗余数据的一致性。</p>
<p>选择合适的方法：</p>
<p> 在实际应用中，可以根据具体情况选择合适的方法来解决反规范化带来的数据不一致性问题。一般来说，如果数据更新频繁，则可以使用触发器或并发控制机制；如果数据更新不频繁，则可以使用应用程序逻辑</p>
<h5 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h5><p>面向对象编程把所有实体看成对象(object)，关系型数据库则是采用实体之间的关系(relation)连接数据。很早就有人提出，关系也可以用对象表达，这样的话，就能使用面向对象编程，来操作关系型数据库。</p>
<p><strong>ORM把数据库映射成对象。</strong></p>
<p> 数据库的表(table) –&gt;类(class)</p>
<p> 记录(record，行数据)–&gt;对象(object)</p>
<p> 字段(field) –&gt;对象的属性(attribute)</p>
<p><strong>ORM优点：</strong></p>
<p> 使用ORM可以大大降低学习和开发成本。</p>
<p> 程序员不用再写SQL来进行数据库操作。</p>
<p> 减少程序的代码量。</p>
<p> 降低由于SQL代码质量差而带来的影响。</p>
<p><strong>ORM缺点</strong></p>
<p> 不太容易处理复杂查询语句。</p>
<p> 性能教直接用SQL差。</p>
<h4 id="信息系统架构ISA"><a href="#信息系统架构ISA" class="headerlink" title="信息系统架构ISA"></a>信息系统架构ISA</h4><p>信息系统架构(ISA)是指对某一特定内容里的信息进行统筹、规划、设计、安排等一系列有机处理的活动</p>
<p>信息系统架构可分为物理结构与逻辑结构两种，物理结构是指不考虑系统各部分的实际工作与功能结构，只抽象地考察其硬件系统的空间分布情况。</p>
<p>• 逻辑结构是指信息系统各种功能子系统的综合体。</p>
<p>• 物理结构一般分为集中式与分布式两大类。</p>
<p>信息系统常用四种架构模型</p>
<p>• 单机应用模式：是最简单的软件结构，是指运行在一台物理机器上的独立应用程序。单机系统本身也可以很复杂。</p>
<p>• 客户机/服务器模式：即两层、三层C/S、B/S模式、MVC模式等。</p>
<p>• 面向服务架构(SOA)模式。</p>
<p>• 企业数据交换总线：不同的企业应用之间进行信息交换的公共通道</p>
<p>要在企业中建立一个有效集成的ISA，必须考虑企业中的四个方面：</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/19.jpg" alt="1"></p>
<p>1.战略系统：是指企业中与战略制定、高层决策有关的管理活动和计算机辅助系统。</p>
<p>• 在ISA中战略系统由两个部分组成，其一是为以计算机为基础的高层决策支持系统，比如DSS(决策支持系统)，其二是企业的战略规划体系。</p>
<p>• 在ISA中设立战略系统有两重含义：一是它表示信息系统对企业高层管理者的决策支持能力;二是它表示企业战略规划对信息系统建设的影响和要求。</p>
<p>2.业务系统：是指企业中完成一定业务功能的各部分(物质、能量、信息和人)组成的系统。</p>
<p>作用：对企业现有业务系统、业务过程和业务活动进行建模，并在企业战略的指导下，采用业务流程管理(BPM)和业务流程重组(BPR)。</p>
<p>3.应用系统：即应用软件系统，指信息系统中的应用软件部分。如TPS(业务处理系统)、MIS(管理信息系统)等。包含两个基本组成部分：内部功能实现部分和外部界面<strong>部分。</strong></p>
<p><strong>4</strong>.企业信息基础设施(EII)：是指根据企业当前业务和可预见的发展趋势，及对信息采集、处理、存储和流通的要求，构筑由信息设备、通信网络、数据库、系统软件和支持性软件等组成的环境。这里可以将企业信息基础设施分成三部分：技术基础设施、信息资源设施和管理基础设施。</p>
<p>• 技术基础设施：由计算机、网络、系统软件、支持性软件、数据交换协议等组成; </p>
<p>• 信息资源设施：由数据与信息本身、数据交换的形式与标准、信息处理方法等组成; </p>
<p>• 管理基础设施：指企业中信息系统部门的组织结构、信息资源设施管理人员的分工、企业信息基础设施的管理方法与规章制度等。</p>
<h5 id="架构案例"><a href="#架构案例" class="headerlink" title="架构案例"></a>架构案例</h5><p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/36.jpg" alt="1"></p>
<p>信息系统常用四种架构：</p>
<p>1.单机应用系统：单机应用系统是最简单的软件结构，是指运行在一台物理机器上的独立应用程序。当然，该应用可以是多进程或多线程的。</p>
<p>2.两层、多层C/S：C/S 概念可理解为基于TCP/IP 协议的进程间通信IPC 编程的“发送”与“反射”程序结构，即 Client方 向Server方发送一个TCP 或UDP 包，然后Server方根据接收到的请求向 Client方回送TCP 或 UDP 数据包</p>
<p>3.MVC 结构：MVC(Model-View-Controller)的概念在目前信息系统设计中非常流行，严格来讲， MVC实际上是上述多层 C/S 结构的一种常用的标准化模式，或者可以说是从另一个角度去抽象这种多层C/S 结构</p>
<p>4.面向服务的 SOA：上面所论述的客户机/服务器模式，无论多少层的C/S 软件结，对外来讲，都只是一个单结点应用(无论它由多个不同层的“服务”相互配合来完成其功能),具体表现为一个门户网站、一个应用系统等。而多个单点应用相互通信的服务结构也是一种信息系统常用的架构模式。</p>
<h4 id="层次架构"><a href="#层次架构" class="headerlink" title="层次架构"></a>层次架构</h4><p>软件层次式体系结构是<strong>最通用</strong>的架构，也被叫作N层架构模式。大部分的用会分成表现层(或称为展示层)、中间层(或称为业务层)、数据访问层(或称为持久层)和数据层。</p>
<h5 id="表现层框架设计"><a href="#表现层框架设计" class="headerlink" title="表现层框架设计"></a>表现层框架设计</h5><h6 id="UIP"><a href="#UIP" class="headerlink" title="UIP"></a>UIP</h6><p>使用UIP框架的应用程序把表现层分为了以下几层。</p>
<p>• User Interface Components（用户界面组件）：这个组件就是原来的表现层，用户看到的和进行交互都是这个组件，它负责获取用户的数据并且返回结果。</p>
<p>• User Interface Process Components（用户界面过程组件）：这个组件用于协调用户界面的各部分，使其配合后台的活动，例如导航和工作流控制，以及状态和视图的管理。用户看不到这一组件，但是这些组件为User lnterfaceComponents提供了重要的支持功能。</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/37.jpg" alt="1"></p>
<p>UIP的组件主要负责的功能是：</p>
<p> 管理经过User Interface Components 的信息流；</p>
<p> 管理UIP 中各个事件之间的事务；</p>
<p> 修改用户过程的流程以响应异常；</p>
<p> 将概念上的用户交互流程从实现或者涉及的设备上分离出来；</p>
<p> 保持内部的事务关联状态，通常是持有一个或者多个的与用户交互的事务实因此，这些组件也能从U I 组件收集数据，执行服务器的成组的升级或是跟踪UIP中的任务过程的管理。</p>
<h6 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h6><p>基于 XML界面管理技术，包括界面配置、界面动态生成和界面定制三部分</p>
<p> 界面配置是对用户界面的静态定义，通过读取配置文件的初始值对界面配置。由界面配置对软件功能进行裁剪、重组和扩充，以实现特殊需求。</p>
<p> 界面定制是对用户界面的动态修改过程，在软件运行过程中，用户可按需求和使用习惯，对界面元素(如菜单、工具栏、键盘命令)的属性(如文字、图标、大小和位置等)进行修改。软件运行结束，界面定制的结果被保存。</p>
<p> 系统通过 DOM API读取XML配置文件的表示层信息(如初始界面大小、位置等),通过据存取类读取数据库中的数据层信息，运行时由界面元素动态生成界面。界面配置和定制模块在软件运行前后修改配置文件、更改界面内容。</p>
<p>基于XML的界面管理技术实现的管理信息系统实现了用户界面描述信息与功能实现代码的分离，可针对不同用户需求进行界面配置和定制，能适应一定程度内的数据库结构改动。只须对 XML文件稍加修改，即可实现系统的移植</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/20.jpg" alt="1"></p>
<h5 id="中间层框架设计"><a href="#中间层框架设计" class="headerlink" title="中间层框架设计"></a>中间层框架设计</h5><p>业务框架位于系统架构的中间层，是实现系统功能的核心组件。采用容器的形式，便于系统功能的开发、代码重用和管理。</p>
<p>下图便是在吸收了SOA 思想之后的一个三层体系结构的简图。</p>
<p> 业务层采用业务容器的方式存在于整个系统当中，采用此方可以大大降低业务层和相邻各层的耦合，表示层代码只需要将业务参数传递给业务容器，而不需要业务层多余的干预。如此一来，可以有效地防止业务层代码渗透到表示层。</p>
<p> 在业务容器中，业务逻辑是按照Domain Model—Service—Control思想来实现的。</p>
<p> Domain Model：是领域层业务对象，它仅仅包含<strong>业务</strong>相关的属性。</p>
<p> Service：是 业务过程实现的组成部分，是应用程序的不同功能单元，通过在这些服务之间定义良好的接口和</p>
<p>契约联系起来。</p>
<p> Control：服务控制器，是服务之间的纽带，不同服务之间的切换就是通过它来实现的。</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/21.jpg" alt="1"></p>
<p>如果没有明显的数据访问层设计。这样的设计虽然提高了数据访问的性能，但也同时导致了业务逻辑层与数据访问的职责混乱</p>
<p>引入了缓存和异步处理机制，在数据访问层中，完全采用了“面向接口编程”思想。抽象出来的IDA L模块，脱离了</p>
<p>与具体数据库的依赖，从而使得整个数据访问层有利于数据库迁移。BLL是业务逻辑层的核心模块，它包含了整个系统的核心业务。在业务逻辑层中，不能直接访问数据库，而必须</p>
<p>通过数据访问层。注意，图13-20中对数据访问业务的调用，是通过接口模块IDAL来完成的。既然与具体的数据访问逻辑无关，则层与层之间的关系就是松散耦合的</p>
<h5 id="数据访问层设计"><a href="#数据访问层设计" class="headerlink" title="数据访问层设计"></a>数据访问层设计</h5><p>5种数据访问模式：</p>
<p>• 在线访问：会占用一个数据库连接，读取数据，每个数据库操作都会通过这个连接不断地与后台的数据源进行交互。比如使用pl/sql或者navicat连接数据库</p>
<p>• Data Access Object：是标准J2EE设计模式之一，开发人员常常用这种模式将底层数据访问操作与高层业务逻辑分离开。</p>
<p>• Data Transfer Object：是经典EJB设计模式之一。DTO本身是这样一组对象或是数据的容器，它需要跨不同的进程或是网络的边界来传输数据。这类对象本身应该不包含具体的业务逻辑，并且通常这些对象内部只能进行一些诸如内部一致性检查和基本验证之类的方法，而且这些方法最好不要再调用其他的对象行为。</p>
<p>• 离线数据模式是以数据为中心，数据从数据源获取之后，将按照某种预定义的结构存放在系统中，成为应用的中心。离线，对数据的各种操作独立于各种与后台数据源之间的连接或是事务</p>
<p>• 对象/关系映射(Object/Relation Mapping，0/R Mapping)：大多数应用中的数据都是依据关系模型存储在关系型数据库中;而很多应用程序中的数据在开发或是运行时则是以对象的形式组织起来的。那么，对象/关系映射就提供了这样一种工具或是平台，能够帮助将应用程序中的数据转换成关系型数据库中的记录;或是将关系数据库中的记录转换成应用程序中代码便于操作的对象</p>
<p><strong>工厂模式</strong>在数据库访问层的应用：首先定义一个操纵数据库的接口DataAccess，然后根据数据库的不同，由类工厂决定实例化哪个类</p>
<p><strong>事务处理设计</strong>：JavaBean中使用JDBC方式进行事务处理：在JDBC中，打开一个连接对象Connection时，默认是auto-commit模式，每个SQL语句都被当作一个事务，即每次执行一个语句，都会自动地得到事务确认</p>
<p><strong>连接对象管理设计（数据库连接池）</strong>：通过资源池解决资源频繁分配、释放所造成的问题</p>
<h5 id="数据架构规划与设计"><a href="#数据架构规划与设计" class="headerlink" title="数据架构规划与设计"></a>数据架构规划与设计</h5><p>• 基于文件的存储方式。基于文件的存储方式是指将XML文档按其原始文本形式存储，主要存储技术包括操作系统文件库、通用文档管理系统和传统数据库的列。这种存储方式需维护某种类型的附加索引，以建立文件之间的层次结构。基于文件的存储方式的特点：无法获取XML文档中的结构化数据;通过附加索引可以定位具有某些关键字的XML文档，一旦关键字不确定，将很难定位;查询时，只能以原始文档的形式返回，即不能获取文档内部信息;文件管理存在容量大、管理难的缺点。</p>
<p>• 数据库存储方式。数据库在数据管理方面具有管理方便、存储占用空间小、检索速度快、修改效率高和安全性好等优点。一种比较自然的想法是采用数据库对XML文档进行存取和操作，这样可以利用相对成熟的数据库技术处理XML文档内部的数据。数据库存储方式的特点：能够管理结构化和半结构化数据;具有管理和控制整个文档集合本身的能力;可以对文档内部的数据进行操作;具有数据库技术的特性，如多用户、并发控制和一致性约束等;管理方便，易于操作。</p>
<h5 id="各层设计中可能遇到的问题以及解决方案"><a href="#各层设计中可能遇到的问题以及解决方案" class="headerlink" title="各层设计中可能遇到的问题以及解决方案"></a>各层设计中可能遇到的问题以及解决方案</h5><h6 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h6><p>问题：</p>
<ol>
<li><strong>耦合度过高</strong>：表示层与业务逻辑层或数据访问层之间的耦合度过高，导致修改一个层可能影响到其他层。</li>
<li><strong>过度复杂</strong>：表示层包含过多的业务逻辑或处理逻辑，使得代码难以理解和维护。</li>
<li><strong>性能问题</strong>：界面响应速度慢，加载时间长，影响用户体验。</li>
<li><strong>不一致的用户体验</strong>：不同部分的界面设计风格、交互方式不一致，给用户造成困惑。</li>
</ol>
<p>解决方案：</p>
<ol>
<li><strong>分离关注点</strong>：采用MVC（Model-View-Controller）或MVVM（Model-View-ViewModel）等设计模式，将表示层、业务逻辑层和数据访问层分离，降低耦合度。</li>
<li><strong>单一职责原则</strong>：确保表示层只负责展示数据和处理用户交互，将复杂的业务逻辑放在业务逻辑层中处理。</li>
<li><strong>性能优化</strong>：使用合适的技术和工具进行性能优化，如异步加载数据、缓存数据、减少页面加载时间等。</li>
<li><strong>统一设计风格</strong>：制定统一的UI设计规范和交互设计原则，确保整个应用的界面风格和交互方式一致。</li>
<li><strong>用户反馈和测试</strong>：与用户进行反馈交流，不断优化和改进界面设计，进行用户体验测试，及时发现和解决问题。</li>
<li><strong>使用前端框架</strong>：使用现代的前端框架如React、Angular、Vue等，可以提高开发效率，减少代码复杂度，并提供更好的用户体验。</li>
<li><strong>模块化设计</strong>：将界面拆分成多个独立的模块，每个模块负责特定的功能，便于维护和扩展。</li>
</ol>
<p>通过以上解决方案，可以帮助解决表示层设计中可能遇到的问题，提高系统的可维护性、性能和用户体验。</p>
<h6 id="业务逻辑层"><a href="#业务逻辑层" class="headerlink" title="业务逻辑层"></a>业务逻辑层</h6><p>问题：</p>
<ol>
<li><strong>复杂性过高</strong>：业务逻辑层包含大量复杂的业务规则和逻辑，使得代码难以理解和维护。</li>
<li><strong>耦合度过高</strong>：业务逻辑层与表示层或数据访问层之间的耦合度过高，导致修改一个层可能影响到其他层。</li>
<li><strong>业务规则冗余</strong>：业务规则重复定义或分散在多个地方，导致难以管理和维护。</li>
<li><strong>性能问题</strong>：业务逻辑处理效率低下，影响系统的性能表现。</li>
</ol>
<p>解决方案：</p>
<ol>
<li><strong>分层设计</strong>：遵循分层架构原则，将业务逻辑层与其他层分离，降低耦合度，提高可维护性。</li>
<li><strong>单一职责原则</strong>：确保每个业务逻辑组件只负责一个特定的业务功能，避免功能交叉和重复。</li>
<li><strong>业务规则集中管理</strong>：将业务规则集中管理，避免规则的重复定义，可以使用规则引擎或业务规则管理系统来管理业务规则。</li>
<li><strong>模块化设计</strong>：将业务逻辑拆分成多个模块或服务，每个模块负责特定的业务功能，便于管理和维护。</li>
<li><strong>使用设计模式</strong>：使用设计模式如策略模式、观察者模式等，可以更好地组织和管理业务逻辑。</li>
<li><strong>性能优化</strong>：优化业务逻辑处理的算法和流程，避免不必要的计算和数据访问，提高系统性能。</li>
<li><strong>单元测试</strong>：编写单元测试用例来验证业务逻辑的正确性，确保业务逻辑的稳定性和可靠性。</li>
<li><strong>版本控制和文档</strong>：对业务逻辑进行版本控制，及时更新文档，确保团队成员了解业务规则和逻辑。</li>
</ol>
<h6 id="数据访问层"><a href="#数据访问层" class="headerlink" title="数据访问层"></a>数据访问层</h6><p>问题：</p>
<ol>
<li><strong>性能问题</strong>：数据访问层的性能不佳，导致数据查询或更新操作耗时过长。</li>
<li><strong>复杂性过高</strong>：数据访问层包含大量复杂的数据访问逻辑，使得代码难以理解和维护。</li>
<li><strong>耦合度过高</strong>：业务数据访问层与业务逻辑层之间的耦合度过高，导致修改一个层可能影响到其他层。</li>
<li><strong>数据一致性问题</strong>：数据访问层的操作不符合事务性要求，导致数据不一致或丢失。</li>
</ol>
<p>解决方案：</p>
<ol>
<li><strong>分离关注点</strong>：采用数据访问对象（DAO）模式或存储库模式，将数据访问层与业务逻辑层分离，降低耦合度。</li>
<li><strong>使用ORM框架</strong>：使用ORM（对象关系映射）框架可以简化数据访问层的开发，减少手动编写SQL的工作量，提高开发效率。</li>
<li><strong>性能优化</strong>：优化数据库查询语句、建立合适的索引、使用缓存等方法来提高数据访问层的性能。</li>
<li><strong>事务管理</strong>：确保数据访问层的操作符合事务性要求，可以使用数据库事务或编程事务来保证数据的一致性。</li>
<li><strong>单一职责原则</strong>：确保每个数据访问对象只负责特定数据表或实体的操作，避免功能交叉和重复。</li>
<li><strong>数据访问层的抽象</strong>：使用接口或抽象类来定义数据访问层的操作，便于替换或扩展具体实现。</li>
<li><strong>错误处理</strong>：在数据访问层进行合适的错误处理和异常处理，确保系统的稳定性和可靠性。</li>
<li><strong>使用连接池</strong>：使用连接池来管理数据库连接，避免频繁创建和销毁连接，提高系统的性能和资源利用率。</li>
</ol>
<h5 id="层次架构的关键设计策略"><a href="#层次架构的关键设计策略" class="headerlink" title="层次架构的关键设计策略"></a>层次架构的关键设计策略</h5><p>以下是层次架构中的一些关键策略：</p>
<ol>
<li><strong>分层设计</strong>：将系统分解为多个层次，如表示层、业务逻辑层和数据访问层，每个层次负责特定的功能，降低耦合度，提高模块化和复用性。</li>
<li><strong>单一职责原则</strong>：确保每个组件或模块只负责一个特定的功能，避免功能交叉和复杂性过高。</li>
<li><strong>明确定义的接口</strong>：每个层次之间通过明确定义的接口进行通信，降低耦合度，提高灵活性和可替代性。</li>
<li><strong>依赖反转原则</strong>：依赖反转原则（Dependency Inversion Principle）要求高层模块不应依赖于低层模块的具体实现，而是依赖于抽象，通过接口来解耦。</li>
<li><strong>模块化设计</strong>：将系统拆分为多个独立的模块或组件，每个模块负责特定的功能，便于管理、维护和扩展。</li>
<li><strong>设计模式</strong>：使用设计模式如工厂模式、观察者模式、策略模式等，可以提高系统的灵活性、可维护性和可扩展性。</li>
<li><strong>分布式架构</strong>：在需要时考虑使用分布式架构，将系统拆分为多个独立的服务，可以提高系统的性能、可伸缩性和容错性。</li>
<li><strong>安全性</strong>：在设计层次架构时要考虑系统的安全性，包括数据加密、访问控制、身份验证等安全措施。</li>
<li><strong>性能优化</strong>：在系统设计阶段考虑性能优化策略，如缓存、异步处理、数据库索引等，以提高系统的性能和响应速度。</li>
<li><strong>单一职责原则（Single Responsibility Principle，SRP）</strong>：每个模块或组件应该只有一个单一的责任，避免功能交叉和复杂性过高。</li>
<li><strong>开放封闭原则（Open/Closed Principle，OCP）</strong>：模块应该对扩展开放，对修改关闭，通过扩展现有模块来添加新功能，而不是修改已有模块。</li>
<li><strong>依赖倒置原则（Dependency Inversion Principle，DIP）</strong>：高层模块不应该依赖于低层模块的具体实现，而是应该依赖于抽象，通过接口来解耦。</li>
<li><strong>接口隔离原则（Interface Segregation Principle，ISP）</strong>：接口应该细化，一个类不应该强迫其客户端实现其不需要的接口，避免接口臃肿和不必要依赖。</li>
</ol>
<h5 id="层次架构的主要作用"><a href="#层次架构的主要作用" class="headerlink" title="层次架构的主要作用"></a>层次架构的主要作用</h5><ol>
<li><strong>模块化和组织性</strong>：层次架构将系统分解为多个层次，每个层次负责特定的功能，使得系统更易于理解、维护和扩展。</li>
<li><strong>降低耦合度</strong>：不同层次之间通过定义清晰的接口进行通信，降低了各个模块之间的耦合度，使得修改一个模块不会对其他模块产生影响。</li>
<li><strong>提高可维护性</strong>：通过将系统分解为多个层次，每个层次都有明确的责任，使得系统更易于定位问题、进行调试和修改。</li>
<li><strong>提高可扩展性</strong>：层次架构使得系统的功能模块化，通过添加新的层次或扩展现有层次，可以更容易地实现系统的功能扩展。</li>
<li><strong>提高复用性</strong>：模块化的设计使得各个层次中的功能可以被重复使用，提高了代码的复用性和开发效率。</li>
<li><strong>分工协作</strong>：不同的团队可以专注于开发不同层次的功能，降低了团队成员之间的协作成本，提高了开发效率。</li>
<li><strong>提高系统的可靠性和稳定性</strong>：通过清晰的层次划分和模块化设计，可以降低系统出错的可能性，提高系统的稳定性和可靠性。</li>
<li><strong>性能优化</strong>：通过层次架构可以更容易地对系统进行性能优化，例如在数据访问层添加缓存、在表示层进行页面静态化等。</li>
</ol>
<p>层次架构解决了诸多问题，包括：</p>
<ul>
<li><strong>耦合度过高</strong>：通过定义清晰的接口，降低了各个模块之间的耦合度。</li>
<li><strong>功能交叉</strong>：每个层次只负责特定的功能，避免了功能交叉和重复。</li>
<li><strong>复杂性过高</strong>：将系统分解为多个层次，降低了系统整体的复杂性，使得系统更易于管理和维护。</li>
<li><strong>可维护性差</strong>：通过模块化的设计，提高了系统的可维护性，使得修改和扩展更加容易。</li>
<li><strong>可扩展性差</strong>：层次架构使得系统更易于扩展，通过添加新的层次或扩展现有层次，可以更容易地实现系统的功能扩展。</li>
</ul>
<h5 id="物联网层次规划设计"><a href="#物联网层次规划设计" class="headerlink" title="物联网层次规划设计"></a>物联网层次规划设计</h5><p>物联网可以分为三个层次，底层是用来感知数据的感知层，即利用传感器、二维码、RFID等设备随时随地获取物体的信息。第二层是数据传输处理的网络层，即通过各种传感网络与互联网的融合，将对象当前的信息实时准确地传递出去。第三层则是与行业需求结合的应用层，即通过智能计算、云计算等将对象进行智能化控制。</p>
<p>• 感知层：用于识别物体、采集信息。感知层包括二维码标签和识读器、RFID标签和读写器、摄像头、GPS、传感器、M2M终端、传感器网关等，<strong>主要功能是识别对象、采集信息，与人体结构中皮肤和五官的作用类似。感知层解决的是人类世界和物理世界的数据获取问题</strong>。</p>
<p>• 网络层：用于传递信息和处理信息。网络层包括通信网与互联网的融合网络、网络管理中心、信息中心和智能处理中心等。<strong>网络层将感知层获取的信息进行传递和处理，类似于人体结构中的神经中枢和大脑。网络层解决的是传输和预处理感知层所获得数据的问题</strong>。</p>
<p>• 应用层：实现广泛智能化。应用层是物联网与行业专业技术的深度融合，结合行业需求实现行业智能化，这类似于人们的社会分工。<strong>物联网应用层利用经过分析处理的感知数据，为用户提供丰富的特定服务。应用层解决的是信息处理和人机交互的问题</strong>。</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/22.jpg" alt="1"></p>
<h4 id="云原生架构"><a href="#云原生架构" class="headerlink" title="云原生架构"></a>云原生架构</h4><h5 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h5><p>云计算是一种通过互联网向用户提供计算资源的服务模式。用户无需购买、维护和管理硬件和软件，而是根据需求从云服务提供商处租赁资源，并按使用量付费。</p>
<p>云计算的主要特点包括：</p>
<p> 按需服务：用户可以根据需求随时随地获取和使用计算资源，无需提前进行规划和采购。</p>
<p> 弹性扩展：用户可以根据业务需求快速扩展或缩减计算资源，无需进行额外的硬件或软件投资。</p>
<p> 低成本：用户无需购买和维护昂贵的硬件和软件，可以降低 IT 成本。</p>
<p> 高可用性：云服务提供商通常拥有多个数据中心，可以确保应用程序的高可用性。</p>
<p> 易于管理：用户无需管理复杂的 IT 基础架构，可以将更多精力集中在业务创新上。 </p>
<p>云计算的服务方式</p>
<p> 基础设施即服务(IaaS)。在IaaS模式下，服务提供商将多台服务器组成的“云端”基础设施作为计量服务提供给客户。</p>
<p> 平台即服务(PaaS)。在PaaS模式下，服务提供商将分布式开发环境与平台作为一种服务来提供。</p>
<p> 软件即服务(Saas)。在Saas的服务模式下，服务提供商将应用软件统一部署在云计算平台上，客户根据需要通过互联网向服务提供商</p>
<p>订购应用软件服务，服务提供商根据客户所订购软件的数量、时间的长短等因素收费，并且通过标准浏览器向客户提供应用服务</p>
<p>云计算的部署模式：</p>
<p> 公有云。在公有云模式下，云基础设施是公开的，可以自由地分配给公众。企业、学术界与政府机构都可以拥有和管理公用云，并实现对公有云的操作。公有云能够以低廉的价格为最终用户提供有吸引力的服务，创造新的业务价值。</p>
<p> 社区云。在社区云模式下，云基础设施分配给一些社区组织所专有，这些组织共同关注任务、安全需求、政策等信。云基础设施被社区内的一个或多个组织所拥有、管理及操作。“社区云”是”公有云”范畴内的一个组成部分。</p>
<p> 私有云。在私有云模式下，云基础服务设施分配给由多种用户组成的单个组织。它可以被这个组织或其他第三方组织所拥有、管理及操作。</p>
<p> 混合云。混合云是公有云、私有云和社区云的组合。由于安全和控制原因，并非所有的企业信息都能放置在公有云上，因此企业将会使用混合云模式</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/26.jpg" alt="1"></p>
<h5 id="云原生架构原则"><a href="#云原生架构原则" class="headerlink" title="云原生架构原则"></a>云原生架构原则</h5><p>云原生架构是基于云原生技术的一组架构原则和设计模式的集合，旨在将云应用中的非业务代码部分进行最大化的剥离，从而让云设施接管应用中原有的大量非功能特性(如弹性、韧性、安全、可观测性、灰度等)，使业务不再有非功能性业务中断困扰的同时，具备轻量、敏捷、高度自动化的特点。</p>
<p> 云原生架构原则</p>
<p>• 服务化原则：拆分为微服务架构、小服务架构，分别迭代。</p>
<p>• 弹性原则：系统的部署规模可以随着业务量的变化而自动伸缩。</p>
<p>• 可观测原则：通过日志、链路跟踪和度量等手段。</p>
<p>• 韧性原则：当软件所依赖的软硬件组件出现各种异常时，软件表现出来的抵御能力。</p>
<p>• 所有过程自动化原则：一方面标准化企业内部的软件交付过程，另一方面在标准化的基础上进行自动化，通过配置数据自描述和面向终态的交付过程。</p>
<p>• 零信任原则：默认情况下不应该信任网络内部和外部的任何人/设备/系统，需要基于认证和授权重构访问控制的信任基础，以身份为中心。</p>
<p>• 架构持续演进原则：我们做设计的时候就要考虑到业务有可能高速演进，所以架构设计时也要保证架构和变化的业务能保持平衡</p>
<h5 id="云原生架构模式"><a href="#云原生架构模式" class="headerlink" title="云原生架构模式"></a>云原生架构模式</h5><p>服务化架构模式：典型模式是微服务和小服务模式。通过服务化架构，把代码模块关系和部署关系进行分离，每个接口可以署不同数量的实例，单独扩缩容，从而使得整体的部署更经济。这种是最主流的模式，例如：一个电商平台可以拆分为多个服务，例如商品服务、订单服务、支付服务和物流服务。每个服务都可以独立部署和扩展，以满足不同的需求。</p>
<p> Mesh化架构模式：把中间件框架(如RPC、缓存、异步消息等)从业务进程中分离，这部分的功能都交给Mesh完成。分离后在业务进程中只保留很“薄”的Client部分。举例： Istio是一个流行的Mesh平台，可以提供服务发现、流量管理、安全性和可观察性等功能。</p>
<p> Serverless模式：无服务器模式，将“部署”这个动作从运维中“收走”，使开发者不用关心应用运行地点、操作系统、网络配置、CPU性能等，也就是把应用的整个运行都委托给云。云端再根据代码运行情况自动分配和回收资源，并仅对使用的资源进行计费。</p>
<p> 存储计算分离模式：是一种将存储和计算资源分离的架构模式。在云环境中，推荐把各类暂态数据（如session）、结构化和非结构化持久数据都采用云服务来保存，从而实现存储计算分离。</p>
<p> 分布式事务模式：用来解决微服务架构模式中访问多个数据源所带来的分布式事务问题。架构师需要根据不同的场景选择合适的分布式事务模式。举例： 一个电商平台的订单处理可能涉及多个服务，例如库存服务、支付服务和物流服务。这服务都可能需要访问数据库，如果这些数据库都处于不同数据源上，就需要使用分布式事务模式来确保事务的一致性。</p>
<p> 可观测架构：引入一些技术让架构变得可观测，主要包括Logging、Tracing、Metrics 三个方面</p>
<p> 事件驱动架构：本质上是一种应用/组件间的集成架构模式。可用于服务解耦、增强服务韧性、数据变化通知等场景中。</p>
<h5 id="云原生架构技术"><a href="#云原生架构技术" class="headerlink" title="云原生架构技术"></a>云原生架构技术</h5><p><strong>容器技术</strong>：容器作为标准化软件单元，它将应用及其所有依赖项打包，使应用不再受环境限制，在不同计算环境间快速、可靠地运行。通过容器技术，企业可以充分发挥云计算弹性优势，降低运维成本。</p>
<p><strong>云原生微服务</strong>：微服务模式将后端单体应用拆分为松耦合的多个子应用，每个子应用负责一组子功能。这些子应用称为“微服务”，多个“微服务”共同形成了一个物理独立但逻辑完整的分布式微服务体系。这些微服务相对独立，通过解耦研发、测试与部署流程，提高整体迭代效率</p>
<p>Apache Dubbo，Eclipse MicroProfile，Tars，SOFAStack，DAPR</p>
<p>Spring Cloud作为开发者的主要微服务选择之一，为开发者提供了分布式系统需要的配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性Token、全局锁、决策竞选、分布式会话与集群状态管理等能力和开发工具。</p>
<p><strong>无服务器技术</strong>(Serverless)因为屏蔽了服务器的各种运维复杂度，让开发人员可以将更多精力用于业务逻辑设计与实现，而逐渐成为云原生主流技术之一。无服务器技术关注点：计算资源弹性调度、负载均衡和流控、安全性</p>
<p>Serverless技术包含以下特征：</p>
<p>• 全托管的计算服务：这意味着用户无需担心底层服务器的维护和管理。 云平台会负责处理所有基础设施方面的细节，例如服务器配置、网络管理和操作系统更新。 用户只需专注于编写代码并构建应用程序，而无需担心服务器的管理工作。这种全托管的服务模式可以显著降低开发人员的运维负担，并提高开发效率。</p>
<p>• 通用性：可以支持云上所有重要类型的应用，包括 Web 应用、移动后端、数据处理、物联网、事件驱动应用程序等。它可以与各种其他云服务无缝集成，例如数据库、存储、分析和机器学习。Serverless计算的通用性使其成为各种应用场景的理想选择。</p>
<p>• 自动弹性伸缩：可以根据应用程序的负载自动弹性伸缩资源。 当应用程序的流量增加时，云平台会自动启动更多实例来处理负载。 当流量减少时，云平台会自动释放闲置资源。这种自动弹性伸缩功能可以让用户避免为闲置资源付费，并确保应用程序始终保持高可用性。</p>
<p>• 按量计费：采用按量计费模式，这意味着用户只需为实际使用的资源付费。 云平台会根据应用程序的实际使用情况进行计费</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/27.jpg" alt="1"></p>
<h5 id="架构案例-1"><a href="#架构案例-1" class="headerlink" title="架构案例"></a>架构案例</h5><p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/35.jpg" alt="1"></p>
<p>云原生技术助力某汽车公司数字化转型实践：</p>
<p>• 战略性构建容器云平台。通过平台实现对某云行App、二手车、在线支付、优惠券等核心互联网应用承载。以多租户的式提供弹性计算、数据持久化、应用发布等面向敏捷业务服务，并实现高水平资源隔离。标准化交付部署，快速实现业务扩展，满足弹性要求。</p>
<p>• 数字混合云交付。采用私有云+公有云的混合交付模式，按照服务的敏态/稳态特性和管控要求划分部署，灵活调度公有云资源来满足临时突发或短期高TPS业务支撑的需求。</p>
<p>• 深度融合微服务治理体系，实现架构的革新和能力的沉淀，逐步形成支撑数字化应用的业务中台</p>
<h4 id="面向服务架构SOA"><a href="#面向服务架构SOA" class="headerlink" title="面向服务架构SOA"></a>面向服务架构SOA</h4><h5 id="SOA与微服务"><a href="#SOA与微服务" class="headerlink" title="SOA与微服务"></a>SOA与微服务</h5><p>在面向服务的体系结构(SOA)中，服务的概念有了延伸，泛指系统对外提供的功能集</p>
<p>从应用的角度定义，可以认为SOA是一种应用框架，它着眼于日常的业务应用，并将它们划分为单独的业务功能和流程</p>
<p>从软件的基本原理定义，可以认为SOA是一个组件模型</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/23.jpg" alt="1"></p>
<h5 id="服务分类"><a href="#服务分类" class="headerlink" title="服务分类"></a>服务分类</h5><p>典型的以服务为中心的企业集成架构如下图所示，采用“<strong>关注点分离</strong>”的方法规划企业集成中的各种架构元素，同时从服务视角规划每种架构元素提供的服务，以及服务如何被组合在一起完成某种类型的集成。可划分为六大类：</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/24.jpg" alt="1"></p>
<p>1、业务逻辑服务 (Business Logic Service)： 包括用于实现业务逻辑的服务和执行业务逻辑的能力，其中包括业务应用服务 (Business Application Service)、 业务伙伴服务 (PartnerService) 以及应用和信息资产 (Application and Informationasset)。</p>
<p>• 整合已有应用(应用和信息访问服务)：实现对已有应用和信息的集成，主要有两类访问服务：可接入服务、事件发现服务。</p>
<p>• 整合新开发的应用(业务应用服务)：实现新应用集成，主要有三类业务应用服务：组件服务(可重用）、核心服务（运行时）、接口服务。</p>
<p>• 整合客户和业务伙伴(B2C/B2B，伙伴服务)：提供与企业外部的B2B的集成能力，包括：社区服务、文档服务、协议服务。</p>
<p>2、控制服务 (Control Service)： 包括实现人 (People)、 流程 (Process) 和信息(Information) 集成的服务，以及执行这些集成逻辑的能力。</p>
<p>• 数据整合(信息服务)：提供集成数据的能力，目前主要包括如下集中信息服务：联邦服务(不同类型数据聚合)、复制服务(远程数据本地访问)、转换服务(格式转换)、搜索服务。</p>
<p>• 流程整合(流程服务)：完成业务流程集成，包括：编排服务(预定义流程顺序)、事务服务(保证ACID)、人工服务(人工活动集成到流程中)。</p>
<p>• 用户访问整合(交互服务)：实现用户访问集成，包括：交付服务(运行时交互框架)、体验服务、资源服务(运行时交互组件的管理)。</p>
<p>3、连接服务 (Connectivity Service)： 通过提供企业服务总线提供分布在各种架构元素中服务间的连接性。</p>
<p> 通过企业服务总线(ESB)来实现，它的基本特征和能力包括：</p>
<p>• 描述服务的元数据和服务注册管理; </p>
<p>• 在服务请求者和提供者之间传递数据，以及对这些数据进行转换的能力，并支持由实践中总结出来的一些模式如同步</p>
<p>模式、异步模式等; </p>
<p>• 发现、路由、匹配和选择的能力，以支持服务之间的动态交互，解耦服务请求者和服务提供者。</p>
<p>• 高级一些的能力，包括对安全的支持、服务质量保证、可管理性和负载平衡等</p>
<p>4、业务创新和优化服务 (Business Innovation and Optimization Service)： 用于监控业务系统运行时服务的业务性能，并通过及时了解到的业务性能和变化，取措施适应变化的市场。</p>
<p>5、开发服务 (Development Service)： 贯彻整个软件开发生命周期的开发平台，从需求分析，到建模、设计、开发、测试和维护等全面的工具支持。</p>
<p>6、IT服务管理 (IT Service Management)： 支持业务系统运行的各种基础设施管理能力或服务，如安全服务、目录服务、系统管理和资源虚拟化。</p>
<h5 id="SOA协议"><a href="#SOA协议" class="headerlink" title="SOA协议"></a>SOA协议</h5><p>Web服务最基本的协议包括UDDI、WSDL和SOAP，通过它们，可以提供直接而又简单的Web Service支持,如图所示。</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/25.jpg" alt="1"></p>
<p>• UDDI：UDDI 是用于服务的注册和发现。它允许提供者将其 Web 服务描述注册到 UDDI 注册中心，以便其他用户可以发现并访问这些服务。便其他电子商务网站或应用程序可以查找并使用这些服务。</p>
<p>• WSDL：WSDL 是用于用于描述服务的接口和操作。它提供了一种标准方式来定义服务的输入、输出以及如何与服务进行交互。</p>
<p>• SOAP：SOAP 是一种用于在不同计算机之间进行通信的协议(在不同服务之间进行消息交换)。它允许 Web 服务之间的消息交换，并提供了一种标准的、跨平台的通信机制。一般来说是一个XML文件</p>
<h5 id="SOA的设计原则"><a href="#SOA的设计原则" class="headerlink" title="SOA的设计原则"></a>SOA的设计原则</h5><p> SOA的设计原则</p>
<p>• <strong>无状态</strong>。调用服务的时候不用考虑到它还需要其他的状态及数据，以避免服务请求者依赖于服务提供者的状态。</p>
<p>• <strong>单一实例</strong>。每个服务都只提供单一的功能，避免功能冗余。</p>
<p>• <strong>明确定义的接口</strong>。使用者依赖服务规约调用服务，所以服务定义必须长时间稳定，一旦公布，不能随意更改;服务的定义应尽可能明确，减少使用者的不适当使用;不要让使用者看到服务内部的私有数据。</p>
<p>• <strong>自包含和模块化</strong>。服务封装了那些在业务上稳定、重复出现的活动和组件，实现服务的功能实体是完全独立自主的，独立进行部署、版本控制、自我管理和恢复。</p>
<p>• <strong>粗粒度</strong>。服务数量不应该太大，依靠消息交互而不是远程过程调用(RPC)，通常消息量比较大，但是服务之间的交互频度较低。</p>
<p>• <strong>服务之间的松耦合性</strong>。服务使用者看到的是服务的接口，其位置、实现技术和当前状态等对使用者是不可见的，服务私有数据对服务使用者是不可见的。</p>
<p>• <strong>重用能力</strong>。服务应该是可以重用的。</p>
<p>• <strong>互操作性、兼容和策略声明</strong>。为了确保服务规约的全面和明确，策略成为一个越来越重要的方面。这可以是技术相关的内容，例如一个服务对安全性方面的要求;也可以是跟业务有关的语义方面的内容，例如需要满足的费用或者服务级别方面的要求，这些策略对于服务在交互时是非常重要的。</p>
<h5 id="SOA设计模式"><a href="#SOA设计模式" class="headerlink" title="SOA设计模式"></a>SOA设计模式</h5><p>1、服务注册表模式，支持如下SOA治理功能：</p>
<p>• 服务注册：应用开发者，也叫服务提供者，向注册表公布他们的功能。</p>
<p>• 服务位置：也就是服务应用开发者，帮助他们查询注册服务，寻找符合自身要求的服务。</p>
<p>• 服务绑定：服务的消费者利用检索到的服务合同来开发代码，开发的代码将与注册的服务绑定、调用注册的服务以及与它们实现互动。</p>
<p>2、企业服务总线模式ESB，由中间件技术实现的支持面向服务架构的基础软件平台，支持异构环境中的服务以基于消息和事件驱动模式的交互，并且具有适当的服务质量和可管理性。</p>
<p>一个典型的在ESB环境中组件之间的交互过程是：首先由服务请求者触发一次交互过程，产生一个服务请求消息，并将该消息按照ESB的要求标准化，然后标准化的消息被发送给服务总线。ESB根据请求消息中的服务名或者接口名进行目的组件查找，将消息转发至目的组件，并最终将处理结果逆向返回给服务请求者。这种交互过程不再是点对点的直接交互模式，而是由事件驱动的消息交互模式。</p>
<p> ESB的核心功能如下。</p>
<p>• 提供位置透明性的消息路由和寻址服务。</p>
<p>• 提供服务注册和命名的管理功能。</p>
<p>• 支持多种消息传递范型(如请求/响应、发布/订阅等)。</p>
<p>• 支持多种可以广泛使用的传输协议。</p>
<p>• 支持多种数据格式及其相互转换。</p>
<p>• 提供日志和监控功能</p>
<p>3、微服务模式，不再强调传统SOA架构里面比较重的ESB企业服务总线，同时SOA 的思想进入到单个业务系统内部实现真正的组件化。</p>
<p> 微服务模式特点：复杂应用解耦、独立、技术选型灵活、容错、松耦合易扩展。</p>
<p> 常见的微服务设计模式：</p>
<p>• 聚合器微服务：聚合器调用多个微服务实现系统应用程序所需功能，具体有两种形式，一种是将检索到的数据信息进行处理并直接展示;另一种是对获取到的数据信息增加业务逻辑处理后，再进一步发布成一个新的微服务作为一个更高层次的组合微服务，相当于从服务消费者转换成服务提供者。</p>
<p>• 链式微服务：客户端或服务在收到请求后，会返回一个经过合并处理的响应，服务之间形成一条调用链。</p>
<p>• 数据共享微服务：当服务之间存在强耦合关系时，可能存在多个微服务共享缓存与数据库存储的现象。</p>
<p>• 异步消息传递微服务：消息队列将消息写入一个消息队列中，实现业务逻辑以异步方式运行，从而加快系统响应速度。</p>
<p> 微服务架构的问题与挑战：</p>
<p>• 微服务架构分布式特点带来的复杂性; </p>
<p>• 微服务架构的分区数据库体系，不同服务拥有不同数据库; </p>
<p>• 增加了测试的复杂性; </p>
<p>• 在大规模应用部署中，在监控、管理、分发及扩容等方面,也带来了不少复杂性</p>
<h4 id="安全架构"><a href="#安全架构" class="headerlink" title="安全架构"></a>安全架构</h4><p>安全架构是架构面向安全性方向上的一种细分，通常的产品安全架构、安全技术体系架构和审计架构可组成三道安全防线。</p>
<p>• 产品安全架构：构建产品安全质量属性的主要组成部分以及它们之间的关系。产品安全架构的目标是如何在不依赖外部防御系统的情况下，从源头打造自身安全的产品。</p>
<p>• 安全技术体系架构：构建安全技术体系的主要组成部分以及它们之间的关系。安全技术体系架构的任务是构建通用的安全技术基础设施，包括安全基础设施、安全工具和技术、安全组件与支持系统等，系统性地增强各产品的安全防御能力。</p>
<p>• 审计架构：独立的审计部门或其所能提供的风险发现能力，审计的范围主要包括安全风险在内的所有风险</p>
<h5 id="安全体系架构规划框架"><a href="#安全体系架构规划框架" class="headerlink" title="安全体系架构规划框架"></a>安全体系架构规划框架</h5><p>对组织机构信息技术系统的安全体系结构的整体描述。安全技术体系架构的目标是建立可持续改进的安全技术体系架构的能力。根据风险威胁的存在实体划分出5个层次的实体对象：应用、存储、主机、网络和物理。</p>
<p>信息系统安全体系主要是由技术体系(技术)、组织机构体系(人)和管理体系(制度)三部分共同构成的。</p>
<p>• 技术体系是全面提供信息系统安全保护的技术保障系统，该体系由物理安全技术和系统安全技术两大类构成。</p>
<p>• 组织体系是信息系统的组织保障系统，由机构、岗位和人事三个模块构成。</p>
<p>• 管理体系由法律管理、制度管理和培训管理三部分组成</p>
<p>信息系统安全规划需要围绕技术安全、管理安全、组织安全考虑</p>
<p>信息系统安全规划以信息系统与信息资源的安全保护为核心，规划工作需要围绕着信息系统与信息资源的开发、利用和保护工作进行，要包括蓝图、现状、需求和措施4个方面</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/28.jpg" alt="1"></p>
<h5 id="信息安全整体架构设计"><a href="#信息安全整体架构设计" class="headerlink" title="信息安全整体架构设计"></a>信息安全整体架构设计</h5><p>WPDRRC(Waring/Protect/Detect/React/Restore/Counterattack)是我国针对美国提出的PDRR的基础上新增了预警和反击功能的信息安全模型，它有6个环节和3大要素</p>
<p>6个环节包括：预警、保护、检测、响应、恢复和反击，它们具有较强的时序性和动态性，能够较好地反映出信息系统安全保障体系的预警能力、保护能力、检测能力、响应能力、恢复能力和反击能力。</p>
<p>3大要素包括：人员、策略和技术。人员是核心，策略是桥梁，技术是保证，落实在WPDRRC 的6个环节的各个方面，将安全策预警略变为安全现实</p>
<p>W(Waring)：预警主要是指利用远程安全评估系统提供的模拟攻击技术来检查系统存在的、可能被利用的薄弱环节，收集和测试网络与信息的安全风险所在，并以直观的方式进行报告，提供解决方案的建议，在经过分析后，分解网络的风险变化趋势和严重风险点，从而有效降低网络的总体风险，保护关键业务和数据。</p>
<p>P(Protect)：防护通常是通过采用成熟的信息安全技术及方法来实现网络与信息的安全。主要内容有加密机制，数字签名机制，访问控制机制，认证机制，信息隐藏和防火墙技术等。</p>
<p>D(Detect)：检测通过检测和监控网络以及系统，来发现新的威胁和弱点，强制执行安全策略。在这个过程中采用入侵检测、恶意代码过滤等技术，形成动态检测的制度，奖励报告协调机制，提高检测的实时性。主要内容有入侵检测，系统脆弱性检测，数据完整性检测和攻击性检测等。</p>
<p>R(React)：响应是指在检测到安全漏洞和安全事件之后必须及时做出正确的响应，从而把系统调整到安全状态。为此需要相应的报警、跟踪、处理系统，其中处理包括了封堵、隔离、报告等能力。主要内容有应急策略、应急机制、应急手段、入侵过程分析和安全状态评估等。</p>
<p>R(Restore)：恢复灾难恢复系统是当前网络、数据、服务受到黑客攻击并遭到破坏或影响后，通过必要技术手段，在尽可能短的时间内使系统恢复正常。主要内容有容错、冗余、备份、替换、修复和恢复等。</p>
<p>C(Counterattack)：反击是指采用一切可能的高新技术手段，侦察、提取计算机犯罪分子的作案线索与犯罪证据，形成强有力的取证能力和依法打击手段</p>
<p>信息系统安全设计重点考虑两个方面：系统安全保障体系和信息安全体系架构。</p>
<p>1.系统安全保障体系：是由安全服务、协议层次和系统单元等三个层面组成，且每个层都涵盖了安全管理的内容。系统安全保障体系设计工作主要考虑以下几点：</p>
<p>• 安全区域策略的确定：根据安全区域的划分，主管部门应制定针对性的安全策略，比如涉及到金钱和隐私信息的区域的安全级别更高，涉及到外部人员的区域安全级别低一些。</p>
<p>• 统一配置和管理防病毒系统：主管部门应当建立整体防御策略，以实现统一的配置和管理。</p>
<p>• 网络安全管理：加强网络安全管理，制定有关规章制度。</p>
<p>2.信息安全体系架构：具体在安全控制系统，我们可以从下面5个方面开展分析和设计工作。</p>
<p>• 物理安全：保证计算机信息系统各种设备的物理安全是保障整个网络系统安全的前提。包括：环境安全、设备安全、媒体安全等。</p>
<p>• 系统安全：主要是指对信息系统组成中各个部件的安全要求。系统安全是系统整体安全的基础。它主要包括：网络结构安全、操作系统安全和应用系统安全。</p>
<p>• 网络安全：是整个安全解决方案的关键。它主要包括：访问控制、通信保密、入侵检测、网络安全扫描系统和防病毒等。</p>
<p>• 应用安全：主要是指多个用户使用网络系统时，对共享资源和信息存储操作所带来的安全问题。它主要包括资源共享和信息存储两个方面。</p>
<p>• 安全管理：主要体现在三个方面。其一是制定健全的安全管理体制;其二是构建安全管理平台;其三是增强人员的安全防范意识</p>
<h5 id="网络安全体系架构设计"><a href="#网络安全体系架构设计" class="headerlink" title="网络安全体系架构设计"></a>网络安全体系架构设计</h5><p>0SI定义了7层协议，其中除第5层(会话层)外，每一层均能提供相应的安全服务。实际上，最适合配置安全服务的是物理层、网络层、运输层及应用层上，其他层都不宜配置安全服务。</p>
<p>0SI开放系统互联安全体系的5类安全服务包括：鉴别、访问控制、数据机密性、数据完整性和抗抵赖性。</p>
<p>0SI定义分层多点安全技术体系架构，也称为深度防御安全技术体系架构，它通过以下三种方式将防御能力分布至整个信息系统中。</p>
<p>• 多点技术防御：在对手可以从内部或外部多点攻击一个目标的前提下，多点技术防御通过对网络和基础设施、边界、计算环境这三个防御核心区域的防御达到抵御所有方式的攻击目的。</p>
<p>• 分层技术防御：即使最好的可得到的信息保障产品也有弱点，其最终结果将使对手能找到一个可探查的脆弱性，一个有效的措施是在对手和目标间使用多个防御机制。</p>
<p>• 支撑性基础设施：为网络、边界和计算环境中信息保障机制运行基础的支撑性基础设施，包括公钥基础设施以及检测和响应基础设施。</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/29.jpg" alt="1"></p>
<h5 id="数据库系统的安全设计"><a href="#数据库系统的安全设计" class="headerlink" title="数据库系统的安全设计"></a>数据库系统的安全设计</h5><p>数据库的完整性约束：</p>
<p>数据库完整性是指数据库中数据的正确性和相容性</p>
<p>• 在需求分析阶段就必须制定完整性约束的命名规范</p>
<p>• 要根据业务规则对数据库完整性进行细致的测试，以尽早排除隐含的完整性约束间的冲突和对性能的影响。</p>
<p>• 要有专职的数据库设计小组，自始至终负责数据库的分析、设计、测试、实施及早期维护。</p>
<p>• 应采用合适的CASE工具来降低数据库设计各阶段的工作量。</p>
<p>利用基于DBMS的完整性控制机制来实现业务规则，易于定义，容易理解，而且可以降低应用程序的复杂性</p>
<h5 id="系统架构的脆弱性分析"><a href="#系统架构的脆弱性分析" class="headerlink" title="系统架构的脆弱性分析"></a>系统架构的脆弱性分析</h5><p>1.分层架构的脆弱性主要表现在两个方面：</p>
<p>• 层间的脆弱性。一旦某个底层发生错误，那么整个程序将会无法正常运行。</p>
<p>• 层间通信的脆弱性。将系统隔离为多个相对独立的层，这就要求在层与层之间引入通信机制。本来“直来直去”的操作现在要层层传递，势必造成性能下降。</p>
<p>2.C/S架构的脆弱性主要表现在以下几个方面：</p>
<p>• 客户端软件的脆弱性。因为在用户计算机上安装了客户端软件，所以这个系统就面临着程序被分析、数据被截取的安全隐患。</p>
<p>• 网络开放性的脆弱性。目前很多传统的C/S系统还是采用二层结构，也就是说所有客户端直接读取服务器端中的数据，在客户端包括了数据的用户名，密码等致命的信息，这样会给系统带来安全隐患。</p>
<p>• 网络协议的脆弱性</p>
<p>3.B/S 架构的脆弱性主要表现在：系统如果使用HTTP协议，B/S架构相对C/S架构而言更容易被病毒入侵，虽然最新的HTTP协议在安全性方面有所提升，但还是弱于C/S。</p>
<p>4.事件驱动架构的脆弱性主要表现在：</p>
<p>• 组件的脆弱性。组件削弱了自身对系统的控制能力，一个组件触发事件，并不能确定响应该事件的其他组件及各组建的执行顺序。</p>
<p>• 组件间交换数据的脆弱性。组件不能很好地解决数据交换问题，事件触发时，一个组件有可能需要将参数传递给另一个组件，而数据量很大的时候，如何有效传递是一个脆弱性问题。</p>
<p>• 组件间逻辑关系的脆弱性。事件架构使系统中各组件的逻辑关系变得更加复杂。</p>
<p>• 事件驱动容易进入死循环，这是由编程逻辑决定的。</p>
<p>• 高并发的脆弱性。虽然事件驱动可实现有效利用CPU资源，但是存在高并发事件处理造成的系统响应问题，而且，高并发容易导致系统数据不正确、丢失数据等现象。</p>
<p>• 固定流程的脆弱性。因为事件驱动的可响应流程基本都是固定的，如果操作不当，容易引发安全问题</p>
<p>5.MVC架构的脆弱性主要表现在：</p>
<p>• MVC架构的复杂性带来脆弱性。MVC架构增加了系统结构和实现的复杂性。比如说一个简单的界面，如果严格遵循MVC方式，使得模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</p>
<p>• 视图与控制器间紧密连接的脆弱性。视图与控制器是相互分离但确是联系紧密的部件，没有控制器的存在，视图应用是很有限的。反之亦然，这样就妨碍了它们的独立重用。</p>
<p>• 视图对模型数据的低效率访问的脆弱性。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问也将损害操作性能。</p>
<p>6.微内核架构的脆弱性主要表现在：</p>
<p>• 微内核架构难以进行良好的整体化优化。由于微内核系统的核心态只实现了最基本的系统操作，这样内核以外的外部程序之间的独立运行使得系统难以进行良好的整体优化。</p>
<p>• 微内核系统的进程间通信开销也较单一内核系统要大得多。从整体上看，在当前硬件条件下，微内核在效率上的损失小于其在结构上获得的收益。</p>
<p>• 通信损失率高。微内核把系统分为各个小的功能块，从而降低了设计难度，系统的维护与修改也容易，但通信带来的效率损失是一个问题。</p>
<p>7.微服务架构的脆弱性主要表现在：</p>
<p>• 开发人员需要处理分布式系统的复杂结构。</p>
<p>• 开发人员要设计服务之间的通信机制，通过写代码来处理消息传递中速度过慢或者不可用等局部实效问题。</p>
<p>• 服务管理的复杂性，在生产环境中要管理多个不同的服务实例，这意味着开发团队需要全局统筹</p>
<h5 id="架构案例-2"><a href="#架构案例-2" class="headerlink" title="架构案例"></a>架构案例</h5><p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/34.jpg" alt="1"></p>
<p>整个安全生产管理系统架构由四层组成：</p>
<p>• 设备层：主要是指用于智能工厂生产产品所需的相关设备; </p>
<p>• 控制层：主要是指智能工厂生产产品所需要建立的一套自动控制系统，控制智能设备完成生产工作; </p>
<p>• 设计/管理层：是指智能工厂各种开发、业务控制和数据管理功能的集合，实现数据集成与应用; </p>
<p>• 应用层：主要是指在云计算平台上进行信息处理，有两个核心功能，一是“数据”，二是“应用”。</p>
<h4 id="鸿蒙架构"><a href="#鸿蒙架构" class="headerlink" title="鸿蒙架构"></a>鸿蒙架构</h4><p><strong>鸿蒙(</strong> HarmonyOS) 整体采用分层的层次化设计，从下向上依次为： 内核层、系统服务层、框架层和应用层*<em>。</em>系统功能按照“系统” → “子系统” → “功能/模块”逐级展开，在多设备部署场景下，支持根据实际需求裁剪某些非必要的子系统或功能/模块</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/33.jpg" alt="1"></p>
<p>1)内核层：主要由内核子系统和驱动子系统组成。</p>
<p>• 内核子系统：HarmonyOS采用多内核设计，支持针对不同资源受限设备选用适合的OS内核。内核抽象层通过屏蔽多内核差异，对上层提供基础的内核能力。</p>
<p>• 驱动子系统：提供统一外设访问能力和驱动开发、管理框架。</p>
<p>2)系统服务层：是Harmony0S的 核心能力集合，通过框架层对应用程序提供服务。该层包含4个部分：</p>
<p>• 系统基本能力子系统集：为分布式应用在HarmonyOS多设备上的运行、调度、迁移等操作提供了基础能力。</p>
<p>• 基础软件服务子系统集：为HarmonyOS提供公共的、通用的软件服务。</p>
<p>• 增强软件服务子系统集：为HarmonyOS提供针对不同设备的、差异化的能力增强型软件服务。</p>
<p>• 硬件服务子系统集：为Harmony0S 提供硬件服务。</p>
<p>3)框架层：为HarmonyOS的应用程序提供了Java/C/C++/JS等 多语言的用户程序框架和Ability框架，以及各种软硬件服务对外开放的多语言框架API; 同时为采用Harmony0S的设备提供了C/C++/JS等多语言的框架API,不同设备支持的API与系统的组件化裁剪程度相关。</p>
<p>4)应用层：包括系统应用和第三方非系统应用。HarmonyOS的应用由一个或多个FA(Feature Ability)或PA(Particle Ability) 组成。其中，FA有UI界面，提供与用户交互的能力；而PA无UI界面，提供后台运行任务的能力以及统一 的数据访问抽象。</p>
<p><strong>鸿蒙操作系统架构具有4个技术特性</strong>：</p>
<p>• 分布式架构首次用于终端OS, 实现跨终端无缝协同体验 。</p>
<p>• 确定时延引擎和高性能IPC技术实现系统天生流畅。</p>
<p>• 基于微内核架构重塑终端设备可信安全。</p>
<p>• 通过统一的IDE支撑一次开发， 多端部署， 实现跨终端生态共享。</p>
<p><strong>在HarmonyOS架构中， 重点关注于分布式架构所带来的优势， 主要体现在下面四个方面</strong>：</p>
<p>• 分布式软总线是多种终端设备的统一基座， 为设备之间的互联互通提供了统一 的分布式通信能力；</p>
<p>• 分布式设备虚拟化平台可以实现不同设备的资源融合 、设备管理 、数据处理 ， 多种设备共同形成一个超级虚拟</p>
<p>终端 。针对不同类型的任务 ， 为用户匹配并选择能力合适的执行硬件；</p>
<p>• 分布式数据管理基于分布式软总线的能力 实现应用程序数据和用户数据的分布式管理用户数据不再与单一物理设备绑定 ，业务逻辑与数据存储分离 ， 应用跨设备运行时数据无 缝衔接</p>
<p>• 分布式任务调度构建统一的分布式服务管理 (发现 、同步 、注册 调用 )机制，支持对跨设备的应用进行远程启动 、远程调用 、远程连接以及迁移等操作 ， 选择合适的设备运行分布式任务。</p>
<p>HarmonyOS 架构的系统安全性主要体现在搭载HarmonyOS 的分布式终端上 ， 可以保证 “ 正确的人通过正确的设备， 正确地使用数据” 。这里通过 “ 分布式多端协同身份认证” 来保证 “ 正确的人 “ , 通过 “ 在分布式终端上构筑可信运行环境 “ 来保证 “ 正确的设备” ,通过 “分布式数据在跨终端流动的过程中 ， 对数据进行分类分级管理” 来保证 “ 正确地使用数据”</p>
<h4 id="大数据架构"><a href="#大数据架构" class="headerlink" title="大数据架构"></a>大数据架构</h4><h5 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h5><p>Lambda架构设计目的在于提供一个能满足大数据系统关键特性的架构，包括高容错、低延迟、可扩展等。其整合离线计算与实时计算，融合不可变性、读写分离和复杂性隔离等原则。Lambda是用于同时处理离线和实时数据的，可容错的，可扩展的分布式系统。它具备强鲁棒性，提供低延迟和持续更新。</p>
<p> Lambda架构应用场景：机器学习、物联网、流处理。</p>
<p> 如图所示，Lambda架构可分解为三层，即批处理层、加速层和服务层。</p>
<h5 id="Kappa"><a href="#Kappa" class="headerlink" title="Kappa"></a>Kappa</h5><p>Kappa架构的原理就是：在Lambda的基础上进行了优化，删除了Batch Layer 的架构，将数据通道以消息队列进行替代。因此对于Kappa架构来说，依旧以流处理为主，但是数据却在数据湖层面进行了存储，当需要进行离线分析或者再次计算的时候，则将数据湖的数据再次经过消息队列重播一次则可。</p>
<p>输入数据直接由实时层的实时数据处理引擎对源源不断的源数据进行处理，再由服务层的服务后端进一步处理以提供上层的业务查询。而中间结果的数据都是需要存储的，这些数据包括历史数据与结果数据，统一存储在存储介质中</p>
<p><img src="/2000/01/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/38.jpg" alt="1"></p>
<h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p><strong>摘要</strong>：(300~330字) </p>
<p>• 项目背景与信息系统的介绍</p>
<p>• 你的岗位与职责</p>
<p>• 根据不同论文的主题进行概括你的项目</p>
<p>• 项目成果</p>
<p><strong>搭建自己的万能模板-万能模板公式</strong>正文：</p>
<ol>
<li><strong>项目背景、系统功能介绍</strong>（400字，体现项目的真实性）</li>
</ol>
<p>• 项目背景与系统功能的详细介绍</p>
<p>• 项目开发时间</p>
<p>• 项目组的规模</p>
<p>• 在项目的岗位与职责</p>
<ol start="2">
<li>题目问题回答（400字，衔接项目背景与论文主题）</li>
</ol>
<p>• 回答题目中的知识点问题</p>
<p>• 引出论文主体内容</p>
<ol start="3">
<li><p>论文主体内容（1000-1500字，最重要的部分）</p>
</li>
<li><p><strong>总结</strong>（400-500字）</p>
</li>
</ol>
<p>• 项目上线及运行效果</p>
<p>• 客户评价</p>
<p>• 项目收获</p>
<p>• 项目不足和解决思路</p>
<p>举例：</p>
<p>论微服务架构及其应用</p>
<p>微服务提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通。在微服务架构中，每个服务都是一个相对独立的个体，每个服务都可以选择适合于自身的技术来实现。每个服务的部署都是独立的，这样就可以更快地对特定部分的代码进行部署。</p>
<p>请围绕“论微服务架构及其应用”论题，依次从以下三个方面进行论述。</p>
<p>1、概要叙述你所参与管理或开发的软件项目，以及你在其中所承担的主要工作。</p>
<p>2、简要描述微服务优点。</p>
<p>3、具体阐述如何基于微服务架构进行软件设计实现的。</p>
<p>第一问：对应公式中”1. 项目背景、系统功能介绍” </p>
<p>第二问：对应公式中”2. 题目知识点问题回答” </p>
<p>第三问：对应公式中”3. 论文主体内容</p>
<p>1、摘要</p>
<p>摘要自己参考范文或者下面的格式，根据自己选择的项目准备一个就可以了。建议逻辑上分两段，第一段是通用的介绍项目背景，第二段是根据不同的论文题目发挥的，简单回应子题目并介绍论文结构。</p>
<p>包含内容：项目名称、(项目金额、项目历时)、项目简介、我的责任、本文讨论主题概括。</p>
<p>摘要模板（时间+项目+项目简介+个人岗位+工作职责+投入+历时+成功交付客户好评+结合具体题目说明本文结构）</p>
<p>示例1：</p>
<p>2018年3月，我参与了某航天研究所某型号卫星的全数字仿真验证平台项目的建设，并担任系统架构设计师，负责系统架构设计工作。该系统包括虚拟目标机仿真、动力学模型仿真、同步时序控制三大功能模块，能够模拟卫星在太空中运行所需的所有硬件及外部力学环境，从而可以在虚拟平台中充分测试卫星软件的功能及性能以提高卫星软件的可靠性。该项目总投入565万元人民币，历时15个月，于2019年06月正式交付运行至今，受到了客户的一致好评。本文结合笔者的实际工作经验就该项目的…（根据不同论文思目去简进概括本文内容）</p>
<p>2、项目背景</p>
<p>项目背景模板(为什么要做这个项目+岗位职责+项目规模+开发周期+项目功能和技术介绍+回应子题目并过渡到主体)</p>
<p>3、正文</p>
<p>正文应该按照论文题目和子题目的要求来写作，并且一定要回应论文子题目。</p>
<p>正文需要写1200字左右。</p>
<p>4、结尾</p>
<p>项目结尾模板(项目上线及运行效果、客户评价、项目收获、项目不足和解决思路)</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>系统架构风格(system Architecture style〉是描述某一特定应用领域中系统组织方式的惯用模式.架构风格定义了一个词汇表和一组约束，词汇表中包含一些构件和连接件类型，而这组约束指出系统是如何将这些构件和连接件组合起来的口软件系统架构风格反映了领域中众多软件系统所共有的结构和语义特性并指导如何将各个模块和子系统有效地组织成一个完整的系统。软件系统架构风格的共有部分可以使得不同系统共享同一个实现代码，系统能够按照常用的、规范化的方式来组织，便于不同设计者很容易地理解系统架构。</p>
<p>请以“软件系统架构风格”论题，依次从以下三个方面进行论述:</p>
<p>1.概要叙述你参与分析和开发的软件系统开发项目以及你所担任的主要工作。</p>
<p>2.分析软件系统开发中常用的软件系统架构风格有哪些?详细阐述每种风格的具体含义。</p>
<p>3.详细说明在你所参与的软件系统开发项目中，采用了哪种软件系统架构风格，具体实施效果如何。</p>
<p>摘要：</p>
<p>2022年5月，我参与了某公司承接某银行的智能运维统一告警管理平台项目的建设，并在项目中担任系统架构师，负责该项目的系统设计工作。该系统主要包括告警接入流式处理，告警通知中心，告警智能检测分析三大功能模块，能够对银行各种监控系统的告警事件与业务性能指标进行统一的接入与处理，实现告警的全生命周期管控，帮助一线，二线运维人员快速了解告警分布，可疑故障组件和应用，快速识别关键告警信息及假告警，处理告警风暴，解决告警多无所适从的困境，提高运维效率。</p>
<p>该项目总计投入820万人民币，历时14个月，于2023年7月正式验收交付，并投入生产环境稳定运行至今，协助客户高效率解决了十二起告警风暴，受到了客户一致好评。本文结合笔者的实际工作经验就该项目的架构设计风格进行讨论，论多种架构风格在该项目中的应用以及实施效果。</p>
<p>正文：</p>
<p>某银行的告警监控系统庞杂，需要同时应对多个系统的告警管理，存在诸多问题，当告警风暴来临的时候，缺乏统一数据采集与存储工具，工具分散、信息杂乱，数据标准化程度低；缺乏统一数据查询分析工具，数据孤岛效应明显，没有有效的关联分析手段，这些就会导致告警易读性差，告警数量、字段多，有效告警识别困难，异常发现时效性慢，告警误报漏报多，故障排查依赖于专家经验，无法快速准确的定界根因。为了解决当前的运维困境，该行领导决定使用项目经费采购一套统一告警智能运维管理平台，整合各个监控工具的告警事件，进行告警的集中化管理与处理，增加告警的关联分析功能，提高一线二线人员的运维效率。</p>
<p>我所在的公司成功中标该项目，并于2022年5月正式启动该项目的建设工作，我被任命为该项目的系统架构设计师，负责该系统的架构设计工作。该项目总计投入820万人民币，历时14个月，于2023年7月正式验收交付。该系统包含三大主要功能模块告警接入处理功能、告警通知中心功能、告警智能分析检测功能和一些次要功能模块。一、告警接入处理功能，主要对多个监控工具产生的告警数据进行统一接入和标准化，用户可以根据不同的接入源配置不同的字段映射，经过标准化的告警会进入告警的流式处理流程，可以对告警事件进行过滤，屏蔽，压缩，丰富，定级，处置，跟踪，实现告警事件全生命周期管控。二、告警事件通知中心功能，用户可以自定义配置通知规则，多个通知规则构成通知规则池，告警在流式处理流程中，会流入通知规则池，根据通知规则去匹配触发通知，比如告警等级达到某个级别，某一段时间内告警数量突增等条件会发送通知到对应的处理人，并提供通知记录管理、通知人管理等功能。三、告警事件智能检测分析功能，通过不同的分析组件对指定时间段内的告警数据进行模型训练、指标统计、算法检测、风暴定界、基带分析，然后将这些分析结果进行汇总得到一份摘要报告呈现给用户，帮助用户快速高效准确的进行故障排查。</p>
<p>作为项目的架构设计师，我需要根据常用的架构风格进行选择与设计。常用的架构风格包括数据流风格，面向数据流的架构设计，按照一定的顺序从前向后执行，要一步一步处理的，可以参考此架构风格；调用返回风格，构件之间存在相互调用的关系，比如显示调用，主程序/子程序调用，面向对象，对象间的调用，分层，层与层之间的调用等；独立构件风格，构件之间相互独立，不存在显示调用关系，而是通过某个事件驱动触发，可以是异步调用，进程通信等的隐式调用，优点是利于软件复用为构件的维护和演化带来方便，缺点是只能被动控制；虚拟机风格，可以自定义流程，按流程执行，规则随时改变，灵活定义，业务灵活组合；以数据为中心的风格，以数据为中心进行数据共享，在处理复杂问题和协作方面有一定的优势；闭环控制风格，发出控制命令并接受反馈，通过反馈循环达到控制平衡。</p>
<p>根据以上功能需求以及常用架构风格考虑，参考产品总负责人的指导建议，每个功能模块我们选用了不同的架构风格进行设计。</p>
<p>告警接入处理功能我们选用了数据流风格，来满足该功能模块的需求。数据流风格的特点是面向数据流，按照一定的顺序从前向后执行，其中的管道过滤风格适用于该功能的设计。我们提供多种接入方式，Kafka接入，Post接口接入，接入后的告警数据按照我们定义好的流程按顺序执行，将整个流程分为不同阶段，接入标准化、丰富、定级、过滤，屏蔽，压缩，关闭等，前一个阶段的输出，作为后一个阶段的输入，在每一个阶段中用户可以自定义筛选条件，按照设置好的筛选条件当告警流入这一阶段时只要满足筛选条件就会触发相应的动作，技术选择上使用Redis5.0以上版本的stream流消息结构，作为各个阶段的流队列中间件衔接，该结构相比于kafka等队列更加轻量化，并能够提供消息确认机制确保各个阶段的业务逻辑正确处理。通过该架构设计实现了告警流程的全自动处理和告警生命周期的全阶段管控。</p>
<p>告警通知中心功能我们选用了虚拟机风格，来满足功能模块的需求。虚拟机风格的特点是可以自定义规则，规则随时改变，灵活定义，灵活组合，其中虚拟机规则系统风格适用于该功能的设计。我们提供用户可以自定义通知规则的配置功能，构建通知规则池，告警数据流入规则池后，会触发各种规则的匹配，匹配后会触发通知，实现基于规则集匹配的自动化智能通知功能，规则引擎选用Drools实现，该引擎规则设置灵活，可以实时修改规则并实时生效，实现通知规则的实时匹配，实时生效。当某一告警同时命中多个规则时，可以根据用户的配置设置执行策略，通过Drools引擎可以设置按优先级执行、全部执行、将规则分组，按组执行等，实现规则的灵活组合以满足用户的不同需求。</p>
<p>告警智能检测分析功能我们选用了以数据为中心风格，来满足功能模块的需求。以数据为中心风格的特点是进行数据共享，根据共享信息多个组件进行通信和协作，适用于该功能的设计。将告警数据统一存储在ElasticSearch数据搜索引擎中，利用ElasticSearch的搜索特性、丰富，高效的查询聚合、分值权重排序等功能，对数据进行统计计算，并提供各个功能组件对这一批数据进行模型训练，算法检测，风暴定界，基带分析，通过组件之间的数据共享，综合各个组件的运算结果，得到一份最终的摘要报告存储在ElasticSearch中，不同的组件会不断的对ElasticSearch中的报告结果进行计算，更新，并提供实时查看功能。用户可以通这个报告，快速、综合的了解这一批告警数据的分布与风暴特征，并给出智能推荐，协助用户决策。</p>
<p>该项目于2023年7月正式验收交付，某银行客户投入生产环境使用，运行至今，期间服务稳定运行，无重大事故，并协助客户解决十二起告警事件风暴，准确对告警进行降噪，定位，根因分析，客户反馈良好，得到客户的邮件表扬，并将本项目在该银行的应用作为本公司的优秀案例进行推广，在近期基于本优秀案例又中标了三家新银行客户，受到客户的一致好评。不过由于客户的逐渐增多，不同客户的需求存在差异性，这也导致我们的功能设计、架构设计存在互不兼容的情况，在今后的工作中，我们会对项目的架构设计、功能设计不断完善，以兼容不同客户的需求，同时随着项目在生产环境的稳定运行，告警量日益增多，我们也会对大数据量告警的存储、计算、查询等性能问题不断优化。</p>
<p>摘要：</p>
<p>2022年5月，我参与了某公司承接某银行的智能运维统一告警管理平台项目的建设，并在项目中担任系统架构设计师，负责该项目的系统设计工作。该系统主要包括告警规则处理与展示，告警通知中心，告警智能检测分析三大功能模块，能够对银行的各种监控系统的告警事件和性能业务指标进行统一的接入与处理。实现告警的全生命周期管控，帮助一线、二线人员快速了解告警分布，可疑故障组件和应用，快速识别关键告警信息和假告警，处理告警风暴，解决告警多无所适从的困境，提高运维效率。</p>
<p>该项目总计投入820万人民币，历时14个月，于2023年7月正式验收交付，并投入生产环境稳定运行至今，协助客户高效率解决十二起告警风暴，受到客户的一致好评。本文结合笔者的实际工作经验就该项目的层次架构设计进行讨论，论层次架构在该项目中的应用以及实施效果。</p>
<p>正文：</p>
<p>某银行的告警监控系统庞杂，需要同时应对多个系统的告警管理，存在诸多问题，当告警风暴来临的时候，缺乏统一的数据采集与存储工具，工具分散，信息杂乱，数据标准化程度低；缺乏统一的数据查询分析工具，数据孤岛效应明显，没有有效的关联分析手段，这样会导致告警易读性差，告警数量多，字段多，有效告警识别困难，异常发现时效性慢，故障解决依赖专家经验，无法快速准确的定界根因。为了解决当前的运维困境，某行领导决定采购一套统一告警智能运维管理平台，整合各个监控的告警事件，进行告警的集中化管理与处理，增加告警的关联分析功能，提高一线二线人员的运维效率。</p>
<p>我所在的公司成功中标该项目，由我负责该系统的架构设计工作。该系统包含三大主要功能模块，一、告警规则处理展示功能模块，主要对多个监控工具产生的告警进行采集、标准化、丰富、定级、压缩、屏蔽等规则处理，经过处理的数据通过告警列表进行展示、操作，并提供各种图表统计，帮助运维人员快速了解告警分布。二、告警通知中心功能，用户可以自定义各种通知规则，构成通知规则集，告警数据在处理过程中会匹配规则触发通知，并提供通知记录，通知人的管理页面。三、告警智能检测分析功能，通过不同的分析组件对指定时间段内的告警数据进行模型训练，指标统计，算法检测，风暴定界，基带分析，然后将这些分析结果进行汇总得到一份摘要报告呈现给用户，帮助用户快速高效准确的进行故障排查。</p>
<p>作为该项目的系统架构设计师，参考产品总负责人的指导建议，我们决定选用层次架构进行设计。层次架构是一种最通用的体系架构，也叫N层架构模式，分为表示层，业务逻辑层，数据访问层，它的优势在于将系统分为多个独立的层次，提高系统的模块化程度，易于理解，扩展和维护，同时每个层次独立设计和实现，提高了代码的可重用性，高内聚，低耦合，可以降低层与层之间的依赖。根据该项目系统功能特性，我们将告警的展示，图表统计展示，通知记录管理，分析报告的呈现置于表示层，告警的处理逻辑，通知逻辑，分析，计算等置于业务逻辑层，告警数据的存储，报告的存储，告警数据的查询与统计，置于数据访问层。采用MVC的设计模式，将各层分离，降低耦合度。</p>
<p>接下来我将详细阐述表示层，业务逻辑层，数据访问层的设计思路，以及遇到问题和解决方案。</p>
<p>表示层，就是我们呈现给用户的界面，用于显示告警数据，图表展示，报告展示，记录展示等，并接受用户的输入对告警数据，记录进行操作。由于告警数据展示，图表展示等涉及统计计算，为了避免表示层过于复杂，采用单一职责原则，确保展示层只负责处理数据和用户交互，将复杂的统计计算放在中间层处理。同时前端采用React框架，提高开发效率，减少代码复杂度。告警列表，图表展示时涉及数据量大，多图渲染等性能问题，为了提高性能采用异步加载技术，LocalStory缓存数据，列表虚拟滚动的技术来优化用户体验。在界面展示交互方面制定统一的UI设计规范和交互原则，让用户少输入多选择，避免给用户带来困惑。</p>
<p>业务逻辑层，作为表示层和数据访问层的中间层，负责处理告警规则处理逻辑，告警通知逻辑，与各种分析智能检测的计算逻辑。该层包含了大量复杂的处理规则逻辑，和分析计算逻辑，使得代码难以维护和扩展，为了应对这种情况，我们采用规则引擎Drools对告警处理规则进行集中管理，避免规则的重复定义。对于分析计算，采用模块化组件设计，分为模型训练，算法检测，风暴定界，基带分析多个功能组件，每个组件进行特定的业务功能，便于管理和维护，通过组件间的协作，最终生成一份分析摘要报告，帮助用户快速地、综合地了解这批告警数据的分布和风暴特征，并给出智能推荐，协助用户决策。</p>
<p>数据访问层，对数据库存储的告警数据，配置数据，缓存数据等进行增删改查，我们采用DAO的数据对象模式，将数据访问层与业务逻辑层进行分离，降低耦合度。但是这三种类型的数据并不能用一个数据库去解决，为了发挥多种数据库的优势，多种数据库搭配使用，我们对这三种场景的数据访问进行抽象封装，配置数据数据量较少，但要求实时更新生效，采用Mysql数据库，告警数据数据量大，要进行各种聚合查询，同时满足查询性能，采用Elasticsearch存储，还有一些业务逻辑层可能会用到的缓存数据，用Redis存储，以达到最快的访问速度。并且每一种都用对应的连接池来管理，避免频繁创建和销毁连接，提高系统的性能和资源利用率。</p>
<p>该项目于2023年7月正式验收交付，某银行客户投入生产环境使用，运行至今，期间服务稳定运行，无重大事故，并协助客户高效快速的解决十二起告警风暴事件，准确对告警进行降噪，定位，根因分析，客户反馈良好，得到客户的邮件表扬，并将本项目在该银行的应用作为本公司的优秀案例进行推广，在近期基于本优秀案例又中标了三家新银行客户，受到客户的一致好评。不过由于客户的逐渐增多，不同客户的需求存在差异性，这也导致我们的功能设计，架构设计存在不兼容的情况。在今后的工作中，我们将对项目的功能设计，架构设计不断完善，以兼容客户的不同需求。同时随着项目的稳定运行，告警量日益增多，我们也会对大数据量告警的存储，计算，查询展示等性能不断进行优化。</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机储存系统和缓存</title>
    <url>/2024/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%82%A8%E5%AD%98%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>计算机采用分级存储体系的主要目的是为了 解决存储容量 、成本和速度之间的矛盾问题<br>两级存储： Cache-主存 、主存-辅存（虚拟存 储体系）</p>
<p>寄存器 （cpu，64位比特位），Cache（SRAM相联存储器）， 内存（主存，DRAM，RAM，ROM（掉电不会丢失）），外存（辅存）</p>
<h3 id="cache缓存"><a href="#cache缓存" class="headerlink" title="cache缓存"></a>cache缓存</h3><h4 id="高速缓存cache"><a href="#高速缓存cache" class="headerlink" title="高速缓存cache"></a>高速缓存cache</h4><p>用来存储当前最活跃的程序和数据， 直接与CPU交互， 位于<br>CPU和主存之间， 容量小， 速度为内存的5—10倍， 由半导体材料构成 。其内<br>容 是主存内存的副本拷贝， 对于程序员来说是透明的，不可操作的，其他的程序员都可操作</p>
<h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><p>由控制部分和存储器组成， 存储器存储数据， 控制部分判断CPU要访问 的数据是否在Cache中， 在则命中， 不在则依据一定的算法从主存中替换，设置多级高速缓存Cache可以提高命中率（访问主存的效率）</p>
<p>使用Cache改善性能的依据是程序的局部性原理</p>
<p>时间局部性：被引用过一次的存储位置可能在未来会被多次引用 （for循环）</p>
<p>空间局部性：如果一个存储器的位置被引用，那么将来它附近的位置也会被引用  （顺序执行过程）</p>
<h4 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h4><p>在CPU工作时， 送出的是主存单元的地址， 而应从Cache存储器中 读／写信息 。这就需要将主存地址转换为Cache存储器地址， 这种地址的转换称为地址映射， 由硬件自动完成映射，Cache与主存的地址映射（主存与外存的地址映射是由软件和硬件结合完成的）</p>
<p>1、直接映射： 将Cache存储器等分成块， 主存也等分成块并编号，二者块号相同才能命中</p>
<p>2、全相联映射： 同样都等分成块并编号 。主 存中任意一块都与Cache中任意一块对应 。<br>因此可以随意调入Cache任意位置， 但地 址变换复杂， 速度较慢 。因为主存可以随 意调入Cache任意块， 只有当Cache满了 才会发生块冲突， 是最不容易发生块冲突 的映像方式</p>
<p>3、组组相连映射： 前面两种方式的结合，组间采用直接映像， 即主 存中组号与Cache中组号相同的组才能命 中， 但是组内全相联映像， 也即组号相同 的两个组内的所有块可以任意调换</p>
<table>
<thead>
<tr>
<th>地址映像方法</th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>直接相联映像</td>
<td>主存的块与Cache的块的关系是固定的</td>
<td>硬件电路设计，地址变换简单</td>
<td>冲突率较高，灵活性较差</td>
</tr>
<tr>
<td>全相联映像</td>
<td>主存与Cache均分大小相同的块，允许主存的任何一块可以调入Cache存储器的任何一块</td>
<td>冲突率较低，主存的块调入Cache的位置不受限制，十分灵活</td>
<td>电路难于设计和实现，只适用于小容量的Cache，无法从主存块号直接获得Cache块号，变换比较复杂，速度较慢</td>
</tr>
<tr>
<td>组相联映像</td>
<td>将Cache中的块再分组，组采用直接相联，块采用全相联</td>
<td>折中</td>
<td>折中</td>
</tr>
</tbody></table>
<h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><p>替换算法的目标就是使Cache获得尽可能高的命中率，当发生冲突时，需要进行页面淘汰<br>1、随机替换算法 （RAND）。就是用随机数发生器产生一个要替换的块号， 将该块替换出去 。<br>2、先进先出算法 （FIFO）。就是将最先进入Cache的信息块替换出去 。<br>3、近期最少使用算法（LRU） 。这种方法是将近期最少使用的Cache中 的信息块替换出去 。<br>4、优化替换算法 。这种方法必须先执行一次程序， 统计Cache的替换情况 。有了这样的先验信息， 在第二次执行该程序时便可以 用最有效的方式来替换</p>
<p>5、最不频繁使用算法（LFU），计数器，统计使用次数，计数器位数比较多，实现困难</p>
<h4 id="cache读写过程"><a href="#cache读写过程" class="headerlink" title="cache读写过程"></a>cache读写过程</h4><p>写直达：同时写Cache和内存</p>
<p>写回：只写cache，淘汰页面时写回内存</p>
<p>标记法：只写入内存，并将标志位清零，若用到此数据，只需要再次调取</p>
<h4 id="cache命中率"><a href="#cache命中率" class="headerlink" title="cache命中率"></a>cache命中率</h4><p>设读取一次Cache时间为1ns， 若 CPU访问的数据不在Cache中， 则需要从内存中读取， 设读取一次内 存的时间为1000ns， 若在CPU多次读取数据过程中， 有90％命中<br>Cache， 则CPU读取一次的平均时间为（ 90％＊ 1＋10％＊ 1000） ns</p>
<h3 id="存储磁盘"><a href="#存储磁盘" class="headerlink" title="存储磁盘"></a>存储磁盘</h3><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>磁盘有正反两个盘面， 每个盘面有多个同心圆， 每个同心圆是一个磁道， 每个同心 圆又被划分为多个扇区， 数据就被存放在一个个扇区中</p>
<p>磁头首先要寻找到对应的磁道， 然后等待磁盘进行周期旋转， 旋转到指定的扇区 ， 才能读取到对应的数据，</p>
<p>所以一般先进行移臂调度，切换不同磁道，再进行旋转调度，旋转到指定扇区</p>
<p>因此， 会产生寻道时间和等待时间 。公式为： 存取时间 = 寻道时间＋等待时间（平均定位时间 ＋转动延迟） 。<br>注意： 寻道时间是指磁头移动到磁道所需的时间； 等待时间为等待读写的扇区转到磁头下方所用的时间 。</p>
<h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><p>1、先来先服务FCFS： 根据进程请求访问磁盘的先后顺序进行调度<br>2、最短寻道时间优先SSTF： 请求访问的磁道与当前磁道最近的进程优先调度，使得<br>每 次的寻道时间最短 。会产生“饥饿 ”现象， 即远处进程可能永远无法访问 。<br>3、扫描算法SCAN： 又称“ 电梯算法 ”，磁头在磁盘上双向移动， 其会选择离磁头当 前所在磁道最近的请求访问的磁道， 并且与磁头移动方向一致，磁头永远都是从里 向外或者从外向里一直移动完才掉头， 与电梯类似<br>4、单向扫描调度算法CSCAN： 与SCAN不同的是， 其只做单向移动， 即只能从里向外 或者从外向里 。</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机指令系统</title>
    <url>/2024/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>计算机指令的组成： 一条指令由操作码和操作数两部分组成， 操作码决定要<br>完 成的操作， 操作数指参加运算的数据及其所在的单元地址 。</p>
<p>执行过程：<br>取指令——分析指令——执行指令三个步骤， 首先将<br>程 序计数器PC中的指令地址取出， 送入地址总线， CPU依据指令地址去内存<br>中 取出指令内容存入指令寄存器IR； 而后由指令译码器进行分析， 分析指<br>令操作 码； 最后执行指令， 取出指令执行所需的源操作数</p>
<h3 id="指令寻址方式，找到下一条指令"><a href="#指令寻址方式，找到下一条指令" class="headerlink" title="指令寻址方式，找到下一条指令"></a>指令寻址方式，找到下一条指令</h3><h4 id="顺序寻址方式"><a href="#顺序寻址方式" class="headerlink" title="顺序寻址方式"></a>顺序寻址方式</h4><p>当执行一段程序时，根据PC（程序计数器） 中指令，是一条指令接着一条指 令地顺序执行</p>
<h4 id="跳跃寻址方式"><a href="#跳跃寻址方式" class="headerlink" title="跳跃寻址方式"></a>跳跃寻址方式</h4><p>指下一条指令的地址码不是由程序计数器给出， 而是由本条指令直接给出 。<br>程 序跳跃后， 按新的指令地址开始顺序执行 。因此， 程序计数器的内容也必须相应改变， 以便及<br>时跟 踪新的指令地址 ，可以实现程序的无条件转移和有条件转移。</p>
<h3 id="指令寻址方式，找到操作数"><a href="#指令寻址方式，找到操作数" class="headerlink" title="指令寻址方式，找到操作数"></a>指令寻址方式，找到操作数</h3><h4 id="立即寻址方式"><a href="#立即寻址方式" class="headerlink" title="立即寻址方式"></a>立即寻址方式</h4><p>指令的地址码字段指出的不是地址， 而是操作数本身 。</p>
<h4 id="直接寻址方式"><a href="#直接寻址方式" class="headerlink" title="直接寻址方式"></a>直接寻址方式</h4><p>在指令的地址字段中直接指出操作数在主存中的地址 。</p>
<h4 id="间接寻址方式"><a href="#间接寻址方式" class="headerlink" title="间接寻址方式"></a>间接寻址方式</h4><p>指令地址码字段所指向的存储单元中存储的是操作数的地址 。</p>
<h4 id="寄存器寻址方式"><a href="#寄存器寻址方式" class="headerlink" title="寄存器寻址方式"></a>寄存器寻址方式</h4><p>指令中的地址码是寄存器的编号 。</p>
<h4 id="基址寻址方式"><a href="#基址寻址方式" class="headerlink" title="基址寻址方式"></a>基址寻址方式</h4><p> 将基址寄存器的内容加上指令中的形式地址而形成操作数的有效地址， 其优<br>点 是可以扩大寻址能力 。</p>
<h4 id="变址寻址方式"><a href="#变址寻址方式" class="headerlink" title="变址寻址方式"></a>变址寻址方式</h4><p>变址寻址方式计算有效地址的方法与基址寻址方式很相似， 它是将变址寄存<br>器 的内容加上指令中的形式地址而形成操作数的有效地址 。</p>
<h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><h4 id="CISC是复杂指令系统"><a href="#CISC是复杂指令系统" class="headerlink" title="CISC是复杂指令系统"></a>CISC是复杂指令系统</h4><p>兼容性强， 指令繁多 、长度可变， 由微程序实现；</p>
<h4 id="RISC是精简指令系统"><a href="#RISC是精简指令系统" class="headerlink" title="RISC是精简指令系统"></a>RISC是精简指令系统</h4><p>指令少，使用频率接近， 主要依靠硬件实现（通用寄存器 、硬布线逻辑控制） 。</p>
<table>
<thead>
<tr>
<th>指令系统类型</th>
<th>指令</th>
<th>寻址方式</th>
<th>实现方式</th>
<th>其他</th>
<th>代表</th>
</tr>
</thead>
<tbody><tr>
<td>CISC是复杂指令系统</td>
<td>兼容性强， 指令繁多 、长度可变，使用频率差别大</td>
<td>支持多种</td>
<td>微程序，也可以采用流水线技术，但不适合</td>
<td>研制周期长</td>
<td>x86</td>
</tr>
<tr>
<td>RISC是精简指令系统</td>
<td>指令少，使用频率接近，定长格式，大部分单周期指令</td>
<td>支持较少</td>
<td>增加了通用寄存器，硬布线逻辑控制为主，更适合采用流水线</td>
<td>优化编译，有效支持高级语言</td>
<td>ARM，RISC-V</td>
</tr>
</tbody></table>
<h3 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h3><p>取指 -&gt; 分析 -&gt; 执行<br>将指令分成不同段， 每段 由不同的部分去处理， 因此可以产生叠加的 效果， 所有的部件去处理指令的不同段</p>
<p>流水线是指程序在执行多条指令重叠操作的一种准并行处理实现技术</p>
<h4 id="流水线技术"><a href="#流水线技术" class="headerlink" title="流水线技术"></a>流水线技术</h4><p>（ 1）超流水线（ Super Pipe Line）技术 。 它通过细化流水 、增加级数和提高主频，使 得在每个机器周期内能完成一个甚至两个浮 点操作 。其实质是以时间换取空间 。<br>（ 2）超标量（ Super Scalar）技术 。它通 过内装多条流水线来同时执行多个处理， 其 时钟频率虽然与一般流水接近， 却有更小的 CPI 。其实质是以空间换取时间 。<br>（ 3）超长指令字（ Very Long Instruction<br>Word，VLIW）技术 。 VLIW和超标量都是 20世纪80年代出现的概念， 其共同点是要同 时执行多条指令， 其不同在于超标量依靠硬 件来实现并行处理的调度，VLIW则充分发挥 软件的作用， 而使硬件简化， 性能提高</p>
<h4 id="流水线周期"><a href="#流水线周期" class="headerlink" title="流水线周期"></a>流水线周期</h4><ol>
<li><p>流水线周期： 指令分成不同执行段， 其中执行时间最长的段为流水线周期 。</p>
</li>
<li><p>流水线执行时间： </p>
<p>理论公式：1条指令总执行时间＋（总指令条数-1）＊流水线周期 。</p>
<p>实践公式：执行阶段数x流水线周期 + （总指令条数-1）＊流水线周期 </p>
</li>
<li><p>流水线吞吐率计算： 吞吐率即单位时间内执行的指令条数 。<br> 公式： 指令条数／流水线执行时间 。</p>
</li>
<li><p>流水线的加速比计算： 加速比即使用流水线后的效率提升度， 即比不使用流水线快了多少倍， 越高表明流水线效率越高，<br> 公式： 不使用流水线执行时间／使用流水线执行时间 。</p>
</li>
</ol>
<h3 id="Flynn分类法"><a href="#Flynn分类法" class="headerlink" title="Flynn分类法"></a>Flynn分类法</h3><table>
<thead>
<tr>
<th>体系结构</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>单指令单数据流（SISD）</td>
<td>传统的串行计算机，冯诺依曼架构</td>
</tr>
<tr>
<td>单指令多数据流（SIMD）</td>
<td>单核计算机，GPU（显卡）</td>
</tr>
<tr>
<td>多指令单数据流（MISD）</td>
<td>理论模型，没有实际到应用中</td>
</tr>
<tr>
<td>多指令多数据流（MIMD）</td>
<td>主流计算机，intel，amd等多核处理器</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机操作存储，文件，设备管理</title>
    <url>/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E5%AD%98%E5%82%A8%EF%BC%8C%E6%96%87%E4%BB%B6%EF%BC%8C%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><h3 id="页式存储"><a href="#页式存储" class="headerlink" title="页式存储"></a>页式存储</h3><p>页式存储是操作系统的一种存储管理方式。通过页表来进行映射程序中的页在内存中的块的存储</p>
<p>进程(程序)中的地址， 我们称之为逻辑地址(虚地址),而内存中的地址我们称之为物理地址(实地址)；</p>
<p>每个页分为页号和页内地址， 页号用来和块号对应， 代表存储的位置， 大小可以代表页的数量，页内地址代表的是存储的数据内容， 大小可以代表数据大小</p>
<p>优点： 利用率高 、碎片小（只在最后一个页中有） 、分配及管理简单 。缺点： 增加了系统开销，可能产生抖动现象。</p>
<p>默认页面大小是4K，逻辑地址十六进制1D16H，H代表是十六进制，所以数据是1D16， 通常来说1是页码，D16是数据，所以物理地址就是1对应的块号，数据不变还是D16</p>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>缺页表示需要执行的页不在内存物理块中， 需要从外部调入内存， 会增加执行时间，因此， 缺页数越多， 系统效率越低。</p>
<p>最优算法： OPT，理论上的算法， 无法实现， 是在进程执行完后进行的最佳效率计算， 用来让其他算法比较差距 。原理是选择未来最长时间内不被访问的页面置换， 这样可以保证未来执行的都是马上要访问的。<br>先进先出算法： FIFO， 先调入内存的页先被置换淘汰， 会产生抖动现象， 即分配的页数越多， 缺页率可能越多（即效率越低）<br>最近最少使用： LRU，在最近的过去， 进程执行过程中， 过去最少使用的页面被置换淘汰， 根据局部性原理，这种方式效率高， 且不会产生抖动现象。</p>
<p>最少访问过的先淘汰掉</p>
<h4 id="快表（TLB）"><a href="#快表（TLB）" class="headerlink" title="快表（TLB）"></a>快表（TLB）</h4><p>快表是一块小容量的相联存储器， 由快速存储器组成， 按内容访问， 速度快， 并且可以从硬件上保证按内容并行查找， 一般用来存放当前访问最频繁的少数活动页面的页号(可以看成是页表的频繁访问数据的副本)。</p>
<p>快表是将页表存于Cache中<br>慢表是将页表存于内存上</p>
<p>因此慢表需要访问两次内存才能取出数据， 而快表是访问一次Cache和一次内存， 因此更快</p>
<p>第一次去拿页号，第二次去拿物理地址</p>
<h3 id="段式存储"><a href="#段式存储" class="headerlink" title="段式存储"></a>段式存储</h3><p>将进程空间分为一个个段， 每段也有段号和段内地址， 与页式存储不同的是， 每段物理大小 不同， 分段是根据逻辑整体分段的</p>
<p>地址表示： （段号， 段内偏移）：其中段内偏移不能超过该段号对应的段长， 否则越界错误，而此地址对应的真正内存地址应该是： 段号对应的基地址（所存储的位置）+段内偏移。</p>
<p>优点： 程序逻辑完整， 修改互不影响<br>缺点： 内存碎片浪费大，导致内存利用率低。</p>
<p>段表，段号，基地址，段长，看是否越界，是看的段长，不是基地址（0，1597）。0是段号，1597是段内偏移，就是段长</p>
<h3 id="段页存储"><a href="#段页存储" class="headerlink" title="段页存储"></a>段页存储</h3><p>对进程空间先分段， 后分页，段表每个段号再对应一个页表， 优缺点如下：<br>优点： 空间浪费小 、存储共享容易 、能动态连接。<br>缺点： 由于管理软件的增加， 复杂性和开销也增加， 执行速度下降</p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>计算机系统中采用的索引文件结构如下图所示：<br><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E5%AD%98%E5%82%A8%EF%BC%8C%E6%96%87%E4%BB%B6%EF%BC%8C%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/1.jpg" alt="1"><br>系统中有13个索引节点， 0-9为直接索引， 即每个索引节点存放的是内容， 假设每个物理<br>盘大小为4KB， 共可存4KB*10=40KB数据；<br>10号索引节点为一级间接索引节点， 大小为4KB， 存放的并非直接数据， 而是链接到直<br>接 物理盘块的地址， 假设每个地址占4B， 则共有1024个地址， 对应1024个物理盘， 可<br>存1024x4KB=4096KB数据。<br>二级索引节点类似， 直接盘存放一级地址， 一级地址再存放物理盘快地址，而后链接到存放数据的物理盘块， 容量又扩大了一个数量级， 为1024x1024x4KB数据。</p>
<p>8个地址项0，1，2，3，4，5，6，7，每个地址项大小4字节，5个地址为直接索引0，1，2，3，4，2个是一级索引5，6，一个是二级索引7，，磁盘索引块和磁盘数据块大小为1KB，访问文件的逻辑块号为5和518，块号为5是第6个，块号518是第519个，地址是4字节，1kb大小，则一级索引就可以存256个，两个1级索引就是512，，加上前面5个直接索引就是5个数据，就是517</p>
<p>单个文件最大长度就是直接索引加一级索引加二级索引的总和</p>
<h3 id="树形文件"><a href="#树形文件" class="headerlink" title="树形文件"></a>树形文件</h3><p>相对路径： 是从当前路径开始的路径，不包括当前的工作目录。<br>绝对路径： 是从根目录开始的路径。</p>
<h3 id="空间存储"><a href="#空间存储" class="headerlink" title="空间存储"></a>空间存储</h3><p>空闲区表法： 将所有空闲空间整合成一张表， 即空闲文件目录。<br>空闲链表法： 将所有空闲空间链接成一个链表， 根据需要分配。<br>成组链接法： 既分组， 每组内又链接成链表， 是上述两种方法的综合。<br>位示图法： 对每个物理空间用一位标识， 为1则使用， 为0则空闲， 形成一 张位示图。</p>
<p>32位，0到31每个对应一个物理块，一排就是一个字，字长就是32，第几个字就是第几排</p>
<p>4195号就是第4196个数据，4196除以32得131余4，131存满，第132个字，也就是第132排</p>
<p>余4就是第4个位置，0，1，2，3， 3号位是1，已经存储了</p>
<h2 id="微内核操作系统"><a href="#微内核操作系统" class="headerlink" title="微内核操作系统"></a>微内核操作系统</h2><p>微内核， 顾名思义， 就是尽可能的将内核做的很小， 只将最为核心必要的东西放入内核中， 其<br>他 能独立的东西都放入用户进程中， 这样， 系统就被分为了用户态和内核态<br><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E5%AD%98%E5%82%A8%EF%BC%8C%E6%96%87%E4%BB%B6%EF%BC%8C%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/2.jpg" alt="1"></p>
<h2 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h2><p>嵌入式操作系统特点： 微型化 、代码质量高 、专业化 、实时性强 、可裁剪可配置。<br>实时嵌入式操作系统的内核服务： 异常和中断 、计时器 、I/O管理。<br>常见的嵌入式RTOS（实时操作系统）：VxWorks、RT-Linux、QNX、pSOS。<br>嵌入式系统初始化过程按照自底向上 、从硬件到软件的次序依次为：<br>芯片级初始化-&gt;板卡级初始化-&gt;系统级初始化。<br>芯片级是微处理器的初始化， 板卡级是其他硬件设备初始化， 系统级初始化就是软 件及操作系统初始化。</p>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="SPOOLING技术"><a href="#SPOOLING技术" class="headerlink" title="SPOOLING技术"></a>SPOOLING技术</h3><p>外设建立两个缓冲区，输入井和输出井，数据排队打印，每个进程都在用一个打印机，设备虚拟化</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机操作系统进程管理</title>
    <url>/2024/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>通过资源管理提高计算机系统的效率； 改善人机界面向用户提供友好的工作环境。</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>并发性 、 共享性 、 虚拟性 、 不确定性。</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>进程管理 、存储管理 、 文件管理 、设备管理 、作业管理。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>批处理操作系统 、分时操作系统（轮流使用CPU工作片） 、<br>实时操作系统（快速响应） 、网络操作系统 、分布式操作系统（物理分散的<br>计 算机互联系统） 、微机操作系统（Windows） 、嵌入式操作系统。</p>
<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p>BIOS-&gt;主引导记录-&gt;操作系统。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是计算机中正在运行的程序的实例 。它是操作系统进行资源分配和管理的基本单位， 包括代码、数据和执行状态等信息</p>
<p>进程控制块PCB（唯一标志） 、程序（描述进程要做什么） 、数据（存放进程执行时 所需数据）</p>
<h4 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h4><p>分为三态图，五态图<br><img src="/2024/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/1.jpg" alt="1"><br><img src="/2024/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/2.jpg" alt="1"></p>
<h4 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h4><p>用来表示哪些任务可以并行执行， 哪些任务之间有顺序关系<br>任务间的并行 、 任务间的先后顺序。<br><img src="/2024/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/3.jpg" alt="1"></p>
<h4 id="资源图"><a href="#资源图" class="headerlink" title="资源图"></a>资源图</h4><p>用来表示进程和资源之间的分配和请求关系。<br><img src="/2024/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/4.jpg" alt="1"><br>P代表进程， R代表资源， R方框中有几个圆球就表示有几个这种资源， 在图中， R1指向P1， 表示R1有一个资源已经分配给了P1， P1指向R2， 表示P1还需要P1请求一个R2资源才能执行。</p>
<p>阻塞节点： 某进程所请求的资源已经全部分配完毕，先分配，后请求， 无法获取所需资源， 该进程被阻塞了无法<br>继 续 。如上图中P2。<br>非阻塞节点： 某进程所请求的资源还有剩余， 可以分配给该进程继续运行 。如上图中P1、P3。<br>当一个进程资源图中所有进程都是阻塞节点时， 即陷入死锁状态。</p>
<h4 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h4><p>互斥： 某资源（即临界资源）在同一时间内只能由一个任务单独使用， 使用时需要加锁，使用完后解锁才能被其他任务使用；</p>
<p>临界资源： 各进程间需要以互斥方式对其进行访问的资源。<br>临界区： 指进程中对临界资源实施操作的那段程序 。本质是一段程序代码。<br>互斥信号量：对临界资源采用互斥访问，使用互斥信号量后其他进程无法访问，初值为1。</p>
<p>同步： 多个任务可以并发执行， 只不过有速度上的差异，在一定情况下停下等待，不存在资源是否单独或共享的问题；</p>
<p>同步信号量： 对共享资源的访问控制，初值一般是共享资源的数量。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>P操作： 申请资源， S=S-1，若S&gt;=0， 则执行P操作的进程继续执行；若S&lt;0， 则<br>置该进程为阻塞状态（因为无可用资源），并将其插入阻塞队列。<br>V操作： 释放资源， S=S+1，若S&gt;0， 代表此时资源有空余， 没有阻塞的进程， 则<br>该进程继续执行； 若S&lt;=0， 代表此时线程在被阻塞， 所以需要从阻塞状态唤醒一<br>个进程， 并将其插入就绪队列（此时因为缺少资源被P操作阻塞的进程可以继续执<br>行），然后执行V操作的进程继续。</p>
<p>经典问题： 生产者和消费者的问题<br>三个信号量： 互斥信号量S0（仓库独立使用权）， 同步信号量S1（仓库空闲位<br>置）， 同步信号量S2（仓库商品个数） 。<br>生产者流程：<br>生产一个商品S<br>P(S0) 占用仓库<br>P(S1) 申请资源，申请一个位置<br>将商品放入仓库中<br>V(S2) 释放资源，商品个数+1<br>V(S0) 不再占用仓库<br>消费者流程：<br>P(S0) 占用仓库<br>P(S2) 消耗一个商品，商品个数-1<br>取出一个商品<br>V(S1) 商品被取出，释放一个位置+1<br>V(S0) 不再占用仓库</p>
<p>1、PV对等，会形成平衡 </p>
<p>2、先P后V</p>
<p>1、图上面都是P操作，下面都是V操作，根据V的信号量，在前驱图标出信号量S</p>
<p>前驱图：</p>
<p>指进去P操作，指进去的前面的点就是V操作，指出去V操作，指出去后面的点就是P操作</p>
<p>如果第一个进程只有一步，就是V操作</p>
<p>如果最后一个点只有一步，就是P操作</p>
<p>2、两个程序段推导，根据S信号量的初始值，然后PV的操作顺序，来控制程序等待，如果唤醒了其他进程，需要当前进程执行完，才去执行被唤醒的进程</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>当一个进程在等待永远不可能发生的事件时， 就会产生死锁， 若系统中<br>有 多个进程处于死锁状态， 就会造成系统死锁。<br>死锁产生的四个必要条件：<br>• 资源互斥<br>• 每个进程占有资源并等待其他资源<br>• 系统不能剥夺进程资源<br>• 进程资源图是一个环路。</p>
<p>死锁产生后， 解决措施是打破四大条件， 有下列方法：<br>死锁预防： 采用某种策略限制并发进程对于资源的请求，破坏死锁产生的四个条件之一， 使系统任何时刻都不满足死锁的条件。<br>死锁避免： 一般采用银行家算法来避免，银行家算法， 就是提前计算出一条不会死锁的资源分配方法， 才分配资源，否则不分配资源，相当于借贷， 考虑对方 还得起才借钱， 提前考虑好以后， 就可以避免死锁。<br>死锁检测： 允许死锁产生， 但系统定时运行一个检测死锁的程序，若检测到系<br>统 中发生死锁， 则设法加以解除。<br>死锁解除： 即死锁发生后的解除方法， 如强制剥夺资源，撤销进程等。</p>
<p>死锁计算问题： 系统内有n个进程，每个进程都需要R个资源，那么其发生死锁的最 大资源数为n<em>（R-1） 。其不发生死锁的最小资源数为n</em>（R-1）+1。</p>
<p>银行家算法问题：</p>
<p>根据总资源数-已分配资源数，得到剩余资源数，然后看满足哪个进程资源先执行，先执行后就会释放资源</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>传统的进程有两个属性：<br>• 可拥有资源的独立单位<br>• 可独立调度和分配的基本单位<br>引入线程后， 线程是独立调度的最小单位， 进程是拥有资源的最小单位，<br>线程可以共享进程的公共数据 、全局变量 、代码 、文件等资源， 但不能<br>共 享线程独有的资源， 如线程的栈指针等标识数据</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机硬件组成</title>
    <url>/2024/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="硬件系统"><a href="#硬件系统" class="headerlink" title="硬件系统"></a>硬件系统</h3><p>计算机的基本硬件系统由运算器、控制器、存储器、输入设备和输出设备5大<br>部件组成。</p>
<p>运算器、控制器等部件被集成在一起统称为中央处理单元CPU。</p>
<p>存储器是计算机系统中的记忆设备，分为内部存储器和外部存储器。</p>
<p>输入设备和输出设备合称为外部设备（简称外设），输入设备用于输入原始数<br>据及各种命令，而输出设备则用于输出计算机运行的结果。</p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>1、程序控制：CPU通过执行指令来控制程序的执行顺序，这是CPU的重要功能。<br>2、操作控制：一条指令功能的实现需要若干操作信号配合来完成，CPU产生每条指令的操<br>作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。<br>3、时间控制：CPU对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、<br>持续时间及出现的时间顺序都需要进行严格控制。<br>4、数据处理：CPU通过对数据进行算术运算及逻辑运算等方式进行加工处理，数据加工处<br>理的结果被人们所利用。所以，对数据的加工处理也是CPU最根本的任务。</p>
<p>此外，CPU还需要对系统内部和外部的中断或异常做出响应，进行相应的处理。</p>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>CPU主要由运算器、控制器、寄存器组和内部总线等部件组成</p>
<p>1、运算器：执行所有的算术运算，数据加工，如加减乘除等；执行所有的逻辑运算并进行逻辑测试，如与、或、非、比较等，只有加法计算器。<br>1） 算术逻辑单元ALU（实现对数据的算术和逻辑运算）<br>2）累加寄存器AC（运算结果或源操作数的存放区）<br>3）数据缓冲寄存器DR（暂时存放内存的指令或数据）<br>4）状态条件寄存器PSW（保存指令运行结果的条件码内容，如溢出标志等）组成。<br>2、 控制器：控制整个CPU的工作，最为重要，保证指令的正确执行，能够处理异常事件。<br>1） 指令寄存器IR（暂存CPU执行指令）<br>2） 程序计数器PC（存放指令执行地址）<br>3）地址寄存器AR（保存当前CPU所访问的内存地址）<br>4） 指令译码器ID（分析指令操作码）等组成。</p>
<p>通过汇编指令可以操作寄存器</p>
<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>二转十：</p>
<p>带符号：，符号位最高位1为负数，0为正数</p>
<p>小数位：小数点后第1位x2的-1次方，以此类推相加</p>
<p>十转二：</p>
<p>整数位：除2取余，直至结果为0，下到上记录</p>
<p>小数位：x2取整数部分，直到小数部分为0， 上到下记录</p>
<p>十六（H）转二：</p>
<p>一位对应4位的二进制，90H，9对应4位二进制1001，0对应的二进制0000</p>
<h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>最高位符号位，其余n-1位数的绝对值，0的原码有两种 +0 -0</p>
<p>原码运算，只适用于加法，因为符号位的问题，导致减法（变相的加法）会出问题</p>
<p>根据机器字长补0，符号位占一位</p>
<h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>正数的反码还是等于原码</p>
<p>负数的反码，原码除符号位外，其他位按位取反</p>
<p>反码中，计算会有问题</p>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>正数的补码等于原码</p>
<p>负数的补码等于反码+1，或（原码）等于2的机器字长次方-负数的绝对值</p>
<p>通过补码计算 减法，正数加上负数，计算机中都通过补码进行加减运算</p>
<p>负数的补码-1就是反码，取反就是原码</p>
<p>补码将减法转换为加法，简化运算器的设计</p>
<p>原码，反码，补码，的最高位都是符号位</p>
<h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><p>补码的符号位取反，表示浮点数的指数（阶码）</p>
<p>浮点数：</p>
<p>尾数x基数的阶码次幂</p>
<p>尾数：补码表示，表示精度，位数越多精度越高</p>
<p>阶码：移码表示，表示范围，位数越多范围越大</p>
<p>对阶：小数向大数看齐，阶码一致，将尾数右移n位阶差，小数点左移</p>
<h3 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h3><p>在两个编码中，从A码到B码转换所需要改变的位数称为码距，如A： 00要转换为B：11，码距为2。一般来说，码距越大，越利于纠错和检错</p>
<h4 id="奇偶校验码："><a href="#奇偶校验码：" class="headerlink" title="奇偶校验码："></a>奇偶校验码：</h4><p>用增加校验位的方法</p>
<ol>
<li>无论数据位多少位，校验位只有一位</li>
<li>数据位和校验位一共所含的1个数为奇数，称为奇校验</li>
<li>数据位和校验位一共所含的1个数为偶数，称为偶校验，只能检测出奇数个错误</li>
</ol>
<p>可以检查出误码，但不能纠错</p>
<h4 id="循环冗余校验码（Cyclic-Redundancy-Check，CRC）"><a href="#循环冗余校验码（Cyclic-Redundancy-Check，CRC）" class="headerlink" title="循环冗余校验码（Cyclic Redundancy Check，CRC）"></a>循环冗余校验码（Cyclic Redundancy Check，CRC）</h4><p>可以检查错误，不能纠错，漏检率比较低</p>
<p>模2除法：</p>
<p>1、被除数首位是几，商就是几</p>
<p>2、异或运算，相同为0，不同为1</p>
<p>3、弃首位，补末位，再上商</p>
<p>计算过程：<br>假设原始信息串为10110，CRC的生成多项式为G（x）＝x＾4＋x＋1，必须包含1，求CRC校验码。<br>1、在原始信息位后面添0，假设生成多项式的阶为r，则在原始信息位后添加r个0，本题中，G<br>（x）阶为4，则在原始信息串后加4个0，得到的新串为101100000，作为被除数。<br>2 、由多项式得到除数，多项中x的幂指数存在的位置1，不存在的位置0。本题中，x的幂指数为<br>0，1，4的变量都存在，而幂指数为2，3的不存在，因此得到串10011。<br>3、生成CRC校验码，将前两步得出的被除数和除数进行模2除法运算（即不进位也不借位的除法运<br>算）。<br>得到余数1111。<br>注意：余数不足r，则余数左边用若干个0补齐。如求得余数为11，r＝4，则补两个0得到0011。<br>4、生成最终发送信息串，将余数添加到原始信息后。上例中，原始信息为10110，添加余数<br>1111后，结果为101101111。发送方将此数据发送给接收方。<br>5、接收方进行校验。接收方的CRC校验过程与生成过程类似，接收方接收了带校验和的帧后，<br>用多项式G（x）来除。余数为0，则表示信息无错；否则要求发送方进行重传。</p>
<p>上面是发送方</p>
<p>注意接收方，接收方就是被除数</p>
<h4 id="海明码校验"><a href="#海明码校验" class="headerlink" title="海明码校验"></a>海明码校验</h4><p>可以检错，也可以纠错</p>
<p>数据位n位，增加k个校验位，扩大码距</p>
<p>2的k次方 -1 &gt;= n + k</p>
<p>传送的信息是1010，海明校验，奇校验的规则下海明码</p>
<p>1、根据上面的公式，n是信息位，求出k校验位的个数，1010，求出的k是3，n是4,则海明码是7位</p>
<p>2、然后校验码Pi，要放在2的i-1次方的位置，也就是i=1，2，3，求出Pi的位置1，2，4，剩下的4位就是数据位D1,D2,D3,D4</p>
<p>3、根据海明位的校验位的位置是1，2，4，被校验的海明位的下标是校验位的下标之和，如果该海明位就是校验位，那就是自身校验，得到每个海明位，根据下标和，得到所关联的校验位</p>
<p>4、得到校验位的对应的海明位的数据位一组，根据奇偶校验补充得到校验位的海明位，和原先数据位组合得到海明码</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>计算机网络的功能： 数据通信 、资源共享 、管理集中化 、实现分布式处理 、负 载均衡。<br>网络性能指标： 速率 、带宽(频带宽度或传送线路速率)、吞吐量 、时延 、往返时间 、利用率。<br>网络非性能指标： 费用 、质量 、标准化 、可靠性 、可扩展性 、可升级性 、易管理性和可维 护性。</p>
<h2 id="拓扑分类"><a href="#拓扑分类" class="headerlink" title="拓扑分类"></a>拓扑分类</h2><h3 id="总线型拓扑"><a href="#总线型拓扑" class="headerlink" title="总线型拓扑"></a>总线型拓扑</h3><p>特点:采用总线的形式将所有计算机相连,信息只能在一条线路上传输。</p>
<ul>
<li>优点:成本低,实现简单。</li>
<li>缺点:带宽低,延迟高,任何节点发生故障整条总线瘫痪。</li>
<li>举例:一个简单的以太网线路就是总线型拓扑的一个例子 。所有计算机通过网线连接到交<br>换机的各个端口上,数据只能在这条总线上传输<br><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.jpg" alt="1"><h3 id="星型拓扑"><a href="#星型拓扑" class="headerlink" title="星型拓扑"></a>星型拓扑</h3></li>
<li>特点:通过一个中心交换机将计算机互联,形成星型网络。</li>
<li>优点:容易扩展,集中管理。</li>
<li>缺点: 中央交换机单点故障会瘫痪全网。</li>
<li>举例:一个小型办公室的网络就可以采用星型拓扑 。计算机通过网线连接到中心的交换机<br>上,形成星型结构<br><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.jpg" alt="1"><h3 id="环型拓扑"><a href="#环型拓扑" class="headerlink" title="环型拓扑"></a>环型拓扑</h3></li>
<li>特点:计算机按环形连接,信息只能前进或后退进行传输。</li>
<li>优点:故障启闭容易诊断。</li>
<li>缺点:数据传输效率低,扩展性差<br><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.jpg" alt="1"><h3 id="树型拓扑"><a href="#树型拓扑" class="headerlink" title="树型拓扑"></a>树型拓扑</h3></li>
<li>特点:采用分级交换机进行分层管理的方式构建局域网。</li>
<li>优点:易于管理和扩展,并行数据传输,性能高。</li>
<li>缺点:增加层次会降低效率。</li>
<li>举例:一个大型的企业网络可能采用树型拓扑 。计算机先连接到分支交换机上,<br>分 支交换机再连接到主干交换机上,实现分级管理<br><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.jpg" alt="1"><h3 id="分布式拓扑"><a href="#分布式拓扑" class="headerlink" title="分布式拓扑"></a>分布式拓扑</h3></li>
<li>特点:任何节点都能与其他节点互联,不存在集中交换。</li>
<li>优点:无中心,任意节点故障不影响全网。</li>
<li>缺点:管理复杂,成本高。</li>
<li>举例: 比特币网络就是一个分布式拓扑的例子 。 网络中的每个节点都是对等的,<br>没 有中心机构 。任意两个节点都可以直接通信<br><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.jpg" alt="1"></li>
</ul>
<h2 id="通信技术"><a href="#通信技术" class="headerlink" title="通信技术"></a>通信技术</h2><p>计算机网络是利用通信技术将数据从一个结点传送到另一结点的过程。<br>通信技术是计算机网络的基础。<br>信道可分为物理信道和逻辑信道。<br>物理信道由传输介质和设备组成， 根据传输介质的不同， 分为无线信道和有线信道。<br>逻辑信道是指在数据发送端和接收端之间存在的一条虚拟线路， 可以是有连接的或无连接的 。逻辑信道以物理信 道为载体。</p>
<p>发信机进行的信号处理包括信源编码，信道编码，交织，脉冲，调制</p>
<p>收信机信号处理解调，采样判决，去交织，译码</p>
<h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>如果同时传递多路数据就需要复用技术和多址技术 。</p>
<p>复用技术是指在一条信道上同时传输多路数据的技术， 如DM时分复用 、FDM频分复用和CDM码分复用等 。</p>
<p>多址技术是指在一条线上同时传输多个用户数据的技术， 在接收端把多个用户的数据分离(TDMA时分多址 、FDMA频分多址和CDMA码分多址)。</p>
<h3 id="5G"><a href="#5G" class="headerlink" title="5G"></a>5G</h3><p>作为新一代的移动通信技术， 5G特征体现在以下方面。<br>1） 实现可扩展的OFDM间隔参数配直<br>2） 灵活框架设计<br>3） 毫米波:频率大于24GHz以上的频段<br>4） 基于OFDM优化的波形和多址接入<br>5） OFDM加窗提高多路传输效率<br>6） 大规模MIMO:最多256根天线<br>7）频谱共享 8）先进的信道编码设计<br>5G网络的主要特征:服务化架构 、 网络切片。</p>
<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6.jpg" alt="1"></p>
<p>中继器，集线器：物理层，对接收信号进行再生，发送，只起到扩展传输距离的作用</p>
<p>网桥：数据链路层</p>
<p>路由器：网络层，IP</p>
<p>网关：高层协议</p>
<p>二层交换机：数据链路层</p>
<p>三层交换机：网络层</p>
<p>多层交换机：高层协议</p>
<h3 id="局域网广域网协议"><a href="#局域网广域网协议" class="headerlink" title="局域网广域网协议"></a>局域网广域网协议</h3><p>以太网，计算机局域网组网技术<br>IEEE802.3<br><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.jpg" alt="1"></p>
<h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>三要素，语法，语义，时序</p>
<h4 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h4><p>◆IP:网络层最重要的核心协议，在源地址和目的地址之间传送数据报， 无连接 、不可靠。<br>◆ICMP:因特网控制报文协议， 用于在IP主机 、路由器之间传递控制消息 。控制消息是指网络通不通 、主机是否可达 、路由是否可用等网络本身的消息。<br>◆ARP和RARP:地址解析协议，ARP是将IP地址转换为物理地址， RARP是将物理地址转换为IP地址。<br>◆IGMP:网络组管理协议， 允许因特网中的计算机参加多播， 是计算机用做向相邻多目路由器报告多目组成员的协议， 支持组播。</p>
<h4 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h4><p>◆TCP:整个TCP/IP协议族中最重要的协议之一，在IP协议提供的不可靠数据数据基础上，采 用了重发技术， 为应用程序提供了一个可靠的 、面向连接的 、全双工的数据传输服务 。一般 用于传输数据量比较少， 且对可靠性要求高的场合。</p>
<p>1、使用序号对数据报进行标记</p>
<p>2、TCP使用确认，校验，定时器系统提供可靠性</p>
<p>3、tcp使用窗口机制调整数据流量</p>
<p>◆UDP:是一种不可靠 、无连接的协议， 有助于提高传输速率， 一般用于传输数据量大，对可 靠性要求不高， 但要求速度快的场合。</p>
<p>1、无连接，使用最大努力交付，面向报文，没有拥塞控制，一对一，一对多，多对一，多对多，首部开销小</p>
<h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><p>基于TCP的FTP、HTTP等都是可靠传输 。基于UDP的DHCP、DNS等都是不可靠传输。<br>◆FTP:可靠的文件传输协议， 用于因特网上的控制文件的双向传输。<br>◆HTTP:超文本传输协议， 用于从WWW服务器传输超文本到本地浏览器的传输协议 。使用SSL 加密后的安全网页协议为HTTPS。<br>◆SMTP和POP3:简单邮件传输协议， 是一组用于由源地址到目的地址传送邮件的规则， 邮件报 文采用ASCII格式表示， SMTP是发送，POP3是接收<br>◆Telnet:远程连接协议， 是因特网远程登录服务的标准协议和主要方式。<br>◆TFTP:不可靠的 、开销不大的小文件传输协议。<br>◆SNMP:简单网络管理协议， 它主要用于网络设备与网络管理系统(NMS)之间进行监测与管理，比如路由器和交换机设备通过SNMP定期向网络管理系统上报接口流量 、CPU利用率等性能指标<br>◆DHCP:动态主机配置协议， 基于UDP,基于C/S模型， 为主机动态分配IP地址， 有三种方式：固定分配、动态分配、 自动分配。<br>◆DNS:域名解析协议， 通过域名解析出IP地址。</p>
<h4 id="端口对照"><a href="#端口对照" class="headerlink" title="端口对照"></a>端口对照</h4><p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/8.jpg" alt="1"></p>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>交换机功能包括:<br>集线功能 。提供大量可供线缆连接的端口达到部署星状拓扑网络的目的。<br>中继功能 。在转发帧时重新产生不失真的电信号。<br>桥接功能 。在内置的端口上使用相同的转发和过滤逻辑。<br>隔离冲突域功能 。将部署好的局域网分为多个冲突域， 而每个冲突域都有自己独立的带宽， 以提高交换机整体宽带利用效率。<br>交换机的功能包括:<br>( 1)转发路径学习 。根据收到数据帧中的源MAC地址建立该地址同交换机端口的映射写入MAC地址表中。<br>(2)数据转发 。如果交换机根据数据帧中的目的MAC地址在建立好的MAC地址表中查询到了， 就向对应端口 进行转发。<br>(3)数据泛洪 。如果数据帧中的目的MAC地址不在MAC地址表中， 则向所有端口转发也就是泛洪 。广播帧和 组播帧向所有端口（不包括源端口） 进行转发。<br>(4)链路地址更新 。MAC地址表会每隔一定时间（如300s ） 更新一次</p>
<h2 id="路由技术"><a href="#路由技术" class="headerlink" title="路由技术"></a>路由技术</h2><p>路由功能由路由器来提供， 具体包括:<br>(1)异种网络互连， 比如具有异种子网协议的网络互连:<br>(2)子网协议转换， 不同子网间包括局域网和广域网之间的协议转换:<br>(3)数据路由， 即将数据从一个网络依据路由规则转发到另一个网络:<br>(4)速率适配， 利用缓存和流控协议进行适配:<br>(5)隔离网络， 防止广播风暴,实现防火墙;<br>(6)报文分片和重组， 超过接口的MTU报文被分片， 到达目的地之后的报文被重组:<br>(7)备份 、流量控制， 如主备线路的切换和复杂流量控制等。</p>
<p>路由器工作在OSl七层协议中的第3层， 即网络层 。其主要任务是接收来源于一个网络接口的数据包， 通常 根据此数据包的目地址决定待转发的下一个地址（即下一跳地址) 。路由器中维持着数据转发所需的路由 表， 所有数据包的发送或转发都通过查找路由表来实现 。这个路由表可以静态配置， 也可以通过动态路由 协议自动生成。</p>
<p>一般来说， 路由协议可分为内部网关协议（IGP） 和外部网关协议(EGP）两类。</p>
<p>网络建设工程可分为网络规划 、 网络设计和网络实施三个环节。</p>
<h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2><h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><p>将多根铜线按规则缠绕在一起，能够减少干扰;分为无屏蔽双绞线UTP和屏蔽双<br>绞线STP，都是由一对铜线簇组成。也即我们常说的网线;双绞线的传输距离在100m以内</p>
<p>无屏蔽双绞线UTP:价格低，安装简单，但可靠性相对较低，分为CAT3(3类UTP，速率为10Mbps)、CAT4(4类UTP，与3类差不多，无应用）、CAT5(5类UTP，速率为100Mbps，用于快速以太网)、CAT5E(超5类UTP，速率为1000Mbps）、CAT6(6类UTP，用来替代CAT5E，速率也是<br>10OOMbps） 。</p>
<p>屏蔽双绞线STP:比之UTP增加了一层屏蔽层，可以有效的提高可靠性，但对应的价格高，安装麻烦，一般用于对传输可靠性要求很高的场合</p>
<p>网线有如下两种安装标准：都是八根不同颜色的网线，按照不同的顺序排序，插入水晶头中，区分在第1236四根网线的位置不同。</p>
<p>T568A T568B</p>
<h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p>由纤芯和包层组成，传输的光信号在纤芯中传输，然而从PC端出来的信号都是电信号，要经过光纤传输的话，就必须将电信号转换为光信号</p>
<p>多模光纤MMF:纤芯半径较大，因此可以同时传输多种不同的信号，光信号在光纤中以全反射的形式传输，采用发光二极管LED为光源，成本低，但是传输的效率和可靠性都较低，适合于短距离传输，其传输距离与传输速率相关，速率为100Mbps时为2KM，速率为1000Mbps时为550m</p>
<p>单模光纤SMF:纤芯半径很小，一般只能传输一种信号，采用激光二极管LD作为光源，并且只支持激光信号的传播，同样是以全反射形式传播，只不过反射角很大，看起来像一条直线，成本高，但是传输距离远，可靠性高。传输距离可达5KM</p>
<h3 id="无线信道"><a href="#无线信道" class="headerlink" title="无线信道"></a>无线信道</h3><p>无线电波，红外光波</p>
<h3 id="通信方向"><a href="#通信方向" class="headerlink" title="通信方向"></a>通信方向</h3><p>通信方向:数据通信是指发送方发送数据到接收方，这个传输过程可以分类如下:<br>单工:只能由设备A发给设备B，即数据流只能单向流动。<br>半双工:设备A和设备B可以互相通信，但是同一时刻数据流只能单向流动<br>全双工:设备A和设备B在任意时刻都能互相通信</p>
<p>异步传输:发送方每发送一个字符，需要在字符的起始和结尾处插入标识，当接收方接收到该字符时需要处理开始和结尾处的标识，处理完之后就能识别发送过来的数据，但是这样会造成资源浪费，传输效率降低。发送方和接收方并不是同时进行处理数据</p>
<p>同步传输:以数据块为单位进行传输，当发送方要发送数据时，先发送一个同步帧，接收方收到后做好接收准备，开始接收数据块，结束后又会有结束帧确认，这样一次传输一个数据块，效率高。</p>
<p>串行传输:只有一根数据线，数据只能1bit挨个排队传送，适合低速设备、远距离的传送，一般用于广域网中。<br>并行传输:有多根数据线，可以同时传输多个bit数据，适合高速设备的传送，常用语计算机内部各硬件模块之间。</p>
<h3 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h3><p>电路交换:通信一方进行呼叫，另一方接收后，在二者之间会建立一个专用电路，特点为面向连接、实时性高、链路利用率低，一般用于语音视频通信。<br>报文交换:以报文为单位，存储转发模式，接收到数据后先存储，进行差错校验，没有错误则转发，有错误则丢弃，因此会有延时，但可靠性高，是面向无连接的。<br>分组交换:以分组为单位，也是存储转发模式，因为分组的长度比报文小，所以时延小于报文交换，又可分为三种方式:<br>• 数据报:是现在主流的交换方式，各个分组携带地址信息，自由的选择不同的路由路径传送到接收方，接收方接收到分组后再根据地址信息重新组装成原数据，是面向无连接的，但是不可靠的。<br>• 虚电路:发送方发送一个分组，接收方收到后二者之间就建立了一个虚拟的通信线路，二者之间的分组数据交互都通过这条线路传送，在空闲的时候这条线路也可以传输其他数据，是面向连接的，可靠的。<br>• 信元交换:异步传输模式ATM采用的交换方式，本质是按照虚电路方式进行转发，只不过信元是固定长度的分组，共53B，其中5B为头部，48B为数据域，也是面向连接的，可靠的。</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>机器中存放的IP地址是32位的二进制代码，每隔8位插入一个空格，可提高可读性，为了便于理解和设置，一般会采用点分十进制方法来表示:将32位二进制代码每8位二进制转换成十进制，就变成了4个十进制数，而后在每个十进制数间隔中插入.</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>分类IP地址:IP地址分四段，每段八位，共32位二进制数组成。在逻辑上，这32位IP地址分为网络号(带下划线的)和主机号，依据网络号位数的不同，可以将IP地址分为以下几类:<br>按照A类来分配IP地址，总计可以分配：2^24-2=16777214<br>B类的分配数为：2^16-2=65534<br>C类的分配数为：2^8-2=254<br><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.jpg" alt="1"></p>
<p>无分类编址:即不按照ABC类规则，自动规定网络号，无分类编址格式为:IP地址/网络号，示<br>例:128.168.0.11/20表示的IP地址为128.168.0.11，其网络号占20位，因此主机号占32-20=12位，也可以划分子网。<br>特殊IP地址<br>公有地址:通过它直接访问因特网。是全网唯一的IP地址。<br>私有地址:属于非注册地址，专门为组织机构内部使用，不能直接访问因特网，</p>
<h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><p>A类地址网络号：第一部分，8位</p>
<p>B类地址网络号：第一部分，第二部分， 16位</p>
<p>C类地址网络号：第一部分，第二部分，第三部分， 24位</p>
<p>子网划分：一般公司在申请网络时，会直接获得一个范围很大的网络，如一个A类地址，因为主机数之间相差的太大了，不利于分配，我们一般采用子网划分的方法来划分网络，即自定义网络号位数，就能自定义主机号位数，就能根据主机个数来划分出最适合的方案，不会造成资源的浪费。</p>
<p>子网号：一般的IP地址按标准划分为A B C类后可以进行再一步的划分，将主机号多出的几位作为子网号，就可以划分出多个子网，</p>
<p>IP地址组成：网络号+子网号+主机号，网络号和子网号都为1，主机号都是0，就是子网掩码</p>
<p>比如只需要为30台主机分配ip地址，那么我们会申请C类的地址，C类地址是2^8次方个主机号，远远超过了30的需求，于是我们按照2^n-2=30来计算，n=5是最合适的，那么多于的那3位就是用来作为子网号，那么子网就一共可以划分2^3=8个，按照IP地址组成为：网络号+子网号+主机号来算的话，那么就是网络号24+子网号3+主机号5.网络号和子网号都为1,主机号都为0,这样的地址为子网掩码。如果把上面的例子拿来算子网掩码的话就是：24个1+3个1+5个0，得到的就是255.255.255.224要</p>
<p>注意的是：子网号可以为全0和全1,主机号不能为全0或全1,因此，主机数需要-2,而子网数不用。</p>
<p>还可以聚合网络为超网，就是划分子网的逆过程，将网络号取出几位作为主机号，此时，这个网络内的主机数量就变多了，成为一个更大的网络</p>
<p>三级IP地址：网络号+子网号+主机号</p>
<p>子网掩码：网络号全是1，主机号全是0</p>
<p>A类子网掩码：255.0.0.0</p>
<p>B类子网掩码：255.255.0.0</p>
<p>C类子网掩码：255.255.255.0</p>
<p>将ip地址与其对应的子网掩码，逐位进行与（1就是保留原先的数据。与0与就是0）运算，可以得到子网的网络地址（只包含网络号）</p>
<p>IP地址：131.1.123.24/27，/27代表前面27位都是网络号，前三部分是24，最后一部分的前三位也是网络号，网络号不一样代表不在同一网段，路由表的表项</p>
<p>/23 -》/27 主机号少4个变网络号，则是2的4次方个子网，主机号位数就是5，2的5次方，主机号不能全0或者全1，然后可确定其子网掩码</p>
<p>/20，可以划分多少个C类子网，C类子网的主机号是8位，网络号是24位，24-20等于4，则子网号是2的4次方</p>
<p>不属于子网地址算法：网络号确定，确定剩下的最大地址范围，不在范围内就不是</p>
<h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><p>IPV6主要是为了解决IPv4地址数不够用的情况而提出的设计方案，IPv6具有以下特性：<br>1、 IPv6地址长度为128位，而IPV4地址仅32位，空间增大了2^96倍；<br>2、 灵活的IP报文头部格式，使用一系列固定格式的扩展头部取代了IPv4中可变长度的选项字段。<br>3、 IPv6简化了报文头部格式，加快报文转发，提高了吞吐量；<br>4、提高安全性，身份认证和隐私权是IPv6的关键特性；<br>5、支持更多的服务类型；<br>6、允许协议继续演变，增加新的功能，使之适应未来技术的发展。</p>
<p>IPV4过渡IPV6技术：</p>
<p>1、双协议栈技术：可同时支持</p>
<p>2、隧道技术：在4网络上建立一个能够传输6的数据报的隧道</p>
<p>3、翻译技术：4转换6</p>
<h2 id="网络三层模型"><a href="#网络三层模型" class="headerlink" title="网络三层模型"></a>网络三层模型</h2><p>三层模型将网络划分为核心层、汇聚层和接入层：<br>1、核心层：提供不同区域之间的最佳路由和高速数据传送，提高高速转发通信，骨干传输，拥有更高的可靠性，性能，吞吐量，ATM，100BASE_Fx，千兆以太网，双机冗余备份<br>2、 汇聚层：核心层，接入层的分界面，完成网络访问控制，数据包处理，过滤寻址，多台接入层交换机汇聚点，所以汇聚层交换机与接入层交换相比，需要更高的性能，更少的接口，更高的交换速率<br>3、接入层：直接面向用户连接或访问网络的部分，允许终端用户连接到网络，负责一些用户管理功能，用户信息收集工作，为用户提供了在本地网段访问应用系统的能力，还要解决相邻用户之间的互访需要，接入层要负责一些用户信息(例如用户IP地址、MAC地址和访问日志等)的收集工作和用户管理功能(包括认证和计费等)</p>
<h2 id="网络规划与设计"><a href="#网络规划与设计" class="headerlink" title="网络规划与设计"></a>网络规划与设计</h2><p>建筑物综合布线系统PDS:<br>工作区子系统：实现工作区终端设备到水平子系统的信息插座之间的互联。<br>水平布线子系统：实现信息插座和管理子系统之间的连接。<br>管理子系统：连接各楼层水平布线子系统和垂直干缆线，负责连接控制其他子系统为连接其<br>他子系统提供连接手段<br>垂直干线子系统：实现各楼层设备间子系统之间的互连。<br>设备间子系统：实现中央主配线架与各种不同设备之间的连接。<br>建筑群子系统：各个建筑物通信系统之间的互联</p>
<p><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/10.jpg" alt="1"></p>
<p>1、工作区子系统负责房间内部各个设备终端的互联。<br>2、水平和垂直子系统负责不同楼层和建筑内部的互联。<br>3、设备间子系统实现各种设备与交换机之间的互联。<br>4、管理子系统实现整个综合布线系统的管理。<br>5、建筑群子系统实现不同建筑物之间的互联。</p>
<h2 id="磁盘冗余阵列"><a href="#磁盘冗余阵列" class="headerlink" title="磁盘冗余阵列"></a>磁盘冗余阵列</h2><p>RAID即磁盘冗余阵列技术，将数据分散存储在不同磁盘中，可并行读取，可冗余存储，提高磁盘访问速度，保障数据安全性。<br>RAID0将数据分散的存储在不同磁盘中，磁盘利用率100%,访问速度最快，但是没有提供冗余和错误修复技术；<br>RAID1在成对的独立磁盘上产生互为备份的数据，增加存储可靠性，可以纠错，但磁盘利用率只有50%;<br><img src="/2024/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/11.jpg" alt="1"></p>
<h2 id="网络存储技术"><a href="#网络存储技术" class="headerlink" title="网络存储技术"></a>网络存储技术</h2><p>1.直接附加存储(DAS):是指将存储设备通过SCSI接口直接连接到一台服务器上使用，其本身是硬件的堆叠，存储操作依赖于服务器，不带有任何存储操作系统。<br>◆存在问题：在传递距离、连接数量、传输速率等方面都受到限制。容量难以扩展升级；数据处理和传输能力降低；服务器异常会波及存储器。</p>
<p>2.网络附加存储(NAS):通过网络接口与网络直接相连，由用户通过网络访问，有独立的存储系统。如下图所示。NAS存储设备类似于一个专用的文件服务器，去掉了通用服务器大多数计算功能，而仅仅提供文件系统功能。以数据为中心，将存储设备与服务器分离，其存储设<br>备在功能上完全独立于网络中的主服务器。客户机与存储设备之间的数据访问不再需要文件服务器的干预，同时它允许客户机与存储设备之间进行直接的数据访问，所以不仅响应速度快，而且数据传输速率也很高。<br>◆NAS的性能特点是进行小文件级的共享存取；支持即插即用；可以很经济的解决存储容量不足的问题，但难以获得满意的性能。</p>
<p>3.存储区域网(SAN):SAN是通过专用交换机将磁盘阵列与服务器连接起来的高速专用子网。它没有采用文件共享存取方式，而是采用块(block)级别存储。SAN是通过专用高速网将一个或多个网络存储设备和服务器连接起来的专用存储系统，其最大特点是将存储设备从传统的以太网中分离了出来，成为独立的存储区域网络SAN的系统结构。根据数据传输过程采用的协议，其技术划分为FCSAN(光纤通道)、IP SAN(IP网络)和IB SAN(无线带宽)技术。</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="DNS协议查询"><a href="#DNS协议查询" class="headerlink" title="DNS协议查询"></a>DNS协议查询</h3><h4 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h4><p>当用户发出查询请求时，本地服务要进行递归查询，这种查询方式要求服务器彻底进行名字解析，并返回最后的结果</p>
<h4 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h4><p>服务器与服务器之间的查询采用迭代的方式进行，发出查询请求的服务器得到的响应，可能不是目标IP地址，而是其他服务器的引用，然后继续查询</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>质量属性和架构评估</title>
    <url>/2024/04/17/%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/</url>
    <content><![CDATA[<h3 id="软件系统属性-质量属性"><a href="#软件系统属性-质量属性" class="headerlink" title="软件系统属性-质量属性"></a>软件系统属性-质量属性</h3><p>软件系统属性包括功能属性和质量属性，软件架构重点关注的是质量属性</p>
<p>架构的基本需求是在满足功能属性的前提下，关注软件系统质量属性，为了精确、定量地表达系统的质量属性，通常会采用<strong>质量属性场景</strong>的方式进行描述。在确定软件系统架构，精确描述质量属性场景后，就需要对<strong>系统架构进行评估。软件系统架构评估是在对架构分析、评估的基础上，对架构策略的选取进行决策</strong>。它也可以灵活地运用于软件架构评审等工作</p>
<p>软件系统质量属性 (Quality Attribute) 是一个系统的可测量或者可测试的属性</p>
<p>软件系统质量属性是指软件系统满足用户需求的程度，是衡量软件系统质量的重要指标。</p>
<p>基于软件系统的生命周期，可以将软件系统的质量属性分为开发期质量属性和运行期质量属性2个部分</p>
<p>开发期质量属性主要指在<strong>软件开发阶段所关注的质量属性，这个阶段关注人群主要是开发者</strong></p>
<p>易理解性：指设计被开发人员理解的难易程度。</p>
<p>可扩展性：软件因适应新需求或需求变化而增加新功能的能力，也称为灵活性。</p>
<p>可重用性：指重用软件系统或某一部分的难易程度。</p>
<p>可测试性：对软件测试以证明其满足需求规范的难易程度。</p>
<p>可维护性：当需要修改缺陷、增加功能、提高质量属性时，识别修改点并实施修改的难易程度。</p>
<p>可移植性：将软件系统从一个运行环境转移到另一个不同的运行环境的难易程度。</p>
<p>运行期质量属性主要指在<strong>软件运行阶段所关注的质量属性，这个阶段关注人群主要是用户</strong></p>
<p>性能：性能是指软件系统及时提供相应服务的能力，如速度、吞吐量和容量等的要求。</p>
<p>安全性：指软件系统同时兼顾向合法用户提供服务，以及阻止非授权使用的能力。</p>
<p>可伸缩性：指当用户数和数据量增加时，软件系统维持高服务质量的能力。例如，通过增加服务器来提高能力。</p>
<p>互操作性：指本软件系统与其他系统交换数据和相互调用服务的难易程度。</p>
<p>可靠性：软件系统在一定的时间内持续无故障运行的能力。</p>
<p>可用性：指系统在一定时间内正常工作的时间所占的比例。可用性会受到系统错误，恶意攻击，高负载等问题的影响。</p>
<p>鲁棒性：是指软件系统在非正常情况(用户进行了非法操作、相关软硬件系统发生了故障)下仍能够正常运行的能力，也称健壮性或容性。</p>
<h4 id="质量属性"><a href="#质量属性" class="headerlink" title="质量属性"></a>质量属性</h4><ol>
<li>性能：指系统的响应能力，即要经过多长时间才能对某个事件做出响应，或者在某段时间内系统所能处理的事件的个数。如响应时间、吞吐量。</li>
</ol>
<p>设计策略：优先级队列、增加计算资源、减少计算开销、引入并发机制、采用资源调度等。</p>
<ol start="2">
<li>可靠性：是指系统在一段时间内保持正常运行而不发生故障的能力。它强调了系统的稳定性和可靠性，通常是通过衡量系统在一段时间内发生故障的概率来评估的。一个可靠性高的系统意味着它很少出现故障，用户可以信任它的稳定性。可靠性有一些指标需要了解。如MTTF(平均无故障时间)、MTBF(平均故障间隔时间)、MTTR(平均故障修复时间)。MTBF=MTTF+MTTR</li>
</ol>
<p>设计策略：心跳、Ping/Echo、冗余、选举</p>
<ol start="3">
<li>可用性：是指系统在需要的时候可供使用的能力，即系统处于可操作状态的时间比例。可用性通常通过计算系统在一定时间内可操作的百分比来评估。一个高可用性的系统意味着它在大部分时间内都是可用的，用户可以随时访问和使用它。</li>
</ol>
<p>设计策略：心跳、Ping/Echo、冗余、选举。</p>
<p>可靠性强调系统不发生故障，而可用性强调系统在需要时可供使用。两者都是衡量系统性能和质量的重要标准，但它们关注的方面略有不同</p>
<ol start="4">
<li>安全性：是指系统在向合法用户提供服务的同时能够阻止非授权用户使用的企图或拒绝服务的能力。如保密性、完整性、不可抵赖性、可控性。</li>
</ol>
<p>设计策略：入侵检测、用户认证、用户授权、追踪审计。</p>
<ol start="5">
<li>可修改性：指能够快速的以较高的性能价格比对系统进行变更的能力。通常以某些具体的变更为基准，通过考察这些变更的代价衡量。</li>
</ol>
<p>设计策略：接口-实现分类、抽象、信息隐藏（是不是感觉有点像结构化开发和面向对象开发的设计原则）。</p>
<ol start="6">
<li><p>功能性：是系统所能完成所期望的工作的能力。一项任务的完成需要系统中许多或大多数构件的相互协作。</p>
</li>
<li><p>可变性（可扩展）：指体系结构经扩充或变更而成为新体系结构的能力。这种新体系结构应该符合预先定义的规则，在某些具体方面不同于原有的体系结构。当要将某个体系结构作为一系列相关产品的基础时，可变性是很重要的。</p>
</li>
<li><p>互操作性：作为系统组成部分的软件不是独立存在的，经常与其他系统或自身环境相互作用。为了支持互操作性，软件体系结构必须为外部可视的功能特性和数据结构提供精心设计的软件入口。程序和用其他编程语言编写的软件系统的交互作用就是互操作性的问题，也影响应用的软件体系结构。</p>
</li>
<li><p>易用性：它关注的是软件系统的用户界面和交互设计，以确保用户能够轻松、高效地使用系统，并感到满意。易用性不仅关乎用户界面的外观，还包括用户体验、交互流程和用户学习曲线等方面</p>
</li>
</ol>
<h4 id="质量场景描述"><a href="#质量场景描述" class="headerlink" title="质量场景描述"></a>质量场景描述</h4><p>通常采用质量属性场景 (Quality Attribute Scenario) 作为描述质量属性的手段。质量属性场景是一个具体的质量属性需求，是利益相关者与系统的交互的简短陈述。</p>
<p>质量属性场景是一种用于描述系统如何满足特定质量属性需求的情境或情景。它由6部分组成：</p>
<p>刺激源(谁)：这是某个生成该刺激的实体(人、计算机系统或者任何其他刺激器)。</p>
<p>刺激(做什么)：该刺激是当刺激到达系统时需要考虑的条件。</p>
<p>环境(在什么样的环境下)∶该刺激在某些条件内发生。当激励发生时，系统可能处于过载、运行或者其他情况。</p>
<p>制品(对哪个功能)：某个制品被激励。这可能是整个系统，也可能是系统的一部分。</p>
<p>响应(得到什么反馈)：该响应是在激励到达后所采取的行动。</p>
<p>响应度量(对反馈进行度量)︰当响应发生时，应当能够以某种方式对其进行度量，以对需求进行测试。</p>
<h3 id="系统架构评估"><a href="#系统架构评估" class="headerlink" title="系统架构评估"></a>系统架构评估</h3><p>敏感点：是指为了实现某一种特定的质量属性，一个或多个构件所具有的特性。</p>
<p>权衡点：是影响多个质量属性的特性，是多个质量属性的敏感点</p>
<p>软件架构评估在架构设计之后，系统设计之前，因此与设计、实现、测试都没有关系。评估的目的是为了评估所采用的架构是否能解决软件系统需求</p>
<h4 id="评估方式"><a href="#评估方式" class="headerlink" title="评估方式"></a>评估方式</h4><p>1 . 基于调查问卷(检查表)的方式</p>
<p>2、基于度量的方式</p>
<p>3、基于场景的方式</p>
<h4 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h4><h5 id="基于场景的架构分析方法SAAM"><a href="#基于场景的架构分析方法SAAM" class="headerlink" title="基于场景的架构分析方法SAAM"></a>基于场景的架构分析方法SAAM</h5><p>SAAM是一种非功能质量属性的架构分析方法，是最早形成文档并得到广泛应用的软件架构分析方法。针对可修改性</p>
<p>SAAM的主要输入是问题描述、需求声明和架构描述</p>
<h5 id="架构权衡分析法ATAM"><a href="#架构权衡分析法ATAM" class="headerlink" title="架构权衡分析法ATAM"></a>架构权衡分析法ATAM</h5><p>是一种系统架构评估方法，主要在系统开发之前，<strong>针对性能、可用性、安全性和可修改性等质量属性</strong>进行评价和折中，让架构师明确如何权衡多个质量目标，参与者有评估小组、项目决策者和其他项目相关人</p>
<p>ATAM被分为四个主要的活动领域,分别是</p>
<p>场景和需求收集、体系结构（架构）视图和场景实现、属性模型构造和分析以及架构评审与折中。</p>
<p>整个评估过程强调以属性(质量属性)作为架构评估的核心概念</p>
<p>ATAM 方法采用效用树 (Utility tree) 这一工具来对质量属性进行分类和优先级排序。效用树的结构包括：树根—质量属性—属性分类—质量属性场景(叶子节点)</p>
<p>得到初始的效用树后，需要修剪这棵树，保留重要场景(通常不超过50个),再对场景按重要性给定优先级(用 H/M/L 的形式),再按场景实现的难易度来确定优先级(用 H/M/L的形式),这样对所选定的每个场景就有一个优先级对(重要度、难易度),如 (H、L) 表示该场景重要且易实现。</p>
<p>ATAM的阶段解释：</p>
<p><strong>1 .</strong> <strong>描述和介绍阶段：</strong></p>
<p>目标： 此阶段的目标是收集相关架构材料，定义评估的目标和评估的软件架构，明确要优化的质量属性以及介绍ATAM方法的步骤和原则。</p>
<p>活动： 在这个阶段，评估团队会与项目干系人一起定义评估的目标，确定评估的软件架构，并收集架构文档和相关信息。团队还会介绍ATAM方法的步骤，以确保所有参与者了解评估的过程。</p>
<p>示例： 对于电子商务网站的架构评估，评估团队会与项目干系人合作，确定评估的目标是提高性能和安全性。他们收集有关网站架构的文档，如架构图和设计文档。</p>
<p><strong>2.</strong> <strong>调查和分析阶段：</strong></p>
<p>目标： 此阶段的目标是确定架构方法，分析架构并评估这些架构方法对质量属性的影响，同时识别潜在的问题和权衡决策。</p>
<p>活动： 在这个阶段，评估团队会定义架构方法，分析不同的架构设计，生成质量属性效应树以表示不同决策对质量属性的影响。他们还会识别潜在的问题和决策权衡。</p>
<p>产出： 在此阶段，<strong>产出质量属性效应树</strong>（Quality Attribute Utility Tree），用于表示不同架构决策对质量属性的影响以及它们之间的权衡关系。</p>
<p>示例： 对于电子商务网站的架构评估，评估团队会定义不同的架构决策，如引入缓存或增加服务器资源。他们生成质量属性效应树，以分析这些决策对性能和安全性的影响。</p>
<p><strong>3.</strong> <strong>测试阶段：</strong></p>
<p>目标： 测试阶段旨在验证架构是否满足质量属性需求。</p>
<p>活动： 团队创建测试用例来模拟质量属性场景，包括性能测试、安全性测试等。他们运行这些测试用例，测量系统的性能和行为，并记录测试结果。在此阶段，评估团队讨论各种质量属性场景，对它们进行分级，以确定哪些场景对系统的关键性最高。团队还会分析不同的架构方法，以确定哪种方法最有可能满足关键场景的需求。最后，项目干系人会对不同的架构方法和场景分级进行投票，以帮助团队确定最佳的架构方案。</p>
<p>示例： 评估团队可能会讨论电子商务网站的性能、可伸缩性和安全性场景，分级它们的重要性，并分析引入缓存或增加服务器资源等不同架构方法的影响。项目干系人会进行投票，以选择最合适的架构方法。</p>
<p><strong>4.</strong> <strong>报告阶段：</strong></p>
<p>目标： 报告阶段的目标是总结评估的结果、提供改进建议，并为决策者提供决策依据。</p>
<p>活动： 团队生成ATAM评估报告，其中包括评估的发现、性能数据、可能的改进建议以及权衡决策。报告应该清晰地传达关键信息，以便决策者可以做出明智的架构决策。</p>
<p>示例： 电子商务网站的评估报告可能包括性能测试结果、安全性评估、建议的架构改进，以及与质量属性场景相关的权衡决策。报告将提供给项目管理团队，以指导后续的架构决策和改进。</p>
<h5 id="成本效益分析法CBAM"><a href="#成本效益分析法CBAM" class="headerlink" title="成本效益分析法CBAM"></a>成本效益分析法CBAM</h5><p>用来对架构建立的成本来进行设计和建模，让决策者根据投资收益率来选择合适的架构，可以看做对ATAM的补充，在ATAM确定质量合理的基础上，再对效益进行分析</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>在一个分布式系统环境中处于操作系统和应用程序之间的软件，可以在不同的技术之间共享资源，将不同的操作系统、数据库、异构的网络环境以及若干应用结合成一个有机的协同工作整体</p>
<p>中间件位于客户机/服务器的操作系统之上，管理计算机资源和网络通信，</p>
<p>中间件是一类软件，而非一种软件；</p>
<p>中间件不仅仅实现互连，还要实现应用之间的互操作；</p>
<p>中间件是基于分布式处理的软件，最突出的特点是网络通信</p>
<p>使应用程序开发变得更容易，通过提供统一的程序抽象，隐藏异构系统和分布式系统下低级别编程的复杂度</p>
<p>1、数据库访问中间件：通过一个抽象层访问数据库，从而允许使用相同或相似的代码访问不同的数据库资源。典型的技术如Windows平台的ODBC和Java平台的JDBC等。</p>
<p>2、远程过程调用(RPC)：是一种广泛使用的分布式应用程序处理方法。一个应用程序使用RPC来“远程”执行一个位于不同地址空间内的过程，从效果上看和执行本地调用相同。</p>
<p>3、面向消息中间件(MOM)：利用高效可靠的消息传递机制进行平台无关的数据交流，并可基于数据通信进行分布系统的集成。通过提供消息传递和消息排队模型，可在分布环境下扩展进程间的通信，并支持多种通信协议、语言、应用程序、硬件和软件平台。典型的产品如RabbitMQ。</p>
<p>4、分布式对象中间件：随着对象技术与分布式计算技术的发展，两者相互结合形成了分布式对象技术，并发展成为当今软件技术的主流方向。典型的产品如OMG的CORBA、Sun的RMI/EJB、Microsoft的DCOM等。</p>
<p>5、事务中间件：也称事务处理监控器(TPM)，最早出现在大型机上。事务处理监控程序位于客户和服务器之间，完成事务管理与协调、负载平衡、失效恢复等任务，提高系统的整体性能。</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2021/03/29/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>每一步选取当前最优解</p>
<p>问题能够分解成子问题，子问题最优解，递推到最终最优解</p>
<p>与动态规划区别：</p>
<p>贪心算法：每个子情况都进行选择，不能回退</p>
<p>动态规划：保存以前的运算结果，可以回退</p>
<p>PS： 关键点在于如何证明可以使用贪心算法，能得到想要的结果</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 倒序贪心，从后开始，最先能跳到目标点的</span></span><br><span class="line">func canJump(nums []int) bool &#123;</span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    tmp := len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := len(nums) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] + i &gt;= tmp &#123;</span><br><span class="line">            tmp = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看最后是不是0</span></span><br><span class="line">    <span class="keyword">return</span> tmp == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先进行排序，然后贪心</span></span><br><span class="line">func findContentChildren(g []int, s []int) int &#123;</span><br><span class="line">    sort.Ints(g)</span><br><span class="line">    sort.Ints(s)</span><br><span class="line">    i, j, <span class="attr">res</span> := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">// 通过两个指针，进行移动</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; len(g) &amp;&amp; j &lt; <span class="function"><span class="title">len</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> s[j] &lt; g[i] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            i++</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="跳跃游戏2"><a href="#跳跃游戏2" class="headerlink" title="跳跃游戏2"></a>跳跃游戏2</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// jump ...</span></span><br><span class="line"><span class="comment">// 最少的跳跃次数，则从前开始贪心，每次跳最大步数</span></span><br><span class="line"><span class="comment">// 也就是从后开始，可以到达最后结果的最远步数，下标最小的那个</span></span><br><span class="line">func jump(nums []int) int &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    tmp := len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> tmp &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 每次从头开始循环，找到最先满足的值，然后break，更新tmp</span></span><br><span class="line">        <span class="comment">// 每次都是最先满足，最优解，贪心算法</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tmp; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] + i &gt;= tmp &#123;</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                tmp = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化贪心，减少for循环</span></span><br><span class="line"><span class="comment">// 从前往后找其每次能跳跃的最大步数，实现贪心</span></span><br><span class="line">func jump(nums []int) int &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    end := <span class="number">0</span></span><br><span class="line">    maxTmp := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 一次循环</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(nums) - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 每次循环找其跳的最大步数</span></span><br><span class="line">        maxTmp = max(maxTmp, nums[i] + i)</span><br><span class="line">        <span class="comment">// 遍历到end，说明要发生跳跃，加1，并更新end</span></span><br><span class="line">        <span class="keyword">if</span> i == end &#123;</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            end = maxTmp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个指针记录5， 10的数量，通过，5，10，20的计算，每次循环判断数量小于0则false</span></span><br><span class="line">func lemonadeChange(bills []int) bool &#123;</span><br><span class="line">    f, <span class="attr">t</span> := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(bills); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> bills[i] == <span class="number">5</span> &#123;f += <span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> bills[i] == <span class="number">10</span> &#123;</span><br><span class="line">            t += <span class="number">1</span></span><br><span class="line">            f -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> bills[i] == <span class="number">20</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> t &gt; <span class="number">0</span> &#123;</span><br><span class="line">                t -= <span class="number">1</span></span><br><span class="line">                f -= <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;f -= <span class="number">3</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> f &lt; <span class="number">0</span> || t &lt; <span class="number">0</span> &#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次循环，只要有收益就进行计算，完成收益累加</span></span><br><span class="line">func maxProfit(prices []int) int &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &gt; prices[i - <span class="number">1</span>] &#123;</span><br><span class="line">            res += prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模拟机器人"><a href="#模拟机器人" class="headerlink" title="模拟机器人"></a>模拟机器人</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录障碍点为map</span></span><br><span class="line">func robotSim(commands []int, obstacles [][]int) int &#123;</span><br><span class="line">    type p struct &#123;</span><br><span class="line">        x int</span><br><span class="line">        y int</span><br><span class="line">    &#125;</span><br><span class="line">    res := p&#123;<span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">    maxRes := <span class="number">0</span></span><br><span class="line">    dire := <span class="number">0</span></span><br><span class="line">    obsMap := make(map[p]bool, len(obstacles))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt; len(obstacles); i++ &#123;</span><br><span class="line">        tmp := p&#123;obstacles[i][<span class="number">0</span>], obstacles[i][<span class="number">1</span>]&#125;</span><br><span class="line">        obsMap[tmp] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, <span class="attr">v</span> := range commands &#123;</span><br><span class="line">        <span class="comment">// 步数行走</span></span><br><span class="line">        <span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 一步一步走，每步判断是否障碍点</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= v; i++ &#123;</span><br><span class="line">                <span class="comment">// 临时点</span></span><br><span class="line">                tmp := res</span><br><span class="line">                <span class="comment">// 结果往前走</span></span><br><span class="line">                <span class="keyword">switch</span> dire &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: res.x -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: res.y += <span class="number">1</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: res.x += <span class="number">1</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: res.y -= <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果结果遇到障碍，则结果回到临时点</span></span><br><span class="line">                <span class="keyword">if</span> _, <span class="attr">ok</span> := obsMap[res]; ok &#123;</span><br><span class="line">                    res = tmp</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没遇到则计算</span></span><br><span class="line">                    <span class="keyword">if</span> (res.x*res.x + res.y*res.y) &gt; maxRes &#123;</span><br><span class="line">                        maxRes = res.x*res.x + res.y*res.y</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理方向，0北，1东，2南，3西，取余简单循环</span></span><br><span class="line">        <span class="keyword">if</span> v == -<span class="number">1</span> &#123;</span><br><span class="line">            dire = (dire + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> v == -<span class="number">2</span> &#123;</span><br><span class="line">            dire = (dire + <span class="number">4</span> - <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxRes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>较大分组位置</title>
    <url>/2021/01/05/%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</p>
<p>例如，在字符串 s = “abbxxxxzyy” 中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。</p>
<p>分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 “xxxx” 分组用区间表示为 [3,6] 。</p>
<p>我们称所有包含大于或等于三个连续字符的分组为 较大分组 。</p>
<p>找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def largeGroupPositions(self, <span class="attr">s</span>: str) -&gt; List[List[int]]:</span><br><span class="line">        res = []</span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> index, i <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            a = s[index + <span class="number">1</span>] <span class="keyword">if</span> index + <span class="number">1</span> &lt; len(s) <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> s[index] == a:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> num &gt;= <span class="number">3</span>:</span><br><span class="line">                    res.append([index - num + <span class="number">1</span>, index])</span><br><span class="line">                num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="go"><a href="#go" class="headerlink" title="go"></a>go</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func largeGroupPositions(s string) [][]int &#123;</span><br><span class="line">    num := <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> res [][]int</span><br><span class="line">    <span class="keyword">for</span> index, <span class="attr">i</span> := range s &#123;</span><br><span class="line">        <span class="keyword">var</span> next string</span><br><span class="line">        <span class="keyword">if</span> index + <span class="number">1</span> &lt; <span class="function"><span class="title">len</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">            next = string(s[index + <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> string(i) == next &#123;</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> num &gt;= <span class="number">3</span> &#123;</span><br><span class="line">                res = append(res, []int&#123;index - num + <span class="number">1</span>, index&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">1</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>时间复杂度：O(n)，其中 n 是字符串的长度。我们只需要遍历一次该数组。</p>
<p>空间复杂度：O(1)。我们只需要常数的空间来保存若干变量，注意返回值不计入空间复杂度。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>通过两个指针指向窗口的首端和尾端。<br>通过尾端的不断确定相同元素，进行窗口尾端向右移动。<br>如果尾端元素与首端元素不同，则说明达到窗口的最大值，则查看窗口内元素是否达到3，如果达到3则记录。最后将窗口首端直接移动到与尾端相同位置(有KMP记忆的思想)。<br>当两个指针都达到末端则结束</p>
<h4 id="go-1"><a href="#go-1" class="headerlink" title="go"></a>go</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func largeGroupPositions(s string) [][]int &#123;</span><br><span class="line">    cur, <span class="attr">next</span> := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> res [][]int</span><br><span class="line">    <span class="keyword">if</span> len(s) &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> next &gt;= <span class="function"><span class="title">len</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>  next &lt; <span class="function"><span class="title">len</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> s[cur] == s[next] &#123;</span><br><span class="line">                    next++</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> next - cur &gt;= <span class="number">3</span> &#123;</span><br><span class="line">            res = append(res, []int&#123;cur, next-<span class="number">1</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        cur = next      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>输入输出、总线技术</title>
    <url>/2024/01/18/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8A%80%E6%9C%AF%E3%80%81%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<h3 id="输入输出技术"><a href="#输入输出技术" class="headerlink" title="输入输出技术"></a>输入输出技术</h3><p>cpu控制主存，外设的技术</p>
<h4 id="直接程序控制"><a href="#直接程序控制" class="headerlink" title="直接程序控制"></a>直接程序控制</h4><p>cpu直接控制外设，cpu与外设（cpu与主存是总线）</p>
<p>1、分为无条件传送和程序查询方式</p>
<p>2、降低了cpu的效率，无法使cpu与外设并行工作</p>
<p>3、对外面的突发事件无法做出实时响应</p>
<h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><p>1、利用中断方式完成数据的输入输出</p>
<p>2、CPU接到中断请求信号后，先保存正在执行的程序现场</p>
<p>3、与程序控制方式相比，因为cpu无须等待而提高了效率</p>
<h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p>1、在主存与外设（IO设备）之间建立数据通路进行的数据交换处理</p>
<p>2、在DMA的传送过程中无须cpu进行任何干涉</p>
<p>3、DMA传送过程中需要占用系统总线，此时cpu不能使用总线</p>
<h4 id="输入输出处理机（IOP）"><a href="#输入输出处理机（IOP）" class="headerlink" title="输入输出处理机（IOP）"></a>输入输出处理机（IOP）</h4><p>1、分担了cPU的 一部分功能，可以实现对外围设备的统一管理，完成外围设备与主存之间的数据传送</p>
<p>2、大大提高了cpu的工作效率，这种效率的提高是以增加更多的硬件为代价的</p>
<h3 id="内存接口编址方式"><a href="#内存接口编址方式" class="headerlink" title="内存接口编址方式"></a>内存接口编址方式</h3><p>1、内存与接口地址独立编址方法<br>内存地址和接口地址是完全独立的两个地址空间，这种编址方法的缺点是用于接口的<br>指 令太少 、功能太弱 。<br>2、内存与接口地址统一编址方法<br>内存地址和接口地址统一在一个公共的地址空间里， 即内存单元和接口共用地 址空间 。优点是原则上用于内存的指令全都可以用于接口，缺点是内存地址不连续</p>
<h3 id="计算机与外设的数据交互方式"><a href="#计算机与外设的数据交互方式" class="headerlink" title="计算机与外设的数据交互方式"></a>计算机与外设的数据交互方式</h3><p>1、程序控制（查询）方式： CPU主动查询外设是否完成数据传输， 效率极低</p>
<p>2、程序中断方式： 向CPU发送中断， 等待CPU处理数据， 效率相对较高 。 中断响应时间指的是从发出中断请求到开始进入中断处理程序； 中断处理时间指的是从中断处 理开始到中断处理结束 。中断向量提供中断服务程序的入口地址 。多级中断嵌套，使用堆栈来 保护断点和现场 。</p>
<p>3、DMA方式（直接主存存取）： CPU只需完成必要的初始化等操作，数据传输的整个过程都由 DMA控制器来完成，在主存和外设之间建立直接的数据通路， 效率很高 。在一个总线周期结束后， CPU会响应DMA请求开始读取数据； CPU响应程序中断方式请求是 在一条指令执行结束时 。</p>
<h3 id="总线技术"><a href="#总线技术" class="headerlink" title="总线技术"></a>总线技术</h3><p>总线（ Bus） ， 是指计算机设备和设备之间传输信息的公共数据通道 。总线是连 接计算机硬件系统内多种设备的通信线路， 它的一个重要特征是由总线上的所有设备共享， 因此可以将计算机系统内的多种设备连接到总线上 。便于增减外设，同时减少信息传输线的条数</p>
<p>共享：总线的部件相互之间可以进行信息交换</p>
<p>分时：同一时刻仅允许一个部件向总线发送消息，但允许多个部件同时从总线上接收相同的消息</p>
<h4 id="总线分类"><a href="#总线分类" class="headerlink" title="总线分类"></a>总线分类</h4><p>串行总线：适合长距离传输，传输较慢，性能不高</p>
<p>并行总线：适合近距离传输</p>
<p>单工：一个方向上传输，不能改变信号的传输方向</p>
<p>半双工：一个可切换方向的单工通信</p>
<p>全双工：双向的传输</p>
<p>1、内部总线： 内部芯片级别的总线， 芯片与处理器之间通信的总线 。<br>2、系统总线： 是板级总线， 用于计算机内各部分之间的连接， 具体分为<br>数据总线（并行数据传输位数，双向）<br>地址总线（系统可管理的内存空间的大小，单向）<br>控制总线（传 送控制命令） 。代表的有ISA总线 、EISA总线 、PCI总线 。<br>3、外部总线： 设备一级的总线， 微机和外部设备的总线 。代表的有RS232（串行总 线） 、SCSI（并行总线） 、USB（通用串行总线， 即插即用， 支持热插拔） 。</p>
<h4 id="总线事务"><a href="#总线事务" class="headerlink" title="总线事务"></a>总线事务</h4><p>1、突发传输：一个总线周期内，传输多个存储地址的连续数据<br>2、并行传输：多个数据位同事传输<br>3、串行传输：：一条物理信道上单位时间顺序逐位传输<br>4、同步传输：统一时钟控制</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向工程和需求工程</title>
    <url>/2024/03/08/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%92%8C%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h2><p><strong>软件复用：</strong>是将已有软件的各种有关知识用于建立新的软件，以缩减软件开发和维护的花费</p>
<p><strong>逆向工程：</strong>软件的逆向工程是分析程序，力图在比源代码更高抽象层次上建立程序的表示过程，逆向工程是设计的恢复过程</p>
<p><strong>逆向工程的四个级别：</strong></p>
<p>实现级：包括程序的抽象语法树、符号表、过程的设计表示。</p>
<p>结构级：包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图、程序和数据结构。</p>
<p>功能级：包括反映程序段功能及程序段之间关系的信息，例如数据和控制流模型。</p>
<p>领域级：包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息，例如E-R模型。</p>
<p>其中，领域级抽象级别最高，完备性(完整)最低，实现级抽象级别最低，完备性最高。</p>
<h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p>重构是指通过改变程序的内部结构，以改进其设计、可读性、可维护性和性能，而不改变其外部行为。重构可以通过重新组织代码、简化算法、消除重复等方式来改善程序的质量和结构。</p>
<h4 id="设计恢复"><a href="#设计恢复" class="headerlink" title="设计恢复"></a>设计恢复</h4><p>设计恢复是指通过对已有软件系统的逆向工程分析，还原出其设计和结构。这可以帮助我们理解现有系统的组织方式、模块之间的关系以及它们之间的交互</p>
<h4 id="再工程"><a href="#再工程" class="headerlink" title="再工程"></a>再工程</h4><p>再工程是指对现有软件系统进行重构、改进和现代化，以满足新的需求、提高性能或增强可维护性等方面的要求。是在逆向工程所获得信息的基础上，修改或重构已有的系统，产生系统的一个新版本</p>
<h2 id="正向工程"><a href="#正向工程" class="headerlink" title="正向工程"></a>正向工程</h2><p>正向工程是指将软件设计的高级概念和抽象转化为实现代码的过程。它是逆向工程的相反过程，不仅从现有系统中恢复设计信息，而且使用该信息去改变或重构现有系统</p>
<h2 id="需求工程"><a href="#需求工程" class="headerlink" title="需求工程"></a>需求工程</h2><h3 id="需求分类"><a href="#需求分类" class="headerlink" title="需求分类"></a>需求分类</h3><h4 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h4><p>是指用户对系统在功能、行为、性能、设计约束等方面的期望。是指用户解决问题或达到目标所需的条件或能力，是系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或能力，以及反映这些条件或能力的文档说明。</p>
<p>分为需求开发，需求管理两大过程：</p>
<p><strong>需求开发</strong>：需求获取，需求分析，需求定义（需求规划说明书SRS），需求验证</p>
<p><strong>需求管理</strong>：变更控制，版本控制，需求跟踪，需求状态跟踪</p>
<h4 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h4><p>反映企业或客户对系统高层次的目标要求，抽象级别最高</p>
<h4 id="用户需求"><a href="#用户需求" class="headerlink" title="用户需求"></a>用户需求</h4><p>描述的是用户的具体目标，或用户要求系统必须能完成的任务。即描述了用户能使用系统来做什么</p>
<h4 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h4><p>从系统的角度来说明软件的需求， 抽象级别最低</p>
<p>分为下面三种：</p>
<p><strong>功能需求</strong>：也称为行为需求，规定了开发人员必须在系统中实现的软件功能，用户利用这些功能来完成任务，满足业务需要。</p>
<p><strong>非功能需求</strong>：指系统必须具备的属性或品质，又可以细分为软件质量属性(如可维护性、可靠性、效率等)、性能需求以及其他非功能需求。</p>
<p><strong>设计约束</strong>：也称为限制条件或补充规约，通常是对系统的一些约束说明，例如必须采用国有自主知识产权的数据库系统，必须运行在UNIX操作系统之，又比如涉及到金钱的要精确到小数点后面2位等人为规定的或约束</p>
<h3 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h3><p>用户访谈：1对1-3,找有代表性的用户进行访谈，对提问者的水平是有要求的。其形式包括结构化(有剧本)和非结构化(随意发挥)两种。</p>
<p>问卷调查：用户多，无法一一访谈，收集到的需求不够精准，比较杂乱，比较考验问卷编写者的水平</p>
<p>采样：从种群中系统地选出有代表性的样本集的过程，类似于数学中的数理统计。样本数量=0.25*(可信度因子/错误率)2</p>
<p>情节串联板：一系列图片，通过这些图片来把需求给进行叙述出来，这样虽然生动，但是耗时</p>
<p>联合需求计划(JRP)：通过联合各个关键用户代表、系统分析师、开发团队代表一起，通过有组织的会议来讨论需求。</p>
<p>需求记录技术：任务卡片、场景说明、用户故事、Volere白卡。</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>一个好的需求应该具有无二义性、完整性、一致性、可测试性、确定性、可跟踪性、正确性、必要性等特性，因此，需要分析人员把杂乱无章的用户要求和期望转化为用户需求，这就是需求分析的工作。</p>
<p>绘制系统上下文范围关系图（数据流图DFD）</p>
<p>创建用户界面原型</p>
<p>分析需求的可行性</p>
<p>确定需求的优先级</p>
<p>为需求建立模型</p>
<p>创建数据字典</p>
<p>使用QFD(QFD:质量功能部署，把需求和QFD进行关联)</p>
<h4 id="结构化分析"><a href="#结构化分析" class="headerlink" title="结构化分析"></a>结构化分析</h4><p>结构化特点：自顶向下，逐步分解，面向数据。</p>
<p>三大模型：功能模型(数据流图)、行为模型(状态转换图)、数据模型(E-R图)以及数据字典</p>
<h5 id="数据流图（DFD）"><a href="#数据流图（DFD）" class="headerlink" title="数据流图（DFD）"></a>数据流图（DFD）</h5><p>数据流，加工，数据存储，外部实体，功能模型，从功能角度</p>
<p><img src="/2024/03/08/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%92%8C%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/1.jpg" alt="1"></p>
<p><strong>数据流：</strong>由一组固定成分的数据组成，表示数据的流向。在DFD中，数据流的流向必须经过加工</p>
<p><strong>加工：</strong>描述了输入数据流到输出数据流之间的变换，数据流图中常见的三种错误如图所示</p>
<p><img src="/2024/03/08/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%92%8C%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/2.jpg" alt="1"></p>
<p><strong>数据存储：</strong>用来存储数据。</p>
<p><strong>外部实体(外部主体)：</strong>是指存在于软件系统之外的人员或组织，它指出系统所需数据的发源地(源)和系统所产生的数据的归宿地(宿)。</p>
<h5 id="分层数据流图"><a href="#分层数据流图" class="headerlink" title="分层数据流图"></a>分层数据流图</h5><p>顶层图：空的部分就是系统</p>
<p><img src="/2024/03/08/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%92%8C%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/3.jpg" alt="1"></p>
<p>0层图：根据顶层图的外部实体，得到加工过程</p>
<p><img src="/2024/03/08/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%92%8C%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/4.jpg" alt="1"></p>
<p>1层图：根据加工过程，得到加工的1层图</p>
<p><img src="/2024/03/08/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%92%8C%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/5.jpg" alt="1"></p>
<h5 id="状态转换图（STD）"><a href="#状态转换图（STD）" class="headerlink" title="状态转换图（STD）"></a>状态转换图（STD）</h5><p>状态（始态，终态），事件，行为模型，从行为角度</p>
<h5 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h5><p>实体联系，数据模型，从数据角度</p>
<h5 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h5><p>数据字典就是为数据流图中的每个数据流、文件、加工，以及组成数据流或文件的数据项做出说明，即为了描述数据流图的</p>
<p>数据字典有以下4类条目：数据流、数据项、数据存储和基本加工</p>
<h3 id="需求定义"><a href="#需求定义" class="headerlink" title="需求定义"></a>需求定义</h3><p>软件需求规格说明书SRS：是需求开发活动的产物， 整个开发工作的基础</p>
<p>需求定义方法：</p>
<p>严格定义也称为预先定义（结构化定义），需求的严格定义建立在以下的基本假设之上：所有需求都能够被预先定义，开发人员与用户之间能够准确而清晰地交流。采用图形(或文字)可以充分体现最终系统，适合需求明确的情况</p>
<p>原型方法，迭代的循环型开发方式，原型提供了克该服困难的一个手段。特点：需要实际的、可供用户参与的系统模型。有合适的系统开发环境。反复是完全需要和值得提倡的，需求一旦确定，就应遵从严格的方法</p>
<h3 id="需求验证"><a href="#需求验证" class="headerlink" title="需求验证"></a>需求验证</h3><p>也称为需求确认，目的是与用户一起确认需求无误，对需求规格说明书SAS进行评审和测试</p>
<p>需求验证通过后，要请用户签字确认，作为验收标准之一， 这个需求规格说明书就是需求基线，不可以再随意更新，如果需要更改必须走需求变更流程</p>
<p>定义需求基线：通过了评审的需求说明书就是需求基线，客户和开发者的需求约定</p>
<h3 id="需求管理"><a href="#需求管理" class="headerlink" title="需求管理"></a>需求管理</h3><h4 id="变更和风险"><a href="#变更和风险" class="headerlink" title="变更和风险"></a>变更和风险</h4><p>主要关心需求变更过程中的需求风险管理，带有风险的做法有：无足够用户参与、忽略了用户分类、用户需求的不断增加、模棱两可的需求、不必要的特性、过于精简的SRS、不准确的估算</p>
<h4 id="需求跟踪"><a href="#需求跟踪" class="headerlink" title="需求跟踪"></a>需求跟踪</h4><p>包括编制每个需求与系统元素之间的联系文档，这些元素包括其它需求、体系结构、设计部件、源代码模块、测试、帮助文件和文档等。</p>
<p>正向跟踪表示用户原始需求是否都实现了，正向跟踪一般是用来判断产品有没有少实现</p>
<p>反向跟踪表示软件实现的是否都是用户要求的，不多不少，可以用原始需求和用例表格(需求跟踪矩阵)来表示，反向跟踪一般是用来判断产品有没有多实现</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2020/12/18/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="思维要点"><a href="#思维要点" class="headerlink" title="思维要点"></a>思维要点</h3><ol>
<li><p>不要人肉进行递归（最大误区）</p>
</li>
<li><p>找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）</p>
</li>
<li><p>数学归纳法思维</p>
</li>
<li><p>递归每一层的逻辑环境都一样，不影响前后每一层</p>
</li>
</ol>
<p>模板：</p>
<ol>
<li>首先规定递归什么时候结束，一定要限制条件，不能无限循环</li>
<li>递归的执行逻辑，当前层的执行逻辑，即重复性思维，重复性处理，找相似性</li>
<li>递归调用，层数加1，进入下一层</li>
<li>最后清除，如果有涉及到外部逻辑的</li>
</ol>
<h3 id="python模板"><a href="#python模板" class="headerlink" title="python模板"></a>python模板</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">def recursion(level, param1, param2, ...):</span><br><span class="line">	# recursion terminator递归跳出条件</span><br><span class="line">	<span class="keyword">if</span> level &gt; MAX_LEVEL:</span><br><span class="line"> 		process_result</span><br><span class="line"> 		<span class="keyword">return</span></span><br><span class="line">	# process logic in current level 当前层的执行逻辑</span><br><span class="line">	process(level, data...)</span><br><span class="line">	# drill down</span><br><span class="line">	self.recursion(level + <span class="number">1</span>, p1, ...) 递归调用</span><br><span class="line">	# reverse the current level status if neede 清除收尾</span><br></pre></td></tr></table></figure>

<h3 id="GO模板"><a href="#GO模板" class="headerlink" title="GO模板"></a>GO模板</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">recursion</span>(<span class="params">level int, param1, param2 interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// recursion terminator递归跳出条件</span></span><br><span class="line">	<span class="keyword">if</span> level &gt; MAX_LEVEL &#123;</span><br><span class="line">		process_result</span><br><span class="line"> 		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"> 		</span><br><span class="line">	<span class="comment">// process logic in current level 当前层的执行逻辑</span></span><br><span class="line">	process(level, data...)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// drill down递归调用</span></span><br><span class="line">	recursion(level + <span class="number">1</span>, p1, ...)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// reverse the current level status if neede 清除收尾</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>递归分治回溯，bfs专题</title>
    <url>/2021/02/22/%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ol>
<li><p>首先规定递归什么时候结束，一定要限制条件，不能无限循环</p>
</li>
<li><p>递归的执行逻辑，当前层的执行逻辑，即重复性思维，重复性处理，找相似性</p>
</li>
<li><p>递归调用，层数加1，进入下一层</p>
</li>
<li><p>最后清除，如果有涉及到外部逻辑的</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">recursion</span>(<span class="params">level int, param1, param2 interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// recursion terminator递归跳出条件</span></span><br><span class="line">	<span class="keyword">if</span> level &gt; MAX_LEVEL &#123;</span><br><span class="line">		process_result</span><br><span class="line"> 		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"> 		</span><br><span class="line">	<span class="comment">// process logic in current level 当前层的执行逻辑</span></span><br><span class="line">	process(level, data...)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// drill down递归调用</span></span><br><span class="line">	recursion(level + <span class="number">1</span>, p1, ...)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// reverse the current level status if neede 清除收尾</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>1.递归要找到重复子问题，不要人肉递归</p>
<p>2.一定注意递归终止条件</p>
<p>3.递归属于后进先出（与栈，深度优先遍历类似）</p>
<p>4.明白是层级向下递减，还是递增，带不带return值</p>
<p>递增：边界条件达到最大值，层逻辑在递归调用前处理，看看是不是需要传给下一层</p>
<p>递减：边界条件达到最小值，带返回值，返回后，层逻辑在递归调用后处理，用上一层的返回值处理，看看是不是要用到上一层的结果</p>
<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>1.分治是将递归过程中的问题分步骤解决，每一步骤单独递归，最终得到结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">recursion</span>(<span class="params">level int, param1, param2 interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// recursion terminator递归跳出条件</span></span><br><span class="line">	<span class="keyword">if</span> level &gt; MAX_LEVEL &#123;</span><br><span class="line">		process_result</span><br><span class="line"> 		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"> 		</span><br><span class="line">	<span class="comment">// 分治处理当前层逻辑</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// </span></span><br><span class="line">		process(...)</span><br><span class="line">		<span class="comment">// drill down递归调用</span></span><br><span class="line">		recursion(...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// reverse the current level status if neede 清除收尾</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>


<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>1.回溯采用试错的思想，分布解决，达到某种特定条件，或者是错误结果，则进行回溯，要有一个不断变化的变量，递归下一层改变，回溯上一层重置</p>
<p>2.递归过程中是一直向深层递归，处理完某种特定条件之后，返回当前层，回到上一层</p>
<p>3.对于当前层的处理进行回溯，回到上一层的状态，进行状态重置</p>
<p>4.在上一层做相应处理，通过分治，走下一种情况去解决，进入到另一种情况下一层，继续处理</p>
<p>5.重复4步骤，知道递归完毕</p>
<p>例如: 组合，全排列等题</p>
<p>1.通过递归往数组里添加数字，直到这个数组，满足结果，添加进最终结果，这个数组就是不断变化的变量</p>
<p>2.然后回溯，将状态回到上一层，再对上一层的分治的第二种情况，继续向下递归，然后回溯，重复步骤</p>
<p>3.区别在于分治时候的逻辑不一样，组合是依次遍历+1，所以不会加入重复的， 全排列是全遍历，要对于已加入的数字进行过滤</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>由于回溯相当于遍历，所以时间复杂度会比较高，通过特定条件进行剪枝，跳过一些情况，可以降低复杂度</p>
<p>比如全排列2的排序操作，通过排序预处理，针对已经加入，或者重复的进行跳过，达到剪枝，减少递归</p>
<p>时间复杂度： O(N×N!)<br>空间复杂度： O(N×N!)</p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>1.为什么要进行回溯，不回溯的话也可以解决问题，则需要在每一层递归的时候，创建新的变量来处理问题，消耗比较大</p>
<p>2.回溯则是用一个变化的变量，进行修改状态，重置状态，不用创建变量</p>
<p>3.回溯问题思考：<br>    1.如何产生分支，如何进行下次递归，递归树是怎样的<br>    2.解在哪里，是在叶子节点，还是路径，还是非叶子节点，如何得到解<br>    3.哪些情况不需要解，如何过滤掉这些解，如何剪枝，如何避免重复</p>
<p>4.要记得优化参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">recursion</span>(<span class="params">level int, param1, param2 interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 得到解，解的条件</span></span><br><span class="line">	<span class="function"><span class="title">terminator</span>(<span class="params">...</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分治处理</span></span><br><span class="line"> 	<span class="keyword">for</span> &#123;</span><br><span class="line"> 		<span class="comment">// 剪枝判断，剪枝过滤，减少递归</span></span><br><span class="line"> 		fix(...)</span><br><span class="line"> 		<span class="comment">// 得到解的过程，当前层处理逻辑，变化变量的处理</span></span><br><span class="line">		process(...)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 进入下一层，变化的变量传入下一层</span></span><br><span class="line">		recursion(...)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 回溯，回溯变化的变量，回到上一层之后的处理</span></span><br><span class="line">		back()</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h3><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<p>递归+回溯</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func generateParenthesis(n int) []string &#123;</span><br><span class="line">    res := []string&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> handle func(int, int, string)</span><br><span class="line">    handle = <span class="function"><span class="title">func</span>(<span class="params">left, right int, r string</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> len(r) == <span class="number">2</span>*n &#123;</span><br><span class="line">            res = append(res, r)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left &lt; n &#123;</span><br><span class="line">            r += <span class="string">&quot;(&quot;</span></span><br><span class="line">            handle(left + <span class="number">1</span>, right, r)</span><br><span class="line">            r = r[:len(r) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> right &lt; left &#123;</span><br><span class="line">            r += <span class="string">&quot;)&quot;</span></span><br><span class="line">            handle(left, right + <span class="number">1</span>, r)</span><br><span class="line">            r = r[:len(r) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// combine 递归方法</span></span><br><span class="line"><span class="comment">// 1.递归中往数组里添加数字，不断往深递归，达到k的长度要求，则加入结果</span></span><br><span class="line"><span class="comment">// 2.达到结果开始回溯，当前结果满足，则回到上一递归结果，回到上一递归状态</span></span><br><span class="line"><span class="comment">// 3.继续上一个递归的for循环，i++，继续开始下一个数字的组合</span></span><br><span class="line">func combine(n int, k int) [][]int &#123;</span><br><span class="line">    res := [][]int&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> n &lt; k &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> handle func(start int, path []int)</span><br><span class="line">    handle = <span class="function"><span class="title">func</span>(<span class="params">start int, path []int</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 得到结果的长度，加入结果，加入后进行回溯</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == k &#123;</span><br><span class="line">        	<span class="comment">// 后续会修改path，需要拷贝，不然数据会修改，path是地址引用</span></span><br><span class="line">            tmp := make([]int, len(path))</span><br><span class="line">            copy(tmp, path)</span><br><span class="line">            res = append(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt;= n; i++ &#123;</span><br><span class="line">            <span class="comment">// 1加入</span></span><br><span class="line">            path = append(path, i)</span><br><span class="line">            <span class="comment">// 从2开始，判断是否到回溯条件，如果符合，加入最终结果</span></span><br><span class="line">            handle(i+<span class="number">1</span>, path)</span><br><span class="line">            <span class="comment">// 回溯去掉最后一位，继续递归。2完了3，开始下一位循环</span></span><br><span class="line">            path = path[:len(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    handle(<span class="number">1</span>, []int&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// permute 递归法，分治回溯</span></span><br><span class="line"><span class="comment">// 1.递归中往数组里添加数字，不断往深递归，达到结果要求，加入最终结果</span></span><br><span class="line"><span class="comment">// 2.满足一种结果后，进行回溯，全排列，相当于每一个空位，每一个数字都有可能</span></span><br><span class="line"><span class="comment">// 3.避免重复，对于已经加入的数字通过map记录，因为是全遍历，再加入时进行过滤</span></span><br><span class="line"><span class="comment">// 4.回溯到上一状态，重置之前加入的数字，重置当前数组</span></span><br><span class="line">func permute(nums []int) [][]int &#123;</span><br><span class="line">    <span class="comment">// 结果</span></span><br><span class="line">    res := [][]int&#123;&#125;</span><br><span class="line">    <span class="comment">// 用于记录访问过的节点</span></span><br><span class="line">    vis := make(map[int]bool, len(nums))</span><br><span class="line">    <span class="keyword">var</span> handle func(curNums []int)</span><br><span class="line">    handle = <span class="function"><span class="title">func</span>(<span class="params">curNums []int</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到结果的条件</span></span><br><span class="line">        <span class="keyword">if</span> len(curNums) == <span class="function"><span class="title">len</span>(<span class="params">nums</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// 数组是地址引用，需要拷贝加入最终结果</span></span><br><span class="line">            tmp := make([]int, len(curNums))</span><br><span class="line">            copy(tmp, curNums)</span><br><span class="line">            res = append(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组全遍历，要对重复数字进行过滤</span></span><br><span class="line">        <span class="keyword">for</span> _, <span class="attr">v</span> := range nums &#123;</span><br><span class="line">            <span class="keyword">if</span> vis[v] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入结果，并记录</span></span><br><span class="line">            vis[v] = <span class="literal">true</span></span><br><span class="line">            curNums = append(curNums, v)</span><br><span class="line">            handle(curNums)</span><br><span class="line">            <span class="comment">// 回溯，重置记录与数组</span></span><br><span class="line">            vis[v] = <span class="literal">false</span></span><br><span class="line">            curNums = curNums[:len(curNums) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handle([]int&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全排列2"><a href="#全排列2" class="headerlink" title="全排列2"></a>全排列2</h3><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// permuteUnique 全排列2，包含重复数字</span></span><br><span class="line"><span class="comment">// 1.递归不断往数组中添加数字，往深递归，达到结果长度，加入最终结果</span></span><br><span class="line"><span class="comment">// 2.之后回溯，重置状态</span></span><br><span class="line"><span class="comment">// 3.相比全排列1，包含了重复数字，除了要对已经加入的进行记录过滤，还要对重复数字进行过滤</span></span><br><span class="line"><span class="comment">// 4.为了更好的处理重复，对数组进行排序，重复数字都在一起</span></span><br><span class="line"><span class="comment">// 5.因为包含重复数字，所以记录下标，判断下标是否被记录</span></span><br><span class="line"><span class="comment">// 6.、已经记录的过滤，当前下标值与之前的一样，遇到重复的，且前面一个没有被记录的话，说明是一个新的循环，会产生重复结果，要跳过</span></span><br><span class="line">func permuteUnique(nums []int) [][]int &#123;</span><br><span class="line">    res := [][]int&#123;&#125;</span><br><span class="line">    vis := make(map[int]bool, len(nums))</span><br><span class="line">    <span class="comment">// 数组排序，方便处理重复数据</span></span><br><span class="line">    sort.Ints(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> handle func(curNums []int)</span><br><span class="line">    handle = <span class="function"><span class="title">func</span>(<span class="params">curNums []int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> len(curNums) == <span class="function"><span class="title">len</span>(<span class="params">nums</span>)</span> &#123;</span><br><span class="line">            tmp := make([]int, len(curNums))</span><br><span class="line">            copy(tmp, curNums)</span><br><span class="line">            res = append(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i, <span class="attr">v</span> := range nums &#123;</span><br><span class="line">            <span class="comment">// 已经记录过的跳过</span></span><br><span class="line">            <span class="keyword">if</span> vis[i] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 与前面的数字值重复，且前面的数字没有被记录过，说明是新的循环，说明会产生重复结果，跳过</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; v == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入数字，记录</span></span><br><span class="line">            vis[i] = <span class="literal">true</span></span><br><span class="line">            curNums = append(curNums, v)</span><br><span class="line">            handle(curNums)</span><br><span class="line">            <span class="comment">// 回溯重置</span></span><br><span class="line">            vis[i] = <span class="literal">false</span></span><br><span class="line">            curNums = curNums[:len(curNums) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle([]int&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>回溯递归：</p>
<p>1.与之前递归回溯类似，只不过是二维数组，多了一维，可以先初始化一个二维数组，然后在递归过程中不断赋值修改</p>
<p>2.类似组合start +1这种，start就是行， 递归中遍历列，递归深度行+1，达到类似两个指针的效果，就像组合，固定一个，遍历从固定的开始</p>
<p>3.剪枝规则，就是行，左对角线，右对角线都没有重复的</p>
<p>4.递归是另一种遍历，后进先出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func solveNQueens(n int) [][]string &#123;</span><br><span class="line">    res := [][]string&#123;&#125;</span><br><span class="line"></span><br><span class="line">    bd := make([][]string, n)</span><br><span class="line">	<span class="keyword">for</span> i := range bd &#123;</span><br><span class="line">		bd[i] = make([]string, n)</span><br><span class="line">		<span class="keyword">for</span> j := range bd[i] &#123;</span><br><span class="line">			bd[i][j] = <span class="string">&quot;.&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    visCol := make(map[int]bool, n)</span><br><span class="line">    visLeftSth := make(map[int]bool, n)</span><br><span class="line">    visRightSth := make(map[int]bool, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> handle func([][]string, int)</span><br><span class="line">    handle = <span class="function"><span class="title">func</span>(<span class="params">bd [][]string, r int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r == n &#123;</span><br><span class="line">            tmp := make([]string, n)</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                tmp[i] = strings.Join(bd[i], <span class="string">&quot;&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            res = append(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> c := <span class="number">0</span>; c &lt; n; c++ &#123;</span><br><span class="line">            <span class="keyword">if</span> visCol[c] || visLeftSth[c - r] || visRightSth[c + r] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            bd[r][c] = <span class="string">&quot;Q&quot;</span></span><br><span class="line">            visCol[c] = <span class="literal">true</span></span><br><span class="line">            visLeftSth[c - r] = <span class="literal">true</span></span><br><span class="line">            visRightSth[c + r] = <span class="literal">true</span></span><br><span class="line">            handle(bd, r + <span class="number">1</span>)</span><br><span class="line">            bd[r][c] = <span class="string">&quot;.&quot;</span></span><br><span class="line">            visCol[c] = <span class="literal">false</span></span><br><span class="line">            visLeftSth[c - r] = <span class="literal">false</span></span><br><span class="line">            visRightSth[c + r] = <span class="literal">false</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    handle(bd, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Pow"><a href="#Pow" class="headerlink" title="Pow"></a>Pow</h3><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。</p>
<p>for循环迭代会超时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func myPow(x float64, n int) float64 &#123;</span><br><span class="line">	<span class="comment">// 处理边界条件</span></span><br><span class="line">    res := <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 小于0的时候，负数单独处理</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">        x = <span class="number">1</span> / x</span><br><span class="line">        n = -n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后递归，n不断向下递减</span></span><br><span class="line">    <span class="keyword">var</span> handle func(float64, int) float64</span><br><span class="line">    handle = func (x float64, n int) float64 &#123;</span><br><span class="line">    	<span class="comment">// 边界条件</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        res = handle(x, n/<span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 向上处理</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res * res</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * res * x</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handle(x, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p>回溯递归：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func subsets(nums []int) [][]int &#123;</span><br><span class="line">    res := [][]int&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> handle func([]int, int)</span><br><span class="line">    handle = func (cur []int, start int) &#123;</span><br><span class="line">        <span class="keyword">if</span> len(cur) &lt;= <span class="function"><span class="title">len</span>(<span class="params">nums</span>)</span> &#123;</span><br><span class="line">            tmp := make([]int, len(cur))</span><br><span class="line">            copy(tmp, cur)</span><br><span class="line">            res = append(res, tmp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt; len(nums); i++ &#123;</span><br><span class="line">            cur = append(cur, nums[i])</span><br><span class="line">            handle(cur, i+<span class="number">1</span>)</span><br><span class="line">            cur = cur[:len(cur) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handle([]int&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func subsets(nums []int) (ans [][]int) &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    <span class="comment">// &lt;&lt; 位操作运算 1&lt;&lt;n</span></span><br><span class="line">    <span class="keyword">for</span> mask := <span class="number">0</span>; mask &lt; <span class="number">1</span>&lt;&lt;n; mask++ &#123;</span><br><span class="line">        set := []int&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, <span class="attr">v</span> := range nums &#123;</span><br><span class="line">            <span class="keyword">if</span> mask&gt;&gt;i&amp;<span class="number">1</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">                set = append(set, v)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = append(ans, append([]int(nil), set...))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子集2"><a href="#子集2" class="headerlink" title="子集2"></a>子集2</h3><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>回溯递归：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func subsetsWithDup(nums []int) [][]int &#123;</span><br><span class="line">    res := [][]int&#123;&#125;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    vis := make(map[int]bool, len(nums))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> handle func([]int, int)</span><br><span class="line">    handle = <span class="function"><span class="title">func</span>(<span class="params">cur []int, start int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> len(cur) &lt;= <span class="function"><span class="title">len</span>(<span class="params">nums</span>)</span> &#123;</span><br><span class="line">            tmp := make([]int, len(cur))</span><br><span class="line">            copy(tmp, cur)</span><br><span class="line">            res = append(res, tmp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt; len(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            vis[i] = <span class="literal">true</span></span><br><span class="line">            cur = append(cur, nums[i])</span><br><span class="line">            handle(cur, i + <span class="number">1</span>)</span><br><span class="line">            cur = cur[:len(cur) - <span class="number">1</span>]</span><br><span class="line">            vis[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handle([]int&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象技术</title>
    <url>/2024/04/13/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>对象：由数据及其操作所构成的封装体，是系统中用来描述客观事务的一个实体，是构成系统的 一个基本单位。 一个对象通常可以由对象名、属性和方 法3个部分组成。</p>
<p>类：现实世界中实体的形式化描述，类将该实体的属性(数据)和操作 (函数)封装在一起。对象是类的实例，类是对象的模板</p>
<p>抽象：通过特定的实例抽取共同特征以后形成概念的过程</p>
<p>封装：是一种信息隐蔽技术， 将相关的概念组成一个单元模块， 并通过一个名称来引用 。面向对象封装是将数据和基于数据的操作封装成一个整体对象</p>
<p>继承：表示类之间的层次关系 (父类与子类)</p>
<p>多态：不同的对象收到同 一个消息时产生完全不同的结果</p>
<p>接口：其只说明操作应该做什么， 并没有定义操作如何做</p>
<p>消息：体现对象间的交互， 通过它向目标对象发送操作请求</p>
<p>覆盖：子类在原有父类接口的基础上， 用适合于自己要求的实现去置换父类中的相应实现 。即在子类中重定义-个与父类同名同参的方法</p>
<p>重载： 与覆盖要区分开， 函数重载与子类父类无关， 且函数是同名不同参数</p>
<p>绑定：是一个把过程调用和响应调用所需要执行的代码加以结合的过程。动态绑定，运行时，静态绑定，编译时</p>
<h3 id="UML统一建模语言"><a href="#UML统一建模语言" class="headerlink" title="UML统一建模语言"></a>UML统一建模语言</h3><p>UML三要素：UML的基本构造块、支配这些构造块如何放置在一起的规则和运用与整个语言的一些公共机制</p>
<p>UML的基本构造块包括：事物(对模型中最具有代表性的成分的抽象)、关系(把事务结合在一起)、图(聚集了相关的事物)。</p>
<h4 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h4><p>UML中有四种事物：结构事物（静态事物）、行为事物（动态事物）、分组事物、注释事物</p>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>依赖：一个事物的语义依赖于另一个事物的语义的变化而变化</p>
<p>关联：是一种结构关系，描述了一组链，链是对象之间的连接。分为组合和聚合，都是部分和整体的关系，其中组合事物之间关系更强。两个类之间的关联，实际上是两个类所扮演角色的关联，因此，两个类之间可以有多个由不同角色标识的关联。</p>
<p>泛化：一般/特殊的关系，子类和父类之间的关系，继承关系</p>
<p>实现：一个类元指定了另一个类元保证执行的契约。</p>
<h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><p>长方形：类</p>
<p>实习菱形：组合，强关联</p>
<p>空心菱形：聚集，弱关联</p>
<p>横线：关联</p>
<p>虚线箭头：依赖</p>
<p>圆形：接口</p>
<p>空心三角：泛化</p>
<p>虚线三角：实现</p>
<p>点点*：多重度，1个到多个</p>
<p>类图：静态图，为系统的静态设计视图，展现一组对象、接口、协作和它们之间的关系。</p>
<p>对象图：静态图，展现某一时刻一组对象及它们之间的关系，为类图的某一快照。在没有类图的前提下，对象图就是静态设计视图。</p>
<p>用例图：静态图，展现了一组用例、参与者以及它们之间的关系。用例图中的参与者是人、硬件或其他系统可以扮演的角色；用例是参与者完成的一系列操作。用例之间的关系：包含（include）、扩展(extend)、泛化。</p>
<p>序列图：即顺序图，动态图，是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。有同步消息(进行阻塞调用，调用者中止执行，等待控制权返回，需要等待返回消息，用实心三角箭头表示)、异步消息(发出消息后继续执行，不引起调用者阻塞，也不等待返回消息，由空心箭头表示)、返回消息(由从右到左的虚线箭头表示)三种。 </p>
<p>实心箭头：同步消息</p>
<p>异步消息：空心箭头</p>
<p>返回消息：虚线箭头</p>
<p>通信图：动态图，即协作图，是顺序图的另一种表示方法，也是由对象和消息组成的图，只不过不强调时间顺序，只强调事件之间的通信，而且也没有固定的画法规则，和顺序图统称为交互图</p>
<p>状态图：动态图，展现了一个状态机，描述单个对象在多个用例中的行为，包括简单状态和组合状态。转换可以通过事件触发器触发，事件触发后相应的监护条件会进行检查。状态图中转换和状态是两个独立的概念，如下：图中方框代表状态，箭头上的代表触发事件，实心圆点为起点和终点</p>
<p>活动图：动态图，是一种特殊的状态图，展现了在系统内从一个活动到另二个活动的流程。活动的分岔和汇合线是一条水平粗线。每个分岔的分支数代表了可同时运行的线程数。活动图中能够并行执行的是在一个分岔粗线下的分支上的活动。</p>
<p>构件图(组件图):静态图，为系统静态实现视图，展现了一组构件之间的组织和依赖。</p>
<p>部署图：静态图，为系统静态部署视图，部署图描述的事物理模块的节点分布。它与构件图相关，通常一个结点包含一个或多个构件。其依赖关系类似于包依赖，因此部署组件之间的依赖是单向的类似于包含关系。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>架构模式:软件设计中的高层决策，例如C/S结构就属于架构模式, 架构模式反映了开发软件系统过程中所作的基本设计决策。</p>
<p>设计模式:每一个设计模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。设计模式的核心在于提供了相关问题的解决方案，使得人们可以更加简单方便的复用成功的的设计和体系结构。</p>
<p>四个基本要素:模式名称、问题（应该在何时使用模式）、解决方案（设计的内容）、效果（模式应用的效果）。</p>
<p>惯用法:是最低层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用一计数就是C++语言中的一种惯用法。</p>
<h4 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h4><p>抽象工厂模式：抽象接口</p>
<p>构件器模式：类与构造分离</p>
<p>单例模式：唯一实例</p>
<p>工厂方法模式：子类决定实例化</p>
<p>原型模式：原型，拷贝</p>
<h4 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h4><p>适配器模式：转换，兼容接口</p>
<p>桥接模式：抽象和实现分离</p>
<p>组合模式：整体部分，树形结构</p>
<p>装饰模式：附加职责</p>
<p>外观模式：对外统一接口</p>
<p>享元模式：细粒度，共享</p>
<p>代理模式：代理控制</p>
<h4 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h4><p>责任链模式：传递请求，指责链接</p>
<p>命令模式：日志记录，可撤销</p>
<p>解释器模式：解释器，虚拟机</p>
<p>迭代器模式：顺序访问，不暴露内部</p>
<p>中介者模式：不直接引用</p>
<p>备忘录模式：保存恢复</p>
<p>观察者模式：通知，自定更新</p>
<p>状态模式：状态变成类</p>
<p>策略模式：算法替换</p>
<p>模板方法模式</p>
<p>访问者模式：数据和操作分离</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>页面静态化与定时任务</title>
    <url>/2018/07/08/%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>网站的首页频繁被访问，为了提升访问速度，除了缓存技术，还可以使用页面静态化技术。其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。</p>
<h2 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h2><h3 id="什么是页面静态化"><a href="#什么是页面静态化" class="headerlink" title="什么是页面静态化"></a>什么是页面静态化</h3><p>页面静态化即将动态渲染生成的页面结果保存成html文件，放到静态文件服务器中。用户访问的时候访问的是处理好之后的html静态文件。</p>
<p>页面中有些区域，因登录用户不同，而显示不同的数据，可以在用户请求完html页面后，通过ajax向后端发送请求，获取属于用户的特殊的数据。</p>
<h3 id="首页配置静态化"><a href="#首页配置静态化" class="headerlink" title="首页配置静态化"></a>首页配置静态化</h3><p>在settings.py中添加保存静态文件的目录</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 生成的静态html文件保存目录</span><br><span class="line">GENERATED_STATIC_HTML_FILES_DIR = os.path.join(os.path.dirname(BASE_DIR), <span class="string">&#x27;front_end_pc&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>front_end_pc为前端文件的存放目录</p>
<p>然后将静态化的页面数据例:index.html放置在templates文件里</p>
<p>静态化逻辑，生成静态化页面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 获取要生成的数据</span><br><span class="line"> context = &#123;</span><br><span class="line">        <span class="string">&#x27;categories&#x27;</span>: categories,</span><br><span class="line">        <span class="string">&#x27;contents&#x27;</span>: contents</span><br><span class="line">    &#125;</span><br><span class="line">	# 加载模板</span><br><span class="line">    template = loader.get_template(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line">	# 渲染模板</span><br><span class="line">    html_text = template.render(context)</span><br><span class="line">	# 静态文件保存的路径</span><br><span class="line">    file_path = os.path.join(settings.GENERATED_STATIC_HTML_FILES_DIR, <span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line">	# 打开该路径下的文件，没有则生成创建</span><br><span class="line">    <span class="keyword">with</span> open(file_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(html_text)</span><br></pre></td></tr></table></figure>
<h2 id="实现静态化的两种方式"><a href="#实现静态化的两种方式" class="headerlink" title="实现静态化的两种方式"></a>实现静态化的两种方式</h2><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在Django执行定时任务，可以通过django-crontab扩展来实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pip install django-crontab</span><br></pre></td></tr></table></figure>
<p>然后配置中添加应用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    &#x27;django_crontab&#x27;,  # 定时任务</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>设置任务的定时时间</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 定时任务</span><br><span class="line">CRONJOBS = [</span><br><span class="line">    # 每5分钟执行一次生成主页静态文件</span><br><span class="line">    (<span class="string">&#x27;*/5 * * * *&#x27;</span>, <span class="string">&#x27;contents.crons.generate_static_index_html&#x27;</span>, <span class="string">&#x27;&gt;&gt; 日志路径/logs/crontab.log&#x27;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>基本格式 :</p>
<hr>
<p>分 时 日 月 周      命令</p>
<p>M: 分钟（0-59）。每分钟用*或者 */1表示</p>
<p>H：小时（0-23）。（0表示0点）</p>
<p>D：天（1-31）。</p>
<p>m: 月（1-12）。</p>
<p>d: 一星期内的天（0~6，0为星期天）</p>
<p>开启定时任务</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">python manage.py crontab add</span><br></pre></td></tr></table></figure>
<p>显示已经激活的定时任务</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">python manage.py crontab show</span><br></pre></td></tr></table></figure>
<p>移除定时任务</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">python manage.py crontab remove</span><br></pre></td></tr></table></figure>

<h4 id="解决中文字符问题"><a href="#解决中文字符问题" class="headerlink" title="解决中文字符问题"></a>解决中文字符问题</h4><p>在定时任务中，如果出现非英文字符，会出现字符异常错误<br>在settings中配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 解决crontab中文问题</span><br><span class="line">CRONTAB_COMMAND_PREFIX = <span class="string">&#x27;LANG_ALL=zh_cn.UTF-8&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="脚本手动生成静态化页面"><a href="#脚本手动生成静态化页面" class="headerlink" title="脚本手动生成静态化页面"></a>脚本手动生成静态化页面</h3><p>为了开发方便，可以编写手动生成所有商品静态页面的脚本 在项目下新建包scripts，再创建regenerate_detail_html.py</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#指定执行此py文件的命令为python</span><br><span class="line">#/usr/bin/env表示在当前环境中查找python命令，当前为虚拟环境py3_django</span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">功能：手动生成所有SKU的静态detail html文件</span></span><br><span class="line"><span class="string">使用方法:</span></span><br><span class="line"><span class="string">    ./regenerate_detail_html.py</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">&#x27;../&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;meiduo_api.settings&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> django</span><br><span class="line"></span><br><span class="line">django.setup()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> goods.models <span class="keyword">import</span> SKU</span><br><span class="line"># 异步任务执行静态化</span><br><span class="line"><span class="keyword">from</span> celery_tasks.html.tasks <span class="keyword">import</span> generate_static_sku_detail_html</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    skus = SKU.objects.all()</span><br><span class="line">    <span class="keyword">for</span> sku <span class="keyword">in</span> skus:</span><br><span class="line">        print(sku.id)</span><br><span class="line">        generate_static_sku_detail_html(sku.id)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>项目管理</title>
    <url>/2024/04/14/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="进度管理"><a href="#进度管理" class="headerlink" title="进度管理"></a>进度管理</h3><p> 进度管理就是采用科学的方法，确定进度目标，编制进度计划和资源供应计划，进行进度控制，在与质量、成本目标协调的基础上，实现工期目标。</p>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>活动定义：需要开展的具体活动</p>
<p>活动排序：先后关系和逻辑关系</p>
<p>活动资源估算：需要的资源类型和效益</p>
<p>活动历时估算：需要的具体时间</p>
<p>进度计划编制：制订项目进度计划</p>
<p>进度控制：若发现偏差，则分析原因或进行调整</p>
<p>常用的图形方法有甘特图，项目计划评审技术（PERT）</p>
<h4 id="工具与技术"><a href="#工具与技术" class="headerlink" title="工具与技术"></a>工具与技术</h4><p>关键路径法：是项目的最短工期，但却是从开始到结束时间最长的路径。进度网络图中可能有多条关键路径，总浮动时间为0</p>
<p>关键活动:关键路径上的活动，最早开始时间=最晚开始时间</p>
<p>最早开始时间 (ES)：某项活动能够开始的最早时间.</p>
<p>最早结束时间(EF )：某项活动能够完成的最早时间。EF=ES+工期</p>
<p>最迟结束时间(LF)。为了使项目按时完成，某项活动必须完成的最迟时间</p>
<p>最迟开始时间 (LS) 。为了使项目按时完成，某项活动必须开始的最迟时间LS=LF-工期</p>
<p>浮动时间：最晚开始时间-最早开始时间</p>
<p>总浮动时间=最迟开始LS-最早开始ES或最迟完成LF-最早完成EF或关键路径- 非关键路径（包含某个活动的非关键路径）时长。</p>
<p>自由浮动时间=紧后活动最早开始时间的最小值-本活动的最早完成时间</p>
<p>最早开始时间ES。工期。最早完成时间EF</p>
<p>最晚开始LS。总浮动时间。最晚结束时间LF</p>
<p>顺推：最早开始ES=所有前置活动最早完成EF的最大值；最早完成EF=最早开始ES+持续时间。</p>
<p>逆推：最晚完成LF=所有后续活动最晩开始LS的最小值；最晚开始LS=最晩完成LF-持续时间。</p>
<h3 id="软件配置管理"><a href="#软件配置管理" class="headerlink" title="软件配置管理"></a>软件配置管理</h3><p>配置管理是为了系统地控制配置变更，在系统的整个生命周期中维持配置的 完整性和可跟踪性，从而标识系统在不同时间点上配置的学科。</p>
<p>配置管理包括6个主要活动：制订配置管理计划、配置标识、配置控制、配置 状态报告、配置审计、发布管理和交付</p>
<p>典型配置项包括项目计划书、需求文档、设计文档、源代码、可执行代码、测试用例、运行软件所需的各种数据，它们经评审和检查通过后进入配置管理</p>
<p>配置项版本管理：</p>
<p>草稿状态：0.YZ，YZ范围0-99</p>
<p>正式状态：X.Y,X的范围1-9，Y为次版本号X.Y</p>
<h3 id="质量与风险管理"><a href="#质量与风险管理" class="headerlink" title="质量与风险管理"></a>质量与风险管理</h3><p>质量是软件产品特性的综合，表示软件产品满足明确(基本需求)或隐含(期望需求)要求的能力。质量管理是指确定质量方针、目标和职责，并通过质量体系中的质量计划、质量控制、质量保证和质量改进来使其实现的所有管理职能的全部活动;</p>
<p>主要包括以下过程:</p>
<p>质量规划:识别项目及其产品的质量要求和标准，并书面描述项目将如何达到这些要求和标准的过程。</p>
<p>质量保证:一般是每隔一定时间 (例如，每个阶段未) 进行的，主要通过系统的质量审计 (软件评审) 和过程分析来保证项目的质量</p>
<p>质量控制: 实时监控项目的具体结果，以判断它们是否符合相关质量标全制订有效方案，以消除产生质量问题的原因</p>
<p>风险管理就是要对项目风险进行认真的分析和科学的管理</p>
<p>风险管理计划编制:如何安排与实施项目的风险管理，制定下列各步的计划.</p>
<p>风险识别: 识别出项目中已知和可预测的风险确定风险的来源、产生的条件、描述风险的特征以及哪些项目可以产生风险，形成一个风险列表。</p>
<p>风险定性分析:对已经识别的风险进行排序，确定风险可能性与影响、确定风险优先级、确定风险类型。</p>
<p>风险定量分析: 进一步了解风险发生的可能性具体由多大，后果具体由多严重。包括灵敏度分析期望货币价值分析、决策树分析、蒙特卡罗模拟。</p>
<p>风险应对计划编制: 对每一个识别出来的风险来分别制定应对措施，这些措施组成的文档称为风险应对计划。包括消极风险(避免策略、转移策略、减策略) ;积极风险(开拓、分享、强大)。</p>
<p>风险监控:监控风险计划的执行，检测残余风险，识别新的风险，保证风险并评价这些计划对减少风险的有效性计划的执行</p>
<p>风险可以分为项目风险、技术风险和商业风险</p>
<p>项目风险是指潜在的预算、进度、个人 (包括人员和组织)、资源、用户和需求方面的问题，以及它们对项目的影响。项目复杂性、规模和结构的不确定性也构成项目的(估算)风险因素。项目风险威胁到项目计划，一但项目风险成为现实，可能会拖延项目进度，增加项目的成本</p>
<p>技术风险是指潜在的设计、实现、接口、测试和维护方面的问题。此外，规格说明的多义性、技术上的不确定性、技术陈旧、最新技术 (不成熟)也是风险因素。技术风险威胁到待开发系统的质量和预定的交付时间。如果技术风险成为现实，开发工作可能会变得很困难或根本不可能</p>
<p>商业风险威胁到待开发系统的生存能力</p>
<p>市场风险。开发的系统虽然很优秀但不是市场真正所想要的。</p>
<p>策略风险。开发的系统不再符合企业的信息系统战略。</p>
<p>销售风险。开发了销售部门不清楚如何推销的系统。</p>
<p>管理风险。由于重点转移或人员变动而失去上级管理部门的支持.</p>
<p>预算风险。开发过程没有得到预算或人员的保证</p>
]]></content>
      <categories>
        <category>系统架构设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>错误页面</title>
    <url>//404.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>关于</title>
    <url>/about/index.html</url>
    <content><![CDATA[<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是一个在命运长河里挣扎的小鱼，90后，目前是小白一枚。<br>虽然心中不甘，但是目前确实是 <strong>Worst One</strong> 。<br>目标是成为全栈工程师、系统架构师。虽然前路迷茫，但是我会一步一步往前走。</p>
]]></content>
  </entry>
  <entry>
    <title>留言板</title>
    <url>/comment/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
