<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"zypuu.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="解析go语言，go的垃圾回收">
<meta property="og:type" content="article">
<meta property="og:title" content="GO的垃圾回收">
<meta property="og:url" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/index.html">
<meta property="og:site_name" content="All-Nothing">
<meta property="og:description" content="解析go语言，go的垃圾回收">
<meta property="og:locale">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/1.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/3.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/4.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/5.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/6.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/7.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/8.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/9.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/10.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/11.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/12.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/13.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/14.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/15.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/16.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/17.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/18.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/19.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/20.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/21.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/22.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/23.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/24.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/25.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/26.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/27.png">
<meta property="og:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/28.png">
<meta property="article:published_time" content="2021-01-12T10:07:22.000Z">
<meta property="article:modified_time" content="2024-06-03T09:11:29.927Z">
<meta property="article:author" content="ZYP">
<meta property="article:tag" content="垃圾回收">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/1.png">


<link rel="canonical" href="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","path":"2021/01/12/GO的垃圾回收/","title":"GO的垃圾回收"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>GO的垃圾回收 | All-Nothing</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="All-Nothing" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">All-Nothing</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Life has a funny way of working out, just when you start to believe it never will</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archive/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6GC"><span class="nav-number">1.</span> <span class="nav-text">垃圾回收GC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-number">1.2.</span> <span class="nav-text">GC性能指标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">1.2.1.</span> <span class="nav-text">吞吐量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4STW"><span class="nav-number">1.2.2.</span> <span class="nav-text">最大暂停时间STW</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%B1%80%E9%83%A8%E6%80%A7"><span class="nav-number">1.2.3.</span> <span class="nav-text">访问局部性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E4%BD%BF%E7%94%A8%E6%95%88%E7%8E%87"><span class="nav-number">1.2.4.</span> <span class="nav-text">堆使用效率</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87"><span class="nav-number">1.3.</span> <span class="nav-text">目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">GC常见算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">引用计数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%EF%BC%9A%E5%BB%B6%E8%BF%9F%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">2.1.1.</span> <span class="nav-text">改进：延迟引用计数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%BD%E8%B8%AA%E5%9B%9E%E6%94%B6%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">追踪回收式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.1.</span> <span class="nav-text">可达性分析算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4-Mark-Sweep"><span class="nav-number">2.2.2.</span> <span class="nav-text">标记-清除 Mark-Sweep</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6-Mark-Copy"><span class="nav-number">2.2.3.</span> <span class="nav-text">标记-复制 Mark-Copy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86-Mark-Compact"><span class="nav-number">2.2.4.</span> <span class="nav-text">标记-整理 Mark-Compact</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95"><span class="nav-number">2.2.5.</span> <span class="nav-text">三色标记法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E7%9A%84%E5%B9%B6%E5%8F%91%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">三色标记法的并发性问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="nav-number">2.2.5.2.</span> <span class="nav-text">问题原因及解决</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%B1%8F%E9%9A%9C%E6%8A%80%E6%9C%AF"><span class="nav-number">2.3.</span> <span class="nav-text">读写屏障技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dijkstra%E6%8F%92%E5%85%A5%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="nav-number">2.3.1.</span> <span class="nav-text">Dijkstra插入写屏障</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Yuasa%E5%88%A0%E9%99%A4%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="nav-number">2.3.2.</span> <span class="nav-text">Yuasa删除写屏障</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="nav-number">2.3.3.</span> <span class="nav-text">混合写屏障</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">使用混合写屏障的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">分代收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86%EF%BC%9A%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%8C%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">2.4.1.</span> <span class="nav-text">区域划分：新生代，老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E4%B8%8E%E6%B5%81%E7%A8%8B"><span class="nav-number">2.4.2.</span> <span class="nav-text">分配策略与流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E5%92%8C%E5%B9%B6%E5%8F%91%E5%BC%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">2.5.</span> <span class="nav-text">增量和并发式垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E5%BC%8F"><span class="nav-number">2.5.1.</span> <span class="nav-text">增量式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%BC%8F"><span class="nav-number">2.5.2.</span> <span class="nav-text">并发式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GO%E7%9A%84GC"><span class="nav-number">3.</span> <span class="nav-text">GO的GC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="nav-number">3.1.</span> <span class="nav-text">发展史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E6%89%AB%E6%8F%8F%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.2.</span> <span class="nav-text">GC扫描对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5"><span class="nav-number">3.2.1.</span> <span class="nav-text">编译阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#GO%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">GO的结构体对齐规则</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%95%BF%E5%BA%A6%E5%AF%B9%E9%BD%90"><span class="nav-number">3.2.1.1.1.</span> <span class="nav-text">长度对齐</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%AF%B9%E9%BD%90"><span class="nav-number">3.2.1.1.2.</span> <span class="nav-text">地址对齐</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%BD%8D%E6%A0%87%E8%AE%B0"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">指针位标记</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E9%98%B6%E6%AE%B5"><span class="nav-number">3.2.2.</span> <span class="nav-text">运行阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%AB%E6%8F%8F%E9%98%B6%E6%AE%B5"><span class="nav-number">3.2.3.</span> <span class="nav-text">扫描阶段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.</span> <span class="nav-text">GC实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="nav-number">3.3.1.</span> <span class="nav-text">四个阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E7%BB%88%E6%AD%A2Sweep-Termination"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">清除终止Sweep Termination</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0Mark"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">标记Mark</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E7%BB%88%E6%AD%A2Mark-Termination"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">标记终止Mark Termination</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B8%85%E9%99%A4Sweep"><span class="nav-number">3.3.1.4.</span> <span class="nav-text">清除Sweep</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9GC"><span class="nav-number">3.3.2.</span> <span class="nav-text">辅助GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="nav-number">3.3.3.</span> <span class="nav-text">GC触发时机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E8%B0%83%E4%BC%98"><span class="nav-number">3.4.</span> <span class="nav-text">GC调优</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZYP"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ZYP</p>
  <div class="site-description" itemprop="description">Give it a try, whispered the HEART</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archive/">
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zypuu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zypuu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:375133421@qq.com" title="E-Mail → mailto:375133421@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://zypuu.github.io/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZYP">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="All-Nothing">
      <meta itemprop="description" content="Give it a try, whispered the HEART">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="GO的垃圾回收 | All-Nothing">
      <meta itemprop="description" content="解析go语言，go的垃圾回收">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          GO的垃圾回收
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-12 18:07:22" itemprop="dateCreated datePublished" datetime="2021-01-12T18:07:22+08:00">2021-01-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-06-03 17:11:29" itemprop="dateModified" datetime="2024-06-03T17:11:29+08:00">2024-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/GO/" itemprop="url" rel="index"><span itemprop="name">GO</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>9 mins.</span>
    </span>
</div>

            <div class="post-description">解析go语言，go的垃圾回收</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="垃圾回收GC"><a href="#垃圾回收GC" class="headerlink" title="垃圾回收GC"></a>垃圾回收GC</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>程序创建对象等引用类型实体时会在虚拟内存中分配给它们一块内存空间，如果该内存空间不再被任何引用变量引用时就成为需要被回收的垃圾</p>
<p>对于一个运行较长时间的程序，如果使用完内存资源后没有及时释放就会造成内存泄漏甚至系统错误</p>
<p>如果我们在不该释放内存的时候释放内存，那么仍然在使用这块内存的指针就会变成野指针wild pointer，使用该指针对内存进行读写是未定义的行为</p>
<h3 id="GC性能指标"><a href="#GC性能指标" class="headerlink" title="GC性能指标"></a>GC性能指标</h3><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>是指单位时间内是有多少时间是用来运行用户代码的。GC占用的时间过多，就会导致吞吐量较低</p>
<h4 id="最大暂停时间STW"><a href="#最大暂停时间STW" class="headerlink" title="最大暂停时间STW"></a>最大暂停时间STW</h4><p>STW stop the world 暂停所有赋值线程</p>
<p>基本上所有的垃圾回收算法，都会在执行GC的过程中，暂停用户代码。如果暂停时间过长，必然会影响用户体验，尤其是那些交互性较强的应用</p>
<h4 id="访问局部性"><a href="#访问局部性" class="headerlink" title="访问局部性"></a>访问局部性</h4><p>具有引用关系的对象之间很可能存在连续访问的情况。因此，把具有引用关系的对象安排在堆中较劲的位置，可以充分利用内存访问局部性。有的GC算法会根据引用关系重排对象，比如复制算法。</p>
<h4 id="堆使用效率"><a href="#堆使用效率" class="headerlink" title="堆使用效率"></a>堆使用效率</h4><p>影响堆使用效率的主要有两个因素，一个是对象头部大小，一个是堆的用法。</p>
<p>1.一般来说，堆的头部越大，存储的信息越多，那么GC的效率就会越高，吞吐量什么的也会有更佳的表现。但是，我们必须明白，对象头越小越好</p>
<p>2.不同的算法对于堆的不同用法，也会导致堆使用效率差距非常大。比如复制算法，用户应用只能使用一般的堆大小</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>1.无内存泄漏：垃圾回收器最基本的目标就是减少防止程序员未及时释放导致的内存泄漏，垃圾回收器会识别并清理内存中的垃圾</p>
<p>2.自动回收无用内存：垃圾回收器作为独立的子任务，不需要程序员显式调用即可自动清理内存垃圾</p>
<p>3.内存整理：如果只是简单回收无用内存，那么堆上的内存空间会存在较多碎片而无法满足分配较大对象的需求，因此垃圾回收器需要重整内存空间，提高内存利用率</p>
<h2 id="GC常见算法"><a href="#GC常见算法" class="headerlink" title="GC常见算法"></a>GC常见算法</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数Reference counting<br>会为每个对象维护一个计数器，当该对象被其他对象引用时加一，引用失效时减一，当引用次数归零后即可回收对象</p>
<p>python就是引用计数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct_object &#123;</span><br><span class="line">    int ob_refcnt;</span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125;PyObject;</span><br></pre></td></tr></table></figure>

<p>ob_refcnt为引用计数器</p>
<p>优点：<br>1.原理和实现都比较简单</p>
<p>2.回收的即时性：当对象的引用计数为0时立即回收，不像其他GC机制需要等待特定时机再回收，提高了内存的利用率</p>
<p>3.不需要暂停应用即可完成回收</p>
<p>缺点：</p>
<p>1.无法解决循环引用的回收问题：当ObjA引用了ObjB，ObjB也引用ObjA时，这两个对象的引用次数使用大于0，从而占用的内存无法被回收</p>
<p>2.时间和空间成本较高：一方面是因为每个对象需要额外的空间存储引用计数器变量，另一方面是在栈上的赋值时修改引用次数时间成本较高（原本只需要修改寄存器中的值，现在计数器需要不断更新因此不是只读的，需要额外的原子操作来保证线程安全</p>
<p>3.引用计数是一种摊销算法，会将内存的回收分摊到整个程序的运行过程，但是当销毁一个很大的树形结构时无法保证响应时间</p>
<h4 id="改进：延迟引用计数"><a href="#改进：延迟引用计数" class="headerlink" title="改进：延迟引用计数"></a>改进：延迟引用计数</h4><p>在延迟引用计数法中使用ZCT（Zero Count Table）。ZCT 是一个表，它会事先<br>记录下计数器值在dec_ref_cnt() 函数的作用下变为0 的对象， 因为计数器值为0 的对象不一定都是垃圾，所以暂时先将这些对象保留</p>
<p>在延迟引用计数法中，程序延迟了根引用的计数，将垃圾一并回收。通过延迟，减轻了<br>因根引用频繁发生变化而导致的计数器增减所带来的额外负担。当然也失去量垃圾即可回收的特点</p>
<h3 id="追踪回收式"><a href="#追踪回收式" class="headerlink" title="追踪回收式"></a>追踪回收式</h3><p>判断哪些对象存活，然后将其余的所有对象作为垃圾进行回收。追踪回收本身包括<br>标记-清除 Mark-Sweep<br>标记-复制 Mark-Copy<br>标记-整理 Mark-Compact<br>三种回收算法</p>
<p>同引用计数法相比<br>优点：</p>
<p>1.解决了循环引用对象的回收问题</p>
<p>2.占用空间更少</p>
<p>缺点：</p>
<p>1.同引用计数相比无法立刻识别出垃圾对象，需要依赖GC线程</p>
<p>2.算法在标记时必须暂停整个程序，即Stop The World, STW，否则其他线程的代码会修改对象状态从而回收不该回收的对象</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>上面说的三种算法都是通过可达性分析算法，先进行可达性标记，标记对象是否可达</p>
<p>GC ROOT： 当前时刻存活的对象<br>GC会收集那些不是GC Roots且没有被GC Roots引用的对象<br>包括：</p>
<p>1.全局对象、栈上的对象（函数参数与内部变量）</p>
<p>2.与上面对象通过引用链相连的对象</p>
<p>对于“不可达”的对象，我们可以认为该对象为垃圾对象并回收对应的内存空间</p>
<p><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/1.png" alt="1"></p>
<h4 id="标记-清除-Mark-Sweep"><a href="#标记-清除-Mark-Sweep" class="headerlink" title="标记-清除 Mark-Sweep"></a>标记-清除 Mark-Sweep</h4><p>标记：记录需要回收的垃圾对象</p>
<p>清除：在标记完成后回收垃圾对象的内存空间</p>
<p><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2.png" alt="2"></p>
<p>优点：</p>
<p>1.算法吞吐量高：用户代码时间/总时间高</p>
<p>2.空间利用率：同标记-复制相比不需要额外空间复制对象，也不需要像引用计数算法为每个对象设置引用计数器</p>
<p>缺点：</p>
<p>1.清除后会产生大量的内存碎片空间，导致程序在运行时可能没法为较大的对象分配内存空间，导致提前GC</p>
<h4 id="标记-复制-Mark-Copy"><a href="#标记-复制-Mark-Copy" class="headerlink" title="标记-复制 Mark-Copy"></a>标记-复制 Mark-Copy</h4><p>将内存分成大小相同的两块，当某一块的内存使用完了之后就将使用中的对象挨个复制到另一块内存中，最后将当前内存恢复未使用的状态</p>
<p><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/3.png" alt="3"></p>
<p>优点：</p>
<p>1.标记-清除法需要在清除阶段对大量垃圾对象进行扫描，标记-复制则只需要从GC Root对象出发，将“可到达”的对象复制到另一块内存后直接清理当前这块的内存，因此提升了垃圾回收的效率</p>
<p>PS：清除，是扫描所有垃圾，标记垃圾，回收，复制是只扫描GC ROOT对象</p>
<p>2.解决了内存碎片化的问题，防止分配较大连续空间时的提前GC问题</p>
<p>缺点：</p>
<p>1.同标记-清除法相比，在“可达”对象占比较高的情况下有复制对象的开销</p>
<p>2.内存利用率较低，相当于可利用的内存仅有一半</p>
<h4 id="标记-整理-Mark-Compact"><a href="#标记-整理-Mark-Compact" class="headerlink" title="标记-整理 Mark-Compact"></a>标记-整理 Mark-Compact</h4><p>标记出所有“可达”的对象，然后将存活的对象移动到内存空间的一端，最后清理掉端边界以外的内存</p>
<p><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/4.png" alt="4"></p>
<p>优点：</p>
<p>1.避免了内存碎片化的问题</p>
<p>2.在对象存活率较高的情况下，标记-整理算法由于不需要复制对象效率更高，因此更加适合老年代算法</p>
<p>缺点：</p>
<p>1.整理过程较为复杂，需要多次遍历内存导致STW时间比标记-清除算法更长</p>
<h4 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h4><p>三色标记法是对“标记”阶段的改进，在不暂停程序的情况下即可完成对象的可达性分析。GC线程将所有对象分为三类</p>
<p>1.白色：未搜索对象，回收周期开始时，所有对象都是白色，回收周期结束后，所有白色都是垃圾对象</p>
<p>2.灰色：正在搜索的对象，对象身上还有一个或多个引用没有扫描</p>
<p>3.黑色：已搜索完的对象，所有引用已被扫描完</p>
<p>属于增量式GC算法，回收器将所有对象着白色，从GC ROOT出发，逐步把所有可达对象变成灰色再到黑色</p>
<p>最终所有的白色对象即是不可达对象</p>
<p>流程：</p>
<p>1.所有对象都是白色对象</p>
<p>2.从GC Root对象出发，扫描所有可达对象并标记为灰色，放入待处理队列</p>
<p>3.从队列取出一个灰色对象并标记为黑色，将其引用对象标记为灰色放入队列</p>
<p>4.重复上一步骤，直到灰色对象队列为空</p>
<p>5.此时所有剩下的白色对象就是垃圾对象</p>
<p>优点：</p>
<p>1.不需要暂停整个程序进行GC</p>
<p>缺点：</p>
<p>1.如果程序垃圾对象的产生速度大于垃圾对象的回收速度时，可能导致程序中的垃圾对象越来越多而无法及时收集</p>
<p>2.线程切换和上下文转换的消耗会使得垃圾回收的总体成本上升，从而降低系统吞吐量</p>
<h5 id="三色标记法的并发性问题"><a href="#三色标记法的并发性问题" class="headerlink" title="三色标记法的并发性问题"></a>三色标记法的并发性问题</h5><p><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/5.png" alt="5"></p>
<p>如图所示，三色标记法GC与用户程序同时并发执行，用户在标记执行过程中建立了从A对象到D对象的引用，A为黑色，D不会再被扫描为白色，会被错误回收，导致后续对D的访问出错。这种没有指向合法地址的指针一般被称为“野指针”，会造成严重的程序错误</p>
<h5 id="问题原因及解决"><a href="#问题原因及解决" class="headerlink" title="问题原因及解决"></a>问题原因及解决</h5><p>三色标记法和用户程序并发执行，那么下列两个条件同时满足就可能出现错误回收非垃圾对象的问题：</p>
<p>1.某一黑色对象引用白色对象</p>
<p>2.对于某个白色对象，所有和它存在可达关系的灰色对象丢失了访问它的可达路径</p>
<p>最简单解决三色标记并发问题的方法是停止所有的赋值器线程，保证标记过程不受干扰，即垃圾回收器中常提到的STW, stop the world方法。另外一种思路就是使用赋值器屏障技术使得赋值器在进行指针写操作时同步垃圾回收器</p>
<h3 id="读写屏障技术"><a href="#读写屏障技术" class="headerlink" title="读写屏障技术"></a>读写屏障技术</h3><p>使用屏障技术可以使得用户程序和三色标记过程并发执行，我们只需要达成下列任意一种三色不变性：</p>
<p>1.强三色不变性：黑色对象永远不会指向白色对象</p>
<p>2.弱三色不变性：黑色对象指向的白色对象至少包含一条由灰色对象经过白色对象的可达路径</p>
<p>GC中使用的内存读写屏障技术指的是编译器会在编译期间生成一段代码，该代码在运行期间用户读取、创建或更新对象指针时会拦截内存读写操作，相当于一个hook调用，</p>
<p>根据hook时机不同可分为不同的屏障技术。</p>
<p>由于读屏障Read barrier技术需要在读操作中插入代码片段从而影响用户程序性能，所以一般使用写屏障技术来保证三色标记的稳健性</p>
<p>内存屏障技术解决了三色标记法的STW缺点，并不是指消除了所有的赋值器挂起问题。</p>
<p>需要分清楚STW方法是全局性的赋值器挂起而内存屏障技术是局部的赋值器挂起</p>
<h4 id="Dijkstra插入写屏障"><a href="#Dijkstra插入写屏障" class="headerlink" title="Dijkstra插入写屏障"></a>Dijkstra插入写屏障</h4><p>Dijkstra插入写屏障避免了前面提到的条件1，即防止黑色对象指向白色对象</p>
<p>一个对象可以存储在内存中的“栈”或者“堆”，由于“栈”空间容量小且要求相应速度较高，因此“插入写屏障”不适合用于“栈”空间</p>
<p>流程：<br>1.垃圾回收之前将所有的对象标记为白色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/6.png" alt="6"></p>
<p>2.遍历GC Root Set，将可达对象标记为灰色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/7.png" alt="7"></p>
<p>3.遍历灰色对象列表，将可达的对象从白色标记为灰色；将遍历完的灰色对象标记为黑色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/8.png" alt="8"></p>
<p>4.在三色标记过程中用户程序令栈区对象A指向对象H，令堆区对象E指向对象I，由于对象E在堆区从而触发插入写屏障并将黑色对象E指向的白色对象I标记为灰色，栈区对象A不触发<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/9.png" alt="9"></p>
<p>5.继续三色标记直至灰色对象队列为空<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/10.png" alt="10"></p>
<p>6.垃圾回收之前将所有的对象标记为白色由于栈区对象没有启动插入写屏障，因此栈上可能存在白色对象被引用的情况（上图中对应对象H），因此在回收白色对象前在STW保护下重新扫描一次栈空间<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/11.png" alt="11"></p>
<p>7.在STW保护下对栈空间一次性进行三色标记，直到灰色对象队列为空<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/12.png" alt="12"></p>
<p>8.结束STW<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/13.png" alt="13"></p>
<p>9.最后将栈空间和堆空间的白色垃圾对象进行回收<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/14.png" alt="14"></p>
<p>缺点：</p>
<p>1.一方面它是一种比较保守的垃圾回收方法，把有可能存活的对象都标记成灰色了以满足“强三色不变性”，在修改用户修改引用的时候，会被修改后的本该回收的标记为灰色从而漏掉回收</p>
<p>2.在于栈上的对象也是根对象，Dijkstra插入写屏障要么在用户程序执行内存写操作时为栈上对象插入写屏障，要么在一轮三色标记完成后使用STW重新对栈上的对象进行三色标记。前者会降低栈空间的响应速度，后者会暂停用户程序</p>
<h4 id="Yuasa删除写屏障"><a href="#Yuasa删除写屏障" class="headerlink" title="Yuasa删除写屏障"></a>Yuasa删除写屏障</h4><p>Yuasa删除写屏障避免了前面提到的条件2，防止丢失灰色对象到白色对象的可达路径</p>
<p>流程：<br>1.将所有对象标记为白色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/15.png" alt="15"></p>
<p>2.遍历GC Root Set将可达对象设为灰色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/16.png" alt="16"></p>
<p>3.如果用户程序令灰色对象A删除了对白色对象D的引用，如果这时候不触发删除写屏障，那么对象D、B和C直到本轮垃圾回收结束都会是白色对象。因此需要触发删除写屏障，将对象D标记为灰色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/17.png" alt="17"></p>
<p>4.遍历灰色对象队列，将可达的白色对象标记为灰色，遍历完的灰色对象标记为黑色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/18.png" alt="18"></p>
<p>5.继续进行三色标记，直到灰色对象队列为空<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/19.png" alt="19"></p>
<p>6.清除所有的白色对象<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/20.png" alt="20"></p>
<p>优点：</p>
<p>1.不需要在一轮三色标记后对栈空间上的对象进行重新扫描</p>
<p>缺点：</p>
<p>1.Collector会悲观地认为所有被删除的对象都可能被黑色对象引用<br>比如上图中，删除了A到D的指针，D根据删除屏障，会被标记为灰色，如果此时还有一个单独的对象H指向D，那么本该被删除的对象H却可以在本轮垃圾回收中存活</p>
<h4 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h4><h5 id="使用混合写屏障的原因"><a href="#使用混合写屏障的原因" class="headerlink" title="使用混合写屏障的原因"></a>使用混合写屏障的原因</h5><p>go1.8引入混合写屏障</p>
<p>由于GC Root对象包括了栈对象，如果运行时在所有GC Root对象上开启插入写屏障意味着需要在数量庞大的Goroutine的栈上都开启Dijkstra写屏障从而严重影响用户程序的性能</p>
<p>之前的做法是是Mark阶段（golang垃圾回收使用的是标记-清除法）结束后暂停整个程序，对栈上对象重新进行三色标记法</p>
<p>PS：如果Goroutine较多的话，对栈对象re-scan这一步需要耗费10 ~ 100 ms </p>
<p>以上两种屏障的劣势：</p>
<p>Dijkstra插入写屏障：一轮标记结束后需要STW重新扫描栈上对象</p>
<p>Yuasa删除写屏障：回收精度低</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>混合写屏障也是仅在堆空间启动的，防止降低栈空间的运行效率</p>
<p>1.GC开始时将栈上所有对象标记为黑色，无须STW</p>
<p>2.GC期间在栈上创建的新对象均标记为黑色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/21.png" alt="21"></p>
<p>3.将被删除的下游对象标记为灰色</p>
<p>4.将被添加的下游对象标记为灰色</p>
<p>场景一：某个对象从堆对象的下游变成栈对象的下游，这种情况下标记该对象为灰色，该对象就不会被错误地回收<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/22.png" alt="22"></p>
<p>场景二：某个对象从一个栈对象的下游变成另一个对象的下游，由于对象全都在栈空间对象的可达对象中，因此混合写屏障不会对这些对象着色。<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/23.png" alt="23"></p>
<p>场景三：某个对象从一个堆对象的下游变成另一个堆对象的下游，比如下图中对象G从F的下游移动到Y的下游，为了避免对象G被错误回收，我们需要将其标记为灰色<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/24.png" alt="24"></p>
<p>场景四：某个对象从栈对象的下游变成堆对象的下游，对于栈空间对象不触发写屏障，但是对于被删除的堆空间对象G需要标记成灰色以保护它和它的下游对象不被错误删除<br><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/25.png" alt="25"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>追踪式回收有一个问题是会频繁扫描生命周期较长的对象，大部分生命周期都很短，因此有必要将对象按照生命周期的长度划分到堆heap上的两个甚至多个区域。对于新生代区域的扫描频率应该高于老年代区域</p>
<h4 id="区域划分：新生代，老年代"><a href="#区域划分：新生代，老年代" class="headerlink" title="区域划分：新生代，老年代"></a>区域划分：新生代，老年代</h4><p>1.新生代，老年代分为young，old区域<br>2.新生代中的对象生命周期较短（每次回收约98%的对象是垃圾对象）<br>3.新生代采用标记-复制法需要两块内存交替使用<br>4.Young区为了节省复制算法的内存代价又划分成Eden、Survivor0和Survivor1三个分区（内存分配比例为8:1:1）。</p>
<p><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/26.png" alt="26"></p>
<p>新生代回收：Minor GC<br>老年代回收：Major GC</p>
<h4 id="分配策略与流程"><a href="#分配策略与流程" class="headerlink" title="分配策略与流程"></a>分配策略与流程</h4><p>1.对象优先在Yonug上的Eden区域分配（大对象直接进入Old区）</p>
<p>2.Eden区满了之后开始进行Minor GC，将Eden中存活的对象移动到Survivor0区，直接清空Eden区</p>
<p>3.Eden区第二次满了之后进行Minor GC，将Eden和Survivor0中存活的对象复制到Survivor1区，清空Eden和Survivor0区</p>
<p>4.若干轮Minor GC过后，此时新生代中生命周期较长的对象熬过了一定次数的Minor GC晋升成老年代移动到Old区，某轮Minor GC存活率较高Survivor区空间不足时也会将存活对象放到Old区</p>
<p>5.当Old区满了之后进行Major GC</p>
<h3 id="增量和并发式垃圾回收"><a href="#增量和并发式垃圾回收" class="headerlink" title="增量和并发式垃圾回收"></a>增量和并发式垃圾回收</h3><p>传统的垃圾回收算法都有STW的弊端，即需要在执行垃圾回收过程中需要抢占CPU，这会暂停所有的用户程序</p>
<p>1.通常GC任务都比较繁重，长时间暂停用户程序会影响程序的响应速度，这对于实时性要求较高的程序是致命的缺点<br>2.对于多核计算机而言，抢占CPU进行垃圾回收会造成计算资源浪费</p>
<p>增量式垃圾回收和并发式垃圾回收都是基于三色标记法和读写屏障技术的</p>
<h4 id="增量式"><a href="#增量式" class="headerlink" title="增量式"></a>增量式</h4><p><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/27.png" alt="27"></p>
<p>增量式垃圾回收过程图如上所示，同STW垃圾回收过程相比：</p>
<p>优点：</p>
<p>1.将垃圾回收时间分摊开，避免了程序的长时间暂停，防止影响程序的实时性<br>缺点：</p>
<p>1.一方面引入了内存写屏障技术，需要额外的计算开销；另一方面由于写屏障技术的保守性导致有一些垃圾对象没有被回收，会增加一轮垃圾回收的总时长</p>
<h4 id="并发式"><a href="#并发式" class="headerlink" title="并发式"></a>并发式</h4><p><img src="/2021/01/12/GO%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/28.png" alt="28"></p>
<p>同时执行</p>
<p>在一定程序上利用了多核计算机的优势并减少了对用户程序的干扰，不过依然无法摆脱读写屏障的额外计算开销和增加一轮垃圾回收总时长的问题</p>
<h2 id="GO的GC"><a href="#GO的GC" class="headerlink" title="GO的GC"></a>GO的GC</h2><h3 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h3><p>go v1.1：标记-清除法，整个过程都需要STW</p>
<p>go v1.3：标记-清除法，标记过程仍然需要STW但清除过程并行化，gc pause约几百ms</p>
<p>go v1.5：引入插入写屏障技术的三色标记法，仅在堆空间启动插入写屏障，全部扫描后需要STW重新扫描栈空间，gc pause耗时降到10ms以下</p>
<p>go v1.8：引入混合写屏障技术的三色标记法，仅在堆空间启动混合写屏障，不需要在GC结束后对栈空间重新扫描，gc pause时间降低至0.5ms以下</p>
<p>go v1.14：引入新的页分配器用于优化内存分配的速度</p>
<p>PS：gc pause时间的缩短也就意味着程序的响应速度更快</p>
<h3 id="GC扫描对象"><a href="#GC扫描对象" class="headerlink" title="GC扫描对象"></a>GC扫描对象</h3><h4 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h4><p>对静态类型做好标记准备</p>
<h5 id="GO的结构体对齐规则"><a href="#GO的结构体对齐规则" class="headerlink" title="GO的结构体对齐规则"></a>GO的结构体对齐规则</h5><h6 id="长度对齐"><a href="#长度对齐" class="headerlink" title="长度对齐"></a>长度对齐</h6><p>结构体的长度至少是内部最长的基础字段的整数倍</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   type TestStruct struct &#123;</span><br><span class="line">  ptr   uintptr  <span class="comment">// 8字节</span></span><br><span class="line">  int1  uint32   <span class="comment">// 4字节</span></span><br><span class="line">  int2  uint8    <span class="comment">// 1字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体内存占用为16个字节</p>
<h6 id="地址对齐"><a href="#地址对齐" class="headerlink" title="地址对齐"></a>地址对齐</h6><p>字段的地址偏移是自身长度的整数倍</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 假设new一个TestStruct结构体的地址是x, 则各字段的地址如下</span></span><br><span class="line"><span class="comment">// ptr: a + 0</span></span><br><span class="line"><span class="comment">// int1: a + 8</span></span><br><span class="line"><span class="comment">// int2: a + 8 + 4</span></span><br><span class="line">type TestStruct struct &#123;</span><br><span class="line">  ptr   uintptr  <span class="comment">// 8字节</span></span><br><span class="line">  int1  uint8    <span class="comment">// 1字节</span></span><br><span class="line">  int2  uint32   <span class="comment">// 4字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>int1和int2之间填充了一些没使用到的内存空间，进而实现了地址对齐</p>
<h5 id="指针位标记"><a href="#指针位标记" class="headerlink" title="指针位标记"></a>指针位标记</h5><p>GO的所有类型都对应一个_type结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type TestStruct struct &#123;</span><br><span class="line">  ptr   uintptr  <span class="comment">// 8</span></span><br><span class="line">  int1  uint8    <span class="comment">// 1</span></span><br><span class="line">  pint1 *uint8</span><br><span class="line">  int2  uint32   <span class="comment">// 4</span></span><br><span class="line">  pint2 *uint64</span><br><span class="line">  int3  uint64   <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如上面这个结构体：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Needs to be in sync with ../cmd/link/internal/ld/decodesym.go:/^func.commonsize,</span></span><br><span class="line"><span class="comment">// ../cmd/compile/internal/gc/reflect.go:/^func.dcommontype and</span></span><br><span class="line"><span class="comment">// ../reflect/type.go:/^type.rtype.</span></span><br><span class="line">type _type struct &#123;</span><br><span class="line">    size       uintptr  <span class="comment">// 类型长度，上面这个结构体的长度48个字节</span></span><br><span class="line">    ptrdata    uintptr <span class="comment">// 指针截止的长度位置，由于最后一个指针是pint2，因此包含指针的字段截止到40字节的位置</span></span><br><span class="line">    hash       uint32</span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      uint8</span><br><span class="line">    fieldalign uint8</span><br><span class="line">    kind       uint8  <span class="comment">// 类型，自定义struct类型的kind为25</span></span><br><span class="line">    alg        *typeAlg</span><br><span class="line">    <span class="comment">// gcdata stores the GC type data for the garbage collector.</span></span><br><span class="line">    <span class="comment">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span></span><br><span class="line">    <span class="comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></span><br><span class="line">    gcdata    *byte <span class="comment">// byte数组（*byte类型），表示指针的bitmap。比如当gcdata等于20（二进制00010100，从低位到高位就是00101000，其中每个bit表示一个指针大小（8字节）的内存，第3个bit和第5个bit为1表示第三个和第五个字段是指针类型）</span></span><br><span class="line">    str       nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h4><p>golang在运行分配完内存后会调用函数heapBitsSetType，主要逻辑是根据编译期间对每个struct生成的type结构，用一个bitmap记录下来分配的内存块中哪些位置是指针</p>
<h4 id="扫描阶段"><a href="#扫描阶段" class="headerlink" title="扫描阶段"></a>扫描阶段</h4><p>1.扫描阶段从markroot开始，以栈对象、全局变量和寄存器对象作为gc root，创建一个有向引用图并将根对象添加到队列中<br>2.新起一个异步goroutine执行gcDrain函数，从队列里消费并扫描对象</p>
<h3 id="GC实现"><a href="#GC实现" class="headerlink" title="GC实现"></a>GC实现</h3><p>基于三色标记法实现的垃圾回收机制，从而将长时间的STW分隔成多段较短时间的STW的并发式回收</p>
<p>1.GC开始前将所有对象标记为白色</p>
<p>2.将GC Root对象（golang中是栈对象和全局变量的指针）加入灰色对象队列</p>
<p>3.使用并发的goroutine扫描队列中的指针，如果指针还引用了其他指针，那么将被引用的加入灰色对象队列，被扫描的对象标记为黑色</p>
<h4 id="四个阶段"><a href="#四个阶段" class="headerlink" title="四个阶段"></a>四个阶段</h4><h5 id="清除终止Sweep-Termination"><a href="#清除终止Sweep-Termination" class="headerlink" title="清除终止Sweep Termination"></a>清除终止Sweep Termination</h5><p>1.暂停程序</p>
<p>2.清扫未被回收的内存管理单元span，当上一轮GC的清扫工作完成后才可以开始新一轮的GC</p>
<h5 id="标记Mark"><a href="#标记Mark" class="headerlink" title="标记Mark"></a>标记Mark</h5><p>1.切换至_GCmark，开启写屏障和用户程序协助Mutator Assiste并将根对象添加到三色标记法队列</p>
<p>2.恢复程序，标记进程和Mutator Assiste进程会开始并发标记内存中的对象，<br>混合写屏障将被删除的指针和新加入的指针都标记成灰色，新创建的对象标记成黑色</p>
<p>3.扫描根对象（包括所有goroutine的栈、全局对象以及不在堆中的运行时数据结构），扫描goroutine栈期间会暂停当前处理器<br>依次处理三色标记法队列，将扫描过的对象标记为黑色并将它们指向的对象标记成灰色</p>
<p>4.使用分布式终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段</p>
<h5 id="标记终止Mark-Termination"><a href="#标记终止Mark-Termination" class="headerlink" title="标记终止Mark Termination"></a>标记终止Mark Termination</h5><p>1.暂停程序，切换至_GCmarktermination并关闭辅助标记的用户程序</p>
<p>2.清理处理器上的线程缓存</p>
<h5 id="清除Sweep"><a href="#清除Sweep" class="headerlink" title="清除Sweep"></a>清除Sweep</h5><p>1.将状态切换至_GCoff，关闭混合写屏障</p>
<p>2.恢复用户程序，所有新创建的对象标记为白色</p>
<p>3.后台并发清理所有的内存管理单元span，当goroutine申请新的内存管理单元时就会触发清理</p>
<p>PS:在GC过程中会有两种后台任务，包括标记任务和清扫任务。可以同时执行的标记任务约是P数量的四分之一，即go所说的25%CPU用于GC的依据。清扫任务会在程序启动后运行，进入清扫阶段时唤醒</p>
<h4 id="辅助GC"><a href="#辅助GC" class="headerlink" title="辅助GC"></a>辅助GC</h4><p>由于Golang使用了并发式的垃圾回收，将原本需要STW较长时间的GC过程分散到多次小规模的GC</p>
<p>当用户分配内存的速度超过GC回收速度时，Golang会通过辅助GC暂停用户程序进行垃圾回收，防止内存因分配对象速度过快消耗殆尽的问题</p>
<h4 id="GC触发时机"><a href="#GC触发时机" class="headerlink" title="GC触发时机"></a>GC触发时机</h4><p>三个前提条件：</p>
<p>1.允许垃圾回收</p>
<p>2.没有panic</p>
<p>3.处于Gcoff阶段</p>
<p>触发机制：</p>
<p>1.gcTriggerHeap：堆内存大小达到阈值</p>
<p>2.gcTriggerTime：距离上一次垃圾回收超过一定阈值时</p>
<p>3.gcTriggerCycle：如果当前没有启动GC则开始新一轮的GC</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test reports whether the trigger condition is satisfied, meaning</span></span><br><span class="line"><span class="comment">// that the exit condition for the _GCoff phase has been met. The exit</span></span><br><span class="line"><span class="comment">// condition should be tested when allocating.</span></span><br><span class="line">func (t gcTrigger) test() bool &#123;</span><br><span class="line">	<span class="comment">// 前提条件</span></span><br><span class="line">    <span class="keyword">if</span> !memstats.enablegc || panicking != <span class="number">0</span> || gcphase != _GCoff &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发机制</span></span><br><span class="line">    <span class="keyword">switch</span> t.kind &#123;</span><br><span class="line">    <span class="keyword">case</span> gcTriggerHeap:</span><br><span class="line">        <span class="comment">// Non-atomic access to heap_live for performance. If</span></span><br><span class="line">        <span class="comment">// we are going to trigger on this, this thread just</span></span><br><span class="line">        <span class="comment">// atomically wrote heap_live anyway and we&#x27;ll see our</span></span><br><span class="line">        <span class="comment">// own write.</span></span><br><span class="line">        <span class="keyword">return</span> memstats.heap_live &gt;= memstats.gc_trigger</span><br><span class="line">    <span class="keyword">case</span> gcTriggerTime:</span><br><span class="line">        <span class="keyword">if</span> gcpercent &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        lastgc := int64(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line">        <span class="keyword">return</span> lastgc != <span class="number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class="line">    <span class="keyword">case</span> gcTriggerCycle:</span><br><span class="line">        <span class="comment">// t.n &gt; work.cycles, but accounting for wraparound.</span></span><br><span class="line">        <span class="keyword">return</span> int32(t.n-work.cycles) &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h3><p>1.尽量使用小数据类型，比如使用int8代替int</p>
<p>2.少使用+连接string：go语言中string是一个只读类型，针对string的每一个操作都会创建一个新的string。大量小文本拼接时优先使用strings.Join，大量大文本拼接时使用bytes.Buffer</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="tag"># 垃圾回收</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/01/08/GO%E7%9A%84%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/" rel="prev" title="GO的逃逸分析">
                  <i class="fa fa-angle-left"></i> GO的逃逸分析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/01/14/GO%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Achannel/" rel="next" title="GO的基本数据结构：channel">
                  GO的基本数据结构：channel <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZYP</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">617k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">9:21</span>
  </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/zypuu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  





</body>
</html>
