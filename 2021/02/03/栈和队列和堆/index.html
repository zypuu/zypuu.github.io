<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"zypuu.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="栈，队列，堆以及golang的使用">
<meta property="og:type" content="article">
<meta property="og:title" content="栈和队列和堆">
<meta property="og:url" content="https://zypuu.github.io/2021/02/03/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/index.html">
<meta property="og:site_name" content="All-Nothing">
<meta property="og:description" content="栈，队列，堆以及golang的使用">
<meta property="og:locale">
<meta property="og:image" content="https://zypuu.github.io/2021/02/03/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/1.png">
<meta property="article:published_time" content="2021-02-03T07:00:00.000Z">
<meta property="article:modified_time" content="2024-06-03T09:11:30.085Z">
<meta property="article:author" content="ZYP">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zypuu.github.io/2021/02/03/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/1.png">


<link rel="canonical" href="https://zypuu.github.io/2021/02/03/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"https://zypuu.github.io/2021/02/03/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/","path":"2021/02/03/栈和队列和堆/","title":"栈和队列和堆"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>栈和队列和堆 | All-Nothing</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="All-Nothing" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">All-Nothing</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Life has a funny way of working out, just when you start to believe it never will</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archive/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88-Stack"><span class="nav-number">1.</span> <span class="nav-text">栈 Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#golang%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="nav-number">1.1.</span> <span class="nav-text">golang实现栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#slice%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.1.</span> <span class="nav-text">slice实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#container-list%E5%86%85%E7%BD%AE%E5%8C%85"><span class="nav-number">1.1.2.</span> <span class="nav-text">container&#x2F;list内置包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="nav-number">1.1.3.</span> <span class="nav-text">单链表自定义实现栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="nav-number">1.1.4.</span> <span class="nav-text">性能对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97-Queue"><span class="nav-number">2.</span> <span class="nav-text">队列 Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97"><span class="nav-number">2.1.</span> <span class="nav-text">顺序队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#golang-%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97"><span class="nav-number">2.1.1.</span> <span class="nav-text">golang 实现顺序队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97"><span class="nav-number">2.2.</span> <span class="nav-text">链式队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#golang-%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97"><span class="nav-number">2.2.1.</span> <span class="nav-text">golang 实现链式队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="nav-number">2.3.</span> <span class="nav-text">循环队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#golang-%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.1.</span> <span class="nav-text">golang 实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-number">2.4.</span> <span class="nav-text">循环双端队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-number">2.5.</span> <span class="nav-text">优先队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86-heap"><span class="nav-number">3.</span> <span class="nav-text">堆 heap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="nav-number">3.1.</span> <span class="nav-text">二叉堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#golang%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="nav-number">3.1.1.</span> <span class="nav-text">golang实现二叉堆</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZYP"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ZYP</p>
  <div class="site-description" itemprop="description">Give it a try, whispered the HEART</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archive/">
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zypuu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zypuu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:375133421@qq.com" title="E-Mail → mailto:375133421@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://zypuu.github.io/2021/02/03/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZYP">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="All-Nothing">
      <meta itemprop="description" content="Give it a try, whispered the HEART">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="栈和队列和堆 | All-Nothing">
      <meta itemprop="description" content="栈，队列，堆以及golang的使用">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          栈和队列和堆
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-03 15:00:00" itemprop="dateCreated datePublished" datetime="2021-02-03T15:00:00+08:00">2021-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-06-03 17:11:30" itemprop="dateModified" datetime="2024-06-03T17:11:30+08:00">2024-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>19 mins.</span>
    </span>
</div>

            <div class="post-description">栈，队列，堆以及golang的使用</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h2><p>栈是一种非常基础的线性结构，一种FILO类型的数据结构，FILO 即 Fisrt In Last Out</p>
<p>也就是先进后出，也可以说是后进先出</p>
<p>栈只支持三个操作， pop, top, push。</p>
<p>pop取出栈中最上层元素(8)，栈的最上层元素变为早先进入的元素(9)， 出栈</p>
<p>top查看栈的最上层元素(8)。</p>
<p>push将一个新的元素(5)放在栈的最上层， 入栈</p>
<p>通过数组实现的叫顺序栈， 通过链表实现的叫链式栈</p>
<h3 id="golang实现栈"><a href="#golang实现栈" class="headerlink" title="golang实现栈"></a>golang实现栈</h3><p>通过golang实现简单的栈</p>
<h4 id="slice实现"><a href="#slice实现" class="headerlink" title="slice实现"></a>slice实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Item 接口</span></span><br><span class="line">type Item interface&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ItemStack 栈结构体，加锁，保证协程安全</span></span><br><span class="line">type ItemStack struct &#123;</span><br><span class="line">	items []Item</span><br><span class="line">	lock  sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewStack 创建一个新栈</span></span><br><span class="line">func NewStack() *ItemStack &#123;</span><br><span class="line">	s := &amp;ItemStack&#123;&#125;</span><br><span class="line">	s.items = []Item&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pirnt 打印栈的元素</span></span><br><span class="line">func (s *ItemStack) <span class="function"><span class="title">Print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	fmt.Println(s.items)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push 入栈，加锁</span></span><br><span class="line">func (s *ItemStack) <span class="function"><span class="title">Push</span>(<span class="params">t Item</span>)</span> &#123;</span><br><span class="line">	s.lock.Lock()</span><br><span class="line">	defer s.lock.Unlock()</span><br><span class="line">	s.items = append(s.items, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop 出栈，返回栈顶元素</span></span><br><span class="line">func (s *ItemStack) Pop() Item &#123;</span><br><span class="line">	s.lock.Lock()</span><br><span class="line">	defer s.lock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> len(s.items) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line">	item := s.items[len(s.items)-<span class="number">1</span>]</span><br><span class="line">	s.items = s.items[<span class="number">0</span> : len(s.items)-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.slice相对简单</p>
<p>2.interface类型，允许添加任意类型元素</p>
<p>3.Push和Pop有加锁处理，线程安全</p>
<p>问题：slice的pop并不是真正意义上的pop，slice[:]只是一个新的引用，底层的内存并没有减少</p>
<h4 id="container-list内置包"><a href="#container-list内置包" class="headerlink" title="container/list内置包"></a>container/list内置包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack 栈结构体，读写锁</span></span><br><span class="line">type Stack struct &#123;</span><br><span class="line">	list *list.List</span><br><span class="line">	lock *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewStack 初始化栈</span></span><br><span class="line">func NewStack() *Stack &#123;</span><br><span class="line">	list := list.New()</span><br><span class="line">	l := &amp;sync.RWMutex&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;Stack&#123;list, l&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Push 入栈 加锁 </span></span><br><span class="line">func (stack *Stack) <span class="function"><span class="title">Push</span>(<span class="params">value interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">	stack.lock.Lock()</span><br><span class="line">	defer stack.lock.Unlock()</span><br><span class="line">	stack.list.PushBack(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop 出栈</span></span><br><span class="line">func (stack *Stack) Pop() interface&#123;&#125; &#123;</span><br><span class="line">	stack.lock.Lock()</span><br><span class="line">	defer stack.lock.Unlock()</span><br><span class="line">	e := stack.list.Back()</span><br><span class="line">	<span class="keyword">if</span> e != nil &#123;</span><br><span class="line">		stack.list.Remove(e)</span><br><span class="line">		<span class="keyword">return</span> e.Value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Peak 返回栈顶元素</span></span><br><span class="line">func (stack *Stack) Peak() interface&#123;&#125; &#123;</span><br><span class="line">	e := stack.list.Back()</span><br><span class="line">	<span class="keyword">if</span> e != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> e.Value</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 长度</span></span><br><span class="line">func (stack *Stack) Len() int &#123;</span><br><span class="line">	<span class="keyword">return</span> stack.list.Len()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Empty 判断是否为空</span></span><br><span class="line">func (stack *Stack) Empty() bool &#123;</span><br><span class="line">	<span class="keyword">return</span> stack.list.Len() == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>container/list 是一个双向链表 </p>
<p>用链表模拟栈，要么都向链表的最后做push和pop，要么都向链表的起点做push和pop</p>
<h4 id="单链表自定义实现栈"><a href="#单链表自定义实现栈" class="headerlink" title="单链表自定义实现栈"></a>单链表自定义实现栈</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type (</span><br><span class="line">	<span class="comment">// Stack 栈结构体</span></span><br><span class="line">	Stack struct &#123;</span><br><span class="line">		top    *node</span><br><span class="line">		length int</span><br><span class="line">		lock   *sync.RWMutex</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// node 节点，先前指针</span></span><br><span class="line">	node struct &#123;</span><br><span class="line">		value interface&#123;&#125;</span><br><span class="line">		prev  *node</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewStack 初始化栈</span></span><br><span class="line">func NewStack() *Stack &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Stack&#123;nil, <span class="number">0</span>, &amp;sync.RWMutex&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 返回栈的长度</span></span><br><span class="line">func (<span class="built_in">this</span> *Stack) Len() int &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Peek 栈顶元素返回</span></span><br><span class="line">func (<span class="built_in">this</span> *Stack) Peek() interface&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">this</span>.length == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.top.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop 删除栈顶，新栈顶元素等于该栈顶的先前指向元素，再减少长度</span></span><br><span class="line">func (<span class="built_in">this</span> *Stack) Pop() interface&#123;&#125; &#123;</span><br><span class="line">	<span class="built_in">this</span>.lock.Lock()</span><br><span class="line">	defer <span class="built_in">this</span>.lock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">this</span>.length == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="built_in">this</span>.top</span><br><span class="line">	<span class="built_in">this</span>.top = n.prev</span><br><span class="line">	<span class="built_in">this</span>.length--</span><br><span class="line">	<span class="keyword">return</span> n.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push 入栈，新建一个节点，长度加一，先前指针指向当前的top节点，然后 新建的节点等于top</span></span><br><span class="line">func (<span class="built_in">this</span> *Stack) <span class="function"><span class="title">Push</span>(<span class="params">value interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.lock.Lock()</span><br><span class="line">	defer <span class="built_in">this</span>.lock.Unlock()</span><br><span class="line">	n := &amp;node&#123;value, <span class="built_in">this</span>.top&#125;</span><br><span class="line">	<span class="built_in">this</span>.top = n</span><br><span class="line">	<span class="built_in">this</span>.length++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.允许添加任意类型的元素</p>
<p>2.Push和Pop是线程安全的</p>
<h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><p><img src="/2021/02/03/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/1.png" alt="1"></p>
<h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h2><p>队列是一种先进先出，后进后出的线性表</p>
<p>先进入队列的先出去，后进入队列的后出去。必须从队尾插入新元素，队列中的元素只能从队首出</p>
<p>队列也可以通过数组，链表实现</p>
<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>1.初始化一个数组，及两个指针，一个队头指针，一个队尾指针，都指向0的位置</p>
<p>2.队列总是从队头取元素，队尾插入元素</p>
<p>3.入队，判断队列是否已满，队尾指针是否等于长度，不等可以插入，新元素放在队尾位置，指针加一后移</p>
<p>4.出队，头指针和尾指针指向同一个位置，则队列为空，不为空可以出队，出队则头指针的元素出队，头指针加一后移</p>
<p>出队和入队的时间复杂度都是O(1)</p>
<h4 id="golang-实现顺序队列"><a href="#golang-实现顺序队列" class="headerlink" title="golang 实现顺序队列"></a>golang 实现顺序队列</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayQueue</span></span><br><span class="line">type ArrayQueue struct &#123;</span><br><span class="line">    q []interface&#123;&#125;</span><br><span class="line">    capacity int <span class="comment">// 队列容量</span></span><br><span class="line">    head int <span class="comment">// 队头指针</span></span><br><span class="line">    tail int <span class="comment">// 队尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建队列</span></span><br><span class="line">func NewArrayQueue(n int) *ArrayQueue &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ArrayQueue&#123;</span><br><span class="line">        q:        make([]interface&#123;&#125;, n),</span><br><span class="line">        capacity: n,</span><br><span class="line">        head:     <span class="number">0</span>,</span><br><span class="line">        tail:     <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 入队操作</span></span><br><span class="line">func (<span class="built_in">this</span> *ArrayQueue) EnQueue(v interface&#123;&#125;) bool &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">this</span>.tail == <span class="built_in">this</span>.capacity &#123; <span class="comment">// 队列已满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.q[<span class="built_in">this</span>.tail] = v</span><br><span class="line">    <span class="built_in">this</span>.tail++</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 出队操作</span></span><br><span class="line">func (<span class="built_in">this</span> *ArrayQueue) DeQueue() interface&#123;&#125;  &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">this</span>.head == <span class="built_in">this</span>.tail &#123; <span class="comment">// 队列已空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    v := <span class="built_in">this</span>.q[<span class="built_in">this</span>.head]</span><br><span class="line">    <span class="built_in">this</span>.head++</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 队列不为空返回所有元素，否则返回空</span></span><br><span class="line">func (<span class="built_in">this</span> *ArrayQueue) <span class="built_in">String</span>() string  &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">this</span>.head == <span class="built_in">this</span>.tail &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&quot;empty queue!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    result := <span class="string">&quot;head&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">this</span>.head; i &lt;= <span class="built_in">this</span>.tail - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        result += fmt.Sprintf(<span class="string">&quot;&lt;-%+v&quot;</span>, <span class="built_in">this</span>.q[i])</span><br><span class="line">    &#125;</span><br><span class="line">    result += <span class="string">&quot;&lt;-tail&quot;</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line">func (<span class="built_in">this</span> *ArrayQueue) Empty() bool &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">this</span>.head == <span class="built_in">this</span>.tail &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回队列长度</span></span><br><span class="line">func (<span class="built_in">this</span> *ArrayQueue) Len() int &#123;</span><br><span class="line">    <span class="keyword">return</span> len(<span class="built_in">this</span>.q)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回队头元素</span></span><br><span class="line">func (<span class="built_in">this</span> *ArrayQueue) GetHead() interface&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">this</span>.Empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> nil</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.q[<span class="built_in">this</span>.head]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 判断队列是否已满</span></span><br><span class="line">func (<span class="built_in">this</span> *ArrayQueue) Full() bool &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">this</span>.tail == <span class="built_in">this</span>.head &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 清空队列 并没有释放内存</span></span><br><span class="line">func (<span class="built_in">this</span> *ArrayQueue)  <span class="function"><span class="title">Clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.head = <span class="number">0</span></span><br><span class="line">    <span class="built_in">this</span>.tail = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><p>1.初始化也需要两个指针，队头指针，队尾指针</p>
<p>2.入队，让新节点的Next指向队尾节点的Next，也就是nil，再让队尾节点的Next指向新节点，队尾指针加一后移，空队列单独处理</p>
<p>3.出队，头指针指向的元素出队，头指针加一后移，队列长度为1的情况，单独处理</p>
<h4 id="golang-实现链式队列"><a href="#golang-实现链式队列" class="headerlink" title="golang 实现链式队列"></a>golang 实现链式队列</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列的数据结构</span></span><br><span class="line">type queueNode struct &#123;</span><br><span class="line">    data interface&#123;&#125; <span class="comment">// 存放数据</span></span><br><span class="line">    next *queueNode <span class="comment">// 存放指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type queueList struct &#123;</span><br><span class="line">    length int <span class="comment">//存储链表长度</span></span><br><span class="line">    front *queueNode <span class="comment">// 指向队头</span></span><br><span class="line">    rear *queueNode <span class="comment">// 指向队尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链队初始化</span></span><br><span class="line">func initQueue() *queueList &#123;</span><br><span class="line">    L := &amp;queueList&#123;</span><br><span class="line">        length: <span class="number">0</span>,</span><br><span class="line">        front: nil,</span><br><span class="line">        rear: nil,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链队的入队</span></span><br><span class="line">func (queue *queueList) <span class="function"><span class="title">push</span>(<span class="params">val interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">    node := &amp;queueNode&#123;</span><br><span class="line">        data: val,</span><br><span class="line">        next: nil,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理空队</span></span><br><span class="line">    <span class="keyword">if</span> queue.isNull() &#123;</span><br><span class="line">        queue.front = node <span class="comment">// 指向队头</span></span><br><span class="line">        queue.rear = node</span><br><span class="line">        queue.length ++</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue.rear.next = node</span><br><span class="line">    queue.rear = queue.rear.next</span><br><span class="line">    queue.length ++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//链队的出队</span></span><br><span class="line">func (queue *queueList) <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断队空</span></span><br><span class="line">    <span class="keyword">if</span> queue.isNull() &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;队列为空&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理链队中只有一个结点的特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> queue.length == <span class="number">1</span> &#123;</span><br><span class="line">        queue.front = nil</span><br><span class="line">        queue.rear = nil</span><br><span class="line">        queue.length --</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue.front = queue.front.next</span><br><span class="line">    queue.length --</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队空</span></span><br><span class="line">func (queue queueList) isNull() bool &#123;</span><br><span class="line">    <span class="keyword">return</span> queue.length == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (queue *queueList) Traverse() (arr []interface&#123;&#125;) &#123;</span><br><span class="line">    pre := queue.front</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; queue.length; i++ &#123;</span><br><span class="line">        arr = append(arr, pre.data, <span class="string">&quot;--&gt;&quot;</span>)</span><br><span class="line">        pre = pre.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>循环队列是指队列是前后连成一个圆圈，它以循环的方式去存储元素，但还是会按照队列的先进先出的原则去操作</p>
<p>循环队列是基于数组实现的，相比于顺序队列，更好的利用数组空间</p>
<p>普通的数组队列在经过了一段时间的入队和出队以后，尾指针就指向了数组的最后位置了，没法再往队列里插入数据了，但是数组的前面部分（头指针的前面）由于旧的数据曾经出队了，所以会空出来一些空间，这些空间就没法利用起来</p>
<p>即使可以单独处理顺序队列，整体移动，也需要消耗额外的操作</p>
<p>循环队列也是一种线性结构</p>
<p>1.最后一个位置并不是结束位。对于循环队列，头指针始终指向队列的前面，尾指针始终指向队列的末尾</p>
<p>2.初始化队列，头指针和尾指针指向相同位置，此时队列是空</p>
<p>3.入队，新元素插入队尾指针位置，队尾指针加一后移</p>
<p>4.出队，头指针元素出队，头指针加一后移，该元素并不删除，只是不属于队列的一部分</p>
<p>5.继续入队，尾指针到达队列尾部时候，尾指针的下标重新变成0，而之前出队的元素则空出来</p>
<p>6.继续出队，则队列又有空间了，就可以继续入队，头指针的下标已经大于尾指针的下标了，这也是正式循环队列的特性导致的</p>
<p>7.判断队列为空的条件是：head==tail</p>
<p>8.判断队列满的情况：(tail+1)%n=head，取余数等于head，则表示满了，因为是循环</p>
<p>9.会浪费一个空间（length+1）== capacity 表示队列为满</p>
<p>PS：循环队列为什么用空一个元素的位置呢</p>
<p>循环队列中，由于入队时尾指针向前追赶头指针；出队时头指针向前追赶尾指针，造成队空和队满时头尾指针均相等。<br>因此，无法通过条件front==rear来判别队列是”空”还是”满”。<br>解决这个问题的方法至少有三种：<br>1.另设一布尔变量以区别队列的空和满</p>
<p>2.少用一个元素的空间。约定入队前，测试尾指针在循环意义下加1后是否等于头指针，若相等则认为队满（注意：rear所指的单元始终为空）</p>
<p>3.使用一个计数器记录队列中元素的总数（即队列长度）。</p>
<h4 id="golang-实现"><a href="#golang-实现" class="headerlink" title="golang 实现"></a>golang 实现</h4><p>预留了一个空间</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环队列实现方法</span></span><br><span class="line">type loopQueue struct &#123;</span><br><span class="line">    queues   []interface&#123;&#125;</span><br><span class="line">    front    int <span class="comment">//队首</span></span><br><span class="line">    tail     int <span class="comment">//队尾</span></span><br><span class="line">    length   int <span class="comment">//队伍长度</span></span><br><span class="line">    capacity int <span class="comment">//队伍容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLoopQueue 可以自己传参数，初始化队列</span></span><br><span class="line">func NewLoopQueue() *loopQueue &#123;</span><br><span class="line">    loop := &amp;loopQueue&#123;</span><br><span class="line">        queues:   make([]interface&#123;&#125;, <span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">        front:    <span class="number">0</span>,</span><br><span class="line">        tail:     <span class="number">0</span>,</span><br><span class="line">        length:   <span class="number">0</span>,</span><br><span class="line">        capacity: <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化队列，加入初始数据</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        loop.queues = append(loop.queues, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 返回循环队列的长度</span></span><br><span class="line">func (q *loopQueue) Len() int &#123;</span><br><span class="line">    <span class="keyword">return</span> q.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cap 返回循环队列的容量</span></span><br><span class="line">func (q *loopQueue) Cap() int &#123;</span><br><span class="line">    <span class="keyword">return</span> q.capacity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsEmpty 判断队列是否为空</span></span><br><span class="line">func (q *loopQueue) IsEmpty() bool &#123;</span><br><span class="line">    <span class="keyword">return</span> q.length == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsFull 判断队列是否满的</span></span><br><span class="line">func (q *loopQueue) IsFull() bool &#123;</span><br><span class="line">    <span class="keyword">return</span> (q.length + <span class="number">1</span>) == q.capacity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetFront 获取队头元素</span></span><br><span class="line">func (q *loopQueue) GetFront() (interface&#123;&#125;, error) &#123;</span><br><span class="line">    <span class="keyword">if</span> q.Len() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nil, errors.New(</span><br><span class="line">            <span class="string">&quot;failed to getFront,queues is empty.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q.queues[q.front], nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enqueue 入队，放在队尾</span></span><br><span class="line">func (q *loopQueue) <span class="function"><span class="title">Enqueue</span>(<span class="params">elem interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果队列满了，队列扩容</span></span><br><span class="line">    <span class="keyword">if</span> q.IsFull() &#123;</span><br><span class="line">    	<span class="comment">// 创建一个新队列</span></span><br><span class="line">        buffer := <span class="keyword">new</span>(loopQueue)</span><br><span class="line">        <span class="comment">//初始化队列，2倍容量</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>*q.capacity; i++ &#123;</span><br><span class="line">            buffer.queues = append(buffer.queues, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搬运元素</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; q.length; i++ &#123;</span><br><span class="line">            buffer.queues[i] = q.queues[q.front]</span><br><span class="line">            q.front = (q.front + <span class="number">1</span>) % q.capacity</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换当前的queues为扩容后的队列，length不变</span></span><br><span class="line">        q.queues = buffer.queues</span><br><span class="line">        q.front = <span class="number">0</span></span><br><span class="line">        q.tail = q.length</span><br><span class="line">        q.capacity = <span class="number">2</span> * q.capacity</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q.queues[q.tail] = elem</span><br><span class="line">    <span class="comment">// 因为是循环队列，下标会重新设定，循环求法</span></span><br><span class="line">    q.tail = (q.tail + <span class="number">1</span>) % q.capacity</span><br><span class="line">    q.length++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dequeue 出队</span></span><br><span class="line">func (q *loopQueue) Dequeue() (interface&#123;&#125;, error) &#123;</span><br><span class="line">    <span class="keyword">if</span> q.IsEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> nil, errors.New(</span><br><span class="line">            <span class="string">&quot;failed to dequeue,queues is empty.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当队列长度小于容量1/4时，队列容量缩短一半</span></span><br><span class="line">    <span class="keyword">if</span> q.length &lt;= q.capacity/<span class="number">4</span> &#123;</span><br><span class="line">    	<span class="comment">// 创建一个新的队列</span></span><br><span class="line">        buffer := <span class="keyword">new</span>(loopQueue)</span><br><span class="line">        <span class="comment">//初始化队列</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; q.capacity/<span class="number">2</span>; i++ &#123;</span><br><span class="line">            buffer.queues = append(buffer.queues, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搬运元素</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; q.length; i++ &#123;</span><br><span class="line">            buffer.queues[i] = q.queues[q.front]</span><br><span class="line">            q.front = (q.front + <span class="number">1</span>) % q.capacity</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// length不变，缩小其他元素</span></span><br><span class="line">        q.queues = buffer.queues</span><br><span class="line">        q.fron1t = <span class="number">0</span></span><br><span class="line">        q.tail = q.length</span><br><span class="line">        q.capacity = q.capacity / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出队头元素，更新头指针</span></span><br><span class="line">    queue := q.queues[q.front]</span><br><span class="line">    q.front = (q.front + <span class="number">1</span>) % q.capacity</span><br><span class="line">    <span class="comment">// 减少长度</span></span><br><span class="line">    q.length--</span><br><span class="line">    <span class="keyword">return</span> queue, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环双端队列"><a href="#循环双端队列" class="headerlink" title="循环双端队列"></a>循环双端队列</h3><p>双端队列，就是可在头部入队出队，也可在尾部入队出队</p>
<p>leetcode 641 设计循环双端队列</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line">package lt641</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设计实现双端队列。</span></span><br><span class="line"><span class="comment">//你的实现需要支持以下操作：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    MyCircularDeque(k)：构造函数,双端队列的大小为k。</span></span><br><span class="line"><span class="comment">//    insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。</span></span><br><span class="line"><span class="comment">//    insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。</span></span><br><span class="line"><span class="comment">//    deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。</span></span><br><span class="line"><span class="comment">//    deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。</span></span><br><span class="line"><span class="comment">//    getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。</span></span><br><span class="line"><span class="comment">//    getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。</span></span><br><span class="line"><span class="comment">//    isEmpty()：检查双端队列是否为空。</span></span><br><span class="line"><span class="comment">//    isFull()：检查双端队列是否满了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    所有值的范围为 [1, 1000]</span></span><br><span class="line"><span class="comment">//    操作次数的范围为 [1, 1000]</span></span><br><span class="line"><span class="comment">//    请不要使用内置的双端队列库。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 来回顾下队列。</span></span><br><span class="line"><span class="comment">// 顺序队列（基于数组，每次取数据需要进行数据搬迁，优化是等位置不够了再一次搬迁）、</span></span><br><span class="line"><span class="comment">// 链式队列（容易实现，无限扩展，但不太常用）、</span></span><br><span class="line"><span class="comment">// 循环队列（基于数组，head/tail循环移动，多占用一个数据空间）、</span></span><br><span class="line"><span class="comment">// 阻塞队列（取空队列头部阻塞至有值入队）、</span></span><br><span class="line"><span class="comment">// 并发队列(最简单的就是入队出队操作加锁)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列的应用</span></span><br><span class="line"><span class="comment">// 线程池等资源池，通常有最大数量限制，不适合链式队列</span></span><br><span class="line"><span class="comment">// 银行等业务排队系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双端队列就是队头队尾都可以进行出入队操作</span></span><br><span class="line"><span class="comment">// 直接上手干咯，没什么巧的</span></span><br><span class="line"><span class="comment">// 循环队列的难点就在于队满的判定条件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外题给所有值的范围是[1~1000]这是否要我使用而更小的数据表示类型呢？</span></span><br><span class="line"><span class="comment">// 搞不明白</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始队空，f=0=l， 尽管此时一个数据都没有</span></span><br><span class="line"><span class="comment">// fl					// f == l 判空</span></span><br><span class="line"><span class="comment">//[0, 0, 0, 0, 0, 0]	// 为了方便表示，0代表没填充数据</span></span><br><span class="line"><span class="comment">// 插入一个数据， f不变， l后移一位，指向末尾数据的下一位。（如果此时是设计非循环队列，那么 l==n(n为容量)就是判满条件 ）</span></span><br><span class="line"><span class="comment">// f  l</span></span><br><span class="line"><span class="comment">//[1, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">// 数据已满 (暂且按照非循环来看，数据满时 l == n (l==6))</span></span><br><span class="line"><span class="comment">// f			     l</span></span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment">// 头部取出数据,这时候左边空出了一个位置，l应该挪到那里去</span></span><br><span class="line"><span class="comment">// l  f</span></span><br><span class="line"><span class="comment">//[0, 2, 3, 4, 5, 6]		// 这里是为了演示需要，置0了，其实不用管，移动f/l就行，后面只能取出f~l区间里的数据</span></span><br><span class="line"><span class="comment">// 头部再取一个数据</span></span><br><span class="line"><span class="comment">// l	 f</span></span><br><span class="line"><span class="comment">//[0, 0, 3, 4, 5, 6]		// 这里是为了演示需要，置0了，其实不用管，移动f/l就行，后面只能取出f~l区间里的数据</span></span><br><span class="line"><span class="comment">// 尾部插入一个数据</span></span><br><span class="line"><span class="comment">//    l	 f</span></span><br><span class="line"><span class="comment">//[1, 0, 3, 4, 5, 6]		// 这里是为了演示需要，置0了，其实不用管，移动f/l就行，后面只能取出f~l区间里的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 前面这个流程存在问题：</span></span><br><span class="line"><span class="comment">// 当l到数组尾部后，l == 7，但是要按循环处理的话， l就得回到0， 那么此时 f==l！导致该条件下不知道是满是空</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 为了实现循环队列，留一个位置让 l 指向，不填充数据，以使在队中有数据时 l != f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重塑后的流程如下：</span></span><br><span class="line"><span class="comment">// 队列有效容量变成了5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始队空，f=0=l， 此时第一个位置就是 l 的占空位</span></span><br><span class="line"><span class="comment">// fl					// f == l 判空</span></span><br><span class="line"><span class="comment">//[0, 0, 0, 0, 0, 0]	// 为了方便表示，0代表没填充数据</span></span><br><span class="line"><span class="comment">// 插入一个数据， f不变， l后移一位，指向末尾数据的下一位。</span></span><br><span class="line"><span class="comment">// f  l</span></span><br><span class="line"><span class="comment">//[1, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">// 数据已满 （1） f=0, l=5=n (n为队列真实容量)</span></span><br><span class="line"><span class="comment">// f			  l</span></span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 0]</span></span><br><span class="line"><span class="comment">// 头部取出数据,这时候左边空出了一个位置，l应该挪到那里去</span></span><br><span class="line"><span class="comment">//    f	 	      l</span></span><br><span class="line"><span class="comment">//[0, 2, 3, 4, 5, 0]		// 这里是为了演示需要，置0了，其实不用管，移动f/l就行，后面只能取出 [f, l) 区间里的数据</span></span><br><span class="line"><span class="comment">// 头部再取一个数据</span></span><br><span class="line"><span class="comment">//  	 f	      l</span></span><br><span class="line"><span class="comment">//[0, 0, 3, 4, 5, 0]</span></span><br><span class="line"><span class="comment">// 尾部插入一个数据. l = (l+1)%n=(5+1)%6=0回到最左边</span></span><br><span class="line"><span class="comment">// l	 f</span></span><br><span class="line"><span class="comment">//[0, 0, 3, 4, 5, 1]</span></span><br><span class="line"><span class="comment">// 尾部再插入一个数据. 队列满（2） f=2, l=1</span></span><br><span class="line"><span class="comment">//    l	 f</span></span><br><span class="line"><span class="comment">//[2, 0, 3, 4, 5, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面有两种队列满的情况。怎么合并在一起来普适性地判断队满呢</span></span><br><span class="line"><span class="comment">// (2)中 l+1 = f</span></span><br><span class="line"><span class="comment">// (1)中 l+1 = 6, f=0, (l+1)%6 = f</span></span><br><span class="line"><span class="comment">// 合并起来就是 (l+1)%6 == f 为队满条件， 6为实际数组容量，5为有效数据容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑好了循环队列（单向）后，再来看看循环双端队列。</span></span><br><span class="line"><span class="comment">// 就是加上队尾删除和队头插入的情况。</span></span><br><span class="line"><span class="comment">// 一般情况下很好理解，队尾删除就l前移， 队头插入就f前移。 （除非队已满）</span></span><br><span class="line"><span class="comment">// 但是如果是 f发生了循环左移至数组最末呢</span></span><br><span class="line"><span class="comment">// 其实并不会对队空队满条件产生影响</span></span><br><span class="line"><span class="comment">// 来试着看下这个场景：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时队列还剩一个位置可用，front左移一位，在新的front上插入一个数据</span></span><br><span class="line"><span class="comment">//    f	 	      l</span></span><br><span class="line"><span class="comment">//[0, 2, 3, 4, 5, 0]</span></span><br><span class="line"><span class="comment">// f   	 	      l</span></span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环右移操作 l = (l + 1) % n</span></span><br><span class="line"><span class="comment">// 循环左移操作 l = (l - 1) % n ? x  这样会使索引越界，因为真正循环的那一次是由 0 -&gt; -1 -&gt; n-1, 所以应该先加一个 n</span></span><br><span class="line"><span class="comment">// l = (n+l-1) % n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面给出我的程序的操作实验结果</span></span><br><span class="line"><span class="comment">//		obj := Constructor(5)</span></span><br><span class="line"><span class="comment">//		param_1 := obj.InsertFront(99)</span></span><br><span class="line"><span class="comment">//		param_2 := obj.InsertLast(88)</span></span><br><span class="line"><span class="comment">//		param_5 := obj.GetFront()</span></span><br><span class="line"><span class="comment">//		param_6 := obj.GetRear()</span></span><br><span class="line"><span class="comment">//		param_3 := obj.DeleteFront()</span></span><br><span class="line"><span class="comment">//		param_4 := obj.DeleteLast()</span></span><br><span class="line"><span class="comment">//		param_7 := obj.IsEmpty()</span></span><br><span class="line"><span class="comment">//		param_8 := obj.IsFull()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录的队列状态为：</span></span><br><span class="line"><span class="comment">// data=[0 0 0 0 0 0], front=0, last=0</span></span><br><span class="line"><span class="comment">//data=[0 0 0 0 0 99], front=5, last=0</span></span><br><span class="line"><span class="comment">//data=[88 0 0 0 0 99], front=5, last=1</span></span><br><span class="line"><span class="comment">//data=[88 0 0 0 0 99], front=5, last=1</span></span><br><span class="line"><span class="comment">//data=[88 0 0 0 0 99], front=5, last=1</span></span><br><span class="line"><span class="comment">//data=[88 0 0 0 0 0], front=0, last=1</span></span><br><span class="line"><span class="comment">//data=[0 0 0 0 0 0], front=0, last=0</span></span><br><span class="line"><span class="comment">//data=[0 0 0 0 0 0], front=0, last=0</span></span><br><span class="line"><span class="comment">//data=[0 0 0 0 0 0], front=0, last=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好了，开始实现循环双端队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//51/51 cases passed (20 ms)</span></span><br><span class="line"><span class="comment">//Your runtime beats 61.36 % of golang submissions</span></span><br><span class="line"><span class="comment">//Your memory usage beats 100 % of golang submissions (6.1 MB)</span></span><br><span class="line"><span class="comment">// 占用内存少是因为很多地方没有去用局部变量，而是以计算式传入。</span></span><br><span class="line"><span class="comment">// 运行时间却很一般。稍后分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个可以提升效率的地方就是可以通过添加容量字段来减少计算容量的运算。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 奇怪的是，重新提交之后运行效率却击败了百分之九十多....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环双端队列 CircularDoubleEndedQueue</span></span><br><span class="line">type MyCircularDeque struct &#123;</span><br><span class="line">	data []int	<span class="comment">// 数组(切片)存储数据</span></span><br><span class="line">	<span class="comment">// 实际容量为data容量减1，可以在这里记录也可以不记录，我选择不记录</span></span><br><span class="line">	front int	<span class="comment">// “头指针”数组下标</span></span><br><span class="line">	last int	<span class="comment">// “尾指针”数组下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    MyCircularDeque(k)：构造函数,双端队列的大小为k。</span></span><br><span class="line">func Constructor(k int) MyCircularDeque &#123;</span><br><span class="line">	<span class="keyword">return</span> MyCircularDeque&#123;</span><br><span class="line">		<span class="comment">// 构造长度容量都为k+1的切片；当然也可以初始化为长度为0，容量为k+1；</span></span><br><span class="line">		data: make([]int, k+<span class="number">1</span>, k+<span class="number">1</span>),	<span class="comment">// 初始值全0</span></span><br><span class="line">		front:<span class="number">0</span>,</span><br><span class="line">		last:<span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。</span></span><br><span class="line">func (<span class="built_in">this</span> *MyCircularDeque) InsertFront(value int) bool &#123;</span><br><span class="line">	<span class="comment">// 检查队列是否已满</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">this</span>.IsFull() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入元素。</span></span><br><span class="line">	<span class="built_in">this</span>.front = (len(<span class="built_in">this</span>.data) + <span class="built_in">this</span>.front - <span class="number">1</span>) % len(<span class="built_in">this</span>.data)	<span class="comment">// 先循环左移一位</span></span><br><span class="line">	<span class="built_in">this</span>.data[<span class="built_in">this</span>.front] = value	<span class="comment">// 填入数据</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。</span></span><br><span class="line">func (<span class="built_in">this</span> *MyCircularDeque) InsertLast(value int) bool &#123;</span><br><span class="line">	<span class="comment">// 检查队列是否已满</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">this</span>.IsFull() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入元素</span></span><br><span class="line">	<span class="built_in">this</span>.data[<span class="built_in">this</span>.last] = value	<span class="comment">// 填入数据</span></span><br><span class="line">	<span class="built_in">this</span>.last = (<span class="built_in">this</span>.last + <span class="number">1</span>) % len(<span class="built_in">this</span>.data)	<span class="comment">// 循环右移一位</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。</span></span><br><span class="line">func (<span class="built_in">this</span> *MyCircularDeque) DeleteFront() bool &#123;</span><br><span class="line">	<span class="comment">// 检查队列是否为空</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">this</span>.IsEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除头部元素</span></span><br><span class="line">	<span class="comment">//this.data[this.front] = 0	// 置0，这一部完全不是必须，只是为了方便输出调试。可以将这句直接注释</span></span><br><span class="line">	<span class="built_in">this</span>.front = (<span class="built_in">this</span>.front + <span class="number">1</span>) % len(<span class="built_in">this</span>.data)	<span class="comment">// 循环右移一位</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。</span></span><br><span class="line">func (<span class="built_in">this</span> *MyCircularDeque) DeleteLast() bool &#123;</span><br><span class="line">	<span class="comment">// 检查队列是否为空</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">this</span>.IsEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除头部元素</span></span><br><span class="line">	<span class="built_in">this</span>.last = (len(<span class="built_in">this</span>.data) + <span class="built_in">this</span>.last - <span class="number">1</span>) % len(<span class="built_in">this</span>.data)	<span class="comment">// 循环左移一位</span></span><br><span class="line">	<span class="comment">//this.data[this.last] = 0	// 置0，这一部完全不是必须，只是为了方便输出调试。可以将这句直接注释</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。</span></span><br><span class="line">func (<span class="built_in">this</span> *MyCircularDeque) GetFront() int &#123;</span><br><span class="line">	<span class="comment">// 检查队列是否为空</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">this</span>.IsEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取头部元素</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.data[<span class="built_in">this</span>.front]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。</span></span><br><span class="line">func (<span class="built_in">this</span> *MyCircularDeque) GetRear() int &#123;</span><br><span class="line">	<span class="comment">// 检查队列是否为空</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">this</span>.IsEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取尾部元素。这里要注意下，last应该循环左移一位得到数据下标</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.data[(len(<span class="built_in">this</span>.data) + <span class="built_in">this</span>.last - <span class="number">1</span>) % len(<span class="built_in">this</span>.data)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    isEmpty()：检查双端队列是否为空，两个指针在一个位置。</span></span><br><span class="line">func (<span class="built_in">this</span> *MyCircularDeque) IsEmpty() bool &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.last == <span class="built_in">this</span>.front</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    isFull()：检查双端队列是否满了。</span></span><br><span class="line">func (<span class="built_in">this</span> *MyCircularDeque) IsFull() bool &#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">this</span>.last + <span class="number">1</span>) % len(<span class="built_in">this</span>.data) == <span class="built_in">this</span>.front</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>优先队列分为两种，一种是最大优先队列，一种是最小优先队列</p>
<p>最大优先队列，出队时最大值先出</p>
<p>有序数组的入队时间复杂度为 O(n)，出队时间复杂度为 O(1)</p>
<p>无序数组的入队时间复杂度为 O(1)，出队时间复杂度为 O(n)</p>
<p>总的来说出入队都是O(n)</p>
<p>利用堆来实现优先队列</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/heap&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Item 是优先队列中包含的元素。</span></span><br><span class="line">type Item struct &#123;</span><br><span class="line">	value    string <span class="comment">// 元素的值，可以是任意字符串。</span></span><br><span class="line">	priority int    <span class="comment">// 元素在队列中的优先级。</span></span><br><span class="line">	<span class="comment">// 元素的索引可以用于更新操作，它由 heap.Interface 定义的方法维护。</span></span><br><span class="line">	index int <span class="comment">// 元素在堆中的索引。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个实现了 heap.Interface 接口的优先队列，队列中包含任意多个 Item 结构。</span></span><br><span class="line">type PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line">func (pq PriorityQueue) Len() int &#123; <span class="keyword">return</span> len(pq) &#125;</span><br><span class="line"></span><br><span class="line">func (pq PriorityQueue) Less(i, j int) bool &#123;</span><br><span class="line">	<span class="comment">// 我们希望 Pop 返回的是最大值而不是最小值，</span></span><br><span class="line">	<span class="comment">// 因此这里使用大于号进行对比。</span></span><br><span class="line">	<span class="keyword">return</span> pq[i].priority &gt; pq[j].priority</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (pq PriorityQueue) <span class="function"><span class="title">Swap</span>(<span class="params">i, j int</span>)</span> &#123;</span><br><span class="line">	pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">	pq[i].index = i</span><br><span class="line">	pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push 入队，尾部入队</span></span><br><span class="line">func (pq *PriorityQueue) <span class="function"><span class="title">Push</span>(<span class="params">x interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">	n := len(*pq)</span><br><span class="line">	item := x.(*Item)</span><br><span class="line">	item.index = n</span><br><span class="line">	*pq = append(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop 出队，尾部出队</span></span><br><span class="line">func (pq *PriorityQueue) Pop() interface&#123;&#125; &#123;</span><br><span class="line">	old := *pq</span><br><span class="line">	n := len(old)</span><br><span class="line">	item := old[n-<span class="number">1</span>]</span><br><span class="line">	item.index = -<span class="number">1</span> <span class="comment">// 为了安全性考虑而做的设置</span></span><br><span class="line">	*pq = old[<span class="number">0</span> : n-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新函数会修改队列中指定元素的优先级以及值。</span></span><br><span class="line">func (pq *PriorityQueue) <span class="function"><span class="title">update</span>(<span class="params">item *Item, value string, priority int</span>)</span> &#123;</span><br><span class="line">	item.value = value</span><br><span class="line">	item.priority = priority</span><br><span class="line">	heap.Fix(pq, item.index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个示例首先会创建一个优先队列，并在队列中包含一些元素</span></span><br><span class="line"><span class="comment">// 接着将一个新元素添加到队列里面，并对其进行操作</span></span><br><span class="line"><span class="comment">// 最后按优先级有序地移除队列中的各个元素。</span></span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 一些元素以及它们的优先级。</span></span><br><span class="line">	items := map[string]int&#123;</span><br><span class="line">		<span class="string">&quot;banana&quot;</span>: <span class="number">3</span>, <span class="string">&quot;apple&quot;</span>: <span class="number">2</span>, <span class="string">&quot;pear&quot;</span>: <span class="number">4</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个优先队列，并将上述元素放入到队列里面，</span></span><br><span class="line">	<span class="comment">// 然后对队列进行初始化以满足优先队列（堆）的不变性。</span></span><br><span class="line">	pq := make(PriorityQueue, len(items))</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> value, <span class="attr">priority</span> := range items &#123;</span><br><span class="line">		pq[i] = &amp;Item&#123;</span><br><span class="line">			value:    value,</span><br><span class="line">			priority: priority,</span><br><span class="line">			index:    i,</span><br><span class="line">		&#125;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	heap.Init(&amp;pq)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入一个新元素，然后修改它的优先级。</span></span><br><span class="line">	item := &amp;Item&#123;</span><br><span class="line">		value:    <span class="string">&quot;orange&quot;</span>,</span><br><span class="line">		priority: <span class="number">1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	heap.Push(&amp;pq, item)</span><br><span class="line">	pq.update(item, item.value, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以降序形式取出并打印队列中的所有元素。</span></span><br><span class="line">	<span class="keyword">for</span> pq.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		item := heap.Pop(&amp;pq).(*Item)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%.2d:%s &quot;</span>, item.priority, item.value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆 heap"></a>堆 heap</h2><p>分为大顶堆，小顶堆</p>
<p>查找最大或最小：O(1)</p>
<p>删除最大或最小：O（logn）</p>
<p>插入： O（logn）或O（1）</p>
<p>golang 标准库，实现的是小顶堆， “container/heap”包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过小顶堆实现，列表里是一个2个数字的列表嵌套</span></span><br><span class="line">type IHeap []interface&#123;&#125;</span><br><span class="line"><span class="comment">// 返回长度</span></span><br><span class="line">func (h IHeap) Len() int &#123; </span><br><span class="line">    <span class="keyword">return</span> len(h) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 小的值</span></span><br><span class="line">func (h IHeap) Less(i, j int) bool &#123; </span><br><span class="line">    <span class="keyword">return</span> h[i] &lt; h[j] </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line">func (h IHeap) <span class="function"><span class="title">Swap</span>(<span class="params">i, j int</span>)</span> &#123; </span><br><span class="line">    h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入堆</span></span><br><span class="line">func (h *IHeap) <span class="function"><span class="title">Push</span>(<span class="params">x interface&#123;&#125;</span>)</span> &#123;</span><br><span class="line">    *h = append(*h, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出堆，得到最小元素</span></span><br><span class="line">func (h *IHeap) Pop() interface&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := len(old)</span><br><span class="line">    x := old[n-<span class="number">1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><p>1.是一颗完全二叉树，根节点都是满的，除了最后一层</p>
<p>2.树中任意节点的值大于等于或小于等于（二叉大顶，小顶）其子节点的值</p>
<p>3.二叉堆一般都是通过数组实现</p>
<p>4.父节点，子节点位置关系，索引为i</p>
<pre><code>左子节点：2*i+1
右子节点：2*i+2
父节点：floor((i-1)/2)</code></pre>
<p>5.插入元素：插入堆尾部，重新维护堆，向上调整</p>
<p>6。删除元素：向下调整</p>
<h4 id="golang实现二叉堆"><a href="#golang实现二叉堆" class="headerlink" title="golang实现二叉堆"></a>golang实现二叉堆</h4><p>通过数组实现一个二叉大顶堆</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大堆的定义和实现：</span></span><br><span class="line"><span class="comment">// 最大堆</span></span><br><span class="line">type maxHeap struct &#123;</span><br><span class="line">    size int</span><br><span class="line">    nums []int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父节点索引</span></span><br><span class="line">func parent(i int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取左节点索引</span></span><br><span class="line">func leftChild(i int) int &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右节点索引</span></span><br><span class="line">func rightChild(i int) int &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">func NewMaxHeap() *maxHeap &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;maxHeap&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取大小</span></span><br><span class="line">func (heap *maxHeap) GetSize() int &#123;</span><br><span class="line">    <span class="keyword">return</span> heap.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line">func (heap *maxHeap) IsEmpty() bool &#123;</span><br><span class="line">    <span class="keyword">return</span> heap.size == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素，并向上调整</span></span><br><span class="line">func (heap *maxHeap) <span class="function"><span class="title">SiftUp</span>(<span class="params">i int</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 小于则赋值</span></span><br><span class="line">    <span class="keyword">if</span> heap.size &lt; <span class="function"><span class="title">len</span>(<span class="params">heap.nums</span>)</span> &#123;</span><br><span class="line">        heap.nums[heap.size] = i</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 大于则扩容</span></span><br><span class="line">        heap.nums = append(heap.nums, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入的是堆尾，此时的heap.size还没更新，也就是索引</span></span><br><span class="line">    parI := parent(heap.size)</span><br><span class="line">    childI := heap.size</span><br><span class="line">    <span class="comment">// 父节点小于子节点，则交换</span></span><br><span class="line">    <span class="keyword">for</span> heap.nums[parI] &lt; heap.nums[childI] &#123;</span><br><span class="line">        heap.nums[parI], heap.nums[childI] = heap.nums[childI], heap.nums[parI]</span><br><span class="line">        childI = parI</span><br><span class="line">        parI = parent(parI)</span><br><span class="line">    &#125;</span><br><span class="line">    heap.size++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下调整</span></span><br><span class="line">func <span class="function"><span class="title">siftDown</span>(<span class="params">heap *maxHeap, parI int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxI int</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        leftI := leftChild(parI)</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="comment">// 左索引超出size</span></span><br><span class="line">        <span class="keyword">case</span> leftI+<span class="number">1</span> &gt; heap.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左索引不超,右索引超出size,说明左索引是最后索引</span></span><br><span class="line">        <span class="keyword">case</span> leftI+<span class="number">2</span> &gt; heap.size:</span><br><span class="line">            <span class="keyword">if</span> heap.nums[parI] &lt; heap.nums[leftI] &#123;</span><br><span class="line">                heap.nums[parI], heap.nums[leftI] = heap.nums[leftI], heap.nums[parI]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> heap.nums[leftI] &gt;= heap.nums[leftI+<span class="number">1</span>]:</span><br><span class="line">            maxI = leftI</span><br><span class="line">        <span class="keyword">case</span> heap.nums[leftI] &lt; heap.nums[leftI+<span class="number">1</span>]:</span><br><span class="line">            maxI = leftI + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比左右子节点的值都大,返回</span></span><br><span class="line">        <span class="keyword">if</span> heap.nums[parI] &gt;= heap.nums[maxI] &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        heap.nums[parI], heap.nums[maxI] = heap.nums[maxI], heap.nums[parI]</span><br><span class="line">        parI = maxI</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出对中最大元素,即root节点值</span></span><br><span class="line">func (heap *maxHeap) SiftDown() (int, error) &#123;</span><br><span class="line">    <span class="keyword">if</span> heap.IsEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;maxHeap is empty.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    vTop := heap.nums[<span class="number">0</span>]</span><br><span class="line">    heap.size--</span><br><span class="line">    heap.nums[<span class="number">0</span>], heap.nums[heap.size] = heap.nums[heap.size], <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    siftDown(heap, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vTop, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看堆中最大元素</span></span><br><span class="line">func (heap *maxHeap) GetMax() (int, error) &#123;</span><br><span class="line">    <span class="keyword">if</span> heap.IsEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;maxHeap is empty.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap.nums[<span class="number">0</span>], nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/02/01/%E6%9C%80%E5%B0%8F%E6%A0%88/" rel="prev" title="最小栈">
                  <i class="fa fa-angle-left"></i> 最小栈
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/02/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/" rel="next" title="二叉树的最大深度">
                  二叉树的最大深度 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZYP</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">617k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">9:21</span>
  </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/zypuu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  





</body>
</html>
