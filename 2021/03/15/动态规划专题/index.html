<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"zypuu.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="动态规划专题相关例题与解题思路">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划专题">
<meta property="og:url" content="https://zypuu.github.io/2021/03/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/index.html">
<meta property="og:site_name" content="All-Nothing">
<meta property="og:description" content="动态规划专题相关例题与解题思路">
<meta property="og:locale">
<meta property="article:published_time" content="2021-03-15T03:40:00.000Z">
<meta property="article:modified_time" content="2024-06-03T09:11:30.056Z">
<meta property="article:author" content="ZYP">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zypuu.github.io/2021/03/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"https://zypuu.github.io/2021/03/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/","path":"2021/03/15/动态规划专题/","title":"动态规划专题"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>动态规划专题 | All-Nothing</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="All-Nothing" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">All-Nothing</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Life has a funny way of working out, just when you start to believe it never will</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archive/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E8%B7%AF"><span class="nav-number">1.</span> <span class="nav-text">动态规划思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.</span> <span class="nav-text">动态规划解题步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.1.</span> <span class="nav-text">判断边界条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96dp"><span class="nav-number">2.2.</span> <span class="nav-text">初始化dp</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E7%BB%B4dp%E6%95%B0%E7%BB%84%EF%BC%8C-dp-%EF%BC%8C%E8%A6%81%E6%98%8E%E7%99%BDdp-i-%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">2.2.1.</span> <span class="nav-text">初始化一维dp数组， dp&#x3D;[]，要明白dp[i]的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4dp%E6%95%B0%E7%BB%84%E9%80%9A%E8%BF%87%E4%BC%98%E5%8C%96%EF%BC%8C%E5%8F%AF%E5%B0%86%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%99%8D%E4%B8%BA1%EF%BC%8C%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E8%BF%AD%E4%BB%A3"><span class="nav-number">2.2.2.</span> <span class="nav-text">一维dp数组通过优化，可将空间复杂度降为1，通过指针迭代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%8C%E7%BB%B4dp%E6%95%B0%E7%BB%84%EF%BC%8Cdp-int-dp-i-j-%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">2.2.3.</span> <span class="nav-text">初始化二维dp数组，dp&#x3D;[][]int, dp[i][j]的意义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%BF%AD%E4%BB%A3dp%E5%80%BC"><span class="nav-number">2.3.</span> <span class="nav-text">循环迭代dp值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E5%BE%AA%E7%8E%AF%EF%BC%9A%E4%BB%8E%E5%BC%80%E5%A7%8B%E5%BE%80%E5%90%8E%E5%BE%AA%E7%8E%AF%EF%BC%8Ci"><span class="nav-number">2.3.1.</span> <span class="nav-text">一维循环：从开始往后循环，i++</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E5%BE%AA%E7%8E%AF%EF%BC%9A%E4%BB%8E%E5%90%8E%E5%BE%80%E5%89%8D%E5%BE%AA%E7%8E%AF%EF%BC%8Ci%E2%80%93"><span class="nav-number">2.3.2.</span> <span class="nav-text">一维循环：从后往前循环，i–</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%BE%AA%E7%8E%AF%EF%BC%9A%E4%BB%8E%E5%89%8D%E5%BE%80%E5%90%8E%E5%BE%AA%E7%8E%AF%EF%BC%8Ci%E2%80%93"><span class="nav-number">2.3.3.</span> <span class="nav-text">二维循环：从前往后循环，i–</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%BE%AA%E7%8E%AF%EF%BC%9A%E4%BB%8E%E5%90%8E%E5%BE%80%E5%89%8D%E5%BE%AA%E7%8E%AF%EF%BC%8Ci%E2%80%93"><span class="nav-number">2.3.4.</span> <span class="nav-text">二维循环：从后往前循环，i–</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BE%8B%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">动态规划例题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">3.1.</span> <span class="nav-text">爬楼梯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">3.2.</span> <span class="nav-text">打家劫舍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D2"><span class="nav-number">3.3.</span> <span class="nav-text">打家劫舍2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">3.4.</span> <span class="nav-text">零钱兑换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="nav-number">3.5.</span> <span class="nav-text">最大子序和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF"><span class="nav-number">3.6.</span> <span class="nav-text">最大乘积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">3.7.</span> <span class="nav-text">三角形最小路径和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">3.8.</span> <span class="nav-text">回文串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95"><span class="nav-number">3.9.</span> <span class="nav-text">解码方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="nav-number">3.10.</span> <span class="nav-text">最大正方形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">3.11.</span> <span class="nav-text">最小路径和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E4%B8%8D%E8%B6%85%E8%BF%87k%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-number">3.12.</span> <span class="nav-text">矩形区域不超过k的最大和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-number">3.13.</span> <span class="nav-text">编辑距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="nav-number">3.14.</span> <span class="nav-text">最长有效括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3"><span class="nav-number">3.15.</span> <span class="nav-text">青蛙过河</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">3.16.</span> <span class="nav-text">最长重复子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F"><span class="nav-number">3.17.</span> <span class="nav-text">最长上升子序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98"><span class="nav-number">3.18.</span> <span class="nav-text">股票问题</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZYP"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ZYP</p>
  <div class="site-description" itemprop="description">Give it a try, whispered the HEART</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archive/">
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zypuu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zypuu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:375133421@qq.com" title="E-Mail → mailto:375133421@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://zypuu.github.io/2021/03/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZYP">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="All-Nothing">
      <meta itemprop="description" content="Give it a try, whispered the HEART">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="动态规划专题 | All-Nothing">
      <meta itemprop="description" content="动态规划专题相关例题与解题思路">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          动态规划专题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-15 11:40:00" itemprop="dateCreated datePublished" datetime="2021-03-15T11:40:00+08:00">2021-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-06-03 17:11:30" itemprop="dateModified" datetime="2024-06-03T17:11:30+08:00">2024-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>17 mins.</span>
    </span>
</div>

            <div class="post-description">动态规划专题相关例题与解题思路</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>学习笔记</p>
<h2 id="动态规划思路"><a href="#动态规划思路" class="headerlink" title="动态规划思路"></a>动态规划思路</h2><p>1、根据大问题找重复子问题</p>
<p>2、定义dp状态数组，明确dp[i]含义</p>
<p>3、找dp方程，明确边界条件等，不同处理</p>
<h2 id="动态规划解题步骤"><a href="#动态规划解题步骤" class="headerlink" title="动态规划解题步骤"></a>动态规划解题步骤</h2><h3 id="判断边界条件"><a href="#判断边界条件" class="headerlink" title="判断边界条件"></a>判断边界条件</h3><p>1、给的值为空，提前返回</p>
<p>2、长度为1这种特殊值</p>
<h3 id="初始化dp"><a href="#初始化dp" class="headerlink" title="初始化dp"></a>初始化dp</h3><h4 id="初始化一维dp数组，-dp-，要明白dp-i-的意义"><a href="#初始化一维dp数组，-dp-，要明白dp-i-的意义" class="headerlink" title="初始化一维dp数组， dp=[]，要明白dp[i]的意义"></a>初始化一维dp数组， dp=[]，要明白dp[i]的意义</h4><p>初始化方式:<br>    新开数组，并赋上初始0值，然后迭代修改<br>    以原数组直接为dp（优化空间复杂度，不过会修改原数组的值）<br>例：<br>    1、爬楼梯问题：<br>        新开数组，dp[i]代表，第i个数的斐波那契数值，最后迭代到dp[i]即可<br>        初始化dp[0]=1,dp[1]=1,第一个数是1，0是用于初始计算，n是正整数<br>    2、打家劫舍问题：<br>        新开dp数组，dp[i]表示当前的最大值，初始化0值，1值（要不偷0，要不偷1，两个的最大值）<br>        不开dp数组，直接nums为dp，初始化nums[1]=max(nums[0], nums[1])<br>    3、零钱兑换问题：<br>        新开dp，初始化一个amount+1的数组，dp[i]组成该金额的最小组合，最终结果是dp[amount]<br>        金额依次递增，算出每个金额的最小组合，索引即代表金额<br>    4、最长有效括号问题：<br>        dp数组，初始化均为0，dp[i]代表当前位置为结尾的最长有效括号，只看）这个的dp，（的为0<br>    5、最长递增子序列问题：<br>        一维dp数组，dp值代表以当前位置为结尾的最长递增子序列</p>
<h4 id="一维dp数组通过优化，可将空间复杂度降为1，通过指针迭代"><a href="#一维dp数组通过优化，可将空间复杂度降为1，通过指针迭代" class="headerlink" title="一维dp数组通过优化，可将空间复杂度降为1，通过指针迭代"></a>一维dp数组通过优化，可将空间复杂度降为1，通过指针迭代</h4><p>要明白每个指针的意义，以及特殊问题相关<br>一般都会2个-3个指针，分别代表，现在的值，前一个值，结果值或后一个值，迭代过程中不断更新指针值<br>例：<br>    1、爬楼梯问题：<br>        对于上面开数组的优化， a,b,c 三个指针，n是正整数，初始化a=0，b=1，c=1<br>        a：n-2， b：n-1， c：n<br>    2、打家劫舍问题：<br>        数组优化，两个指针cur,pre,pre前一个，cur当前个<br>    3、最大子序和问题：<br>        不需要初始化数组，根据特殊情况，双指针迭代，或者单指针，修改数组，循环中舍弃不符合条件的值<br>        res最终结果，sum当前和，res初始化数组第一个值，从第二个开始<br>    4、最大乘积和：<br>        初始化一个最大值，一个最小值，结果，三个值，处理正负数的问题<br>    5、解码方法问题：<br>        初始化两个指针，一个当前位置的解码方法，一个前一个位置的解码方法</p>
<h4 id="初始化二维dp数组，dp-int-dp-i-j-的意义"><a href="#初始化二维dp数组，dp-int-dp-i-j-的意义" class="headerlink" title="初始化二维dp数组，dp=[][]int, dp[i][j]的意义"></a>初始化二维dp数组，dp=[][]int, dp[i][j]的意义</h4><p>例：<br>    1、打家劫舍问题（一维问题二维化）：<br>        初始化dp数组，dp=[][]int,升维思路记录额外数据，dp[i][0,1],0代表不偷，1代表偷<br>        并初始化0值,dp[0][0],dp[0][1],初始值偷与不偷的情况<br>    2、三角形最小路径和问题：<br>        初始化dp数组[][]int,并将最后一行赋值，逆向循环，从倒数第二行开始<br>        不开dp数组，直接triangle，不需要赋值了<br>        优化空间复杂度，只需dp[],初始化最后一层，记录每一层，逆向循环，整层更新掉<br>    3、回文子串（一维问题二维化）：<br>        初始化二维dp数组，记录i，j下标为起始的字符串是否是回文串，true，false<br>        可优化为1维，在一次里层循环中使用，外层直接从头更新<br>    4、最大正方形问题：<br>        初始化二维数组，并赋值1，与原数组对应，dp[i][j]代表最大正方形的边长，并初始化最初结果1<br>    5、最小路径和问题：<br>        初始化二维dp，dp[i][j]代表到当前点的最小路径和<br>    6、编辑距离问题：<br>        初始化二维dp，长度加1，单词前面加一个空串处理，dp[i][j]表示，单词1和单词2的前ij字符匹配所需要的最小编辑次数<br>    7、不同路径问题：<br>        初始化二维dp，dp[i][j]表示，到达当前点的不同路径和，初始化注意0，0点，如果有 障碍，dp值是1<br>    8、最长重复子数组问题：<br>        初始化二维dp，长度加1，dp[i][j]代表两个数组的指针位置，到当前位置子数组的长度<br>    9、不同子序列问题：<br>        初始化二维dp数组，两个字符串，都是+1的长度初始化，从空串开始</p>
<h3 id="循环迭代dp值"><a href="#循环迭代dp值" class="headerlink" title="循环迭代dp值"></a>循环迭代dp值</h3><p>根据循环方向不同，循环初始值不同，结束值不同，维度不同分多这种情况</p>
<p>每次循环处理dp方程,区分情况，注意边界条件，分治，可能各个条件的dp方程不一样</p>
<p>注意dp[i]的意义，根据循环的正序，倒序返回</p>
<h4 id="一维循环：从开始往后循环，i"><a href="#一维循环：从开始往后循环，i" class="headerlink" title="一维循环：从开始往后循环，i++"></a>一维循环：从开始往后循环，i++</h4><p>例：<br>    1、爬楼梯问题:<br>        初始值，初始到了dp[1]，从2开始循环到n，返回dp[n]，初始的数组要到n+1<br>        dp方程：dp[i] = dp[i-1] + dp[i-2]<br>        返回dp[n]<br>        指针形式：c就相当于n的值，初始化了1的值，从1开始循环到n<br>        先更新值，然后计算<br>        a = b<br>        b = c<br>        c = a + b<br>        返回c<br>    2、打家劫舍问题：（打家劫舍2就是分两种情况dp, 先记录第一种情况的结果dp[n-2]，比较第二种的结果dp[n-1]）<br>        初始化是二维数组：<br>        dp[i]每次计算偷与不偷的情况，最后返回偷与不偷的最大值，从i=1开始，正向<br>        dp方程：   dp[i][0] = max(dp[i-1][0], dp[i-1][1]) // i不偷，i-1偷与不偷之间的最大值<br>                dp[i][1] = nums[i] + dp[i-1][0] // i偷，则当前i加上i-1不偷的值<br>        初始化是一维数组：<br>        dp[i]是代表最大值，不关心偷与不偷，只获取偷和，不偷的最大值， i-2包含了i-3，i-4等<br>        dp方程：dp[i] = max(dp[i-1], dp[i-2] + nums[i])<br>        不开dp数组，直接nums为dp 初始化nums[1]：<br>        dp方程：nums[i] = max(nums[i-1], nums[i-2] + nums[i])<br>        指针pre          ，cur从2开始循环：<br>        dp方程：pre, cur = cur, max(cur, pre + nums[i])<br>    3、最大子序和：<br>        res记录结果，sum当前值，然后对sum进行累加，如果sum累加之后小于0，则把从下一个值从新开始，赋值为sum<br>        比较结果，更新res<br>        另一种思路：更新nums[i],进行累加nums[i] + nums[i-1] &gt; nums[i]，说明nums[i-1]是正数，否则nums[i-1]是负数<br>        则不动，nums[i]就是dp[i]代表累加和<br>    4、最大乘积和：<br>        每次循环，获取当前的最大，最小值，每次更新最大最小值<br>        最大值：比较最大值<em>当前值，当前值，当前值</em>最小值的大小，针对0，变号的处理<br>        最小值：比较最小值<em>当前值，当前值，当前值</em>最大值的大小，针对0，变号的处理<br>        另外思路：负数的个数，偶数则是全部最大，奇数则从前，从后连乘，舍弃1个负数的两种情况的最大值<br>    5、解码方法问题：<br>        先根据0的位置分情况，只有10,20符合且只能这么解码，所以次数不变<br>        除了上一种其他0都不符合<br>        然后找正常可组成26之内的，则解码方法等于加上之前的，然后更新cur，pre<br>        否则就是单数字那种，更新pre<br>        注意判断条件(s[i] &lt;= ‘6’ &amp;&amp; (s[i - 1] == ‘1’ || s[i - 1] == ‘2’)) || (s[i] &gt; ‘6’ &amp;&amp; s[i  - 1] == ‘1’)<br>    6、最长有效括号：<br>        从1开始循环，2个长度才可能有效，只看当前位置是）的dp<br>        pre = i - 1 - dp[i-1]，如果前一个是（，则dp[i-1]=0，也兼容进去<br>        如果pre的位置 存在，且pre的位置是（，则说明有效，结果+2，如果pre前面还有，则加上前面的dp值<br>        dp方程：dp[i] = dp[i-1] + 2<br>        最后返回每次循环的最大值</p>
<h4 id="一维循环：从后往前循环，i–"><a href="#一维循环：从后往前循环，i–" class="headerlink" title="一维循环：从后往前循环，i–"></a>一维循环：从后往前循环，i–</h4><h4 id="二维循环：从前往后循环，i–"><a href="#二维循环：从前往后循环，i–" class="headerlink" title="二维循环：从前往后循环，i–"></a>二维循环：从前往后循环，i–</h4><p>例：<br>    1、零钱兑换问题：<br>        外层循环：从第一个金额开始向后遍历，每个金额初始dp[i] = -1<br>        内层循环：遍历硬币数组当前金额即索引小于硬币数，则为-1跳过或者减去这个硬币金额后前一个也无解是-1<br>             前一个有解的话，就是前一个所需的最小组合数+1，如果这个数字小于dp[i],或者dp[i]没有计算过,则更新dp[i]<br>    最后返回amount索引的金额<br>    2、回文串问题：<br>        外层循环：字符串结束下标<br>        里层循环：字符串起始下标，记录起始下标到结束下标（3种情况：1，ij相等，2：ij差1且相等，3，ij差2以上且相等且里面的dp是true，是回文串），一维优化后，只记录起始下标i，不符合记录false，下一个外层从头更新<br>    3、最大正方形问题：<br>        以右下角包含1的为正方形的右下角，其他三个点的最小值+1，只看dp[i][j]是1的，才有正方形<br>        dp方程：dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1<br>    4、最小路径和问题：<br>        分边界考虑：边界：没得选择，加上前面那点的dp值，加上原数组的值<br>        非边界：前面的两个的最小值，加上原数组值<br>        dp方程：dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]<br>    5、编辑距离问题：<br>        里外层循环，两个单词两个指针位置移动，从0开始，0是空串，边界条件初始化（一个单词为空串）<br>        当word ij相等时，不需要操作，ij = i-1，j-1<br>        word ij不等时，三种操作下的最小值+1<br>        替换操作：i-1与j-1匹配，ij替换即可  +1<br>        插入操作：i与j-1匹配，i后面插入j  +1<br>        删除操作：i-1与j匹配，删除i  +1<br>        dp方程： if word1[i-1] == word2[j-1]: dp[i][j] = dp[i - 1][j - 1]<br>                else：dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1<br>        最后返回dp[m][n]<br>    6、不同路径问题：<br>        两层循环，从前往后，处理i0，j0的边界条件<br>        dp方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]<br>    7、不同路径问题2：<br>        两层循环，从前往后，处理i0，j0的边界条件，障碍那点的dp值是0<br>        dp方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]<br>    8、递增子序列问题：<br>        一维dp，二维循环，<br>        外层循环，重置当前dp值是1，然后内层循环代表，以当前i为结束位置，遍历之前每一个点，如果i的值大于j的值<br>        则dp[i]就是dp[j] +1与dp[i]相比的最大值，然后和结果比较<br>        dp方程：if dp[j] + 1 &gt; dp[i] {dp[i] = dp[j] + 1；if dp[i] &gt; res { res = dp[i]}}</p>
<h4 id="二维循环：从后往前循环，i–"><a href="#二维循环：从后往前循环，i–" class="headerlink" title="二维循环：从后往前循环，i–"></a>二维循环：从后往前循环，i–</h4><p>自下向上循环，注意初始值的处理，看看最后一层是不是需要进入循环，不进入直接初始化最后一层</p>
<p>例：<br>    1、最小三角形路径和：<br>    外层循环从倒数第二层开始。n-2往前，里层循环正向，dp[i][j]为下一层相邻的最小值<br>    dp方程：dp[i][j] = min(dp[i+1][j], dp[i+1][j+1]) + triangle[i][j]<br>    优化空间复杂度：dp[]初始化最后一层，向上循环，每次整层更新<br>    dp方程：dp[j] = min(dp[j], dp[j+1]) + triangle[i][j]<br>    2、最长重复子数组：<br>    外层循环从m-1开始，内层循环从n-1开始，如果这两个元素长度相等，这说明后面位置的最长子数组加1<br>    如果不等，说明这两个位置肯定不在最长子数组里，这个位置的dp值就是0<br>    dp方程：dp[i][j] = dp[i + 1][j + 1] + 1<br>    是双层遍历<br>    2、不同的子序列<br>    从后往前，两个字符串，初始化是空串为1，dp[i][n] = 1，然后内外层都往前<br>    dp方程: 两个字符相等，则匹配当前这个，或者不匹配，走上一个<br>    if s[i] == t[j] {<br>        dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]<br>    } else { 两个字符不等，只能走上一个<br>        dp[i][j] = dp[i + 1][j]<br>    }</p>
<h2 id="动态规划例题"><a href="#动态规划例题" class="headerlink" title="动态规划例题"></a>动态规划例题</h2><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func climbStairs(n int) int &#123;</span><br><span class="line">    a, b, <span class="attr">c</span> := <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        a = b</span><br><span class="line">        b = c</span><br><span class="line">        c = a + b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func rob(nums []int) int &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    pre := nums[<span class="number">0</span>]</span><br><span class="line">    cur := max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">        pre, cur = cur, max(cur, pre + nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打家劫舍2"><a href="#打家劫舍2" class="headerlink" title="打家劫舍2"></a>打家劫舍2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func rob(nums []int) int &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    dp := make([]int, n)</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n - <span class="number">1</span>; i++  &#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    res1 := dp[n - <span class="number">2</span>]</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++  &#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(res1, dp[n-<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><p>完全背包问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func coinChange(coins []int, amount int) int &#123;</span><br><span class="line">    dp := make([]int, amount + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= amount; i++ &#123;</span><br><span class="line">        dp[i] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _, <span class="attr">c</span> := range coins &#123;</span><br><span class="line">            <span class="keyword">if</span> i &lt; c || dp[i-c] == -<span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            count := dp[i-c] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == -<span class="number">1</span> || dp[i] &gt; count &#123;</span><br><span class="line">                    dp[i] = count</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func maxSubArray(nums []int) int &#123;</span><br><span class="line">    res := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] + nums[i-<span class="number">1</span>] &gt; nums[i]&#123;</span><br><span class="line">            nums[i] += nums[i -<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; res &#123;</span><br><span class="line">            res = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大乘积"><a href="#最大乘积" class="headerlink" title="最大乘积"></a>最大乘积</h3><p>遍历法，根据负数的数量是奇数还是偶数个</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func maxProduct(nums []int) int &#123;</span><br><span class="line">    res := nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    cur := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(nums); i++ &#123;</span><br><span class="line">        cur *= nums[i]</span><br><span class="line">        res = max(cur, res)</span><br><span class="line">        <span class="keyword">if</span> nums[i] == <span class="number">0</span> &#123;cur = <span class="number">1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := len(nums) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        cur *= nums[i]</span><br><span class="line">        res = max(cur, res)</span><br><span class="line">        <span class="keyword">if</span> nums[i] == <span class="number">0</span> &#123;cur = <span class="number">1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func maxProduct(nums []int) int &#123;</span><br><span class="line">    mxf, mnf, <span class="attr">res</span> := nums[<span class="number">0</span>], nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(nums); i++ &#123;</span><br><span class="line">        mx, <span class="attr">mn</span> := mxf, mnf</span><br><span class="line">        mxf = max(mx * nums[i], max(nums[i], nums[i] * mn))</span><br><span class="line">        mnf = min(mn * nums[i], min(nums[i], nums[i] * mx))</span><br><span class="line">        res = max(mxf, res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func minimumTotal(triangle [][]int) int &#123;</span><br><span class="line">    n := len(triangle)</span><br><span class="line">    dp := make([]int, len(triangle[n-<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(triangle[n-<span class="number">1</span>]); i++ &#123;</span><br><span class="line">        dp[i] = triangle[n-<span class="number">1</span>][i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; len(triangle[i]); j++ &#123;</span><br><span class="line">            dp[j] = min(dp[j], dp[j+<span class="number">1</span>]) + triangle[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func countSubstrings(s string) int &#123;</span><br><span class="line">    n := len(s)</span><br><span class="line">    dp := make([]bool, n)</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= j; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i == j &#123;</span><br><span class="line">                res++</span><br><span class="line">                dp[i] = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> j - i == <span class="number">1</span> &amp;&amp; s[i] == s[j] &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span></span><br><span class="line">                res++</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> j - i &gt; <span class="number">1</span> &amp;&amp; s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>] &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span></span><br><span class="line">                res++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a>解码方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func numDecodings(s string) int &#123;</span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一维dp，优化空间复杂度</span></span><br><span class="line">    cur, <span class="attr">pre</span> := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(s); i++ &#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="comment">// ‘10’， ‘20’这种情况，不会有额外的解码方法，保持不变，cur=pre，且1,2只能跟0组合，所以是等于前面的</span></span><br><span class="line">        <span class="keyword">case</span> s[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; (s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span>):</span><br><span class="line">            cur = pre</span><br><span class="line">        <span class="comment">// 除去上一种，其他的0都不合法，直接返回</span></span><br><span class="line">        <span class="keyword">case</span> s[i] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">// 可以与前一个数字多一种解码方法的，加上之前的解码方法，并更新</span></span><br><span class="line">        <span class="keyword">case</span> (s[i] &lt;= <span class="string">&#x27;6&#x27;</span> &amp;&amp; (s[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)) || (s[i] &gt; <span class="string">&#x27;6&#x27;</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>):</span><br><span class="line">            tmp := cur</span><br><span class="line">            cur += pre</span><br><span class="line">            pre = tmp</span><br><span class="line">        <span class="comment">// 没有多出解码方法的，cur保持不变， pre=cur</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a>最大正方形</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func maximalSquare(matrix [][]byte) int &#123;</span><br><span class="line">    m := len(matrix)</span><br><span class="line">    n := len(matrix[<span class="number">0</span>])</span><br><span class="line">    dp := make([][]int, m)</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 初始化，并赋值，如果有1，结果为1，特殊处理</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        dp[i] = make([]int, n)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span></span><br><span class="line">                res = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0那一行，最多就是1，不需要进行更新，从1开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="comment">// 如果当前值是1,则以当前点为右下角包含1的正方形，为其他三个点的最小值+1</span></span><br><span class="line">            <span class="comment">// 为0的则 跳过</span></span><br><span class="line">           <span class="keyword">if</span> dp[i][j] == <span class="number">1</span>&#123;</span><br><span class="line">               dp[i][j] = min(min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]), dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 更新res</span></span><br><span class="line">           <span class="keyword">if</span> dp[i][j] &gt; res &#123;</span><br><span class="line">               res = dp[i][j]</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res * res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">func minPathSum(grid [][]int) int &#123;</span><br><span class="line">    <span class="comment">// 初始化dp矩阵，与原数据矩阵对应</span></span><br><span class="line">    m := len(grid)</span><br><span class="line">    n := len(grid[<span class="number">0</span>])</span><br><span class="line">    dp := make([][]int, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        dp[i] = make([]int, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历矩阵，递推出dp[i][j]的值</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++  &#123;</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="comment">// 0,0点特殊处理</span></span><br><span class="line">            <span class="keyword">case</span> i == <span class="number">0</span>  &amp;&amp; j == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = grid[i][j]</span><br><span class="line">            <span class="comment">// 边界特殊处理，原矩阵当前点的 值加上之前的dp值，就是dp当前点的值</span></span><br><span class="line">            <span class="keyword">case</span> i == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + grid[i][j]</span><br><span class="line">            <span class="keyword">case</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j]</span><br><span class="line">            <span class="comment">// 非边界递推，最小路径，只能向右，向下，之前两个点的最小值，加上原矩阵当前点的值</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="矩形区域不超过k的最大和"><a href="#矩形区域不超过k的最大和" class="headerlink" title="矩形区域不超过k的最大和"></a>矩形区域不超过k的最大和</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀和加上最大子序和</span></span><br><span class="line">func maxSumSubmatrix(matrix [][]int, k int) int &#123;</span><br><span class="line">    rowNum, <span class="attr">colNum</span> := len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">// 最小值作为初始结果</span></span><br><span class="line">    result := math.MinInt32</span><br><span class="line">    <span class="comment">// 按列遍历，起始指针</span></span><br><span class="line">    <span class="keyword">for</span> left := <span class="number">0</span>; left &lt; colNum; left ++ &#123;</span><br><span class="line">        rowSum := make([]int, rowNum)</span><br><span class="line">        <span class="comment">// 按列遍历，结束指针</span></span><br><span class="line">        <span class="keyword">for</span> right := left; right &lt; colNum; right++ &#123;</span><br><span class="line">            <span class="comment">// 按行遍历，逐列想加，每一列都是之前列的行行和</span></span><br><span class="line">            <span class="keyword">for</span> row := <span class="number">0</span>; row &lt; rowNum; row++ &#123;</span><br><span class="line">                rowSum[row] += matrix[row][right]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找最大值，每一列的最大子序和，就是矩形区域的和</span></span><br><span class="line">            result = max(result, maxSubArrBelowK(rowSum, k))</span><br><span class="line">            <span class="keyword">if</span> result == k &#123;</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找最大子序和，因为有k限制</span></span><br><span class="line">func maxSubArrBelowK(arr []int, k int) int &#123;</span><br><span class="line">    <span class="comment">// 先按动态规划找最大子序和，找到可以减少时间复杂度</span></span><br><span class="line">    sum, max, <span class="attr">l</span> := arr[<span class="number">0</span>], arr[<span class="number">0</span>], len(arr)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; l; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> sum &gt; <span class="number">0</span> &#123;</span><br><span class="line">            sum += arr[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum = arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sum &gt; max &#123;</span><br><span class="line">            max = sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果结果小于k，则找到，返回</span></span><br><span class="line">    <span class="keyword">if</span> max &lt;= k &#123;</span><br><span class="line">        <span class="keyword">return</span> max</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结果大于k，则只能暴力法去找，最接近k的</span></span><br><span class="line">    max = math.MinInt32</span><br><span class="line">    <span class="keyword">for</span> left := <span class="number">0</span>; left &lt; l; left++ &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right := left; right &lt; l; right++ &#123;</span><br><span class="line">            sum += arr[right]</span><br><span class="line">            <span class="keyword">if</span> sum &gt; max &amp;&amp; sum &lt;= k &#123;</span><br><span class="line">                max = sum</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> max == k &#123;</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">func minDistance(word1 string, word2 string) int &#123;</span><br><span class="line">    m := len(word1)</span><br><span class="line">    n := len(word2)</span><br><span class="line">    <span class="comment">// 初始化m+!,n+1,单词前面加一个空串处理</span></span><br><span class="line">    dp := make([][]int, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m + <span class="number">1</span>; i++ &#123;</span><br><span class="line">        dp[i] = make([]int, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m+<span class="number">1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n+<span class="number">1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="comment">// 00位置两个空串是0</span></span><br><span class="line">            <span class="keyword">case</span> i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 空串对于另一个单词就一直插入</span></span><br><span class="line">            <span class="keyword">case</span> i == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">case</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span></span><br><span class="line">            <span class="comment">// 如果两个单词相等，则不需要操作</span></span><br><span class="line">            <span class="keyword">case</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">            <span class="comment">// dp[i - 1][j - 1]代表替换，dp[i - 1][j]。i-1与j一样，删除i；i与j-1一样。i后面插入j</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                dp[i][j] = min(min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最长 有效括号，双向遍历法</span></span><br><span class="line">func longestValidParentheses(s string) int &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    left, right, <span class="attr">res</span> := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(s); i++ &#123;</span><br><span class="line">        <span class="comment">// 左右计数++</span></span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123; left++ &#125;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &#123; right++ &#125;</span><br><span class="line">        <span class="comment">// 右括号比左括号多，则重置，前面的舍弃</span></span><br><span class="line">        <span class="keyword">if</span> right &gt; left &#123; </span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新结果</span></span><br><span class="line">        <span class="keyword">if</span> left == right &#123; res = max(res, right) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以上会漏掉一种就是左括号始终比右括号多，这种是找不到的</span></span><br><span class="line">    <span class="comment">// 逆向遍历，正向排除右比左多的，逆向排除左比右多的</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := len(s) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123; left++ &#125;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &#123; right++ &#125;</span><br><span class="line">        <span class="keyword">if</span> right &lt; left &#123; </span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left == right &#123; res = max(res, right) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划方法</span></span><br><span class="line">func longestValidParentheses(s string) int &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> || len(s) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp := make([]int, len(s))</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 从1开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(s); i++ &#123;</span><br><span class="line">        <span class="comment">// 结尾是）才能形成有效括号，只看结尾是）的前面， （的dp值都是0</span></span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">            <span class="comment">// 找前面的（，如果前一个就是（，前一个dp值是0，也能找到</span></span><br><span class="line">            pre := i - <span class="number">1</span>- dp[i - <span class="number">1</span>]</span><br><span class="line">            <span class="comment">// 如果大于0，且找到是（，则结果+2</span></span><br><span class="line">            <span class="keyword">if</span> pre &gt;= <span class="number">0</span> &amp;&amp; s[pre] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="comment">// 如果有再前一个，则加上再前一个的dp值</span></span><br><span class="line">                <span class="keyword">if</span> pre - <span class="number">1</span> &gt;= <span class="number">0</span> &#123; dp[i] += dp[pre - <span class="number">1</span>] &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回最大值</span></span><br><span class="line">            res = max(res, dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="青蛙过河"><a href="#青蛙过河" class="headerlink" title="青蛙过河"></a>青蛙过河</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs递归，剪枝</span></span><br><span class="line">func canCross(stones []int) bool &#123;</span><br><span class="line">    <span class="comment">// 记录在别的分支处理过的子问题</span></span><br><span class="line">    vis := make(map[int]bool, len(stones))</span><br><span class="line">    <span class="keyword">var</span> dfs func(int, int) bool</span><br><span class="line">    dfs = func(index, k int) bool &#123;</span><br><span class="line">        <span class="comment">// 如果在别的分支处理过，说明别的分支无法通过，能通过就说明不会有子问题，一直到底结束递归</span></span><br><span class="line">        <span class="comment">// 如果找到，说明别的分支没到底，则1直接返回false</span></span><br><span class="line">        <span class="comment">// 保证石头位置唯一</span></span><br><span class="line">        <span class="keyword">if</span> vis[index*<span class="number">100</span> + k] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        vis[index*<span class="number">100</span> + k] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> i := index + <span class="number">1</span>; i &lt; len(stones); i++ &#123;</span><br><span class="line">            <span class="comment">// 计算下一个石头与当前石头之间的距离</span></span><br><span class="line">            dis := stones[i] - stones[index]</span><br><span class="line">            <span class="comment">// 在跳跃单位内，则继续递归，，return true</span></span><br><span class="line">            <span class="keyword">if</span> dis &gt;= k - <span class="number">1</span> &amp;&amp; dis &lt;= k + <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="function"><span class="title">dfs</span>(<span class="params">i, dis</span>)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 超过了k+1，则说明无法到达，直接break</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> dis &gt; k + <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125; <span class="comment">// 小于k-1，说明太近了，可以下一波循环找后面的石头</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前分支最后是否到达最后位置</span></span><br><span class="line">        <span class="keyword">return</span> index == len(stones) - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line">func canCross(stones []int) bool &#123;</span><br><span class="line">    <span class="comment">// dp[stones[i]] 用个map保存第i个位置所有能跳的k值</span></span><br><span class="line">    dp := make(map[int]map[int]int, len(stones))</span><br><span class="line">    <span class="comment">// 初始化每个石头，和能跳的k值</span></span><br><span class="line">    <span class="keyword">for</span> _, <span class="attr">i</span> := range stones &#123;</span><br><span class="line">        dp[i] = make(map[int]int)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一个石头，0值，跳0步</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(stones); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> _, <span class="attr">k</span> := range dp[stones[i]] &#123;</span><br><span class="line">             <span class="comment">// 初始0，-1， 0， 1，只有1步可以跳到下一个石头 </span></span><br><span class="line">             <span class="keyword">for</span> step := k - <span class="number">1</span>; step &lt;= k + <span class="number">1</span>; step++ &#123;</span><br><span class="line">                <span class="comment">//  如[0,1,3,5,6,8,12,17] 1 点能跳 0，1， 2 共3种距离 只有2跳到了 3里面  </span></span><br><span class="line">                 <span class="keyword">if</span> step &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 跳的距离大于0 且 跳到数组中存在的位置 </span></span><br><span class="line">                    <span class="keyword">if</span> _, <span class="attr">ok</span> := dp[stones[i] + step]; ok &#123;</span><br><span class="line">                        <span class="comment">// 则更新这个位置，dp【1】【0】 = 1</span></span><br><span class="line">                        dp[stones[i] + step][i] = step</span><br><span class="line">                    &#125;           </span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  len(dp[stones[len(stones)-<span class="number">1</span>]]) != <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">func findLength(A []int, B []int) int &#123;</span><br><span class="line">    m := len(A)</span><br><span class="line">    n := len(B)</span><br><span class="line">    dp := make([][]int, m + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m + <span class="number">1</span>; i++ &#123;</span><br><span class="line">        dp[i] = make([]int, n + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">for</span> j := n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">            <span class="keyword">if</span> A[i] == B[j] &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; dp[i][j] = <span class="number">0</span> &#125;</span><br><span class="line">            <span class="keyword">if</span> res &lt; dp[i][j] &#123;</span><br><span class="line">                res = dp[i][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">滑动窗口解法</span><br><span class="line">func findLength(A []int, B []int) int &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    m := len(A)</span><br><span class="line">    n := len(B)</span><br><span class="line">    <span class="comment">// 一个不动，一个动</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        win := min(n, m - i)</span><br><span class="line">        res = max(res, handle(A, B, i, <span class="number">0</span>, win))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        win := min(m, n - i)</span><br><span class="line">        res = max(res, handle(A, B, <span class="number">0</span>, i, win))</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handle(A, B []int, sA, sB, win int) int &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    tmp := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; win; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> A[sA + i] == B[sB + i] &#123;</span><br><span class="line">            tmp++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, tmp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长上升子序"><a href="#最长上升子序" class="headerlink" title="最长上升子序"></a>最长上升子序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">func lengthOfLIS(nums []int) int &#123;</span><br><span class="line">    dp := make([]int, len(nums))</span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(nums); i++ &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j] &#123;</span><br><span class="line">                <span class="keyword">if</span> dp[j] + <span class="number">1</span> &gt; dp[i] &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> dp[i] &gt; res &#123; res = dp[i]&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">二分查找+贪心</span><br><span class="line"><span class="comment">// 初始化一个n+1的数组，从1位置开始计算，最终的位置就是长度</span></span><br><span class="line">func lengthOfLIS(nums []int) int &#123;</span><br><span class="line">    d := make([]int, len(nums) + <span class="number">1</span>)</span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="comment">// 1的位置就是数字0</span></span><br><span class="line">    d[res] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(nums); i++ &#123;</span><br><span class="line">        <span class="comment">// 遍历数组，如果数字大于d的最后一位就是放进去，是递增的</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; d[res] &#123;</span><br><span class="line">            res++</span><br><span class="line">            d[res] = nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不大于，就在d里面二分查找，比nums【i】小的，最靠近nums[i]的位置</span></span><br><span class="line">            s, e, <span class="attr">p</span> := <span class="number">1</span>, res, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> s &lt;= e &#123;</span><br><span class="line">                mid := s + (e - s) &gt;&gt; <span class="number">1</span></span><br><span class="line">                <span class="comment">// 大于就更新p</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; d[mid] &#123;</span><br><span class="line">                    s = mid + <span class="number">1</span></span><br><span class="line">                    p = mid</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    e = mid - <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到后下一位就往里插入</span></span><br><span class="line">            d[p + <span class="number">1</span>] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 也就是大于的往后放，小于的往前插入</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">股票<span class="number">1</span>：只买卖一次</span><br><span class="line">func maxProfit(prices []int) int &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    cur := prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] - cur &lt; <span class="number">0</span> &#123;</span><br><span class="line">            cur = prices[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> prices[i] - cur &gt; res &#123;</span><br><span class="line">            res = prices[i] - cur</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">股票<span class="number">2</span>：无限买卖</span><br><span class="line">func maxProfit(prices []int) int &#123;</span><br><span class="line">    dp := make([][<span class="number">2</span>]int, len(prices))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        dp[i] = [<span class="number">2</span>]int&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0 卖出，1买入</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>]- prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>] )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(dp[len(prices) - <span class="number">1</span>][<span class="number">0</span>], dp[len(prices) - <span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">求累计和</span><br><span class="line">func maxProfit(prices []int) int &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &gt; prices[i - <span class="number">1</span>] &#123;</span><br><span class="line">            res += prices[i] - prices[i-<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">股票<span class="number">3</span>：最多交易<span class="number">2</span>次，三维，第二个是交易次数</span><br><span class="line">func maxProfit(prices []int) int &#123;</span><br><span class="line">    dp := make([][<span class="number">3</span>][<span class="number">2</span>]int, len(prices))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        dp[i] = [<span class="number">3</span>][<span class="number">2</span>]int&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">            dp[i][j] = [<span class="number">2</span>]int&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="number">3</span>;j++ &#123;</span><br><span class="line">            dp[i][j][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i])</span><br><span class="line">            dp[i][j][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i] )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len(prices) - <span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">股票<span class="number">4</span>：最多交易k次</span><br><span class="line">func maxProfit(k int, prices []int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> len(prices) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp := make([][][<span class="number">2</span>]int, len(prices))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        dp[i] = make([][<span class="number">2</span>]int, k + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++ &#123;</span><br><span class="line">            dp[i][j] = [<span class="number">2</span>]int&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++ &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++ &#123;</span><br><span class="line">            dp[i][j][<span class="number">0</span>] = max(dp[i- <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i])</span><br><span class="line">            dp[i][j][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len(prices) - <span class="number">1</span>][k][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123; </span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">股票<span class="number">5</span>：冷冻期，第i天持有买入，则前一天是冷冻期，所以从前两天卖出来看，所以要初始化第<span class="number">0</span>天，第<span class="number">1</span>天的</span><br><span class="line">func maxProfit(prices []int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> len(prices) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp := make([][<span class="number">3</span>]int, len(prices))</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = max(<span class="number">0</span>, prices[<span class="number">1</span>] - prices[<span class="number">0</span>])</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = max(-prices[<span class="number">1</span>], -prices[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len(prices) - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">股票<span class="number">6</span>：手续费， 如果当天卖出，前一天买入的话，则需要扣除手续费</span><br><span class="line">func maxProfit(prices []int, fee int) int &#123;</span><br><span class="line">    dp := make([][<span class="number">2</span>]int, len(prices))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        dp[i] = [<span class="number">2</span>]int&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; len(prices); i++ &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee)</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len(prices) - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/12/Redis%E4%B8%8EMc/" rel="prev" title="Redis， Codis与Mc">
                  <i class="fa fa-angle-left"></i> Redis， Codis与Mc
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/03/18/Go%E7%9A%84%E5%B8%B8%E8%A7%81%E5%B0%8F%E9%97%AE%E9%A2%98/" rel="next" title="GO的常见小问题">
                  GO的常见小问题 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZYP</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">617k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">9:21</span>
  </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/zypuu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  





</body>
</html>
