---
title: 消息队列的推拉模式
date: 2023-01-04 11:26:47
tags: 消息队列
categories: 消息队列
comments: true
description: 消息队列不同阶段的消息推拉，以及kafka，rocketMQ是如何实现的。
---

## 推拉模式
论推拉模式的时候指的是 Comsumer 和 Broker 之间的交互。
默认的认为 Producer 与 Broker 之间就是推的方式，即 Producer 将消息推送给 Broker，而不是
Broker 主动去拉取消息

如果需要 Broker 去拉取消息，那么 Producer 就必须在本地通过日志的形式保存消息来等待 Broker 的拉取，如果有很多生产者的话，那么消息的可靠性不仅仅靠 Broker 自身，还需要靠成百上
千的 Producer。

### 推模式

推模式指的是消息从 Broker 推向 Consumer，即 Consumer 被动的接收消息，由 Broker 来主导消息的发送

#### 优势：
1、消息实时性高， Broker 接受完消息之后可以立马推送给 Consumer。
2、对于消费者使用来说更简单，就等着，反正有消息来了就会推过来

#### 劣势：
推送速率难以适应消费速率，推模式的目标就是以最快的速度推送消息，当生产者往 Broker 发送消息的速率大于消费者消费消息的速率时，消费者服务就容易崩溃，并且不同的消费者的消费速率还不一样，身为 Broker 很难平衡每个消费者的推送速率，如果要实现自适应的推送速率那就需要在推送的时候消费者告诉 Broker ，然后 Broker 需要维护每个消费者的状态进行推送速率的变更。
这其实就增加了 Broker 自身的复杂度。

所以说推模式难以根据消费者的状态控制推送速率，适用于消息量不大、消费能力强要求实时性高的场景

### 拉模式

拉模式指的是 Consumer 主动向 Broker 请求拉取消息，即 Broker 被动的发送消息给 Consumer

#### 优势：
1、拉模式主动权就在消费者身上，消费者可以根据自身的情况来发起拉取消息的请求。假设当前消费者觉得自己消费不过来了，它可以根据一定的策略停止拉取，或者间隔拉取
2、 Broker 就相对轻松，它只管存生产者发来的消息，至于消费的时候自然由消费者主动发
起，不需要关注消息的消费
3、根据消费者的消费能力，可以参考消费者请求的信息来决定缓存多少消息之后批量发送
#### 劣势：
1、消息延迟，消费者去拉取消息，但是消费者怎么知道消息到了呢？所以它只能不断地拉取，但是
又不能很频繁地请求，太频繁了就变成消费者在攻击 Broker 。因此需要降低请求的频率，比如隔个
2 秒请求一次，你看着消息就很有可能延迟 2 秒
2、消息忙请求，忙请求就是比如消息隔了几个小时才有，那么在几个小时之内消费者的请求都是无效的

我个人觉得拉模式更加的合适，因为现在的消息队列都有持久化消息的需求，也就是说本身它就有个存储功能，它的使命就是接受消息，保存好消息使得消费者可以消费消息即可。
虽说一般而言 Broker 不会成为瓶颈，因为消费端有业务消耗比较慢，但是 Broker 毕竟是一个中心点，能轻量就尽量轻量

## RocketMq和kafka的处理

RocketMQ 和 Kafka 都选择了拉模式，通过长轮询来减轻拉模式的劣势影响
基于推模式的消息队列如 ActiveMQ。

### RocketMQ 中的长轮询

### Kafka的长轮询