---
title: 数据库设计
date: 2024-02-18 2:32:00
tags: 计算机基础
categories: 计算机基础
comments: true
description: 数据库设计，函数模式，代数关系
---

## 数据库模式

内模式：简单点说就是管理如何存储物理的数据 ， 对应具体物理存储文件

模式 ： 又称为概念模式，简单点说就是我们通常使用的基本表 ， 根据应用 、 需求将物理数
据划分成一 张张表

外模式：也称用户模式或子模式，对应数据库中的视图这个级别 ， 将表进行一定的处理后
再提供给用户使用

外模式/概念模式映像：是表和视图之间的映射 ， 存在于概念级和外部级之间 ， 若表中数据发生了修改 ， 只需要修改此映射 ， 而无需修改应用程序 。

概念模式/内模式映像：是表和数据的物理存储之间的映射 存在于概念级和内部级之间 ， 若修改了数据存储方式 ， 只需要修改此映射 ，而不需要去修改应用程序

## 数据库设计步骤

1、需求分析
产出物有数据流图 、数据字典 、需求说明书 。 获得用户对系统的三个要求 ： 信息要求 、处理要求 、 系统要求
2、概念结构设计
设计E-R图， 也即实体-联系图
3、逻辑结构设计
将 E-R 图，转换成关系模式
4、物理设计 
步骤包括确定数据分布 、存储结构和访问方式

## 数据模型

### 概念数据模型（实体—联系模型）
按照用户的观点来对数据和信息建模，主要用于数据 库设计。概念模型主要用实体—联系方法（Entity-Relationship Approach）表示，所以也称 E-R 模型

概念模型是从用户的角度进行建模的

在E-R模型中，使用椭圆表示属性 ( 一般没有) 、长方形表示实体（强实体）、长方形里两道竖岗表示弱实体 、菱形表示联系 ， 联系的两端要填写联系类型

### 基本数据模型（结构数据模型）

是按照计算机系统的观点来对数据和信息建模，主要用于 DBMS 的实现。基本数据模型是数据库系统的核心和基础

关系模型是二维表的形式表示的实体-联系模型
网状模型表示实体类型及其实体之间的联系
面向对象模型是采用面向对象的方法设计数据库，以对象为单位，每个对象包括属性和方法 ， 具有类和继承等特点

数据模型三要素： 数据结构 (所研究的对象类型的集合) 、数据操作 (对数据库中各种对象的实例允许执行的操作的集合) 、数据的约束条件 ( 一组完整性规则的集合)

#### 数据的约束条件
实体完整性。实体完整性是指实体的主属性不 能取空值

参照完整性。在关系数据库中主要是值得外键参照的 完整性。若A关系中的某个或者某些属性参照B或其他几个关系中的属性，那么在关系A中该属性要么为空，要么必须出现B或者其他的关系的对应属性中

用户定义完整性。用户定义完整性反映的某一个具 体应用所对应的数据必须满足一定的约束条件

#### 关系模型
优点 ：建立在严格的数学概念基础上； 概念单一、结构简单 、清晰 ， 用户易懂易用 ； 存取路径对用户透明 ， 从而数据独立性 、 安全性好 ， 简化数据库开发工作 。
缺点： 由于存取路径透明，查询效率往往不如非关系数据模型

关系：可以理解为一张二维表，每个关系都具有一个关系名， 就是通常说的表名。
元组：可以理解为二维表中的一行，在数据库中经常被称为记 录。
属性：可以理解为二维表中的一列，在数据库中经常被称为字 段。
域：属性的取值范围，也就是数据库中某一列的取值限制。
关键字：一组可以唯一标识元组的属性，数据库中常称为主键， 由一个或多个列组成。
关系模式：指对关系的描述。其格式为：关系名（属性1，属性
2 ，……，属性N），在数据库中成为表结构。

### 模型转换

E-R模型转换为关系模型 ：每个实体都对应一个关系模式

1:1联系中 ，联系可以放到任意的两端实体中， 作为一个属性 (要保证1:1 的两端关联) ， 也可以转换为一个单独的关系模式；
1:N 的联系中 ， 联系可以单独作为一个关系模式， 也可以在N端中加入1端实体的主键；
M:N的联系中 ，联系必须作为 一个单独的关系模式 ，其主键是M和N端的联合主键

## 关系代数
![1](1.jpg)

并：S1 U S2， 结果是两张表中所有记录数合并 ，相同记录只显示一次。
交：S1 ∩ S2 ,结果是两张表中相同的记录 。
差：S1 - S2 ，结果是S1表中有而S2表中没有的那些记录。

笛卡尔积 ：S1*S2 ，产生的结果包括S1和S2的所有属性列 ，并且S1 中每条记录依次和S2 中所有记录组合成一条记录，最终属性列为S1+S2属性列，记录数为 S1*S2记录数
![1](2.jpg)

查询年龄小于22岁的学生 σSage<22(student)
查询学生的姓名和所在系πSname,Sdept(Student)

自然连接的结果显示全部的属性列 ， 但是相同属性列只显示一次 ， 显示两个关系模式中属性相同且值相同的记录。
设有关系R、S如下左图所示， 自然连接结果如下右图所示：
![1](3.jpg)

注意RxS，和R自然连接S

## 函数依赖范式

### 函数依赖
给定一个X， 能唯一确定一个Y， 就称X确定Y，或者说Y依赖于X ，例如Y=X*X 函数 。
函数依赖又可扩展以下两种规则 :
部分函数依赖 ：A可确定C，(A,B)也可确定C，(A,B)中的一部分 (即A ) 可以确定C ，称为部分函数依赖。
传递函数依赖：当A和B不等价时，A可确定B，B可确定C，则A可确定C，是传递函数依赖；
若A和B等价，则不存在传递，直接就可确定C

设关系模式R<U，F> ,U是关系模式R 的属性全集，F是关系模式R的一个函数依赖集 。
对于R<U，F>来说有以下的：
![1](4.jpg)

超键 ： 能唯一标识此表的属性的组合 。
候选键： 超键中去掉冗余的属性 ， 剩余的属性就是候选键。
主键 ：任选一 个候选键 ， 即可作为主键。
外键 ： 其他表中的主键。
主属性和非主属性： 候选键内的属性为主属性 ， 其他属性为非主属性

候选键：候选码，可以作为主键的字段
根据依赖集，没有出现在右边的字段，且能推导出所有的字段的是候选码
然后确定主属性，非主属性

### 范式
#### 第一范式
关系中的每一个分量必须是一个不可分的数据项 。通俗地说 ，第一范式就是表中不允许有小表的存在
#### 第二范式
如果关系R属于1NF， 且每一个非主属性完全函数依赖于任何一个候选码 ，则R属于2NF。
2NF就是在1NF的基础上 ，表中的每一个非主属性不会依赖复合主键中的某一个列
#### 第三范式
在满足1NF的基础上 ， 表中不存在非主属性对码的传递依赖。
#### BC范式
在第三范式的基础上进一步消除主属性对于码的部分函数依赖和传递依赖。
通俗的来说 ，就是在每一种情况下 每一个依赖的左边决定因素都必然包含候选键 


## 模式分解

把一个关系模式分解成若干个关系模式的过程，也就是由低范式转换为高范式的过程，称为关系模式的分解，简称模式分解。
模式分解具体是通过将原关系模式的属性集进行拆分来实现 ，拆分后的关系模式包含新的属性集，以及新的函数依赖集。
为使分解后的模式与原模式等价，一般要求模式分解具有无损连接性（属性）与保持依赖性（函数依赖）

对于关系模式R， 有依赖集F ，若对R进行分解， 分解出来的多个关系模式，都有对应的函
数依赖集。

### 保持函数依赖
所谓的保持函数依赖就是将分解之后的函数依赖集合并起来（令其等于G），与原来的函数依赖集F是保持等价的，也就是我们就会说是保持函数依赖的。

判断函数依赖集等价公式为：G+（函数依赖集G的闭包） = F+（函数依赖集F的闭包）。注意：拆分前后的函数依赖集判断是否等价时，不需要考虑冗余依赖(如传递依赖) 。

闭包：说属性的闭包就是由一个属性直接或间接推导出的所有属性的集合。
例如： f={a->b,b->c,a->d,e->f} 由a可直接得到b和d，间接得到c，则a的闭包就是{a,b,c,d}，
可以写出a+={a,b,c,d}

完整的判断保持函数依赖的方法：
① 先求函数依赖集投影到分解后的Ri上的函数依赖子集Fi。
② 求分解后关系模式函数依赖集的并集，并令其等于G。
③ 判断F是否包含在G的闭包中。（此处不需要判断G是否包含在F的闭包中，因为G中的每个函数依赖都是由F根据Armstrong公理推导出来的，所以G必定包含于F闭包）

关系模式R(U,F),其中U={A,B,C,D},F={A→B,B→C,C→D,D→A},分解
ρ={R1(A,B),R2(B,C),R3(C,D)}是否具有函数依赖保持性?
解：
① 求函数依赖子集
F1 = πU1(F)=(A→B,B→A);
F2 = πU2(F)=(B→C,C→B);
F3 = πU3(F)=(C→D,D→C);
② 求分解后函数依赖的并集，令其等于G
G=F1∪F2∪F3={A→B,B→A,B→C,C→B,C→D,D→C};
F={A→B,B→C,C→D,D→A}。
③ 判断F是否包含在G的闭包中
经过初步观察，F中的{D->A}不包含在G中，但是通过求G的闭包后，也就是根据G中的依
赖集D->C，C->B，B->A，得出G中是包含{D->A}这个依赖的，所以F包含于G的闭包中。
因此，有G+=F+，即ρ具有函数依赖保持性。

### 无损连接分解

分解后的关系模式能够还原出原关系模式，就是无损连接分解 ，不能还原就是有损连接分解

如何判断是否无损连接？
公式法：判断分解为两个关系模式的情况：如果R 的分解为ρ={R1，R2} ，F为R所
满足的函数依赖集合，分解ρ具有无损连接性的充分必要条件是：R1∩R2->(R1- R2)或者R1∩R2->(R2-R1)。
表格法：当分解为三个及以上关系模式时 ， 可以通过表格法求解
![1](5.jpg)

![1](6.jpg)
## 反规范技术
反规范化技术：规范化设计后，会导致关系的概念愈来愈单一化，在查询时往往需要涉及更多表的关联操作，导致查询性能下降。数据库设计者希望牺牲部分规范化设计（比如对部分影响性能的关系模式进行处理，包括分解、合并、增加冗余属性等）来提高读操作性能 。
采用反规范化技术的益处：降低过多连接操作的需求、 降低外码和索引的数目，还可能减少表的数目，进而能够提高查询效率 。
采用反规范化技术的问题： 数据的重复存储， 浪费了磁盘空间； 可能出现数据的完整性问题 ， 为了保障数据的一致性， 增加了数据维护的复杂性， 会降低修改速度
## 并发控制