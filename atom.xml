<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>All-Nothing</title>
  
  <subtitle>Life has a funny way of working out, just when you start to believe it never will</subtitle>
  <link href="https://zypuu.github.io/atom.xml" rel="self"/>
  
  <link href="https://zypuu.github.io/"/>
  <updated>2024-06-03T09:11:29.919Z</updated>
  <id>https://zypuu.github.io/</id>
  
  <author>
    <name>ZYP</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GO的WaitGroup</title>
    <link href="https://zypuu.github.io/2024/04/20/GO%E7%9A%84WaitGroup/"/>
    <id>https://zypuu.github.io/2024/04/20/GO%E7%9A%84WaitGroup/</id>
    <published>2024-04-20T03:02:20.000Z</published>
    <updated>2024-06-03T09:11:29.919Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言中的WaitGroup类似Java的CountDownLatch，任务检查点，任务等待点，比如有一个主任务，执行到某一时刻需要执行两个子任务，主任务等待阻塞，两个子任务执行完毕后再执行主任务，这就需要一个任务阻塞检查点，等待子任务执行完毕</p><h3 id="WaitGroup使用"><a href="#WaitGroup使用" class="headerlink" title="WaitGroup使用"></a>WaitGroup使用</h3><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> createRand()</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> sumResult()</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> resultChan &#123;</span><br><span class="line">j := (*v).job</span><br><span class="line">s := (*v).sum</span><br><span class="line">fmt.Println(<span class="string">&quot;1111&quot;</span>, j, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建两个协程方法，产生随机数，计算结果，主线程等待计算结果后，再打印结果</p><p>一共有三个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(wg *WaitGroup) Add(delta int)</span><br><span class="line">(wg *WaitGroup) Done()</span><br><span class="line">(wg *WaitGroup) Wait()</span><br></pre></td></tr></table></figure><p><code>Add</code> 方法用于设置 WaitGroup 的计数值，可以理解为子任务的数量</p><p><code>Done</code> 方法用于将 WaitGroup 的计数值减一，可以理解为完成一个子任务</p><p><code>Wait</code> 方法用于阻塞调用者，直到 WaitGroup 的计数值为0，即所有子任务都完成</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="WaitGroup结构"><a href="#WaitGroup结构" class="headerlink" title="WaitGroup结构"></a>WaitGroup结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy <span class="comment">// noCopy 字段标识，由于 WaitGroup 不能复制，方便工具检测</span></span><br><span class="line">    state1 [<span class="number">3</span>]<span class="keyword">uint32</span>  <span class="comment">// 12个字节，8个字节标识 计数值和等待数量，4个字节用于标识信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>state1 是个复合字段，会拆分为两部分： 64位（8个字节）的 statep 作为一个整体用于原子操作, 其中前面4个字节表示计数值，后面四个字节表示等待数量；剩余 32位（4个字节）semap 用于标识信号量。</p><p>Go语言中对于64位的变量进行原子操作，需要保证该变量是 64位对齐 的，也就是要保证这 8个字节 的首地址是 8 的整数倍。因此当 state1 的首地址是 8 的整数倍时，取前8个字节作为 statep ，后4个字节作为 semap；当 state1 的首地址不是 8 的整数倍时，取后8个字节作为 statep ，前4个字节作为 semap。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">state</span><span class="params">()</span> <span class="params">(statep *<span class="keyword">uint64</span>, semap *<span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 首地址是8的倍数时，前8个字节为 statep, 后四个字节为 semap</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="number">2</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 后8个字节为 statep, 前四个字节为 semap  </span></span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), &amp;wg.state1[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到计数值等待者变量 statep 和 信号量 semap</span></span><br><span class="line">    statep, semap := wg.state()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数值加上 delta: statep 的前四个字节是计数值，因此将 delta 前移 32位</span></span><br><span class="line">    state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数值</span></span><br><span class="line">    v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待者数量</span></span><br><span class="line">    w := <span class="keyword">uint32</span>(state)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果加上 delta 之后，计数值变为负数，不合法，panic</span></span><br><span class="line">    <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delta &gt; 0 &amp;&amp; v == int32(delta) : 表示从 0 开始添加计数值</span></span><br><span class="line">    <span class="comment">// w!=0 ：表示已经有了等待者</span></span><br><span class="line">    <span class="comment">// 说明在添加计数值的时候，同时添加了等待者，非法操作。添加等待者需要在添加计数值之后</span></span><br><span class="line">    <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="keyword">int32</span>(delta) &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v&gt;0 : 计数值不等于0，不需要唤醒等待者，直接返回</span></span><br><span class="line">    <span class="comment">// w==0: 没有等待者，不需要唤醒，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查数据是否一致</span></span><br><span class="line">    <span class="keyword">if</span> *statep != state &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里说明计数值为0，且等待者大于0，需要唤醒所有的等待者，并把系统置为初始状态（0状态）</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将计数值和等待者数量都置为0</span></span><br><span class="line">    *statep = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒等待者</span></span><br><span class="line">    <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">        runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完成一个任务，将计数值减一，当计数值减为0时，需要唤醒所有的等待者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Add 方法用于添加一个计数值（负数相当于减），当计数值变为0后， Wait 方法阻塞的所有等待者都会被释放，计数值变为负数是非法操作，产生 panic，当计数值为0时（初始状态），Add 方法不能和 Wait 方法并发调用，需要保证 Add 方法在 Wait 方法之前调用，否则会 panic</p><h4 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 Wait 方法会被阻塞，直到 计数值 变为0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取计数、等待数和信号量</span></span><br><span class="line">    statep, semap := wg.state()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := atomic.LoadUint64(statep)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数值</span></span><br><span class="line">        v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待者数量</span></span><br><span class="line">        w := <span class="keyword">uint32</span>(state)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数值数量为0，直接返回，无需等待</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里说明计数值数量大于0</span></span><br><span class="line">        <span class="comment">// 增加等待者数量：这里会有竞争，比如多个 Wait 调用，或者在同时调用 Add 方法，增加不成功会继续 for 循环</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 增加成功后，阻塞在信号量这里，等待被唤醒</span></span><br><span class="line">            runtime_Semacquire(semap)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 被唤醒的时候，应该是0状态。如果重用 WaitGroup，需要等 Wait 返回</span></span><br><span class="line">            <span class="keyword">if</span> *statep != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>根据源码分析，我们可以得到如何使用waitGroup可以避免panic：</p><p>1、保证 Add 在 Wait 前调用</p><p>2、Add 中不传递负数</p><p>3、任务完成后不要忘记调用 Done 方法，建议使用 defer wg.Done()</p><p>4、不要复制使用 WaitGroup，函数传递时使用指针传递</p><p>5、尽量不复用 WaigGroup，减少出问题的风险</p>]]></content>
    
    
    <summary type="html">GO的WaitGroup用法，以及源码分析，以及使用注意事项</summary>
    
    
    
    <category term="GO" scheme="https://zypuu.github.io/categories/GO/"/>
    
    
    <category term="GO" scheme="https://zypuu.github.io/tags/GO/"/>
    
  </entry>
  
  <entry>
    <title>未来信息综合技术</title>
    <link href="https://zypuu.github.io/2024/04/18/%E6%9C%AA%E6%9D%A5%E4%BF%A1%E6%81%AF%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/"/>
    <id>https://zypuu.github.io/2024/04/18/%E6%9C%AA%E6%9D%A5%E4%BF%A1%E6%81%AF%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/</id>
    <published>2024-04-18T02:29:00.000Z</published>
    <updated>2024-06-03T09:11:30.084Z</updated>
    
    <content type="html"><![CDATA[<h3 id="信息物理系统CPS"><a href="#信息物理系统CPS" class="headerlink" title="信息物理系统CPS"></a>信息物理系统CPS</h3><p>信息物理系统(CPS)是控制系统、嵌入式系统的扩展与延伸，其涉及的相关底层理论技术源于对嵌入式技术的应用与提升。CPS的核心概念是将数字和物理系统融合在一起，以实现更好的协同工作和决策</p><p>CPS的体系架构</p><p>单元级CPS：是具有不可分割性的CPS最小单元，是具备可感知、可计算、可交互、可延展、自决策功能的CPS最小单元，一个智能部件、一个工业机器人或一个智能机床都可能是一个CPS最小单元。</p><p>系统级CPS：多个最小单元(单元级)通过工业网络(如工业现场总线、工业以太网等)，实现更大范围、更宽领域的数据自动流动，实现了多个单元级CPS的互联、互通和互操作，进一步提高制造资源优化配置的广度、深度和精度。包含互联互通、即插即用、边缘网关、数据互操作、协同控制、监视与诊断等功能。</p><p>SoS级：多个系统级CPS的有机组合构成SoS级CPS。比如在一个智能城市中，多个系统级CPS（例如交通管理系统、能源管理系统、环境监测系统）可以组成SoS级CPS。这些系统级CPS共享数据</p><p>CPS的技术体系</p><p>CPS技术体系主要分为：CPS总体技术、CPS支撑技术、CPS核心技术。</p><p>CPS总体技术就是CPS的顶层设计技术，主要包括：系统架构、异构系统集成、安全技术、试验验证技术等</p><p>CPS支撑技术就是基于CPS应用的支撑技术，主要包括：智能感知、嵌入式软件、数据库、人机交互、中间件、SDN(软件定义网络)、物联网、大数据等</p><p>CPS核心技术就是是CPS的基础技术，主要包括：虚实融合控制、智能装备、MBD、数字孪生技术、现场总线、工业以太网、</p><p>CAX\MES\ERP\PLM\CRM\SCM等</p><p>上述技术体系可以分为四大核心技术要素即“一硬”(感知和自动控制)、“一软”(工业软件)、“一网”(工业网络)，“一平台”(工业云和智能服务平台)，工业云和智能服务平台是CPS 数据汇聚和支撑上层解决方案的基础，对外提供资源管控和能力服务。</p><p>CPS的典型应用场景：智能设计，智能生产，智能服务，智能应用</p><p>CPS建设路径：CPS体系设计、单元级CPS建设、系统级CPS建设和SoS级CPS建设阶段</p><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p>人工智能(Al)是利用数字计算机或者数字计算机控制的机器模拟、延伸和扩展人的智能，感知环境、获取知识并使用知识获得最佳结果的理论、方法、技术及应用系统。</p><p>人工智能的目标是了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器。该领域的研究包括机器人、自然语言处理、计算机视觉和专家系统等。</p><p>人工智能关键技术：</p><p>自然语言处理(NLP)，计算机视觉，知识图谱，人机交互(HCI)，虚拟现实或增强现实(VR/AR)，</p><p>机器学习(ML)。是以数据为基础，通过研究样本数据寻找规律，并根据所得规律对未来数据进行预测</p><p>按照学习模式的不同，机器学习可分为监督学习、无监督学习、半监督学习、强化学习。其中，监督学习需要提供标注的样本集，无监督学习不需要提供标注的样本集，半监督学习需要提供少量标注的样本，而强化学习需要反馈机制。</p><p>按照学习方法的不同，机器学习可分为传统机器学习和深度学习。区别在于，传统机器学习的领域特征需要手动完成，且需要大量领域专业知识；深度学习不需要人工特征提取，但需要大量的训练数据集以及强大的GPU服务器来提供算力。</p><p>传统机器学习从一些观测(训练)样本出发，试图发现不能通过原理分析获得的规律，实现对未来数据行为或趋势的准确预测</p><p>深度学习是一种基于多层神经网络并以海量数据作为输入规则的自学习方法，依靠提供给它的大量实际行为数据(训练数据集)，进行参数和规则调整</p><h3 id="机器人"><a href="#机器人" class="headerlink" title="机器人"></a>机器人</h3><p>机器人技术已经准备进入4.0时代。所谓机器人4.0时代，就是把云端大脑分布在各个地方，充分利用边缘计算的优势，提供高性价比的服务，把要完成任务的记忆场景的知识和常识很好地组合起来，实现规模化部署。特别强调机器人除了具有感知能力实现智能协作，还应该具有一定的理解和决策能力，进行更加自主的服务</p><p>机器人4.0的核心技术：云-边-端的无缝协同计算，持续学习与协同学习，知识图谱，场景自适应，数据安全</p><h3 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h3><p>边缘计算是一种分布式计算模型，其中计算资源和数据存储被放置在物理世界的边缘，靠近数据源和终端设备，以降低延迟、提高性能，并更好地满足实时性要求</p><p>边缘计算的业务本质是云计算在数据中心之外汇聚节点的延伸和演进，主要包括云边缘、边缘云和云化网关三类落地形态；以“边云协同”和“边缘智能”为核心能力发展方向</p><p>边缘计算具有以下特点：</p><p>联接性：联接性是边缘计算的基础。所联接物理对象的多样性及应用场景的多样性，需要边缘计算具备丰富的联接功能。</p><p>数据第一入口：边缘计算作为物理世界到数字世界的桥梁，是数据的第一入口，拥有大量、实时、完整的数据，可基于数据全生命周期进行管理与价值创造，将更好的支撑预测性维护、资产效率与管理等创新应用。</p><p>约束性：边缘计算产品需适配工业现场相对恶劣的工作条件与运行环境，如防电磁、防尘.防爆、抗振动、抗电流/电压波动等。在工业互联场景下，对边缘计算设备的功耗、成本、空间也有较高的要求。</p><p>分布性：边缘计算实际部署天然具备分布式特征。这要求边缘计算支持分布式计算与存储、实现分布式资源的动态调度与统一管理、支撑分布式智能、具备分布式安全等能力</p><p>边云协同：边缘计算与云计算各有所长，云计算擅长全局性、非实时、长周期的大数据处理与分析，能够在长周期维护、业务决策支撑等领域发挥优势：边缘计算更适用局部性、实时、短周期数据的处理与分析，能更好地支撑本地业务的实时智能化决策与执行。</p><p>边缘计算既靠近执行单元，更是云端所需高价值数据的采集和初步处理单元，可以更好地支撑云端应用，而云计算则是通过大数据分析优化输出的业务规则或模型可以下发到边缘侧，边缘计算基于新的业务规则或模型运行，两者相辅相成，主要包括六种协同：</p><p>资源协同：边缘节点提供计算、存储、网络、虚拟化等基础设施资源、具有本地资源调度管理能力，同时可与云端协同，接受并执行云端资源调度管理策略，包括边缘节点的设备管理、资源管理以及网络连接管理。</p><p>数据协同：边缘节点主要负责现场/终端数据的采集，按照规则或数据模型对数据进行初步处理与分析，并将处理结果以及相关数据上传给云端：云端提供海量数据的存储、分析与价值挖掘。</p><p>智能协同：边缘节点按照A模型执行推理，实现分布式智能；云端开展AI 的集中式模型训练，并将模型下发边缘节点。</p><p>应用管理协同：边缘节点提供应用部署与运行环境，并对本节点多个应用的生命周期进行管理调度：云端主要提供应用开发、测试环境，以及应用的生命周期管理能力。</p><p>业务管理协同：边缘节点提供模块化、微服务化的应用/数字孪生/网络等应用实例：云端主要提供按照客户需求实现应用、数字孪生、网络等的业务编排能力。</p><p>服务协同：边缘节点按照云端策略实现部分ECSaaS服务，通过ECSaas与云端Saas的协同实现面向客户的按需Saas服务：云端主要提供Saas服务在云端和边缘节点的服务分布策略，以及云端承担的Saas服务能力。 </p><p>边缘计算的应用场合(既有中央控制中心，又有分支设备)：智慧园区、安卓云与云游戏、视频监控、工业互联网、智慧医疗。</p><p>边云协同架构通常包括以下几层：</p><p>• 边缘层：位于网络边缘，负责收集数据、进行初步处理和存储。</p><p>• 雾层：位于边缘层和云层之间，负责数据的聚合、转发和处理。</p><p>• 云层：位于网络中心，负责提供强大的计算、存储和网络资源。</p><p>边云协同架构设计面临以下几个挑战：</p><p>• 异构性：边缘设备、网络和云平台存在异构性，需要统一管理和调度。</p><p>• 延迟：边缘计算需要满足低延迟要求，需要优化网络架构和数据处理流程。</p><p>• 安全性：边云协同系统需要保障数据安全和隐私。</p><p>针对上述挑战，可以采取以下解决方案：</p><p>• 虚拟化：将边缘计算资源虚拟化，以便于统一管理和调度。</p><p>• 容器化：将应用打包成容器，以便于在不同平台上部署和运行。</p><p>• 微服务：将应用拆解成微服务，以便于弹性扩展和故障处理。</p><p>• 软件定义网络 (SDN)：使用 SDN 技术可以灵活控制网络流量，降低延迟。</p><p>• 安全技术：使用安全技术保障数据安全和隐私，例如加密、身份认证、访问控制等</p><h3 id="数字孪生体"><a href="#数字孪生体" class="headerlink" title="数字孪生体"></a>数字孪生体</h3><p>数字孪生体技术是跨层级、跨尺度的现实世界和虚拟世界建立沟通的桥梁。</p><p>数字孪生体是现有或将有的物理实体对象的数字模型，通过实测、仿真和数据分析来实时感知、诊断、预物理实体对象的状态，通过优化和指令来调控物理实体对象的行为，通过相关数字模型间的相互学习来进化自身，同时改进利益相关方在物理实体对象生命周期内的决策</p><p>关键技术：</p><p>建模。建模的目的是将我们对物理世界的理解进行简化和模型化</p><p>仿真。是将包含了确定性规律和完整机理的模型转化成软件的方式来模拟物理世界的一种技术。只要模型正确，并拥有了完整的输入信息和环境数据，就可以基本准确地反映物理世界的特性和参数。</p><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><p>云计算概念的内涵包含两个方面：平台和应用</p><p>云计算的服务方式</p><p>基础设施即服务(laaS)。在laaS模式下，服务提供商将多台服务器组成的“云端”基础设施作为计量服务提供给客户。具体来说，服务提供商将内存、IO设备、存储和计算能力等整合为一个虚拟的资源池，为客户提供所需要的存储资源、虚拟化服务器等服务。比如选择云端的不同配置的服务器</p><p>平台即服务(PaaS)。在PaaS模式下，服务提供商将分布式开发环境与平台作为一种服务来提供。这是一种分布式平台服务，厂商提供开发环境、服务器平台、硬件资源等服务给客户，客户在服务提供商平台的基础上定制开发自己的应用程序，并通过其服务器和互联网传递给其他客户。比如在线编程、在线办公软件</p><p>软件即服务(Saas)。在Saas的服务模式下，服务提供商将应用软件统一部署在云计算平台上，客户根据需要通过互联网向服务提供商订购应用软件服务，服务提供商根据客户所订购软件的数量、时间的长短等因素收费，并且通过标准浏览器、向客户提供应用服务。比如百度云盘之类的</p><p>三者比较：</p><p>在灵活性方面, Saas &lt;PaaS &lt;laas灵活性依次增强。</p><p>在方便性方面, laas &lt;PaaS&lt;Saas方便性依次增强。</p><p>部署方式：</p><p>公有云。在公有云模式下，云基础设施是公开的，可以自由地分配给公众。企业、学术界与政府机构都可以拥有和管理公用云，并实现对公有云的操作。公有云能够以低廉的价格为最终用户提供有吸引力的服务，创造新的业务价值。</p><p>社区云。在社区云模式下，云基础设施分配给一些社区组织所专有，这些组织共同关注任务、安全需求、政策等信息。云基础设施被社区内的一个或多个组织所拥有、管理及操作。“社区云”是”公有云”范畴内的一个组成部分。</p><p>私有云。在私有云模式下，云基础服务设施分配给由多种用户组成的单个组织。它可以被这个组织或其他第三方组织所拥有、管理及操作。</p><p>混合云。混合云是公有云、私有云和社区云的组合。由于安全和控制原因，并非所有的企业信息都能放置在公有云上，因此企业将会使用混合云模式。</p><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><p>大数据的特点：大规模、高速度、多样化、可变性、复杂性等</p><p>大数据分析的分析步骤，大致分为数据获取╱记录、信息抽取/清洗/注记、数据集成/聚集/表现、数据分析/建模和数据解释5个主要阶段。</p><p>大数据的应用领域：制造业、服务业、交通行业、医疗行业</p><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>区块链是一种分布式数据库技术，以区块的形式按时间顺序链接在一起，形成了一个不断增长的、不可篡改的记录链</p><p>它的核心特性包括：</p><p>• 去中心化：区块链的数据不存储在单一的中心服务器上，而是分布在网络的各个节点上，每个节点都有该链的完整副本。这意味着没有一个中心机构能够控制或篡改整个数据库。</p><p>• 不可篡改性：一旦数据被写入区块链，就几乎不可能被修改或删除。这是因为每个区块都包含了前一个区块的哈希值，形成了一个不可逆的链条结构，任何篡改都会立即被其他节点检测出来。</p><p>• 透明性：区块链中的数据是公开可见的，所有参与者都可以查看和验证数据，从而增加了数据的透明度和可信度。</p><p>• 安全性：区块链使用了加密技术确保数据的安全性，使得交易和信息在传输和存储过程中更加安全可靠。</p><p>• 智能合约：智能合约是基于区块链的自动化合约，能够自动执行合约条款，无需中介机构，提高了交易的效率和可靠性</p><p>区块链的原理：</p><p>• 安全性：区块链的安全性是建立在密码学原理上的，包括哈希函数、非对称加密等技术，确保数据的完整性和不可篡改性。</p><p>• 共识机制：共识机制确保了网络中各个节点对交易记录的一致性认可，从而防止了双重支付等问题。</p><p>• 分布式存储：区块链采用分布式存储方式，数据存储在多个节点上，避免了单点故障和数据丢失的风险。</p><p>• 智能合约：智能合约是一种在区块链上执行的自动化合约，其中包含了预先编写好的代码逻辑，可以自动执行合约条款</p>]]></content>
    
    
    <summary type="html">未来信息综合技术</summary>
    
    
    
    <category term="系统架构设计" scheme="https://zypuu.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="架构" scheme="https://zypuu.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构的演化和维护</title>
    <link href="https://zypuu.github.io/2024/04/18/%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8C%96%E5%92%8C%E7%BB%B4%E6%8A%A4/"/>
    <id>https://zypuu.github.io/2024/04/18/%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8C%96%E5%92%8C%E7%BB%B4%E6%8A%A4/</id>
    <published>2024-04-18T01:48:00.000Z</published>
    <updated>2024-06-03T09:11:30.084Z</updated>
    
    <content type="html"><![CDATA[<h3 id="架构演化"><a href="#架构演化" class="headerlink" title="架构演化"></a>架构演化</h3><p>软件架构的演化和维护就是对架构进行修改和完善的过程，目的就是为了使软件能够适应环境的变化而进行的纠错性修改和完善性修改等，是一个不断迭代的过程，直至满足用户需求</p><p>软件架构的演化就是软件整体结构的演化，演化过程涵盖软件架构的全生命周期，包括软件架构需求的获取、软件架构建模、软件架构文档、软件架构实现以及软件架构维护等阶段。</p><p>一是架构是整个系统的骨架，是软件系统具备诸多好的特性的保障;二是软件架构作为软件蓝图为人们宏观管控软件系统的整体复杂性和变化性提供了一条有效途径</p><p>软件架构的定义包含组件、连接件、约束三大要素，这类软件架构演化主要关注的就是这三者之间的添加、修改和删除等</p><h3 id="面向对象架构演化"><a href="#面向对象架构演化" class="headerlink" title="面向对象架构演化"></a>面向对象架构演化</h3><p>面向对象软件架构演化主要分为以下四种演化：对象演化、消息演化、复合片段演化和约束演化</p><p>对象演化：在顺序图中，组件的实体是对象，会对架构设计的动态行为产生影响的演化只包括Add Object (AO)和DeleteObject(DO)两种。</p><p>消息演化：将消息演化分为AddMessage(AM)、 DeleteMessage (DM)、SwapMessageOrder (SMO)、OverturnMessage(OM)、ChangeMessageModule (CMM)5种。</p><p>复合片段演化：复合片段是对象交互关系的控制流描述，表示可能发生在不同场合的交互，与消息同属于连接件范畴。复合片段的演化分为AddFragment (AF)、Deletefragment(DF)、FragmentTypeChange (FTC)和FragmentConditionChange (FCC)。</p><p>约束演化：顺序图中的约束信息以文字描述的方式存储于对象或消息中，约束演化就是直接对约束信息进行添加和删除。</p><h3 id="演化分类"><a href="#演化分类" class="headerlink" title="演化分类"></a>演化分类</h3><p>针对软件架构的演化过程是否处于系统运行时期，可以将软件架构演化分为静态演化和动态演化</p><p>软件架构的演化时期包括：设计时演化、运行前演化、有限制运行时演化、运行时演化</p><p>软件架构静态演化主要是在设计时演化以及运行前演化。与此相对应的维护方法有<strong>3类：更正性维护、适应性维护和完善性维护</strong>。</p><p>动态演化是在系统运行期间的演化，需要在不停止系统功能的情况下完成演化，较之静态演化更加困难。具体发生在有限制的运行时演化和运行时演化阶段。</p><p>软件的动态性分为3个级别：</p><p>交互动态性，要求数据在固定的结构下动态交互;</p><p>结构动态性，允许对结构进行修改，通常的形式是组件和连接件实例的添加和删除，这种动态性是研究和应用的主流;</p><p>架构动态性，允许软件架构的基本构造的变动，即结构可以被重定义，如新的组件类型的定义。</p><p>目前，实现软件架构动态演化的技术主要有两种：采用动态软件架构(DSA)和进行动态重配置(DR)。</p><p>DSA是指在运行时刻会发生变化的系统框架结构，允许在运行过程中通过框架结构的动态演化实现对架构的修改;</p><p>DR从组件和连接件的配置入手，允许在运行过程中增删组件，增删连接件，修改连接关系等操作。</p><p>系统必须提供SA动态演化的一些相关功能：保存当前软件架构信息的功能、设置监控机制监视系统有无需求变化、保证演化操作原子性。</p><p>DSA实施动态演化大体遵循以下4步：①捕捉并分析需求变化；②获取或生成体系结构演化策略；③根据步骤2得到的演化策略，选择适</p><p>当的演化策略并实施演化；④演化后的评估与检测。</p><p>动态重配置模式：主从模式、中央控制模式、客户端/服务器模式、分布式控制模式</p><h3 id="演化评估"><a href="#演化评估" class="headerlink" title="演化评估"></a>演化评估</h3><p>演化过程己知的评估（正向）和演化过程未知的评估（逆向）</p><p>演化过程己知的评估其目的在于通过对架构演化过程进行度量，比较架构内部结构上的差异以及由此导致的外部质量属性上的变化，对该演化过程中相关质量属性进行评估。</p><p>基于度量的架构演化评估方法，其基本思路在于通过对演化前后的软件架构进行度量，比较架构内部结构上的差异以及由此导致的外部质量属性上的变化。具体包括：架构修改影响分析、监控演化过程、分析关键演化过程。</p><p>当演化过程未知时，我们无法像演化过程已知时那样追踪架构在演化过程中的每一步变化，只能根据架构演化前后的度量结果逆向推测出架构发生了哪些改变，并分析这些改变与架构相关质量属性的关联关系。</p><h3 id="架构维护"><a href="#架构维护" class="headerlink" title="架构维护"></a>架构维护</h3><p>软件架构维护过程一般涉及架构知识管理、架构修改管理和架构版本管理</p>]]></content>
    
    
    <summary type="html">架构的演化和维护</summary>
    
    
    
    <category term="系统架构设计" scheme="https://zypuu.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="架构" scheme="https://zypuu.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>质量属性和架构评估</title>
    <link href="https://zypuu.github.io/2024/04/17/%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/"/>
    <id>https://zypuu.github.io/2024/04/17/%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/</id>
    <published>2024-04-17T02:10:00.000Z</published>
    <updated>2024-06-03T09:11:30.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="软件系统属性-质量属性"><a href="#软件系统属性-质量属性" class="headerlink" title="软件系统属性-质量属性"></a>软件系统属性-质量属性</h3><p>软件系统属性包括功能属性和质量属性，软件架构重点关注的是质量属性</p><p>架构的基本需求是在满足功能属性的前提下，关注软件系统质量属性，为了精确、定量地表达系统的质量属性，通常会采用<strong>质量属性场景</strong>的方式进行描述。在确定软件系统架构，精确描述质量属性场景后，就需要对<strong>系统架构进行评估。软件系统架构评估是在对架构分析、评估的基础上，对架构策略的选取进行决策</strong>。它也可以灵活地运用于软件架构评审等工作</p><p>软件系统质量属性 (Quality Attribute) 是一个系统的可测量或者可测试的属性</p><p>软件系统质量属性是指软件系统满足用户需求的程度，是衡量软件系统质量的重要指标。</p><p>基于软件系统的生命周期，可以将软件系统的质量属性分为开发期质量属性和运行期质量属性2个部分</p><p>开发期质量属性主要指在<strong>软件开发阶段所关注的质量属性，这个阶段关注人群主要是开发者</strong></p><p>易理解性：指设计被开发人员理解的难易程度。</p><p>可扩展性：软件因适应新需求或需求变化而增加新功能的能力，也称为灵活性。</p><p>可重用性：指重用软件系统或某一部分的难易程度。</p><p>可测试性：对软件测试以证明其满足需求规范的难易程度。</p><p>可维护性：当需要修改缺陷、增加功能、提高质量属性时，识别修改点并实施修改的难易程度。</p><p>可移植性：将软件系统从一个运行环境转移到另一个不同的运行环境的难易程度。</p><p>运行期质量属性主要指在<strong>软件运行阶段所关注的质量属性，这个阶段关注人群主要是用户</strong></p><p>性能：性能是指软件系统及时提供相应服务的能力，如速度、吞吐量和容量等的要求。</p><p>安全性：指软件系统同时兼顾向合法用户提供服务，以及阻止非授权使用的能力。</p><p>可伸缩性：指当用户数和数据量增加时，软件系统维持高服务质量的能力。例如，通过增加服务器来提高能力。</p><p>互操作性：指本软件系统与其他系统交换数据和相互调用服务的难易程度。</p><p>可靠性：软件系统在一定的时间内持续无故障运行的能力。</p><p>可用性：指系统在一定时间内正常工作的时间所占的比例。可用性会受到系统错误，恶意攻击，高负载等问题的影响。</p><p>鲁棒性：是指软件系统在非正常情况(用户进行了非法操作、相关软硬件系统发生了故障)下仍能够正常运行的能力，也称健壮性或容性。</p><h4 id="质量属性"><a href="#质量属性" class="headerlink" title="质量属性"></a>质量属性</h4><ol><li>性能：指系统的响应能力，即要经过多长时间才能对某个事件做出响应，或者在某段时间内系统所能处理的事件的个数。如响应时间、吞吐量。</li></ol><p>设计策略：优先级队列、增加计算资源、减少计算开销、引入并发机制、采用资源调度等。</p><ol start="2"><li>可靠性：是指系统在一段时间内保持正常运行而不发生故障的能力。它强调了系统的稳定性和可靠性，通常是通过衡量系统在一段时间内发生故障的概率来评估的。一个可靠性高的系统意味着它很少出现故障，用户可以信任它的稳定性。可靠性有一些指标需要了解。如MTTF(平均无故障时间)、MTBF(平均故障间隔时间)、MTTR(平均故障修复时间)。MTBF=MTTF+MTTR</li></ol><p>设计策略：心跳、Ping/Echo、冗余、选举</p><ol start="3"><li>可用性：是指系统在需要的时候可供使用的能力，即系统处于可操作状态的时间比例。可用性通常通过计算系统在一定时间内可操作的百分比来评估。一个高可用性的系统意味着它在大部分时间内都是可用的，用户可以随时访问和使用它。</li></ol><p>设计策略：心跳、Ping/Echo、冗余、选举。</p><p>可靠性强调系统不发生故障，而可用性强调系统在需要时可供使用。两者都是衡量系统性能和质量的重要标准，但它们关注的方面略有不同</p><ol start="4"><li>安全性：是指系统在向合法用户提供服务的同时能够阻止非授权用户使用的企图或拒绝服务的能力。如保密性、完整性、不可抵赖性、可控性。</li></ol><p>设计策略：入侵检测、用户认证、用户授权、追踪审计。</p><ol start="5"><li>可修改性：指能够快速的以较高的性能价格比对系统进行变更的能力。通常以某些具体的变更为基准，通过考察这些变更的代价衡量。</li></ol><p>设计策略：接口-实现分类、抽象、信息隐藏（是不是感觉有点像结构化开发和面向对象开发的设计原则）。</p><ol start="6"><li><p>功能性：是系统所能完成所期望的工作的能力。一项任务的完成需要系统中许多或大多数构件的相互协作。</p></li><li><p>可变性（可扩展）：指体系结构经扩充或变更而成为新体系结构的能力。这种新体系结构应该符合预先定义的规则，在某些具体方面不同于原有的体系结构。当要将某个体系结构作为一系列相关产品的基础时，可变性是很重要的。</p></li><li><p>互操作性：作为系统组成部分的软件不是独立存在的，经常与其他系统或自身环境相互作用。为了支持互操作性，软件体系结构必须为外部可视的功能特性和数据结构提供精心设计的软件入口。程序和用其他编程语言编写的软件系统的交互作用就是互操作性的问题，也影响应用的软件体系结构。</p></li><li><p>易用性：它关注的是软件系统的用户界面和交互设计，以确保用户能够轻松、高效地使用系统，并感到满意。易用性不仅关乎用户界面的外观，还包括用户体验、交互流程和用户学习曲线等方面</p></li></ol><h4 id="质量场景描述"><a href="#质量场景描述" class="headerlink" title="质量场景描述"></a>质量场景描述</h4><p>通常采用质量属性场景 (Quality Attribute Scenario) 作为描述质量属性的手段。质量属性场景是一个具体的质量属性需求，是利益相关者与系统的交互的简短陈述。</p><p>质量属性场景是一种用于描述系统如何满足特定质量属性需求的情境或情景。它由6部分组成：</p><p>刺激源(谁)：这是某个生成该刺激的实体(人、计算机系统或者任何其他刺激器)。</p><p>刺激(做什么)：该刺激是当刺激到达系统时需要考虑的条件。</p><p>环境(在什么样的环境下)∶该刺激在某些条件内发生。当激励发生时，系统可能处于过载、运行或者其他情况。</p><p>制品(对哪个功能)：某个制品被激励。这可能是整个系统，也可能是系统的一部分。</p><p>响应(得到什么反馈)：该响应是在激励到达后所采取的行动。</p><p>响应度量(对反馈进行度量)︰当响应发生时，应当能够以某种方式对其进行度量，以对需求进行测试。</p><h3 id="系统架构评估"><a href="#系统架构评估" class="headerlink" title="系统架构评估"></a>系统架构评估</h3><p>敏感点：是指为了实现某一种特定的质量属性，一个或多个构件所具有的特性。</p><p>权衡点：是影响多个质量属性的特性，是多个质量属性的敏感点</p><p>软件架构评估在架构设计之后，系统设计之前，因此与设计、实现、测试都没有关系。评估的目的是为了评估所采用的架构是否能解决软件系统需求</p><h4 id="评估方式"><a href="#评估方式" class="headerlink" title="评估方式"></a>评估方式</h4><p>1 . 基于调查问卷(检查表)的方式</p><p>2、基于度量的方式</p><p>3、基于场景的方式</p><h4 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h4><h5 id="基于场景的架构分析方法SAAM"><a href="#基于场景的架构分析方法SAAM" class="headerlink" title="基于场景的架构分析方法SAAM"></a>基于场景的架构分析方法SAAM</h5><p>SAAM是一种非功能质量属性的架构分析方法，是最早形成文档并得到广泛应用的软件架构分析方法。针对可修改性</p><p>SAAM的主要输入是问题描述、需求声明和架构描述</p><h5 id="架构权衡分析法ATAM"><a href="#架构权衡分析法ATAM" class="headerlink" title="架构权衡分析法ATAM"></a>架构权衡分析法ATAM</h5><p>是一种系统架构评估方法，主要在系统开发之前，<strong>针对性能、可用性、安全性和可修改性等质量属性</strong>进行评价和折中，让架构师明确如何权衡多个质量目标，参与者有评估小组、项目决策者和其他项目相关人</p><p>ATAM被分为四个主要的活动领域,分别是</p><p>场景和需求收集、体系结构（架构）视图和场景实现、属性模型构造和分析以及架构评审与折中。</p><p>整个评估过程强调以属性(质量属性)作为架构评估的核心概念</p><p>ATAM 方法采用效用树 (Utility tree) 这一工具来对质量属性进行分类和优先级排序。效用树的结构包括：树根—质量属性—属性分类—质量属性场景(叶子节点)</p><p>得到初始的效用树后，需要修剪这棵树，保留重要场景(通常不超过50个),再对场景按重要性给定优先级(用 H/M/L 的形式),再按场景实现的难易度来确定优先级(用 H/M/L的形式),这样对所选定的每个场景就有一个优先级对(重要度、难易度),如 (H、L) 表示该场景重要且易实现。</p><p>ATAM的阶段解释：</p><p><strong>1 .</strong> <strong>描述和介绍阶段：</strong></p><p>目标： 此阶段的目标是收集相关架构材料，定义评估的目标和评估的软件架构，明确要优化的质量属性以及介绍ATAM方法的步骤和原则。</p><p>活动： 在这个阶段，评估团队会与项目干系人一起定义评估的目标，确定评估的软件架构，并收集架构文档和相关信息。团队还会介绍ATAM方法的步骤，以确保所有参与者了解评估的过程。</p><p>示例： 对于电子商务网站的架构评估，评估团队会与项目干系人合作，确定评估的目标是提高性能和安全性。他们收集有关网站架构的文档，如架构图和设计文档。</p><p><strong>2.</strong> <strong>调查和分析阶段：</strong></p><p>目标： 此阶段的目标是确定架构方法，分析架构并评估这些架构方法对质量属性的影响，同时识别潜在的问题和权衡决策。</p><p>活动： 在这个阶段，评估团队会定义架构方法，分析不同的架构设计，生成质量属性效应树以表示不同决策对质量属性的影响。他们还会识别潜在的问题和决策权衡。</p><p>产出： 在此阶段，<strong>产出质量属性效应树</strong>（Quality Attribute Utility Tree），用于表示不同架构决策对质量属性的影响以及它们之间的权衡关系。</p><p>示例： 对于电子商务网站的架构评估，评估团队会定义不同的架构决策，如引入缓存或增加服务器资源。他们生成质量属性效应树，以分析这些决策对性能和安全性的影响。</p><p><strong>3.</strong> <strong>测试阶段：</strong></p><p>目标： 测试阶段旨在验证架构是否满足质量属性需求。</p><p>活动： 团队创建测试用例来模拟质量属性场景，包括性能测试、安全性测试等。他们运行这些测试用例，测量系统的性能和行为，并记录测试结果。在此阶段，评估团队讨论各种质量属性场景，对它们进行分级，以确定哪些场景对系统的关键性最高。团队还会分析不同的架构方法，以确定哪种方法最有可能满足关键场景的需求。最后，项目干系人会对不同的架构方法和场景分级进行投票，以帮助团队确定最佳的架构方案。</p><p>示例： 评估团队可能会讨论电子商务网站的性能、可伸缩性和安全性场景，分级它们的重要性，并分析引入缓存或增加服务器资源等不同架构方法的影响。项目干系人会进行投票，以选择最合适的架构方法。</p><p><strong>4.</strong> <strong>报告阶段：</strong></p><p>目标： 报告阶段的目标是总结评估的结果、提供改进建议，并为决策者提供决策依据。</p><p>活动： 团队生成ATAM评估报告，其中包括评估的发现、性能数据、可能的改进建议以及权衡决策。报告应该清晰地传达关键信息，以便决策者可以做出明智的架构决策。</p><p>示例： 电子商务网站的评估报告可能包括性能测试结果、安全性评估、建议的架构改进，以及与质量属性场景相关的权衡决策。报告将提供给项目管理团队，以指导后续的架构决策和改进。</p><h5 id="成本效益分析法CBAM"><a href="#成本效益分析法CBAM" class="headerlink" title="成本效益分析法CBAM"></a>成本效益分析法CBAM</h5><p>用来对架构建立的成本来进行设计和建模，让决策者根据投资收益率来选择合适的架构，可以看做对ATAM的补充，在ATAM确定质量合理的基础上，再对效益进行分析</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>在一个分布式系统环境中处于操作系统和应用程序之间的软件，可以在不同的技术之间共享资源，将不同的操作系统、数据库、异构的网络环境以及若干应用结合成一个有机的协同工作整体</p><p>中间件位于客户机/服务器的操作系统之上，管理计算机资源和网络通信，</p><p>中间件是一类软件，而非一种软件；</p><p>中间件不仅仅实现互连，还要实现应用之间的互操作；</p><p>中间件是基于分布式处理的软件，最突出的特点是网络通信</p><p>使应用程序开发变得更容易，通过提供统一的程序抽象，隐藏异构系统和分布式系统下低级别编程的复杂度</p><p>1、数据库访问中间件：通过一个抽象层访问数据库，从而允许使用相同或相似的代码访问不同的数据库资源。典型的技术如Windows平台的ODBC和Java平台的JDBC等。</p><p>2、远程过程调用(RPC)：是一种广泛使用的分布式应用程序处理方法。一个应用程序使用RPC来“远程”执行一个位于不同地址空间内的过程，从效果上看和执行本地调用相同。</p><p>3、面向消息中间件(MOM)：利用高效可靠的消息传递机制进行平台无关的数据交流，并可基于数据通信进行分布系统的集成。通过提供消息传递和消息排队模型，可在分布环境下扩展进程间的通信，并支持多种通信协议、语言、应用程序、硬件和软件平台。典型的产品如RabbitMQ。</p><p>4、分布式对象中间件：随着对象技术与分布式计算技术的发展，两者相互结合形成了分布式对象技术，并发展成为当今软件技术的主流方向。典型的产品如OMG的CORBA、Sun的RMI/EJB、Microsoft的DCOM等。</p><p>5、事务中间件：也称事务处理监控器(TPM)，最早出现在大型机上。事务处理监控程序位于客户和服务器之间，完成事务管理与协调、负载平衡、失效恢复等任务，提高系统的整体性能。</p>]]></content>
    
    
    <summary type="html">质量属性和架构评估，中间件</summary>
    
    
    
    <category term="系统架构设计" scheme="https://zypuu.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="架构" scheme="https://zypuu.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>系统架构设计</title>
    <link href="https://zypuu.github.io/2024/04/14/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://zypuu.github.io/2024/04/14/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-04-14T02:05:00.000Z</published>
    <updated>2024-06-03T09:11:30.203Z</updated>
    
    <content type="html"><![CDATA[<h3 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h3><p>一个程序和计算系统软件体系结构是指系统的一个或者多个结构。结构中包括软件的构件，构件的外部可见属性以及它们之间的相互关系</p><p>软件架构指从需求分析到软件设计之间的过渡过程。只要软件架构设计好了，整个软件就不会出现坍塌性的错误，即不会崩溃</p><p>数据设计和体系结构设计。数据设计为软件体系结构设计提供了数据基础，而体系结构设计则为软件系统的整体结构提供了规划和设计</p><p>软件架构为软件系统提供了一个结构、行为和属性的高级抽象，由构件的描述、构件的相互作用(连接件)、指导构件集成的模式以及这些模式的约束组成</p><p>软件架构就是软件的总体设计方案，它决定了软件如何组织和工作，规定了软件系统的整体结构和各个部分之间的关系，以满足用户需求和业务目标。好的架构是构建可靠软件的基础</p><p>需求分析-架构设计-系统设计</p><p><strong>1、软件架构设计贯穿于软件开发生命周期的各个阶段</strong>，软件架构设计并非只在开发初期进行，而是贯穿于软件开发生命周期的各个阶段，包括需求分析、设计、实现、测试、部署和维护等</p><p><strong>2.</strong> <strong>需求分析阶段。</strong>需求分析和SA（架构）设计面临的是不同的对象：一个是问题空间；另一个是解空间。从软件需求模型向SA模型的转换主要关注两个问题：如何根据需求模型构建SA模型。如何保证模型转换的可追踪性。</p><p>简单来说，该阶段关注的是如何将用户需求转换为软件架构模型，并确保模型的可追踪性。</p><p><strong>3.</strong> <strong>设计阶段。</strong>是SA研究关注的最早和最多的阶段，这一阶段的SA研究主要包括：SA模型的描述、SA模型的设计与分析方法，以及对SA设计经验的总结与复用等。有关SA模型描述的研究分为3个层次：SA的基本概念(构件和连接件)、体系结构描述语言ADL、SA模型的多视图表示。</p><p>简单来说，该阶段关注的是软件架构模型的描述、设计与分析方法，以及设计经验的总结与复用。</p><p><strong>4.</strong> <strong>实现阶段。</strong>最初SA研究往往只关注较高层次的系统设计、描述和验证。为了有效实现SA设计向实现的转换，实现阶段的体系结构研究表现在对开发过程的支持、开发语言和构件的选择以及相关测试技术。</p><p>简单来说，该阶段关注的是如何将软件架构设计转换为代码，以及如何进行测试</p><p><strong>5.</strong> <strong>构件组装阶段。</strong>在SA设计模型的指导下，可复用构件的组装可以在较高层次上实现系统，并能够提高系统实现的效率。在构件组装的过程中，SA设计模型起到了系统蓝图的作用。</p><p>简单来说，该阶段关注的是如何在架构设计模型的指导下，进行可复用构件的组装，提高系统实现效率，并解决组装过程中的相关问题。</p><p><strong>6.</strong> <strong>部署阶段。</strong>提供高层的体系结构视图来描述部署阶段的软硬件模型，以及基于SA模型可以分析部署方案的质量属性，从而选择合理的部署方案。</p><p>简单来说，该阶段关注的是如何根据软件架构模型进行部署，并分析部署方案的质量属性。</p><p><strong>7.</strong> <strong>后开发阶段。</strong>是指软件部署安装之后的阶段。这一阶段的SA研究主要围绕维护、演化、复用等方面来进行。典型的研究方向包括动态软件体系结构、体系结构恢复与重建等。</p><p>简单来说，该阶段关注的是如何根据软件架构模型进行维护和演化</p><h3 id="构件"><a href="#构件" class="headerlink" title="构件"></a>构件</h3><p>构件(Component)是指系统的重要部分，它们是功能上独立且可以被替代或扩展的模块或单元，外界通过接口访问其提供的服务</p><p>这些构件代表了系统中的不同功能区域，每个构件都可以独立开发、测试和维护。它们通过明确定义的接口和通信方式相互连接，以协同工作来实现整个电子商务网站的功能。</p><p>可以独立部署，没有外部的可见状态，不可拆分</p><p>类：类是面向对象编程中的基本概念，它描述了一种对象的属性和行为。类定义了对象的结构和行为模板，它可以包括属性(数据成员)和方法(函数成员)。类用于创建对象，对象是类的实例</p><p>模块：模块是一组相关的函数、类、变量或代码块的集合，模块用于划分代码，将相关功能或类放在一个地方，以便更好地组织和维护代码。它还可以支持代码的复用和封装</p><p>构件：是指软件系统中的可复用组件。构件可以是代码、数据、文档或其他任何类型的软件资产。构件通常是松散耦合的，并且可以组合起来形成更大的软件系统。构件的典型示例包括类、模块、组件和框架</p><p>服务：是指提供特定功能的软件单元。服务通常是独立的、可复用的，并且可以通过网络进行访问。服务的典型示例包括 Web服务、REST API 和微服务</p><p><strong>服务和构件之间的主要区别如下：</strong></p><p>服务侧重于功能，而构件侧重于结构。 服务提供特定的功能，而构件是软件系统的组成部分。</p><p>服务通常是独立的和可访问的，而构件通常是松散耦合的和可复用的。 服务可以独立运行并通过网络进行访问，而构件可以组合起来形成更大的软件系统。</p><p>服务通常用于面向服务的架构 (SOA)，而构件通常用于组件化开发。 SOA 是一种将软件系统构建为松散耦合的服务的架构风格。组件化开发是一种将软件系统构建为可复用构件的方法。</p><p>构件技术就是利用某种编程手段，将一些人们所关心的，但又不便于让最终用户去直接操作的细节进行了封装，同时对各种业务逻辑规则进行了实现，用于处理用户的内部操作细节。</p><p>目前，国际上常用的构件标准主要有三大流派。</p><p>EJB(Enterprise Java Bean)规范由Sun公司制定，有三种类型的EJB：</p><p>• 会话Bean(Session Bean)：用于管理会话和业务逻辑，有不同的类型适应不同的需求</p><p>• 实体Bean(Entity Bean)：用于与持久化数据交互，将对象映射到数据库表。</p><p>• 消息驱动Bean(Message-driven Bean)：用于异步消息处理，响应来自消息队列的消息</p><p> COM、DCOM、COM+：COM是微软公司的。DCOM是COM的进一步扩展，具有位置独立性和语言无关性。COM+并不是COM的新版本，是COM的新发展或是更高层次的应用：</p><p> CORBA标准主要分为三个层次：对象请求代理、公共对象服务和公共设施</p><p>• 最底层是对象请求代理ORB,规定了分布对象的定义(接口)和语言映射，实现对象间的通讯和互操作，是分布对象系统中的“软总线”; </p><p>• 在ORB之上定义了很多公共服务，可以提供诸如并发服务、名字服务、事务(交易)服务、安全服务等各种各样的服务；</p><p>• 最上层的公共设施则定义了组件框架，提供可直接为业务对象使用的服务，规定业务对象有效协作所需的协定规则。</p><p>EJB和COM+较为适用于应用服务器</p><h3 id="软件架构风格"><a href="#软件架构风格" class="headerlink" title="软件架构风格"></a>软件架构风格</h3><p>是描述某一特定应用领域中系统组织方式的<strong>惯用模式</strong>。架构风格定义一个系统家族，即一个<strong>架构定义</strong>、一个<strong>词汇表</strong>和一组<strong>约束</strong>。架构定义描述了系统的整体结构和组织方式。词汇表中包含一些构件和连接件类型，而这组约束指出系统是如何将这些构件和连接件组合起来的。</p><p>简单来说，软件体系结构风格就是一个模板，它规定了特定应用领域中软件系统应该如何构建</p><p>软件架构风格的作用：反映了领域中众多系统所<strong>共有的结构</strong>和<strong>语义特性</strong>，并指导如何将各个模块和子系统有效地组织成一个完整的系统</p><p>架构设计的一个核心问题是能否达到架构级的软件复用，强调对架构设计的重用。</p><p>架构风格定义了用于描述系统的术语表和一组指导构建系统的规则</p><h4 id="数据流风格"><a href="#数据流风格" class="headerlink" title="数据流风格"></a>数据流风格</h4><p>面向数据流，按照<strong>一定的顺序从前向后执行程序</strong>，代表的风格有批处理序列、管道-过滤器</p><p>批处理序列：构件为一系列固定顺序的计算单元，多件事情<strong>同步顺序</strong>执行，构件之间<strong>只通过数据传递交互</strong>。每个处理步骤是一个独立的程序，<strong>每一步必须在其前一步结束后才能开始</strong>，<strong>数据必须是完整的</strong>，<strong>以整体的方式传递</strong>。比如批量图像处理：一次性处理大量图像，例如调整大小、添加水印或转换格式。</p><p>管道-过滤器：每个构件都有一组输入和输出，构件读取输入的数据流，经过内部处理，产生输出数据流。<strong>前一个构件的输出作为后一个构件的输入</strong>，前后数据流关联。过滤器就是构件，连接件就是管道。比如文本处理管道：在文本分析中，可以将文本处理划分为分词、词干提取、情感分析等多个阶段，每个阶段是一个过滤器</p><p><strong>早期编译器</strong>就是采用的这种架构，要一步一步处理的，均可考虑此架构风格。</p><p>二者区别：</p><p>批处理风格通常一次性处理大量数据，离线执行，适用于批量处理任务。</p><p>管道过滤器风格将任务分解为多个阶段，每个阶段逐个处理数据，通常是实时或近实时执行，适用于可组合和可扩展的任务。</p><h4 id="调用返回风格"><a href="#调用返回风格" class="headerlink" title="调用返回风格"></a>调用返回风格</h4><p>构件之间存在<strong>互相调用</strong>的关系，一般是显式的调用，代表的风格有主程序/子程序、面向对象、层次结构、客户端服务器</p><p>主程序/子程序：单线程控制，把问题划分为若干个处理步骤，构件即为主程序和子程序，子程序通常可合成为模块。过程调用作为交互机制，充当连接件的角色</p><p>面向对象：构件是对象，对象是抽象数据类型的实例。连接件即使对象间交互的方式，对象是通过函数和过程的调用来交互的。</p><p>层次结构：构件组成一个层次结构，连接件通过决定层间如何交互的协议来定义。每层为上一层提供服务，使用下一层的服务，只能见到与自己邻接的层。修改某一层，最多影响其相邻的两层(通常只能影响上层)。</p><p>优点是可以将一个复杂问题分解成一个增量步骤序列的实现。</p><p>缺点是并不是每个系统都可以很容易的划分为分层的模式，并且因为进行层次调用，会影响效率。</p><p>客户端服务器(C/S)：早期是两层C/S架构模式，由三个部分组成：数据库服务器、客户端服务器和网络，其中服务器负责数据管理，客户端完成用户交互，称之为“胖客户机，瘦服务器”，后期又增加了一个应用服务器，称之为三层C/S架构,分别是表示层、功能层和数据层，表示层就是用户交互、功能层就是业务逻辑处理、数据层就是数据库处理，以上三层独立</p><h4 id="独立构件风格"><a href="#独立构件风格" class="headerlink" title="独立构件风格"></a>独立构件风格</h4><p>构件之间是<strong>互相独立</strong>的，不存在显式的调用关系，而是通过某个事件触发、异步的方式来执行，代表的风格有进程通信、事件驱动系统(隐式调用)</p><p>进程通信：构件是独立的<strong>进程</strong>，连接件是<strong>消息传递</strong>。构件通常是命名过程，消息传递的方式可以是点对点、异步或同步方式，以及远程过程(方法)调用等。进程通信涉及不同的进程或线程之间的通信和数据共享。这些进程可以运行在同一台计算机上，也可以分布在不同的计算机上。</p><p>事件驱动系统(隐式调用)：构件不直接调用一个过程，而是触发或广播一个或多个事件。构件中的过程在一个或多个事件中注册，当某个事件被触发时，系统自动调用在这个事件中注册的所有过程。</p><p>主要优点是为软件复用提供了强大的支持，为构件的维护和演化带来了方便；</p><p>缺点是构件放弃了对系统计算的控制，只能被动的控制</p><h4 id="虚拟机风格"><a href="#虚拟机风格" class="headerlink" title="虚拟机风格"></a>虚拟机风格</h4><p>自定义了一套新规则供使用者使用，使用者基于这个规则来开发构件，能够跨平台适配，代表的风格有解释器、基于规则的系统</p><p>解释器：通常包括一个完成解释工作的解释引擎、一个包含将被解释的代码的存储区、一个记录解释引擎当前工作状态的数据结构，以及一个记录源代码被解释执行的进度的数据结构。涉及解析和执行一系列指令或命令，通常通过解释器来实现。解释器将文本或代码解析成可执行的操作。缺点是执行效率低</p><p>基于规则的系统：包括规则集、规则解释器、规则/数据选择器和工作内存，一般用在人工智能领域和DSS(决策支持系统)中。适用于根据一组事先定义的规则或条件来控制系统的行为。这种风格通常用于实现灵活的业务规则和决策逻辑。</p><h4 id="以数据为中心风格"><a href="#以数据为中心风格" class="headerlink" title="以数据为中心风格"></a>以数据为中心风格</h4><p>以数据为中心，所有的操作都是围绕建立的数据中心进行的，代表的风格有数据库系统、仓库系统、黑板系统</p><p>仓库风格的架构将数据存储在一个中央仓库或数据库中，各个组件可以从仓库中读取和写入数据。组件之间通过共享数据仓库进行通信和协作。</p><p>仓库超文本：网状连接，多用于互联网</p><p>黑板风格的架构类似于一个黑板或公告板，多个独立的组件称为”专家”共享一个公共存储区(黑板)，它们可以读取和写入数据。专家根据黑板上的信息进行推断和决策，适用于解决复杂的非结构化问题。</p><p>总之，仓库风格强调数据的集中存储和共享，组件通过访问共享的仓库来交互。</p><p>而黑板风格侧重于多个独立的组件共享一个中央知识存储区，根据共享的信息进行推断和决策。</p><p>这两种风格在处理复杂问题和协作方面都具有一定的优势。</p><h4 id="闭环控制"><a href="#闭环控制" class="headerlink" title="闭环控制"></a>闭环控制</h4><p>当软件被用来操作一个物理系统时，软件与硬件之间可以粗略的表示为一个反馈循环，这个反馈循环通过接受一定的输入，确定一系列的输出，最终使环境达到一个新的状态，适合于嵌入式系统，涉及连续的动作与状态。</p><h4 id="C2风格"><a href="#C2风格" class="headerlink" title="C2风格"></a>C2风格</h4><p>通过连接件绑定在一起的按照一组规则运作的并行构件网络。C2风格中的系统组织规则如下：</p><p>系统中的构件和连接件都有一个顶部和一个底部；</p><p>构件的顶部应连接到某连接件的底部，构件的底部则应连接到某连接件的顶部，而构件与构件之间的直接连接是不允许的；</p><p>一个连接件可以和任意数目的其它构件和连接件连接；</p><p>当两个连接件进行直接连接时，必须由其中一个的底部到另一个的顶部。</p><p>构件中间要有连接件</p><h3 id="软件架构复用"><a href="#软件架构复用" class="headerlink" title="软件架构复用"></a>软件架构复用</h3><p>软件产品线是指一组（<strong>多个</strong>）软件密集型系统，它们共享一个公共的、可管理的特性集，满足某个特定市场或任务的具体需要，是以规定的方式用公共的核心资产集成开发出来的。即围绕核心资产库进行管理、复用、集成新的系统</p><p>软件架构复用根据复用的时机包括机会复用和系统复用。</p><p>机会复用是指开发过程中，只要发现有可复用的资产，就对其进行复用。</p><p>系统复用是指在开发之前，就要进行规划，以决定哪些需要复用</p><p>复用的基本过程主要包括3个阶段：</p><p>首先构造/获取可复用的软件资产，</p><p>其次管理这些资产(把它们放入到构件库)，</p><p>最后针对特定的需求，从这些资产中选择可复用的部分，以开发满足需求的应用系统</p><h3 id="特定领域软件架构（DSSA）"><a href="#特定领域软件架构（DSSA）" class="headerlink" title="特定领域软件架构（DSSA）"></a>特定领域软件架构（DSSA）</h3><p>DSSA就是专用于一类特定类型的任务(领域)的、在整个领域中能有效地使用的、为成功构造应用系统限定了标准的组合结构的软件构件的集合。它旨在满足该领域的独特需求和约束</p><p>DSSA就是一个特定的问题领域中支持一组应用的领域模型、参考需求、参考架构等组成的开发基础，其目标就是支持在一个特定领域中多个应用的生成</p><p><strong>垂直域：</strong>在一个特定领域中的通用的软件架构，是一个完整的架构</p><p><strong>水平域</strong>：在多个不同的特定领域之间的相同的部分的小工具</p><p>DSSA的三个基本活动：领域分析、领域设计和领域实现</p><p>领域分析：这个阶段的主要目标是获得领域模型**(领域需求)**，在此基础上就可以分析领域中系统的需求，确定哪些需求是领域中的系统广泛共享的，从而建立领域模型</p><p>领域设计：这个阶段的目标是获得DSSA</p><p>领域实现：这个阶段的主要目标是依据领域模型和DSSA开发和组织可重用信息</p><p>领域分析用于确定需求，领域设计用于提供通用架构，而领域实现用于将该架构转化为具体的应用程序模块。这个过程有助于确保系统能够满足特定领域的需求，并具备可维护和可重用的特性</p><p>DSSA的四种角色：领域专家、领域分析人员、领域设计人员和领域实现人员</p><p>三层次模型：领域开发环境、领域特定的应用开发环境、应用执行环境</p><h3 id="基于架构的软件开发（ABSD）"><a href="#基于架构的软件开发（ABSD）" class="headerlink" title="基于架构的软件开发（ABSD）"></a>基于架构的软件开发（ABSD）</h3><p>基于架构的软件开发(Architecturally Based Software Development，ABSD)是一种软件开发方法，强调在开发过程中首先定义系统的体系结构，然后根据这个体系结构来实现系统。它有助于确保系统的结构和设计与业务需求保持一致</p><p>ABSD方法是架构驱动，强调由<strong>业务、质量和功能需求的组合驱动架构设计</strong>。它强调采用<strong>视角</strong>和<strong>视图</strong>来描述软件架构，用例描述的是功能需求，质量（属性）<strong>场景</strong>描述的是质量需求(或侧重于非功能需求)</p><p>ABSD方法有三个基础。</p><p>第一个基础是功能的分解，使用已有的基于模块的内聚和耦合技术;</p><p>第二个基础是通过选择架构风格来实现质量和业务需求;</p><p>第三个基础是软件模板的使用，软</p><p>件模板利用了一些软件系统的结构进行复用。</p><p>ABSD方法是递归的，且迭代的每一个步骤都是清晰定义的。因此，不管设计是否完成，架构总是清晰的，有助于降低架构设计的随意性。</p><p>ABSD六步：</p><p>  1 . 架构需求：重在掌握标识构件的三步，生成类图，对类进行分组，把类打包成构件</p><ol start="2"><li>架构设计：将需求阶段的标识构件映射成构件</li><li>架构(体系结构)文档化：主要产出两种文档，即架构(体系结构)规格说明，测试架构(体系结构)需求的质量设计说明书。文档是至关重要的，是所有人员通信的手段，关系开发的成败</li><li>架构复审：由外部人员(独立于开发组织之外的人，如用户代表和领域专家等)参加的复审，复审架构是否满足需求，质量问题，构件划分合理性等。若复审不过，则返回架构设计阶段进行重新设计、文档化，再复审</li><li>架构实现：用实体来显示出架构。实现构件，构件组装成系统</li><li>架构演化：对架构进行改变，按需求增删构件，使架构可<strong>复用</strong></li></ol><h3 id="层次架构风格"><a href="#层次架构风格" class="headerlink" title="层次架构风格"></a>层次架构风格</h3><h4 id="两层C-S架构"><a href="#两层C-S架构" class="headerlink" title="两层C/S架构"></a>两层C/S架构</h4><p>开发成本较高、客户端程序设计复杂、信息内容和形式单一、用户界面风格不一、软件移植困难、软件维护和升级困难、新技术不能轻易应用、安全性问题、服务器端压力大难以复用</p><h4 id="三层C-S架构"><a href="#三层C-S架构" class="headerlink" title="三层C/S架构"></a>三层C/S架构</h4><p>将处理功能独立出来，<strong>表示层和数据层</strong>都变得简单。表示层在客户机上，<strong>功能层</strong>在应用服务器上，数据层在数据库服务器上</p><h4 id="三层B-S架构"><a href="#三层B-S架构" class="headerlink" title="三层B/S架构"></a>三层B/S架构</h4><p>是三层C/S架构的变种，将客户端变为用户客户端上的浏览器，将应用服务器变为网络上的WEB服务器，又称为0客户端架构</p><h4 id="富互联网应用RIA"><a href="#富互联网应用RIA" class="headerlink" title="富互联网应用RIA"></a>富互联网应用RIA</h4><p>弥补三层B/S架构存在的问题，RIA是一种用户接口，比用HTML实现的接口更加健壮，且有可视化内容，本质还是网站模式，其优点如下：</p><p>RIA结合了C/S架构反应速度快、交互性强的优点与B/S架构传播范围广及容易传播的特性；</p><p>RIA简化并改进了B/S架构的用户交互；</p><p>数据能够被缓存在客户端，从而可以实现一个比基于HTML的响应速度更快且数据往返于服务器的次数更少的用户界面。</p><p>本质还是0客户端，借助于高速网速实现必要插件在本地的快速缓存，增强页面对动态页面的支持能力，典型的如小程序</p><h4 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h4><p>控制器(Controller) ：是应用程序中处理用户交互的部分</p><p>模型(Model)：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。模型表示业务数据和业务逻辑。</p><p>视图(View)：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。是用户看到并与之交互的界面。</p><h4 id="MVP架构"><a href="#MVP架构" class="headerlink" title="MVP架构"></a>MVP架构</h4><p>MVP是把MVC中的Controller换成了Presenter(呈现)，目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离</p><p>MVP特点：</p><p>M、V、P之间双向通信。</p><p>View 与Model不通信，都通过Presenter传递。Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。</p><p>View非常薄，不部署任何业务逻辑，称为”被动视图”(PassiveView)，即没有任何主动性，而Presenter非常厚，所有逻辑都部署在那里。</p><p>Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。</p><h4 id="MVVM架构"><a href="#MVVM架构" class="headerlink" title="MVVM架构"></a>MVVM架构</h4><p>MVVM模式和MVC模式类似，主要目的是分离视图(View)和模型(Model)，实现双向绑定，有几大优点：</p><p>低耦合，视图(vView)可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p><p>可重用性，可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p><p>独立开发，开发人员可以专注于业务逻辑和数据的开发(ViewModel) ，设计人员可以专注于页面设计。</p><p>可测试，界面向来是比较难于测试的，而现在测试可以针对ViewModel来写。</p><h3 id="面向服务的架构风格（SOA）"><a href="#面向服务的架构风格（SOA）" class="headerlink" title="面向服务的架构风格（SOA）"></a>面向服务的架构风格（SOA）</h3><p>SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通信，不涉及底层编程接口和通信模型</p><p>服务是一种为了满足某项业务需求的操作、规则等的逻辑组合，它包含一系列有序活动的交互，为实现用户目标提供支持。</p><p>实施SOA的关键目标是实现企业IT资产重用的最大化，在实施SOA过程中要牢记以下特征：可从企业外部访问、随时可用(服务请求能被及时响应)、粗粒度接口(粗粒度提供一项特定的业务功能，而细粒度服务代表了技术构件方法)、服务分级、松散耦合(服务提供者和服务使用者分离)、可重用的服务及服务接口设计管理、标准化的接口(WSDL、SOAP、XML是核心)、支持各种消息模式、精确定义的服务接口</p><p>从基于对象到基于构件再到基于服务，架构越来越松散耦合，粒度越来越粗，接口越来越标准</p><p>关键技术：</p><p>UDDI：用于WEB服务注册统一描述、发现，查找。</p><p>WSDL (Web Service描述语言)∶将Web服务描述定义为一组服务访问点，用于描述服务</p><p>SOAP(简单对象访问协议)：用于传递信息。</p><p>XML (可扩展标记语言)︰是WebService平台中表示数据的基本格式，用于数据交换</p><p>BPEL：将多个服务组合成一个新的复合服务</p><p>SOA的三种实现方式：WEB Service、服务注册表和企业服务总线ESB</p><p>WEB Service<strong>：</strong>服务提供者、服务注册中心(中介，提供交易平台，可有可无)、服务请求者</p><p>企业服务总线ESB：简单来说是一根管道，用来连接各个服务节点。</p><p>ESB的存在是为了集成基于不同协议的不同服务，ESB做了消息的转化、解释以及路由的工作，以此来让不同的服务互联互通。</p><p>包括：客户端(服务请求者)、基础架构服务(中间件)、核心集成服务(提供服务)。</p><p>ESB特点：</p><p> SOA的一种实现方式，ESB在面向服务的架构中起到的是总线作用，将各种服务进行连接与整合;</p><p>描述服务的元数据和服务注册管理;</p><p>在服务请求者和提供者之间传递数据，以及对这些数据进行转换的能力，并支持由实践中总结出来的一些模式如同步模式、异步模式等;</p><p>发现、路由、匹配和选择的能力，以支持服务之间的动态交互，解耦服务请求者和服务提供者。高级一些的能力，包括对安全的支持、服务质量保证、可管理性和负载平衡等</p>]]></content>
    
    
    <summary type="html">系统架构设计构件，风格</summary>
    
    
    
    <category term="系统架构设计" scheme="https://zypuu.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="架构" scheme="https://zypuu.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>项目管理</title>
    <link href="https://zypuu.github.io/2024/04/14/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <id>https://zypuu.github.io/2024/04/14/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</id>
    <published>2024-04-14T01:14:00.000Z</published>
    <updated>2024-06-03T09:11:30.237Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进度管理"><a href="#进度管理" class="headerlink" title="进度管理"></a>进度管理</h3><p> 进度管理就是采用科学的方法，确定进度目标，编制进度计划和资源供应计划，进行进度控制，在与质量、成本目标协调的基础上，实现工期目标。</p><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>活动定义：需要开展的具体活动</p><p>活动排序：先后关系和逻辑关系</p><p>活动资源估算：需要的资源类型和效益</p><p>活动历时估算：需要的具体时间</p><p>进度计划编制：制订项目进度计划</p><p>进度控制：若发现偏差，则分析原因或进行调整</p><p>常用的图形方法有甘特图，项目计划评审技术（PERT）</p><h4 id="工具与技术"><a href="#工具与技术" class="headerlink" title="工具与技术"></a>工具与技术</h4><p>关键路径法：是项目的最短工期，但却是从开始到结束时间最长的路径。进度网络图中可能有多条关键路径，总浮动时间为0</p><p>关键活动:关键路径上的活动，最早开始时间=最晚开始时间</p><p>最早开始时间 (ES)：某项活动能够开始的最早时间.</p><p>最早结束时间(EF )：某项活动能够完成的最早时间。EF=ES+工期</p><p>最迟结束时间(LF)。为了使项目按时完成，某项活动必须完成的最迟时间</p><p>最迟开始时间 (LS) 。为了使项目按时完成，某项活动必须开始的最迟时间LS=LF-工期</p><p>浮动时间：最晚开始时间-最早开始时间</p><p>总浮动时间=最迟开始LS-最早开始ES或最迟完成LF-最早完成EF或关键路径- 非关键路径（包含某个活动的非关键路径）时长。</p><p>自由浮动时间=紧后活动最早开始时间的最小值-本活动的最早完成时间</p><p>最早开始时间ES。工期。最早完成时间EF</p><p>最晚开始LS。总浮动时间。最晚结束时间LF</p><p>顺推：最早开始ES=所有前置活动最早完成EF的最大值；最早完成EF=最早开始ES+持续时间。</p><p>逆推：最晚完成LF=所有后续活动最晩开始LS的最小值；最晚开始LS=最晩完成LF-持续时间。</p><h3 id="软件配置管理"><a href="#软件配置管理" class="headerlink" title="软件配置管理"></a>软件配置管理</h3><p>配置管理是为了系统地控制配置变更，在系统的整个生命周期中维持配置的 完整性和可跟踪性，从而标识系统在不同时间点上配置的学科。</p><p>配置管理包括6个主要活动：制订配置管理计划、配置标识、配置控制、配置 状态报告、配置审计、发布管理和交付</p><p>典型配置项包括项目计划书、需求文档、设计文档、源代码、可执行代码、测试用例、运行软件所需的各种数据，它们经评审和检查通过后进入配置管理</p><p>配置项版本管理：</p><p>草稿状态：0.YZ，YZ范围0-99</p><p>正式状态：X.Y,X的范围1-9，Y为次版本号X.Y</p><h3 id="质量与风险管理"><a href="#质量与风险管理" class="headerlink" title="质量与风险管理"></a>质量与风险管理</h3><p>质量是软件产品特性的综合，表示软件产品满足明确(基本需求)或隐含(期望需求)要求的能力。质量管理是指确定质量方针、目标和职责，并通过质量体系中的质量计划、质量控制、质量保证和质量改进来使其实现的所有管理职能的全部活动;</p><p>主要包括以下过程:</p><p>质量规划:识别项目及其产品的质量要求和标准，并书面描述项目将如何达到这些要求和标准的过程。</p><p>质量保证:一般是每隔一定时间 (例如，每个阶段未) 进行的，主要通过系统的质量审计 (软件评审) 和过程分析来保证项目的质量</p><p>质量控制: 实时监控项目的具体结果，以判断它们是否符合相关质量标全制订有效方案，以消除产生质量问题的原因</p><p>风险管理就是要对项目风险进行认真的分析和科学的管理</p><p>风险管理计划编制:如何安排与实施项目的风险管理，制定下列各步的计划.</p><p>风险识别: 识别出项目中已知和可预测的风险确定风险的来源、产生的条件、描述风险的特征以及哪些项目可以产生风险，形成一个风险列表。</p><p>风险定性分析:对已经识别的风险进行排序，确定风险可能性与影响、确定风险优先级、确定风险类型。</p><p>风险定量分析: 进一步了解风险发生的可能性具体由多大，后果具体由多严重。包括灵敏度分析期望货币价值分析、决策树分析、蒙特卡罗模拟。</p><p>风险应对计划编制: 对每一个识别出来的风险来分别制定应对措施，这些措施组成的文档称为风险应对计划。包括消极风险(避免策略、转移策略、减策略) ;积极风险(开拓、分享、强大)。</p><p>风险监控:监控风险计划的执行，检测残余风险，识别新的风险，保证风险并评价这些计划对减少风险的有效性计划的执行</p><p>风险可以分为项目风险、技术风险和商业风险</p><p>项目风险是指潜在的预算、进度、个人 (包括人员和组织)、资源、用户和需求方面的问题，以及它们对项目的影响。项目复杂性、规模和结构的不确定性也构成项目的(估算)风险因素。项目风险威胁到项目计划，一但项目风险成为现实，可能会拖延项目进度，增加项目的成本</p><p>技术风险是指潜在的设计、实现、接口、测试和维护方面的问题。此外，规格说明的多义性、技术上的不确定性、技术陈旧、最新技术 (不成熟)也是风险因素。技术风险威胁到待开发系统的质量和预定的交付时间。如果技术风险成为现实，开发工作可能会变得很困难或根本不可能</p><p>商业风险威胁到待开发系统的生存能力</p><p>市场风险。开发的系统虽然很优秀但不是市场真正所想要的。</p><p>策略风险。开发的系统不再符合企业的信息系统战略。</p><p>销售风险。开发了销售部门不清楚如何推销的系统。</p><p>管理风险。由于重点转移或人员变动而失去上级管理部门的支持.</p><p>预算风险。开发过程没有得到预算或人员的保证</p>]]></content>
    
    
    <summary type="html">项目管理，进度管理，配置与质量与风险管理</summary>
    
    
    
    <category term="系统架构设计" scheme="https://zypuu.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="架构" scheme="https://zypuu.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>面向对象技术</title>
    <link href="https://zypuu.github.io/2024/04/13/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/"/>
    <id>https://zypuu.github.io/2024/04/13/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/</id>
    <published>2024-04-13T02:18:00.000Z</published>
    <updated>2024-06-03T09:11:30.237Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>对象：由数据及其操作所构成的封装体，是系统中用来描述客观事务的一个实体，是构成系统的 一个基本单位。 一个对象通常可以由对象名、属性和方 法3个部分组成。</p><p>类：现实世界中实体的形式化描述，类将该实体的属性(数据)和操作 (函数)封装在一起。对象是类的实例，类是对象的模板</p><p>抽象：通过特定的实例抽取共同特征以后形成概念的过程</p><p>封装：是一种信息隐蔽技术， 将相关的概念组成一个单元模块， 并通过一个名称来引用 。面向对象封装是将数据和基于数据的操作封装成一个整体对象</p><p>继承：表示类之间的层次关系 (父类与子类)</p><p>多态：不同的对象收到同 一个消息时产生完全不同的结果</p><p>接口：其只说明操作应该做什么， 并没有定义操作如何做</p><p>消息：体现对象间的交互， 通过它向目标对象发送操作请求</p><p>覆盖：子类在原有父类接口的基础上， 用适合于自己要求的实现去置换父类中的相应实现 。即在子类中重定义-个与父类同名同参的方法</p><p>重载： 与覆盖要区分开， 函数重载与子类父类无关， 且函数是同名不同参数</p><p>绑定：是一个把过程调用和响应调用所需要执行的代码加以结合的过程。动态绑定，运行时，静态绑定，编译时</p><h3 id="UML统一建模语言"><a href="#UML统一建模语言" class="headerlink" title="UML统一建模语言"></a>UML统一建模语言</h3><p>UML三要素：UML的基本构造块、支配这些构造块如何放置在一起的规则和运用与整个语言的一些公共机制</p><p>UML的基本构造块包括：事物(对模型中最具有代表性的成分的抽象)、关系(把事务结合在一起)、图(聚集了相关的事物)。</p><h4 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h4><p>UML中有四种事物：结构事物（静态事物）、行为事物（动态事物）、分组事物、注释事物</p><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>依赖：一个事物的语义依赖于另一个事物的语义的变化而变化</p><p>关联：是一种结构关系，描述了一组链，链是对象之间的连接。分为组合和聚合，都是部分和整体的关系，其中组合事物之间关系更强。两个类之间的关联，实际上是两个类所扮演角色的关联，因此，两个类之间可以有多个由不同角色标识的关联。</p><p>泛化：一般/特殊的关系，子类和父类之间的关系，继承关系</p><p>实现：一个类元指定了另一个类元保证执行的契约。</p><h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><p>长方形：类</p><p>实习菱形：组合，强关联</p><p>空心菱形：聚集，弱关联</p><p>横线：关联</p><p>虚线箭头：依赖</p><p>圆形：接口</p><p>空心三角：泛化</p><p>虚线三角：实现</p><p>点点*：多重度，1个到多个</p><p>类图：静态图，为系统的静态设计视图，展现一组对象、接口、协作和它们之间的关系。</p><p>对象图：静态图，展现某一时刻一组对象及它们之间的关系，为类图的某一快照。在没有类图的前提下，对象图就是静态设计视图。</p><p>用例图：静态图，展现了一组用例、参与者以及它们之间的关系。用例图中的参与者是人、硬件或其他系统可以扮演的角色；用例是参与者完成的一系列操作。用例之间的关系：包含（include）、扩展(extend)、泛化。</p><p>序列图：即顺序图，动态图，是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。有同步消息(进行阻塞调用，调用者中止执行，等待控制权返回，需要等待返回消息，用实心三角箭头表示)、异步消息(发出消息后继续执行，不引起调用者阻塞，也不等待返回消息，由空心箭头表示)、返回消息(由从右到左的虚线箭头表示)三种。 </p><p>实心箭头：同步消息</p><p>异步消息：空心箭头</p><p>返回消息：虚线箭头</p><p>通信图：动态图，即协作图，是顺序图的另一种表示方法，也是由对象和消息组成的图，只不过不强调时间顺序，只强调事件之间的通信，而且也没有固定的画法规则，和顺序图统称为交互图</p><p>状态图：动态图，展现了一个状态机，描述单个对象在多个用例中的行为，包括简单状态和组合状态。转换可以通过事件触发器触发，事件触发后相应的监护条件会进行检查。状态图中转换和状态是两个独立的概念，如下：图中方框代表状态，箭头上的代表触发事件，实心圆点为起点和终点</p><p>活动图：动态图，是一种特殊的状态图，展现了在系统内从一个活动到另二个活动的流程。活动的分岔和汇合线是一条水平粗线。每个分岔的分支数代表了可同时运行的线程数。活动图中能够并行执行的是在一个分岔粗线下的分支上的活动。</p><p>构件图(组件图):静态图，为系统静态实现视图，展现了一组构件之间的组织和依赖。</p><p>部署图：静态图，为系统静态部署视图，部署图描述的事物理模块的节点分布。它与构件图相关，通常一个结点包含一个或多个构件。其依赖关系类似于包依赖，因此部署组件之间的依赖是单向的类似于包含关系。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>架构模式:软件设计中的高层决策，例如C/S结构就属于架构模式, 架构模式反映了开发软件系统过程中所作的基本设计决策。</p><p>设计模式:每一个设计模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。设计模式的核心在于提供了相关问题的解决方案，使得人们可以更加简单方便的复用成功的的设计和体系结构。</p><p>四个基本要素:模式名称、问题（应该在何时使用模式）、解决方案（设计的内容）、效果（模式应用的效果）。</p><p>惯用法:是最低层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用一计数就是C++语言中的一种惯用法。</p><h4 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h4><p>抽象工厂模式：抽象接口</p><p>构件器模式：类与构造分离</p><p>单例模式：唯一实例</p><p>工厂方法模式：子类决定实例化</p><p>原型模式：原型，拷贝</p><h4 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h4><p>适配器模式：转换，兼容接口</p><p>桥接模式：抽象和实现分离</p><p>组合模式：整体部分，树形结构</p><p>装饰模式：附加职责</p><p>外观模式：对外统一接口</p><p>享元模式：细粒度，共享</p><p>代理模式：代理控制</p><h4 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h4><p>责任链模式：传递请求，指责链接</p><p>命令模式：日志记录，可撤销</p><p>解释器模式：解释器，虚拟机</p><p>迭代器模式：顺序访问，不暴露内部</p><p>中介者模式：不直接引用</p><p>备忘录模式：保存恢复</p><p>观察者模式：通知，自定更新</p><p>状态模式：状态变成类</p><p>策略模式：算法替换</p><p>模板方法模式</p><p>访问者模式：数据和操作分离</p>]]></content>
    
    
    <summary type="html">面向对象开发，分析设计，统一建模语言UML，设计模式</summary>
    
    
    
    <category term="系统架构设计" scheme="https://zypuu.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="架构" scheme="https://zypuu.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>系统维护，净室工程</title>
    <link href="https://zypuu.github.io/2024/04/12/%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4%EF%BC%8C%E5%87%80%E5%AE%A4%E5%B7%A5%E7%A8%8B/"/>
    <id>https://zypuu.github.io/2024/04/12/%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4%EF%BC%8C%E5%87%80%E5%AE%A4%E5%B7%A5%E7%A8%8B/</id>
    <published>2024-04-12T01:44:00.000Z</published>
    <updated>2024-06-03T09:11:30.204Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统维护"><a href="#系统维护" class="headerlink" title="系统维护"></a>系统维护</h3><p>系统维护是整个系统开发过程中耗时最长的，系统的可维护性可以定义为维护人员理解、改正、改动和改进这个软件的难易程度，其评价指标如下：</p><p>易分析性：软件产品诊断软件中的缺陷或失效原因或识别待修改部分的能力。</p><p>易改变性：软件产品使指定的修改可以被实现的能力，实现包括编码、设计和文档的更改。</p><p>稳定性：软件产品避免由于软件修改而造成意外结果的能力。</p><p>易测试性：软件产品使已修改软件能被确认的能力。</p><p>系统维护包括硬件维护、软件维护和数据维护，其中软件维护类型如下：</p><p>正确性维护：发现了bug而进行的修改。</p><p>适应性维护：由于外部环境发生了改变，被动进行的对软件的修改和升级。</p><p>完善性维护：基于用户主动对软件提出更多的需求，修改软件，增加更多的功能，使其比之前的软件功能、性能更高，更加完善。</p><p>预防性维护：对未来可能发生的问题进行预防性的修改。</p><h4 id="遗留系统"><a href="#遗留系统" class="headerlink" title="遗留系统"></a>遗留系统</h4><p>是指任何基本上不能进行修改和演化以满足新的变化了的业务需求的信息系统</p><p>高水平低价值：集成</p><p>高水平高价值：改造</p><p>低水平低价值：淘汰</p><p>低水平高价值：继承</p><h4 id="系统转换"><a href="#系统转换" class="headerlink" title="系统转换"></a>系统转换</h4><p>是指新系统开发完毕，投入运行，取代现有系统的过程，有下面三种转换计划：</p><p>直接转换：现有系统被新系统直接取代了，风险很大，适用于新系统不复杂，或者现有系统已经不能使用的情况。优点是节省成本，只适合小系统</p><p>并行转换：新系统和老系统并行工作一段时间，新系统经过试运行后再取代，若新系统在试运行过程中有问题，也不影响现有系统的运行，风险极小，在试运行过程中还可以比较新老系统的性能，适用于大型系统。缺点是耗费人力和时间资源，难以控制两个系统间的数据转换。</p><p>分段转换：分期分批逐步转换，是直接和并行转换的集合，将大型系统分为多个子系统，依次试运行每个子系统，成熟一个子系统，就转换一个子系统。同样适用于大型项目，只是更耗时，而且现有系统和新系统间混合使用，需要协调好接口等问题。</p><h4 id="数据转换与迁移"><a href="#数据转换与迁移" class="headerlink" title="数据转换与迁移"></a>数据转换与迁移</h4><p>系统切换前通过工具迁移、系统切换前采用手工录入、系统切换后通过新系统生成</p><h3 id="净室软件工程（CSE）"><a href="#净室软件工程（CSE）" class="headerlink" title="净室软件工程（CSE）"></a>净室软件工程（CSE）</h3><p>一种应用数学与统计学理论以经济的方式生产高质量软件的工程技术，力图通过严格的工程化的软件过程达到开发中的零缺陷或接近零缺陷，强调的是预防大于检查。净室方法不是先制作一个产品，再去消除缺陷，而是要求在规约和设计中消除错误，然后以“净”的方式制作，可以降低软件开发中的风险，以合理的成本开发出高质量的软件</p><p>在净室软件工程背后的哲学是：通过在第1次正确地书写代码增量，并在测试前验证它们的正确性，来避免对成本很高的错误消除过程的依赖。它的过程模型是在代码增量积聚到系统的过程的同时，进行代码增量的统计质量验证。它甚至提倡开发者不需要进行单元测试，而是进行正确性验证和统计质量控制。</p><p>净室软件工程(CSE)的理论基础主要是函数理论和抽样理论。</p><p>净室软件工程应用技术手段：</p><p> 统计过程控制下的增量式开发。</p><p>基于函数的规范与设计。</p><p>正确性验证（CSE的核心）</p><p>统计测试和软件认证。</p><p>净室软件工程在使用过程的一些缺点：</p><p>CSE太理论化，需要更多的数学知识。其正确性验证的步骤比较困难且比较耗时。</p><p>CSE开发小组不进行传统的模块测试，这是不现实的。</p><p>CSE也会带有传统软件工程的一些弊端</p><h3 id="基于构件的软件工程（CBES）"><a href="#基于构件的软件工程（CBES）" class="headerlink" title="基于构件的软件工程（CBES）"></a>基于构件的软件工程（CBES）</h3><p>一种基于分布对象技术、强调通过可复用构件设计与构造软件系统的软件复用途径。CBSE体现了“购买而不是重新构造”的哲学，将软件开发的重点从程序编写转移到了基于己有构件的组装。用于CBSE的构件应该具备以下特征：</p><p>可组装型</p><p>可部署性</p><p>文档化</p><p>独立性</p><p>标准化</p><p>CBSE过程是支持基于构件组装的软件开发过程，过程中的6个主要活动：系统需求概览、识别候选构件、根据发现的构件修改需求、体系结构设计、构件定制与适配、组装构件创建系统。</p><p>CBSE过程与传统软件开发过程不同点：</p><p>CBSE早期需要完整的需求(即需求明确)，以便尽可能多地识别出可复用的构件。</p><p>在过程早期阶段根据可利用的构件来细化和修改需求。如果可利用的构件不能满足用户需求，就应该考虑由复用构件支持的相关需求。</p><p>在系统体系结构设计完成后，会有一个进一步的对构件搜索及设计精化的活动。可能需要为某些构件寻找备用构件，或者修改构件以适合功能和架构的要求。</p><p>开发就是将己经找到的构件集成在一起的组装过程。</p><p>构件组装是指构件相互直接集成或是用专门编写的“胶水代码”将它们整合在一起来创造一个系统或另一个构件的过程。常见的组装构件有以下3种组装方式：</p><p>顺序组装，层次组装，叠加组装</p>]]></content>
    
    
    <summary type="html">系统维护，净室工程和基于构件的软件工程</summary>
    
    
    
    <category term="系统架构设计" scheme="https://zypuu.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="架构" scheme="https://zypuu.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>系统测试</title>
    <link href="https://zypuu.github.io/2024/03/11/%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95/"/>
    <id>https://zypuu.github.io/2024/03/11/%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95/</id>
    <published>2024-03-11T01:43:00.000Z</published>
    <updated>2024-06-03T09:11:30.203Z</updated>
    
    <content type="html"><![CDATA[<p>系统测试：为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试</p><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><h3 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h3><p>指被测试程序不在机器上运行，而采用人工检测和计算机辅助静态分析的手段对程序进行检测，包括对文档的静态测试和对代码的静态测试。包括桌前检查、代码审查、代码走查的方式。使用这种方法能够有效地发现30%-70%的逻辑设计和编码错误</p><p>静态分析五个阶段：</p><p>1、控制流分析：找出并突出显示那些带有多重入口和出口的循环以及不可达的代码片段</p><p>2、数据使用分析：突出程序中的变量使用情况</p><p>3、接口分析：检查子程序过程说明和他们的使用的一致性</p><p>4、信息流分析：找出输入变量和输出变量的一致性关系</p><p>5、路径分析：找出程序中所有可能的路径，并画出此路径的执行语句</p><h3 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h3><p>指在计算机上实际运行程序进行软件测试，一般采用白盒测试和黑盒测试方法(还有灰盒和自动化)</p><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><p>黑盒测试关注于测试软件的功能(功能性测试)，而不考虑内部实现细节。测试人员不需要知道代码的具体结构，而是根据软件的需求规格和功能来设计测试用例</p><h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>白盒测试关注于测试软件的内部逻辑和代码结构(结构性测试)，以确保代码按照预期方式执行。测试人员需要了解软件的代码，以设计测试用例，以覆盖不同的代码路径和分支情况，以及验证代码是否满足质量标准和最佳实践</p><h2 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>也称为模块测试，测试的对象是可独立编译或汇编的程序模块、软件构件或OO软件中的类(统称为模块),测试依据是软件详细设计说明书。</p><p>驱动模块用来模拟被测试模块的上一级模块，相当于被测模块的主程序</p><p>桩模块（sub）指模拟被测模块所调用的模块，不是产品软件的组成部分</p><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>目的是检查模块之间，以及模块和已集成的软件之间的接口关系，并验证已集成的软件是否符合设计要求。测试依据是软件概要设计文档</p><h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><p>测试对象是完整的、集成的计算机系统；测试的目的是在真实系统工作环境下，验证完成的软件配置项能否和系统正确连接，并满足系统/子系统设计文档和软件开发合同规定的要求。测试依据是用户需求或开发合同。主要内容包括功能测试、健壮性测试、性能测试、用户界面测试、安全性测试、安装与反安装测试等，其中，最重要的工作是进行功能测试与性能测试。</p><p>功能测试主要采用黑盒测试方法；性能测试主要指标有响应时间、吞吐量、并发用户数和资源利用率等。系统测试通常由独立的测试团队执行，他们并不直接参与软件的开发过程</p><p>安全测试：检测系统的安全机制和保密措施是否完善，检测系统的防范能力</p><p>可靠性测试：平均失效时间MTBF是否超过规定时限，故障停机时间MTTR在一年中不应超过多少时间</p><p>恢复测试：检测系统的容错能力</p><p>性能测试：满足系统设计方案说明书对系统的性能要求</p><p>强度测试：是在系统资源特别低的情况下考查软件系统的极限运行情况</p><p>负载测试：用于测试超负荷环境中程序是否能够承担，确定在各种工作负载下系统的性能，测试当负载逐渐增加的时候，系统各项性能指标的变化</p><p>压力测试：通过确定系统的瓶颈或不能接收的性能点，来获得系统能够提供的最大服务级别测试，可以和负载测试结合进行</p><p>容量测试：并发测试，主要用于测试系统可同时处理的在线最大用户数量</p><h3 id="确认测试"><a href="#确认测试" class="headerlink" title="确认测试"></a>确认测试</h3><p>主要用于验证软件的功能、性能和其他特性是否与用户需求一致。测试依据是需求文档，确认测试是软件或产品开发的最后一个阶段，在系统测试完成后进行。它的主要目标是确保软件或产品已经满足最终用户的期望和需求。在确认测试中，最终用户（或其代表）将根据他们的实际使用情境，验证软件是否符合他们的业务流程和预期目标根据用户的参与程度，通常包括以下类型：</p><p>内部确认测试：主要由软件开发组织内部按照SRS进行测试。</p><p>Alpha测试：用户在开发环境下进行测试。</p><p>Beta测试：用户在实际使用环境下进行测试，通过改测试后，产品才能交付用户。</p><p>验收测试：针对SRS,在交付前以用户为主进行的测试。其测试对象为完整的、集成的计算机系统。验收测试的目的是，在真实的用户工作环境下，检验软件系统是否满足开发技术合同或SRS。验收测试的结论是用户确定是否接收该软件的主要依据。除应满足一般测试的准入条件外，在进行验收测试之前，应确认被测软件系统已通过系统测试。</p><h3 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h3><p>测试目的是测试软件变更之后，变更部分的正确性和对变更需求的符合性，以及软件原有的、正确的功能、性能和其他规定的要求的不损害性(不能把其他好的模块改错)</p><h2 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h2><h3 id="黑盒测试用例"><a href="#黑盒测试用例" class="headerlink" title="黑盒测试用例"></a>黑盒测试用例</h3><p>将程序看做一个黑盒子，只知道输入输出，不知道内部代码，由此设计出测试用例，分为下面几类：</p><p>等价类划分：通过将输入值分成不同的类别，从而减少测试用例的数量，同时确保测试覆盖各种可能的情况。这样可以更高效地测试软件，而不必为每个可能的输入值都编写一个测试用例。会分为有效等价类和无效等价类，都要设计测试用例</p><p>边界值划分：将每类的边界值作为测试用例，边界值一般为范围的两端值以及在此范围之外的与此范围间隔最小的两个值</p><p>错误推测：没有固定的方法，凭经验而言，来推测有可能产生问题的地方，作为测试用例进行测试。</p><p>因果图：由一个结果来反推原因的方法，具体结果具体分析，没有固定方法</p><h3 id="白盒测试用例"><a href="#白盒测试用例" class="headerlink" title="白盒测试用例"></a>白盒测试用例</h3><p>知道程序的代码逻辑，按照程序的代码语句，来设计覆盖代码分支的测试用例，覆盖级别从低至高分为下面几种：</p><p>语句覆盖SC:逻辑代码中的所有语句都要被执行一遍，覆盖层级最低，因为执行了所有的语句，不代表执行了所有的条件判断</p><p>判定覆盖DC:逻辑代码中的所有判断语句的条件的真假分支都要覆盖一次</p><p>条件覆盖CC: 针对每一个判断条件内（if）的每一个独立条件内都要执行一遍真假</p><p>条件判定组合覆盖CDC：同时满足判定覆盖和条件覆盖</p><p>路径覆盖：逻辑代码中的所有可行路径都覆盖了，覆盖层级最高</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>测试是发现错误，调试是找出错误的代码和原因</p><p>调试需要确定错误的准确位置；确定问题的原因并设法改正；改正后要进行回归测试。</p><p>调试的方法有：蛮力法、回溯法(从出错的地方开始，向回找)、原因排除法(找出所有可能的原因，逐一进行排除)。</p><p>软件的两种属性：外部属性指面向管理者和用户的属性，可直接测量，一般为性能指标。内部属性指软件产品本身的的属性，如可靠性等，只能间接测量。</p><p>McCabe度量法：又称为环路复杂度，假设有向图中有向边数为m,节点数为n,则此有向图的环路复杂度为m-n+2.</p><p>注意m和n代表的含义不能混淆，可以用一个最简单的环路来做特殊值记忆此公式，另外，针对一个程序流程图，每一个分支边(连线)就是一条有向边，每一条语句(语句框)就是一个顶点。</p>]]></content>
    
    
    <summary type="html">软件工程-系统测试，黑白盒，测试用例设计，调试</summary>
    
    
    
    <category term="系统架构设计" scheme="https://zypuu.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="架构" scheme="https://zypuu.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>系统设计</title>
    <link href="https://zypuu.github.io/2024/03/09/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://zypuu.github.io/2024/03/09/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-03-09T07:42:00.000Z</published>
    <updated>2024-06-03T09:11:30.204Z</updated>
    
    <content type="html"><![CDATA[<p>软件设计包括四个独立，又联系的活动：数据设计软件结构设计，人机界面设计，过程设计</p><h3 id="业务流程设计"><a href="#业务流程设计" class="headerlink" title="业务流程设计"></a>业务流程设计</h3><h4 id="图工具"><a href="#图工具" class="headerlink" title="图工具"></a>图工具</h4><p>程序流程图(Program Flow Diagram,PFD)：它独立于任何一种程序设计语言，比较直观、清晰，易于学习掌握。任何复杂的程序流程图都应该由顺序、选择和循环结构组合或嵌套而成</p><p>IPO图：也是流程描述工具，用来描述构成软件系统的每个模块的输入、输出和数据加工。数据流图其实就是一种IPO图</p><p>N-S图：比较容易表示嵌套和层次关系，并具有强烈的结构化特征。但是当问题很复杂时，N-S图可能很大，因此不适合于复杂程序的设计</p><p>问题分析图（PAD）：是一种支持结构化程序设计的图形工具。PAD具有清晰的逻辑结构、标准化的图形等优点，更重要的是，它引导设计人员使用结构化程序设计方法，从而提高程序的质量</p><h4 id="设计分类"><a href="#设计分类" class="headerlink" title="设计分类"></a>设计分类</h4><p>业务流程管理（BPM）：是一种方法论，用于优化、管理和自动化组织内的业务流程。它涉及识别、建模、分析和优化业务流程，以实现更高效、灵活和协调的运作。BPM关注整个业务流程的管理，包括流程的执行、监控、优化和自动化</p><p>业务流程重组（BPR）：BPR是更为激进的方法，它着眼于对现有业务流程进行彻底的重新设计和改造，以实现质的飞跃的改进，是对企业的业务流程进行根本性的再思考和彻底性的再设计，从而获得可以用诸如成本、质量、服务和速度等方面的业绩来衡量的显著性的成就</p><p>流程管理包含三个层面：规范流程、优化流程和再造流程</p><h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><h4 id="系统设计主要目的"><a href="#系统设计主要目的" class="headerlink" title="系统设计主要目的"></a>系统设计主要目的</h4><p>为系统制定蓝图，在各种技术和实施方法中权衡利弊，精心设计，合理地使用各种资源，最终勾画出新系统的详细设计方法。简单点说，系统设计就是告诉你该怎么做，需求分析就是找到你要做什么，系统设计就是告诉你怎么做</p><h4 id="系统设计方法"><a href="#系统设计方法" class="headerlink" title="系统设计方法"></a>系统设计方法</h4><p>结构化设计方法，面向对象设计方法。</p><h4 id="系统设计的主要内容"><a href="#系统设计的主要内容" class="headerlink" title="系统设计的主要内容"></a>系统设计的主要内容</h4><p>概要设计、详细设计。</p><p>概要设计基本任务：外部设计，又称为系统总体结构设计，是将系统的功能需求分配给软件模块，确定每个模块的功能和调用关系，形成软件的<strong>模块结构图</strong>，即<strong>系统结构图</strong>。还需要产出<strong>概要设计说明书</strong></p><p>详细设计的基本任务：内部设计，模块内详细算法设计、模块内数据结构设计、数据库的物理设计、其他设计(代码、输入/输出格式、用户界面)、编写<strong>详细设计说明书</strong>、评审</p><h4 id="系统设计基本原理"><a href="#系统设计基本原理" class="headerlink" title="系统设计基本原理"></a>系统设计基本原理</h4><p>抽象化： 系统设计中也会将复杂的问题分成更小、更易管理的部分。这样做能让我们关注重要的细节，同时不被不必要的复杂性所困扰。</p><p>自顶而下，逐步求精： 先考虑整体框架，然后逐步添加细节，以确保每个部分都被仔细设计和优化。</p><p>信息隐蔽：在系统设计中，我们可以隐藏复杂的内部细节，只暴露必要的信息给其他部分。这样能够降低不同模块之间的相互影响，使系统更易于管理和维护。</p><p>模块独立（<strong>高内聚</strong>，<strong>低耦合</strong>）： 系统设计中的各个部分应该是独立的，即每个模块都有自己的功能并且尽可能不依赖其他模块。高内聚表示模块内部的元素彼此紧密相关，低耦合表示模块之间的依赖尽可能降低</p><p>衡量模块独立程度的标准有两个：耦合性和内聚性</p><p>内聚程度，模块内</p><table><thead><tr><th>偶然内聚</th><th>无直接关系</th></tr></thead><tbody><tr><td>逻辑内聚</td><td>逻辑相似，参数决定</td></tr><tr><td>时间内聚</td><td>同时执行动作</td></tr><tr><td>过程内聚</td><td>指定的过程顺序</td></tr><tr><td>通信内聚</td><td>相同的数据结构，相同输入输出</td></tr><tr><td>顺序内聚</td><td>顺序执行，前一个输出是下一个输入</td></tr><tr><td>功能内聚</td><td>共同作用，缺一不可</td></tr></tbody></table><p>耦合程度，模块之间</p><table><thead><tr><th>无直接耦合</th><th>无直接关系</th></tr></thead><tbody><tr><td>数据耦合</td><td>模块间调用关系，传递数据值调用</td></tr><tr><td>标记耦合</td><td>传递数据结构</td></tr><tr><td>控制耦合</td><td>传递的是控制变量，执行另一个模块内部的某一功能</td></tr><tr><td>外部耦合</td><td>软件外部环境</td></tr><tr><td>公共耦合</td><td>公共数据结构</td></tr><tr><td>内容耦合</td><td>模块内部关联</td></tr></tbody></table><h4 id="系统设计基本原则"><a href="#系统设计基本原则" class="headerlink" title="系统设计基本原则"></a>系统设计基本原则</h4><p>保持模块的大小适中： 系统中的模块也应该适中，不要太大也不要太小。这样做可以使每个模块的功能清晰，并且易于理解、测试和维护。</p><p>尽可能减少调用的深度： 在系统设计中，减少调用深度意味着尽量减少程序的层层嵌套，以避免复杂的调用关系，使代码更清晰和高效。</p><p>多扇入，少扇出： 在系统设计中，模块应该允许多个模块调用它（多扇入），但它本身应尽量少调用其他模块（少扇出），以减少模块</p><p>之间的复杂关系。</p><p>单入口，单出口：这样可以使模块的功能和接口更清晰，不容易引入混淆和错误。</p><p>模块的作用域应该在模块之内： 模块的功能应该限制在模块内部，不要让外部模块直接访问内部的细节。这有助于封装和隐藏内部逻辑，防止外部干扰。</p><p>功能应该是可预测的： 使用者在调用一个模块时应该能够合理地预期它会发生什么，从而避免产生混淆和不可预知的结果</p><h3 id="人机界面设计"><a href="#人机界面设计" class="headerlink" title="人机界面设计"></a>人机界面设计</h3><p>三大黄金原则：</p><p>置于用户的控制之下</p><p>减少用户的记忆负担</p><p>保持界面的一致性</p>]]></content>
    
    
    <summary type="html">软件工程-系统设计，业务流程设计</summary>
    
    
    
    <category term="系统架构设计" scheme="https://zypuu.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="架构" scheme="https://zypuu.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
