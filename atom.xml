<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog-Youth</title>
  
  <subtitle>个人博客网站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zypuu.com/"/>
  <updated>2018-08-30T07:58:42.685Z</updated>
  <id>http://zypuu.com/</id>
  
  <author>
    <name>ZYP</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于Mysql数据库使用的优化</title>
    <link href="http://zypuu.com/2018/08/30/%E5%85%B3%E4%BA%8EMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://zypuu.com/2018/08/30/关于Mysql数据库使用的优化/</id>
    <published>2018-08-30T07:58:42.000Z</published>
    <updated>2018-08-30T07:58:42.685Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于数据库索引原理及优化</title>
    <link href="http://zypuu.com/2018/08/30/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <id>http://zypuu.com/2018/08/30/关于数据库索引原理及优化/</id>
    <published>2018-08-30T07:58:05.000Z</published>
    <updated>2018-08-30T07:58:05.374Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于Mysql的sql注入问题</title>
    <link href="http://zypuu.com/2018/08/30/%E5%85%B3%E4%BA%8EMysql%E7%9A%84sql%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://zypuu.com/2018/08/30/关于Mysql的sql注入问题/</id>
    <published>2018-08-30T07:54:42.000Z</published>
    <updated>2018-08-30T07:54:42.072Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于数据库redis与Mysql的区别以及在web开发中的配合使用</title>
    <link href="http://zypuu.com/2018/08/18/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93redis%E4%B8%8EMysql%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8web%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8/"/>
    <id>http://zypuu.com/2018/08/18/关于数据库redis与Mysql的区别以及在web开发中的配合使用/</id>
    <published>2018-08-18T13:51:28.000Z</published>
    <updated>2018-08-20T15:09:53.935Z</updated>
    
    <content type="html"><![CDATA[<h3 id="传统型关系数据库Mysql的瓶颈"><a href="#传统型关系数据库Mysql的瓶颈" class="headerlink" title="传统型关系数据库Mysql的瓶颈"></a>传统型关系数据库Mysql的瓶颈</h3><p>在互联网领域，MySQL作为一款关系型数据库为互联网的发展做出了卓越的贡献。然而随着互联网的发展，在大数据量高并发的环境下，应用开发也越来越复杂，具有很强的技术挑战性。分表分库子库等无不在增加数据库结构的复杂程度。MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变得非常的小。<br><br>关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差，大数据下IO压力大，表结构更改困难。</p><h3 id="Nosql与redis"><a href="#Nosql与redis" class="headerlink" title="Nosql与redis"></a>Nosql与redis</h3><p>NoSQL最常见的解释是“non-relational”，“Not Only SQL”也被很多人接受，指的是非关系型的数据库。</p><h4 id="Nosql的优势"><a href="#Nosql的优势" class="headerlink" title="Nosql的优势"></a>Nosql的优势</h4><p>易扩展：NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。<br>大数据量，高性能：NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单<br>灵活的数据模型：NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦<br>高可用：NoSQL在不太影响性能的情况，就可以方便的实现高可用的架构。</p><h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><p>Redis是一个开源（BSD许可）的、内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。<br>redis是一个高性能的key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sortedset–有序集合)和hash（哈希类型）。redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Python，Ruby，Erlang，PHP客户端，使用很方便<br>Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>NoSQL数据库的出现，弥补了关系数据（比如MySQL）在某些方面的不足，在某些方面能极大的节省开发成本和维护成本<br>MySQL和NoSQL都有各自的特点和使用的应用场景，两者的紧密结合将会给数据库发展带来新的思路。让关系数据库关注在关系上，NoSQL关注在存储上。</p><h3 id="利用redis做mysql的缓存"><a href="#利用redis做mysql的缓存" class="headerlink" title="利用redis做mysql的缓存"></a>利用redis做mysql的缓存</h3><p>前面部分已经介绍mysql的瓶颈，当网站的处理和访问量非常大的时候，我们的数据库的压力就变大了，数据库的连接池，数据库同时处理数据的能力就会受到很大的挑战，一旦数据库承受了其最大承受能力，网站的数据处理效率就会大打折扣。此时就要使用高并发处理、负载均衡和分布式数据库，而这些技术既花费人力，又花费资金。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><img src="/2018/08/18/关于数据库redis与Mysql的区别以及在web开发中的配合使用/1.jpg"><p>页面缓存经常用在CMS(content manage system)内存管理系统里面。<br>数据缓存经常会用在页面的具体数据里面。</p><h4 id="Redis缓存原理"><a href="#Redis缓存原理" class="headerlink" title="Redis缓存原理"></a>Redis缓存原理</h4><p>采用redis nosql数据库作为Mysql数据库的缓存，在查找的时候，首先查找redis缓存，如果找到则返回结果；如果在redis中没有找到，那么查找Mysql数据库，找到的花则返回结果并且更新redis；如果没有找到则返回空。</p><img src="/2018/08/18/关于数据库redis与Mysql的区别以及在web开发中的配合使用/2.jpg"><p>对于写入：用户增删改数据库，先访问mysql，mysql再把数据更新到redis。</p><p>Mysql中的数据都是按表存储的；更微观地看，这些表都是按行存储的。每执行一次select查询，Mysql都会返回一个结果集，这个结果集由若干行组成。所以，一个自然而然的想法就是在Redis中找到一种对应于Mysql行的数据结构。<br>Redis中提供了五种基本数据结构，即字符串（string）、列表（list）、哈希（hash）、集合（set）和有序集合（sorted set）。经过调研，发现适合存储行的数据结构有两种，即string和hash。</p><p>用户的缓存数据在返回时一般都是JSON的字典格式，对应的存到redis里就是hash格式，这个与python的字典是相对应的。</p><table><thead><tr><th>redis中的hash</th><th>python中的字典</th></tr></thead><tbody><tr><td><font color="#000000">key</font></td><td><font color="#000000">对象</font></td></tr><tr><td><font color="#000000">field</font></td><td><font color="#000000">key</font></td></tr><tr><td><font color="#000000">value</font></td><td><font color="#000000">value</font></td></tr></tbody></table><p>即hash会根据要缓存的数据生成唯一标识UUID，UUID作为键，用户的字典数据中的键值对作为UUID键的值，存储到redis中。</p>]]></content>
    
    <summary type="html">
    
      redis与mysql的优缺点分析，以及在web中的配合使用
    
    </summary>
    
      <category term="数据库" scheme="http://zypuu.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库,redis,mysql" scheme="http://zypuu.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93-redis-mysql/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch的使用</title>
    <link href="http://zypuu.com/2018/08/01/Elasticsearch%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://zypuu.com/2018/08/01/Elasticsearch的使用/</id>
    <published>2018-08-01T12:02:55.000Z</published>
    <updated>2018-09-01T13:04:17.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h2><p>ES=elaticsearch简写， Elasticsearch是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。<br>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p><h2 id="ES工作原理"><a href="#ES工作原理" class="headerlink" title="ES工作原理"></a>ES工作原理</h2><p>当ElasticSearch的节点启动后，它会利用多播(multicast)(或者单播，如果用户更改了配置)寻找集群中的其它节点，并与之建立连接。这个过程如下图所示：<br><img src="/2018/08/01/Elasticsearch的使用/1.jpg"></p><h2 id="ES核心概念"><a href="#ES核心概念" class="headerlink" title="ES核心概念"></a>ES核心概念</h2><h3 id="Cluster：集群"><a href="#Cluster：集群" class="headerlink" title="Cluster：集群"></a>Cluster：集群</h3><p>ES可以作为一个独立的单个搜索服务器。不过，为了处理大型数据集，实现容错和高可用性，ES可以运行在许多互相合作的服务器上。这些服务器的集合称为集群。</p><h3 id="Node：节点"><a href="#Node：节点" class="headerlink" title="Node：节点"></a>Node：节点</h3><p>形成集群的每个服务器称为节点。</p><h3 id="Shard：分片"><a href="#Shard：分片" class="headerlink" title="Shard：分片"></a>Shard：分片</h3><p>当有大量的文档时，由于内存的限制、磁盘处理能力不足、无法足够快的响应客户端的请求等，一个节点可能不够。这种情况下，数据可以分为较小的分片。每个分片放到不同的服务器上。<br>当你查询的索引分布在多个分片上时，ES会把查询发送给每个相关的分片，并将结果组合在一起，而应用程序并不知道分片的存在。即：这个过程对用户来说是透明的。</p><h3 id="Replia：副本"><a href="#Replia：副本" class="headerlink" title="Replia：副本"></a>Replia：副本</h3><p>为提高查询吞吐量或实现高可用性，可以使用分片副本。<br>副本是一个分片的精确复制，每个分片可以有零个或多个副本。ES中可以有许多相同的分片，其中之一被选择更改索引操作，这种特殊的分片称为主分片。<br>当主分片丢失时，如：该分片所在的数据不可用时，集群将副本提升为新的主分片。</p><h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><p>全文检索就是对一篇文章进行索引，可以根据关键字搜索，类似于mysql里的like语句。<br>全文索引就是把内容根据词的意义进行分词，然后分别创建索引，例如”你们的激情是因为什么事情来的” 可能会被分词成：“你们“，”激情“，“什么事情“，”来“ 等token，这样当你搜索“你们” 或者 “激情” 都会把这句搜出来。</p><h2 id="ES数据架构的主要概念（与关系数据库Mysql对比）"><a href="#ES数据架构的主要概念（与关系数据库Mysql对比）" class="headerlink" title="ES数据架构的主要概念（与关系数据库Mysql对比）"></a>ES数据架构的主要概念（与关系数据库Mysql对比）</h2><img src="/2018/08/01/Elasticsearch的使用/2.jpg"><p>（1）关系型数据库中的数据库（DataBase），等价于ES中的索引（Index）<br>（2）一个数据库下面有N张表（Table），等价于1个索引Index下面有N多类型（Type），<br>（3）一个数据库表（Table）下的数据由多行（ROW）多列（column，属性）组成，等价于1个Type由多个文档（Document）和多Field组成。<br>（4）在一个关系型数据库里面，schema定义了表、每个表的字段，还有表和字段之间的关系。 与之对应的，在ES中：Mapping定义索引下的Type的字段处理规则，即索引如何建立、索引类型、是否保存原始索引JSON文档、是否压缩原始JSON文档、是否需要分词处理、如何进行分词处理等。<br>（5）在数据库中的增insert、删delete、改update、查search操作等价于ES中的增PUT/POST、删Delete、改_update、查GET.</p><h2 id="简单使用ES"><a href="#简单使用ES" class="headerlink" title="简单使用ES"></a>简单使用ES</h2><h3 id="使用Docker安装Elasticsearch及其扩展"><a href="#使用Docker安装Elasticsearch及其扩展" class="headerlink" title="使用Docker安装Elasticsearch及其扩展"></a>使用Docker安装Elasticsearch及其扩展</h3><p>获取镜像，可以通过网络pull</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull delron/elasticsearch-ik:<span class="number">2.4</span><span class="number">.6</span><span class="number">-1.0</span></span><br></pre></td></tr></table></figure><p>修改elasticsearch的配置文件 elasticsearc-2.4.6/config/elasticsearch.yml第54行，更改ip地址为本机ip地址</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network.host: 自己机器的IP地址</span><br></pre></td></tr></table></figure><p>创建docker容器运行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dti --network=host --name=elasticsearch -v /home/python/elasticsearch<span class="number">-2.4</span><span class="number">.6</span>/config:<span class="regexp">/usr/</span>share/elasticsearch/config delron/elasticsearch-ik:<span class="number">2.4</span><span class="number">.6</span><span class="number">-1.0</span></span><br></pre></td></tr></table></figure><h3 id="使用haystack对接Elasticsearch"><a href="#使用haystack对接Elasticsearch" class="headerlink" title="使用haystack对接Elasticsearch"></a>使用haystack对接Elasticsearch</h3><p>Haystack为Django提供了模块化的搜索。它的特点是统一的，熟悉的API，可以让你在不修改代码的情况下使用不同的搜索后端（比如 Solr, Elasticsearch, Whoosh, Xapian 等等）。</p><p>这里通过使用haystack来调用Elasticsearch搜索引擎。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install drf-haystack</span><br><span class="line">pip install elasticsearch==<span class="number">2.4</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>drf-haystack是为了在REST framework中使用haystack而进行的封装（如果在Django中使用haystack，则安装django-haystack即可）。</p><h4 id="注册应用"><a href="#注册应用" class="headerlink" title="注册应用"></a>注册应用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'haystack'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Haystack</span><br><span class="line">HAYSTACK_CONNECTIONS = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'haystack.backends.elasticsearch_backend.ElasticsearchSearchEngine'</span>,</span><br><span class="line">        # 端口号固定为9200</span><br><span class="line">        <span class="string">'URL'</span>: <span class="string">'http://es的IP:9200/'</span>,</span><br><span class="line">        # 指定elasticsearch建立的索引库的名称</span><br><span class="line">        <span class="string">'INDEX_NAME'</span>: <span class="string">'名称自定'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 当添加、修改、删除数据时，自动生成索引</span><br><span class="line">HAYSTACK_SIGNAL_PROCESSOR = <span class="string">'haystack.signals.RealtimeSignalProcessor'</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>HAYSTACK_SIGNAL_PROCESSOR 的配置保证了在Django运行起来后，有新的数据产生时，haystack仍然可以让Elasticsearch实时生成新数据的索引</p><h4 id="创建索引类"><a href="#创建索引类" class="headerlink" title="创建索引类"></a>创建索引类</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> haystack <span class="keyword">import</span> indexes</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> SKU</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SKUIndex(indexes.SearchIndex, indexes.Indexable):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    SKU索引数据模型类</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    text = indexes.CharField(<span class="built_in">document</span>=True, use_template=True)</span><br><span class="line"></span><br><span class="line">    def get_model(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"返回建立索引的模型类"</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">return</span> SKU</span><br><span class="line"></span><br><span class="line">    def index_queryset(self, using=None):</span><br><span class="line">        <span class="string">""</span><span class="string">"返回要建立索引的数据查询集"</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">return</span> self.get_model().objects.filter(is_launched=True)</span><br></pre></td></tr></table></figure><p>在SKUIndex建立的字段，都可以借助haystack由elasticsearch搜索引擎查询。</p><p>其中text字段我们声明为document=True，表名该字段是主要进行关键字查询的字段， 该字段的索引值可以由多个数据库模型类字段组成，具体由哪些模型类字段组成，我们用use_template=True表示后续通过模板来指明。</p><p>在REST framework中，索引类的字段会作为查询结果返回数据的来源。</p><h4 id="在templates目录中创建text字段使用的模板文件"><a href="#在templates目录中创建text字段使用的模板文件" class="headerlink" title="在templates目录中创建text字段使用的模板文件"></a>在templates目录中创建text字段使用的模板文件</h4><p>具体在templates/search/indexes/goods/sku_text.txt文件中定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; object.name &#125;&#125;</span><br><span class="line">&#123;&#123; object.caption &#125;&#125;</span><br></pre></td></tr></table></figure><p>此模板指明当将关键词通过text参数名传递时，可以通过sku的name、caption、id来进行关键字索引查询。</p><h4 id="手动生成初始索引"><a href="#手动生成初始索引" class="headerlink" title="手动生成初始索引"></a>手动生成初始索引</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py rebuild_index</span><br></pre></td></tr></table></figure><h4 id="创建序列化器"><a href="#创建序列化器" class="headerlink" title="创建序列化器"></a>创建序列化器</h4><p>在goods/serializers.py中创建haystack序列化器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> drf_haystack.serializers <span class="keyword">import</span> HaystackSerializer</span><br><span class="line"><span class="keyword">from</span> .search_indexes <span class="keyword">import</span> SKUIndex</span><br><span class="line"></span><br><span class="line">class SKUIndexSerializer(HaystackSerializer):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    SKU索引结果数据序列化器</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    object = SKUSerializer(read_only=True)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        index_classes = [SKUIndex]</span><br><span class="line">        fields = (</span><br><span class="line">            'text',  # 用于接收查询关键字</span><br><span class="line">            'object'  # 用于返回查询结果</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>下面的搜索视图使用SKUIndexSerializer序列化器用来检查前端传入的参数text，并且检索出数据后再使用这个序列化器返回给前端；</p><p>SKUIndexSerializer序列化器中的object字段是用来向前端返回数据时序列化的字段。</p><p>Haystack通过Elasticsearch检索出匹配关键词的搜索结果后，还会在数据库中取出完整的数据库模型类对象，放到搜索结果的object属性中，并将结果通过SKUIndexSerializer序列化器进行序列化。所以我们可以通过声明搜索结果的object字段以SKUSerializer序列化的形式进行处理，明确要返回的搜索结果中每个数据对象包含哪些字段。</p><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><p>在goods/views.py中创建视图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> drf_haystack.viewsets <span class="keyword">import</span> HaystackViewSet</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> SKUIndexSerializer</span><br><span class="line"></span><br><span class="line">class SKUSearchViewSet(HaystackViewSet):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    SKU搜索</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    index_models = [SKU]</span><br><span class="line"></span><br><span class="line">    serializer_class = SKUIndexSerializer</span><br></pre></td></tr></table></figure><p>注意：<br>该视图会返回搜索结果的列表数据，所以可以为视图增加REST framework的分页功能。<br>我们在实现商品列表页面时已经定义了全局的分页配置，所以此搜索视图会使用全局的分页配置。</p><h4 id="定义路由"><a href="#定义路由" class="headerlink" title="定义路由"></a>定义路由</h4><p>在goods/urls.py中通过REST framework的router来定义路由<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> DefaultRouter</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">router = DefaultRouter()</span><br><span class="line">router.register(<span class="string">'skus/search'</span>, views.SKUSearchViewSet, base_name=<span class="string">'skus_search'</span>)</span><br><span class="line"></span><br><span class="line">urlpatterns += router.urls</span><br></pre></td></tr></table></figure></p><h4 id="bug说明"><a href="#bug说明" class="headerlink" title="bug说明"></a>bug说明</h4><p>如果在配置完haystack并启动程序后，出现如下异常，是因为drf-haystack还没有适配最新版本的REST framework框架<br><img src="/2018/08/01/Elasticsearch的使用/3.jpg"><br>可以通过修改REST framework框架代码，补充_get_count函数定义即可</p><p>文件路径 虚拟环境下的 lib/python3.6/site-packages/rest_framework/pagination.py</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def _get_count(queryset):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    Determine an object count, supporting either querysets or regular lists.</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> queryset.count()</span><br><span class="line">    except (AttributeError, <span class="built_in">TypeError</span>):</span><br><span class="line">        <span class="keyword">return</span> len(queryset)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Elasticsearch的初步介绍，以及简单使用。
    
    </summary>
    
      <category term="web开发" scheme="http://zypuu.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="web,search" scheme="http://zypuu.com/tags/web-search/"/>
    
  </entry>
  
  <entry>
    <title>关于docker的个人理解</title>
    <link href="http://zypuu.com/2018/08/01/%E5%85%B3%E4%BA%8Edocker%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <id>http://zypuu.com/2018/08/01/关于docker的个人理解/</id>
    <published>2018-08-01T07:19:59.000Z</published>
    <updated>2018-08-29T10:24:26.839Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Docker通俗理解"><a href="#Docker通俗理解" class="headerlink" title="Docker通俗理解"></a>Docker通俗理解</h3><p>什么是docker，docker翻译过来的名称就是容器，而容器是干什么用的，容器用来装东西的，就像一个集装箱，一个密闭的容器，不受外部的干扰，也无法干扰外部。<br>docker就是这么一个密闭的容器，将那些程序服务就放在docker里来运行。</p><h3 id="为什么使用Docker"><a href="#为什么使用Docker" class="headerlink" title="为什么使用Docker"></a>为什么使用Docker</h3><p>将程序软件安装在docker容器里去运行，本质上讲是一种虚拟技术，提到虚拟技术，就会想到虚拟机，那为什么要将程序安装到docker里运行，不直接在本机安装，使用虚拟技术，它又与虚拟机有和区别呢？</p><p>将程序直接安装在本机上，对于服务或者运行效率当然是最佳的体验，所以为什么使用容器，最主要原因就是成本原因，每一台主机都是有成本的，如果为了保证效率，每一台主机只跑部分服务，而需要多台主机的话，那成本就高了，当然有钱的另说，比如银行，追求省心稳定，一个服务器挂一台主机，性能用不完。但是一般的商业公司追求一定的经济性，一个主机只跑一些服务太浪费了，所以就出现把主机分开独立运行的手段—docker，降低服务器成本，还要保证一定的使用效率。</p><p>还有VM虚拟机，同样是虚拟技术，docker相对于虚拟机有何优点？<br>docker是直接调用原生系统资源，不像虚拟机是安装在操作系统上层层吃配置的软件服务。它比虚拟机更加强大，体积小，运行速度快，启动和关闭只需要几秒。相对于普通虚拟机来说，启动时间在分钟级别，占用内存大。所以这就是docker出现之后的优势。</p><h3 id="docker的应用场景"><a href="#docker的应用场景" class="headerlink" title="docker的应用场景"></a>docker的应用场景</h3><p>容器提供了隔离性，结论是，容器可以为各种测试提供很好的沙盒环境。并且，容器本 身就具有“标准性”的特征，非常适合为服务创建构建块。<br>Docker 的一些应用场景如下:<br>1.加速本地开发和构建流程，使其更加高效、更加轻量化。本地开发人员可以构建、 运行并分享 Docker 容器。容器可以在开发环境中构建，然后轻松的提交到测试环境中，并 最终进入生产环境。<br>2.能够让独立的服务或应用程序在不同的环境中，得到相同的运行结果。这一点在 面向服务的架构和重度依赖微型服务的部署由其实用。<br>3.用 Docker 创建隔离的环境来进行测试。例如，用 Jenkins CI 这样的持续集成工具 启动一个用于测试的容器。<br>4.Docker 可以让开发者先在本机上构建一个复杂的程序或架构来进行测试，而不是 一开始就在生产环境部署、测试。</p><h3 id="镜像、容器与仓库"><a href="#镜像、容器与仓库" class="headerlink" title="镜像、容器与仓库"></a>镜像、容器与仓库</h3><h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><p>创建虚拟机和docker 都必不可少的东西。  用过虚拟机的朋友都知道，创建一个虚拟机就先得下载操作系统的ISO镜像文件，然后通过镜像文件安装操作系统，和实体机类似，然后能在虚拟机中去安装各种软件。也可以将镜像当作容器的“源代码”。镜像体积很小，非常便携，易于分享、存储和更新。<br>Docker 容器启动是需要一些文件的， 而这些文件就可以称为 Docker 镜像。</p><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>通俗拿VM虚拟机和docker来举例，一个容器就类似于一个虚拟机，只不过在docker技术的术语上称为容器。这个容器装的就是我们部署的应用在运行，和虚拟机一样可以开机，关机，重启。docker称为容器的运行，关闭，重启。而且这个容器可以打包为镜像文件，类似虚拟机快照的文件，放在其它虚拟机上又可以保持原样能运行，docker也是如此，把容器打包为镜像文件，然后在新的服务器安装好的docker环境下导入进去，保持原来的状态能够运行。<br>容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。</p><h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><p>如果你使用过git和github就很容易理解Docker的仓库概念。Docker 仓库的概念跟Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</p><p>Docker 仓库是用来包含镜像的位置，Docker提供一个注册服务器（Register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像。Docker运行中使用的默认仓库是 Docker Hub 公共仓库。</p><p>仓库支持的操作类似git，当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。.</p><h3 id="docker、容器、镜像的安装与操作"><a href="#docker、容器、镜像的安装与操作" class="headerlink" title="docker、容器、镜像的安装与操作"></a>docker、容器、镜像的安装与操作</h3><h4 id="docker的安装与操作"><a href="#docker的安装与操作" class="headerlink" title="docker的安装与操作"></a>docker的安装与操作</h4><p>添加Docker官方GPG key<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key add gpg</span><br></pre></td></tr></table></figure></p><p>安装Docker稳定版<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i docker-ce_17<span class="number">.03</span><span class="number">.2</span>~ce<span class="number">-0</span>~ubuntu-xenial_amd64.deb</span><br></pre></td></tr></table></figure></p><p>检查Docker是否安装正确<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure></p><p>为了避免每次命令都输入sudo，可以设置用户权限，注意执行后须注销重新登录<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G docker $USER</span><br></pre></td></tr></table></figure></p><p>安装完成Docker后，默认已经启动了docker服务，如需手动控制docker服务的启停，可执行如下命令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 启动docker</span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line"># 停止docker</span><br><span class="line">sudo service docker stop</span><br><span class="line"></span><br><span class="line"># 重启docker</span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure><h4 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h4><p>列出镜像</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>拉取镜像。即从官方仓库docker hub上拉取。<a href="https://hub.docker.com/" target="_blank" rel="noopener">docker hub</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull library/hello-world</span><br></pre></td></tr></table></figure><p>由于 Docker 官方提供的 image 文件，都放在library组里面，所以它的是默认组，可以省略，hello world 是镜像文件名字。</p><p>删除镜像</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm 镜像名或镜像id</span><br></pre></td></tr></table></figure><h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4><p>创建容器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [option] 镜像名 [向启动容器中传入的命令]</span><br></pre></td></tr></table></figure><p>-i 表示以“交互模式”运行容器<br>-t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即 分配一个伪终端。<br>–name 为创建的容器命名<br>-v 表示目录映射关系(前者是宿主机目录，后者是映射到宿主机上的目录，即 宿主机目录:容器中目录)，可以使 用多个-v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后 共享到容器上。<br>-d 在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不 会自动登录容器，如果只加-i -t 两个参数，创建后就会自动进去容器)。<br>-p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p 做多个端口映射<br>-e 为容器设置环境变量<br>–network=host 表示将主机的网络环境映射到容器中，容器的网络与主机相同<br>例：<br>交互式容器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=myubuntu ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>可以执行linux命令。<br>守护式容器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name=myubuntu2 ubuntu</span><br></pre></td></tr></table></figure><p>如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器。在容器内部exit退出时，容器也不会停止。</p><p>查看容器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 列出本机正在运行的容器</span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line"># 列出本机所有容器，包括已经终止运行的</span><br><span class="line">docker container ls --all</span><br></pre></td></tr></table></figure><p>停止与启动容器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 停止一个已经在运行的容器</span><br><span class="line">docker container stop 容器名或容器id</span><br><span class="line"></span><br><span class="line"># 启动一个已经停止的容器</span><br><span class="line">docker container start 容器名或容器id</span><br><span class="line"></span><br><span class="line"># kill掉一个已经在运行的容器</span><br><span class="line">docker container kill 容器名或容器id</span><br></pre></td></tr></table></figure><p>删除容器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm 容器名或容器id</span><br></pre></td></tr></table></figure><h4 id="将容器保存为镜像，备份迁移"><a href="#将容器保存为镜像，备份迁移" class="headerlink" title="将容器保存为镜像，备份迁移"></a>将容器保存为镜像，备份迁移</h4><p>将容器保存为镜像<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit 容器名 镜像名</span><br></pre></td></tr></table></figure></p><p>将镜像打包成文件，拷贝给别人使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o 保存的文件名 镜像名</span><br></pre></td></tr></table></figure><p>拿到镜像文件加载到本地</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i ./ubuntu.tar</span><br></pre></td></tr></table></figure><p>当前目录下的ubantu为例</p>]]></content>
    
    <summary type="html">
    
      理解docker与镜像，如何使用docker来运行程序
    
    </summary>
    
      <category term="环境安装" scheme="http://zypuu.com/categories/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="虚拟技术,docker" scheme="http://zypuu.com/tags/%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF-docker/"/>
    
  </entry>
  
  <entry>
    <title>关于FastDFS文件分布式系统</title>
    <link href="http://zypuu.com/2018/07/16/%E5%85%B3%E4%BA%8EFastDFS%E6%96%87%E4%BB%B6%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>http://zypuu.com/2018/07/16/关于FastDFS文件分布式系统/</id>
    <published>2018-07-16T11:15:15.000Z</published>
    <updated>2018-08-29T10:48:49.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FastDFS简介"><a href="#FastDFS简介" class="headerlink" title="FastDFS简介"></a>FastDFS简介</h2><h3 id="什么是FastDFS"><a href="#什么是FastDFS" class="headerlink" title="什么是FastDFS"></a>什么是FastDFS</h3><p>FastDFS 是一个开源的高性能分布式文件系统（DFS）。 它的主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡。主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB &lt; file_size &lt;500MB）为载体的在线服务。</p><p>FastDFS 系统有三个角色：跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)。</p><p>　　Tracker Server：跟踪服务器，主要做调度工作，起到均衡的作用；负责管理所有的 storage server和 group，每个 storage 在启动后会连接 Tracker，告知自己所属 group 等信息，并保持周期性心跳。</p><p>　　Storage Server：存储服务器，主要提供容量和备份服务；以 group 为单位，每个 group 内可以有多台 storage server，数据互为备份。</p><p>　　Client：客户端，上传下载数据的服务器，也就是我们自己的项目所部署在的服务器。<br> <img src="/2018/07/16/关于FastDFS文件分布式系统/1.jpg"><br>服务端两个角色:</p><p>Tracker: 管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。<br>Storage: 实际保存文件， Storage 分为多个组，每个组之间保存的文件是不同的。每 个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有 主从的概念。</p><h3 id="FastDFS存储策略"><a href="#FastDFS存储策略" class="headerlink" title="FastDFS存储策略"></a>FastDFS存储策略</h3><p>为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。</p><p>在卷中增加服务器时，同步已有的文件由系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了存储系统的容量。</p><h3 id="文件上传流程"><a href="#文件上传流程" class="headerlink" title="文件上传流程"></a>文件上传流程</h3><p>FastDFS向使用者提供基本文件访问接口，比如upload、download、append、delete等，以客户端库的方式提供给用户使用。</p><p>Storage Server会定期的向Tracker Server发送自己的存储信息。当Tracker Server Cluster中的Tracker Server不止一个时，各个Tracker之间的关系是对等的，所以客户端上传时可以选择任意一个Tracker。<br><img src="/2018/07/16/关于FastDFS文件分布式系统/2.jpg"><br>当Tracker收到客户端上传文件的请求时，会为该文件分配一个可以存储文件的group，当选定了group后就要决定给客户端分配group中的哪一个storage server。当分配好storage server后，客户端向storage发送写文件请求，storage将会为文件分配一个数据存储目录。然后为文件分配一个fileid，最后根据以上的信息生成文件名存储文件。</p><h3 id="文件名组成"><a href="#文件名组成" class="headerlink" title="文件名组成"></a>文件名组成</h3><p>文件名如下：<br><img src="/2018/07/16/关于FastDFS文件分布式系统/3.jpg"><br>组名：文件上传后所在的 storage 组名称，在文件上传成功后有 storage 服务器返回， 需要客户端自行保存。<br>虚拟磁盘路径：storage 配置的虚拟路径，与磁盘选项 store_path对应。如果配置了 store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推。<br>数据两级目录：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据 文件。<br>文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含:源存储 服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。</p><h2 id="简易FastDFS构建"><a href="#简易FastDFS构建" class="headerlink" title="简易FastDFS构建"></a>简易FastDFS构建</h2><h3 id="使用docker安装FastDFS"><a href="#使用docker安装FastDFS" class="headerlink" title="使用docker安装FastDFS"></a>使用docker安装FastDFS</h3><p>拉取镜像</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull delron/fastdfs</span><br></pre></td></tr></table></figure><p>运行tracker</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dti --network=host --name tracker -v /<span class="keyword">var</span>/fdfs/tracker:<span class="regexp">/var/</span>fdfs delron/fastdfs tracker</span><br></pre></td></tr></table></figure><p>运行storage</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dti --network=host --name storage -e TRACKER_SERVER=本机ip:<span class="number">22122</span> -v /<span class="keyword">var</span>/fdfs/storage:<span class="regexp">/var/</span>fdfs delron/fastdfs storage</span><br></pre></td></tr></table></figure><p>然后可使用docker命令进行管理操作。</p><h3 id="FastDFS的Python客户端，Django使用FastDFS"><a href="#FastDFS的Python客户端，Django使用FastDFS" class="headerlink" title="FastDFS的Python客户端，Django使用FastDFS"></a>FastDFS的Python客户端，Django使用FastDFS</h3><p>参考：<a href="https://github.com/jefforeilly/fdfs_client-py" target="_blank" rel="noopener">点这里</a></p><p>安装环境<br>下载安装包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install fdfs_client-py-master.zip</span><br><span class="line">pip install mutagen</span><br><span class="line">pip install requests</span><br></pre></td></tr></table></figure><p>配置<br>我们在utils包下新建fastdfs包，client.conf配置文件放到这个目录中。<br>然后改一下其中的配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base_path=FastDFS客户端存放日志文件的目录</span><br><span class="line">tracker_server=运行tracker服务的机器ip:<span class="number">22122</span></span><br></pre></td></tr></table></figure><p>上传文件需要先创建fdfs_client.client.Fdfs_client的对象，并指明配置文件，如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fdfs_client.client <span class="keyword">import</span> Fdfs_client</span><br><span class="line">client = Fdfs_client(<span class="string">'utils/fastdfs/client.conf'</span>)</span><br></pre></td></tr></table></figure><p>通过创建的对象，执行上传文件的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fdfs_client.client <span class="keyword">import</span> Fdfs_client</span><br><span class="line">client = Fdfs_client(<span class="string">'utils/fastdfs/client.conf'</span>)</span><br></pre></td></tr></table></figure><h3 id="自定义Django文件存储系统"><a href="#自定义Django文件存储系统" class="headerlink" title="自定义Django文件存储系统"></a>自定义Django文件存储系统</h3><p>django自带文件存储系统，但是存储路径是本地，怎样将文件存储到FastDFS的服务器上呢<br>参考文档：<a href="https://yiyibooks.cn/xx/Django_1.11.6/howto/custom-file-storage.html" target="_blank" rel="noopener">点这里</a></p><p>自定义文件存储系统的方法如下：<br>1）需要继承自django.core.files.storage.Storage，如</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.files.storage <span class="keyword">import</span> Storage</span><br><span class="line"></span><br><span class="line">class FastDFSStorage(Storage):</span><br></pre></td></tr></table></figure><p>2）支持Django不带任何参数来实例化存储类，也就是说任何设置都应该从django.conf.settings中获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.core.files.storage <span class="keyword">import</span> Storage</span><br><span class="line"></span><br><span class="line">class FastDFSStorage(Storage):</span><br><span class="line">    def __init__(self, base_url=None, client_conf=None):</span><br><span class="line">        <span class="keyword">if</span> base_url is None:</span><br><span class="line">            base_url = settings.FDFS_URL</span><br><span class="line">        self.base_url = base_url</span><br><span class="line">        <span class="keyword">if</span> client_conf is None:</span><br><span class="line">            client_conf = settings.FDFS_CLIENT_CONF</span><br><span class="line">        self.client_conf = client_conf</span><br></pre></td></tr></table></figure><p>3）存储类中必须实现_open()和_save()方法，以及任何后续使用中可能用到的其他方法。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_open(name, mode=<span class="string">'rb'</span>)</span><br><span class="line"># 被Storage.open()调用，在打开文件时被使用。</span><br><span class="line">_save(name, content)</span><br><span class="line"># 被Storage.save()调用，name是传入的文件名，content是Django接收到的文件内容，该方法需要将content文件内容保存。</span><br><span class="line"># Django会将该方法的返回值保存到数据库中对应的文件字段，也就是说该方法应该返回要保存在数据库中的文件名称信息。</span><br><span class="line">exists(name)</span><br><span class="line"># 如果名为name的文件在文件系统中存在，则返回True，否则返回False。</span><br><span class="line">url(name)</span><br><span class="line"># 返回文件的完整访问URL</span><br><span class="line"><span class="keyword">delete</span>(name)</span><br><span class="line"># 删除name的文件</span><br><span class="line">listdir(path)</span><br><span class="line"># 列出指定路径的内容</span><br><span class="line">size(name)</span><br><span class="line"># 返回name文件的总大小</span><br></pre></td></tr></table></figure><p>4）需要为存储类添加django.utils.deconstruct.deconstructible装饰器<br>我们在utils/fastdfs目录中创建fdfs_storage.py文件，实现可以使用FastDFS存储文件的存储类如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.core.files.storage <span class="keyword">import</span> Storage</span><br><span class="line"><span class="keyword">from</span> django.utils.deconstruct <span class="keyword">import</span> deconstructible</span><br><span class="line"><span class="keyword">from</span> fdfs_client.client <span class="keyword">import</span> Fdfs_client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@deconstructible</span><br><span class="line">class FastDFSStorage(Storage):</span><br><span class="line">    def __init__(self, base_url=None, client_conf=None):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        初始化</span></span><br><span class="line"><span class="string">        :param base_url: 用于构造图片完整路径使用，图片服务器的域名</span></span><br><span class="line"><span class="string">        :param client_conf: FastDFS客户端配置文件的路径</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> base_url is None:</span><br><span class="line">            base_url = settings.FDFS_URL</span><br><span class="line">        self.base_url = base_url</span><br><span class="line">        <span class="keyword">if</span> client_conf is None:</span><br><span class="line">            client_conf = settings.FDFS_CLIENT_CONF</span><br><span class="line">        self.client_conf = client_conf</span><br><span class="line"></span><br><span class="line">    def _open(self, name, mode=<span class="string">'rb'</span>):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        用不到打开文件，所以省略</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def _save(self, name, content):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        在FastDFS中保存文件</span></span><br><span class="line"><span class="string">        :param name: 传入的文件名</span></span><br><span class="line"><span class="string">        :param content: 文件内容</span></span><br><span class="line"><span class="string">        :return: 保存到数据库中的FastDFS的文件名</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        client = Fdfs_client(self.client_conf)</span><br><span class="line">        ret = client.upload_by_buffer(content.read())</span><br><span class="line">        <span class="keyword">if</span> ret.get(<span class="string">"Status"</span>) != <span class="string">"Upload successed."</span>:</span><br><span class="line">            raise Exception(<span class="string">"upload file failed"</span>)</span><br><span class="line">        file_name = ret.get(<span class="string">"Remote file_id"</span>)</span><br><span class="line">        <span class="keyword">return</span> file_name</span><br><span class="line"></span><br><span class="line">    def url(self, name):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        返回文件的完整URL路径</span></span><br><span class="line"><span class="string">        :param name: 数据库中保存的文件名</span></span><br><span class="line"><span class="string">        :return: 完整的URL</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">return</span> self.base_url + name</span><br><span class="line"></span><br><span class="line">    def exists(self, name):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        判断文件是否存在，FastDFS可以自行解决文件的重名问题</span></span><br><span class="line"><span class="string">        所以此处返回False，告诉Django上传的都是新文件</span></span><br><span class="line"><span class="string">        :param name:  文件名</span></span><br><span class="line"><span class="string">        :return: False</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">return</span> False</span><br></pre></td></tr></table></figure></p><h3 id="在Django配置中设置自定义文件存储类"><a href="#在Django配置中设置自定义文件存储类" class="headerlink" title="在Django配置中设置自定义文件存储类"></a>在Django配置中设置自定义文件存储类</h3><p>在settings.py文件中添加设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># django文件存储</span><br><span class="line">DEFAULT_FILE_STORAGE = <span class="string">'utils.fastdfs.fdfs_storage.FastDFSStorage'</span></span><br><span class="line"></span><br><span class="line"># FastDFS</span><br><span class="line">FDFS_URL = <span class="string">'你的域名:8888/'</span>  </span><br><span class="line">FDFS_CLIENT_CONF = os.path.join(BASE_DIR, <span class="string">'utils/fastdfs/client.conf'</span>)</span><br></pre></td></tr></table></figure><h3 id="添加image域名"><a href="#添加image域名" class="headerlink" title="添加image域名"></a>添加image域名</h3><p>在/etc/hosts中添加访问FastDFS storage服务器的域名<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP   image.域名</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      FastDFS简介，使用FastDFS进行文件存储
    
    </summary>
    
      <category term="环境安装" scheme="http://zypuu.com/categories/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="文件存储" scheme="http://zypuu.com/tags/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>页面静态化与定时任务</title>
    <link href="http://zypuu.com/2018/07/08/%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://zypuu.com/2018/07/08/页面静态化与定时任务/</id>
    <published>2018-07-08T11:15:15.000Z</published>
    <updated>2018-08-29T14:40:14.200Z</updated>
    
    <content type="html"><![CDATA[<p>网站的首页频繁被访问，为了提升访问速度，除了缓存技术，还可以使用页面静态化技术。其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。</p><h2 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h2><h3 id="什么是页面静态化"><a href="#什么是页面静态化" class="headerlink" title="什么是页面静态化"></a>什么是页面静态化</h3><p>页面静态化即将动态渲染生成的页面结果保存成html文件，放到静态文件服务器中。用户访问的时候访问的是处理好之后的html静态文件。</p><p>页面中有些区域，因登录用户不同，而显示不同的数据，可以在用户请求完html页面后，通过ajax向后端发送请求，获取属于用户的特殊的数据。</p><h3 id="首页配置静态化"><a href="#首页配置静态化" class="headerlink" title="首页配置静态化"></a>首页配置静态化</h3><p>在settings.py中添加保存静态文件的目录</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 生成的静态html文件保存目录</span><br><span class="line">GENERATED_STATIC_HTML_FILES_DIR = os.path.join(os.path.dirname(BASE_DIR), <span class="string">'front_end_pc'</span>)</span><br></pre></td></tr></table></figure><p>front_end_pc为前端文件的存放目录</p><p>然后将静态化的页面数据例:index.html放置在templates文件里</p><p>静态化逻辑，生成静态化页面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 获取要生成的数据</span><br><span class="line"> context = &#123;</span><br><span class="line">        <span class="string">'categories'</span>: categories,</span><br><span class="line">        <span class="string">'contents'</span>: contents</span><br><span class="line">    &#125;</span><br><span class="line"># 加载模板</span><br><span class="line">    template = loader.get_template(<span class="string">'index.html'</span>)</span><br><span class="line"># 渲染模板</span><br><span class="line">    html_text = template.render(context)</span><br><span class="line"># 静态文件保存的路径</span><br><span class="line">    file_path = os.path.join(settings.GENERATED_STATIC_HTML_FILES_DIR, <span class="string">'index.html'</span>)</span><br><span class="line"># 打开该路径下的文件，没有则生成创建</span><br><span class="line">    <span class="keyword">with</span> open(file_path, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(html_text)</span><br></pre></td></tr></table></figure><h2 id="实现静态化的两种方式"><a href="#实现静态化的两种方式" class="headerlink" title="实现静态化的两种方式"></a>实现静态化的两种方式</h2><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在Django执行定时任务，可以通过django-crontab扩展来实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django-crontab</span><br></pre></td></tr></table></figure><p>然后配置中添加应用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    'django_crontab',  # 定时任务</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>设置任务的定时时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 定时任务</span><br><span class="line">CRONJOBS = [</span><br><span class="line">    # 每5分钟执行一次生成主页静态文件</span><br><span class="line">    (<span class="string">'*/5 * * * *'</span>, <span class="string">'contents.crons.generate_static_index_html'</span>, <span class="string">'&gt;&gt; 日志路径/logs/crontab.log'</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>基本格式 :</p><hr><p>分 时 日 月 周      命令</p><p>M: 分钟（0-59）。每分钟用<em>或者 </em>/1表示</p><p>H：小时（0-23）。（0表示0点）</p><p>D：天（1-31）。</p><p>m: 月（1-12）。</p><p>d: 一星期内的天（0~6，0为星期天）</p><p>开启定时任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py crontab add</span><br></pre></td></tr></table></figure><p>显示已经激活的定时任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py crontab show</span><br></pre></td></tr></table></figure><p>移除定时任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py crontab remove</span><br></pre></td></tr></table></figure><h4 id="解决中文字符问题"><a href="#解决中文字符问题" class="headerlink" title="解决中文字符问题"></a>解决中文字符问题</h4><p>在定时任务中，如果出现非英文字符，会出现字符异常错误<br>在settings中配置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 解决crontab中文问题</span><br><span class="line">CRONTAB_COMMAND_PREFIX = <span class="string">'LANG_ALL=zh_cn.UTF-8'</span></span><br></pre></td></tr></table></figure></p><h3 id="脚本手动生成静态化页面"><a href="#脚本手动生成静态化页面" class="headerlink" title="脚本手动生成静态化页面"></a>脚本手动生成静态化页面</h3><p>为了开发方便，可以编写手动生成所有商品静态页面的脚本 在项目下新建包scripts，再创建regenerate_detail_html.py</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#指定执行此py文件的命令为python</span><br><span class="line">#/usr/bin/env表示在当前环境中查找python命令，当前为虚拟环境py3_django</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">功能：手动生成所有SKU的静态detail html文件</span></span><br><span class="line"><span class="string">使用方法:</span></span><br><span class="line"><span class="string">    ./regenerate_detail_html.py</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">'../'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ.setdefault(<span class="string">"DJANGO_SETTINGS_MODULE"</span>, <span class="string">"meiduo_api.settings"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> django</span><br><span class="line"></span><br><span class="line">django.setup()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> goods.models <span class="keyword">import</span> SKU</span><br><span class="line"># 异步任务执行静态化</span><br><span class="line"><span class="keyword">from</span> celery_tasks.html.tasks <span class="keyword">import</span> generate_static_sku_detail_html</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    skus = SKU.objects.all()</span><br><span class="line">    <span class="keyword">for</span> sku <span class="keyword">in</span> skus:</span><br><span class="line">        print(sku.id)</span><br><span class="line">        generate_static_sku_detail_html(sku.id)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      在网站高并发的访问量下，如何快速生成页面，减少服务器压力
    
    </summary>
    
      <category term="web开发" scheme="http://zypuu.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="html静态化,处理高并发" scheme="http://zypuu.com/tags/html%E9%9D%99%E6%80%81%E5%8C%96-%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>CKEditor富文本编辑器</title>
    <link href="http://zypuu.com/2018/07/02/CKEditor%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://zypuu.com/2018/07/02/CKEditor富文本编辑器/</id>
    <published>2018-07-02T12:21:03.000Z</published>
    <updated>2018-08-29T10:23:28.870Z</updated>
    
    <content type="html"><![CDATA[<p>在运营后台，运营人员需要录入并编辑模型类的详情信息，而这些信息不是普通的文本，可以是包含了HTML语法格式的字符串。为了快速简单的让用户能够在页面中编辑带格式的文本，富文本即具备丰富样式格式的文本。<br><img src="/2018/07/02/CKEditor富文本编辑器/1.jpg"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django-ckeditor</span><br></pre></td></tr></table></figure><h2 id="添加应用"><a href="#添加应用" class="headerlink" title="添加应用"></a>添加应用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在INSTALLED_APPS中添加</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    'ckeditor',  # 富文本编辑器</span><br><span class="line">    'ckeditor_uploader',  # 富文本编辑器上传图片模块</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="添加CKEditor配置"><a href="#添加CKEditor配置" class="headerlink" title="添加CKEditor配置"></a>添加CKEditor配置</h2><p>在settings.py中添加</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 富文本编辑器ckeditor配置</span><br><span class="line">CKEDITOR_CONFIGS = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        'toolbar': 'full',  # 工具条功能</span><br><span class="line">        'height': 300,  # 编辑器高度</span><br><span class="line">        # 'width': 300,  # 编辑器宽度</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">CKEDITOR_UPLOAD_PATH = ''  # 上传图片保存路径，使用了FastDFS，所以此处设为' '</span><br></pre></td></tr></table></figure><h2 id="添加ckeditor路由"><a href="#添加ckeditor路由" class="headerlink" title="添加ckeditor路由"></a>添加ckeditor路由</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r<span class="string">'^ckeditor/'</span>, include(<span class="string">'ckeditor_uploader.urls'</span>)),</span><br></pre></td></tr></table></figure><h2 id="为模型类添加字段"><a href="#为模型类添加字段" class="headerlink" title="为模型类添加字段"></a>为模型类添加字段</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ckeditor.fields.RichTextField 不支持上传文件的富文本字段</span><br><span class="line">ckeditor_uploader.fields.RichTextUploadingField 支持上传文件的富文本字段</span><br></pre></td></tr></table></figure><p>在需要编辑的模型类的设置可以编辑的字段。<br>别忘了数据库迁移。</p>]]></content>
    
    <summary type="html">
    
      CKEditor富文本编辑器的配置安装
    
    </summary>
    
      <category term="环境安装" scheme="http://zypuu.com/categories/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="富文本编辑器" scheme="http://zypuu.com/tags/%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>关于web开发用户注册功能的图形验证码与短信验证码</title>
    <link href="http://zypuu.com/2018/06/18/%E5%85%B3%E4%BA%8Eweb%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E4%B8%8E%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD/"/>
    <id>http://zypuu.com/2018/06/18/关于web开发实现图形验证码与短信验证码功能/</id>
    <published>2018-06-18T11:15:15.000Z</published>
    <updated>2018-08-29T14:42:06.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flask框架"><a href="#Flask框架" class="headerlink" title="Flask框架"></a>Flask框架</h2><div>前后端不分离</div><h3 id="图片验证码"><a href="#图片验证码" class="headerlink" title="图片验证码"></a>图片验证码</h3><h4 id="Captcha"><a href="#Captcha" class="headerlink" title="Captcha"></a>Captcha</h4><div>1.基于captcha实现图片验证码，什么是captcha？<br><br>Captcha是一个第三方工具，提供生成验证码图片通用解决办法，提供了非常灵活的生成验证码图片的框架，可以自由的组合生成图片过程中的各种元素，例如，字体、颜色、背景、扭曲样式等，不仅提供了丰富的变形资源，即使不能满足需求的情况下，也可以实现固有的接口，创造出自己的字体变形的方式，所以该框架应该可以满足生成验证图片的大部分需求。<br><br><br>#### Flask框架中使用captcha完成图片验证码功能<br><br><br>将chptcha的第三方包放在utils文件夹中，utils是基于python创建一个flask工程后一个专门存放第三方工具包的文件夹。然后在功能视图模块中</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.captcha.captcha <span class="keyword">import</span> captcha</span><br></pre></td></tr></table></figure><p>视图函数中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># @user_blueprint是flask框架中，经过创建蓝图，蓝图注册的路由，后面是路由地址</span><br><span class="line">@user_blueprint.route(<span class="string">'/image_code'</span>)</span><br><span class="line">def image_code():</span><br><span class="line">    # 调用第三方的工具，生成图形验证码数据</span><br><span class="line">    name, text, image = captcha.generate_captcha()</span><br><span class="line">    # 保存text值，存放于session中，用于后续的对比验证</span><br><span class="line">    session[<span class="string">'image_code'</span>] = text</span><br><span class="line"> </span><br><span class="line">    # 创建响应对象，响应体为图片数据</span><br><span class="line">    response = make_response(image)</span><br><span class="line">    # 注意：这里一定要设置响应数据的类型为图片，不然会在网页上无法显示，生成乱码数据</span><br><span class="line">    response.content_type = <span class="string">'image/png'</span></span><br><span class="line">    # 返回到响应体</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>在首页的页面中index.html中，添加如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"/user/image_code?1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"get_pic_code"</span> onclick=<span class="string">"generateImageCode()"</span>&gt;</span><br></pre></td></tr></table></figure><p>显示图片，设置css样式，并绑定点击事件，生成图片验证码<br>然后在main.js（主页js里）添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateImageCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'.get_pic_code'</span>).attr(<span class="string">'src'</span>, $(<span class="string">'.get_pic_code'</span>).attr(<span class="string">'src'</span>) + <span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击事件，点击即修改他的src属性，重新生成图片验证码，即可实现<br>$(‘.get_pic_code’)是类选择器，attr获取其src属性进行修改</p><h3 id="短信验证码"><a href="#短信验证码" class="headerlink" title="短信验证码"></a>短信验证码</h3><h4 id="容联云通讯"><a href="#容联云通讯" class="headerlink" title="容联云通讯"></a>容联云通讯</h4><p>容联云通讯为第三方服务，云通讯平台将传统电信网络通讯能力、基于IP的通讯能力，通过开放API的方式提供给开发者与合作伙伴，让开发者们在应用程序中集成网络电话和电话会议功能变得简单。<br><br>可提供语音、IVR、短信、IM、视频等web开发接口，这里使用短信功能，详情可查看官方开发文档<a href="http://doc.yuntongxun.com/space/5a5098313b8496dd00dcdd7f" target="_blank" rel="noopener">点这里</a><br>查看基于python的短信发送接口。</p><h4 id="实现短信验证码发送功能"><a href="#实现短信验证码发送功能" class="headerlink" title="实现短信验证码发送功能"></a>实现短信验证码发送功能</h4><p>将云通讯第三方工具包放入utils文件夹中，云通讯文档使用说明：<br>1.接口声明文件：SDK \CCPRestSDK.py</p><p>2.接口函数定义：def sendTemplateSMS(self, to,datas,tempId) </p><p>3.参数说明：</p><p>to: 短信接收手机号码集合,用英文逗号分开,如 ‘13810001000,13810011001’,最多一次发送200个。</p><p>datas：内容数据，需定义成数组方式，如模板中有两个参数，定义方式为array[‘Marry’,’Alon’]。 </p><p>templateId: 模板Id,如使用测试模板，模板id为”1”，如使用自己创建的模板，则使用自己创建的短信模板id即可。<br>4.接口调用示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">编码说明：coding=utf<span class="number">-8</span>或gbk</span><br><span class="line"> <span class="keyword">from</span> CCPRestSDK <span class="keyword">import</span> REST</span><br><span class="line"> <span class="keyword">import</span> ConfigParser</span><br><span class="line"> </span><br><span class="line"> accountSid= <span class="string">'您的主账号'</span>; </span><br><span class="line"> #说明：主账号，登陆云通讯网站后，可在控制台首页中看到开发者主账号ACCOUNT SID。</span><br><span class="line"> </span><br><span class="line"> accountToken= <span class="string">'您的主账号Token'</span>; </span><br><span class="line"> #说明：主账号Token，登陆云通讯网站后，可在控制台首页中看到开发者主账号AUTH TOKEN。</span><br><span class="line"> </span><br><span class="line"> appId=<span class="string">'您的应用ID'</span>; </span><br><span class="line"> #请使用管理控制台中已创建应用的APPID。</span><br><span class="line"> </span><br><span class="line"> serverIP=<span class="string">'app.cloopen.com'</span>;</span><br><span class="line"> #说明：请求地址，生产环境配置成app.cloopen.com。</span><br><span class="line"> </span><br><span class="line"> serverPort=<span class="string">'8883'</span>; </span><br><span class="line"> #说明：请求端口 ，生产环境为8883.</span><br><span class="line"> </span><br><span class="line"> softVersion='2013-12-26'; #说明：REST API版本号保持不变。 </span><br><span class="line"> </span><br><span class="line"> def sendTemplateSMS(to,datas,tempId): </span><br><span class="line">    #初始化REST SDK</span><br><span class="line">    rest = REST(serverIP,serverPort,softVersion) </span><br><span class="line">    rest.setAccount(accountSid,accountToken) </span><br><span class="line">    rest.setAppId(appId)</span><br><span class="line"> </span><br><span class="line">    result = rest.sendTemplateSMS(to,datas,tempId) </span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> result.iteritems():</span><br><span class="line">        <span class="keyword">if</span> k==<span class="string">'templateSMS'</span> : </span><br><span class="line">                <span class="keyword">for</span> k,s <span class="keyword">in</span> v.iteritems():</span><br><span class="line">                    print <span class="string">'%s:%s'</span> % (k, s) </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            print <span class="string">'%s:%s'</span> % (k, v)</span><br></pre></td></tr></table></figure><p>在视图函数中定义如下视图：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 蓝图注册</span><br><span class="line">@user_blueprint.route(<span class="string">'/sms_code'</span>)</span><br><span class="line">def sms_code():</span><br><span class="line">    # 接收:手机号，图形验证码，从请求报文中接收</span><br><span class="line">    mobile = request.args.get(<span class="string">'mobile'</span>)</span><br><span class="line">    imagecode = request.args.get(<span class="string">'imagecode'</span>)</span><br><span class="line"></span><br><span class="line">    # 验证</span><br><span class="line">    # 1.值必填  空在python中为False</span><br><span class="line">    # 如果都不为空</span><br><span class="line">    <span class="keyword">if</span> not all([mobile, imagecode]):</span><br><span class="line">        # 返回json数据格式，由前端代码进一步处理</span><br><span class="line">        <span class="keyword">return</span> jsonify(result=<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    # 2.检验图形验证码一致，之前图形验证码已经存在session中</span><br><span class="line">    imagecode_session = session.get(<span class="string">'image_code'</span>)</span><br><span class="line">    <span class="keyword">if</span> not imagecode_session:</span><br><span class="line">        <span class="keyword">return</span> jsonify(result=<span class="number">4</span>)</span><br><span class="line">    # 删除session中的数据，强制图形验证码过期，防止客户端不停尝试</span><br><span class="line">    del session[<span class="string">'image_code'</span>]</span><br><span class="line"># 验证码不对的情况</span><br><span class="line">    <span class="keyword">if</span> imagecode != imagecode_session:</span><br><span class="line">        <span class="keyword">return</span> jsonify(result=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    # 处理</span><br><span class="line">    # 1.通过random随机数生成随机的验证码</span><br><span class="line">    smscode = str(random.randint(<span class="number">100000</span>, <span class="number">999999</span>))</span><br><span class="line">    # 2.保存验证码，用于后续验证，存到session中</span><br><span class="line">    session[<span class="string">'sms_code'</span>] = smscode</span><br><span class="line">    # 3.发送短信，云通讯工具包中封装好的函数功能</span><br><span class="line">    ytx_send.sendTemplateSMS(mobile, [smscode, <span class="string">'10'</span>], <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    # 响应</span><br><span class="line">    <span class="keyword">return</span> jsonify(result=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>在mian.JS中修改如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送短信验证码的点击事件，页面css已经由前端绑定好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendSMSCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 校验参数，保证输入框有数据填写</span></span><br><span class="line"><span class="comment">// 先移除绑定事件，防止用户不符合条件下点击执行函数</span></span><br><span class="line">    $(<span class="string">".get_code"</span>).removeAttr(<span class="string">"onclick"</span>);</span><br><span class="line"><span class="comment">// 前端检验规则</span></span><br><span class="line">    <span class="keyword">var</span> mobile = $(<span class="string">"#register_mobile"</span>).val();</span><br><span class="line">    <span class="keyword">if</span> (!mobile) &#123;</span><br><span class="line">        $(<span class="string">"#register-mobile-err"</span>).html(<span class="string">"请填写正确的手机号！"</span>);</span><br><span class="line">        $(<span class="string">"#register-mobile-err"</span>).show();</span><br><span class="line">        $(<span class="string">".get_code"</span>).attr(<span class="string">"onclick"</span>, <span class="string">"sendSMSCode();"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> imageCode = $(<span class="string">"#imagecode"</span>).val();</span><br><span class="line">    <span class="keyword">if</span> (!imageCode) &#123;</span><br><span class="line">        $(<span class="string">"#image-code-err"</span>).html(<span class="string">"请填写验证码！"</span>);</span><br><span class="line">        $(<span class="string">"#image-code-err"</span>).show();</span><br><span class="line">        $(<span class="string">".get_code"</span>).attr(<span class="string">"onclick"</span>, <span class="string">"sendSMSCode();"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 发送短信验证码</span></span><br><span class="line"><span class="comment">// 根据后端返回的json数据实现不同提示，局部刷新，要使用ajax请求</span></span><br><span class="line">    $.get(<span class="string">'/user/sms_code'</span>,&#123;</span><br><span class="line">        <span class="string">'mobile'</span>:mobile,</span><br><span class="line">        <span class="string">'imagecode'</span>:imageCode,</span><br><span class="line">    &#125;,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.result==<span class="number">1</span>)&#123;</span><br><span class="line">            alert(<span class="string">'请填写完整数据'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data.result==<span class="number">2</span> || data.result==<span class="number">4</span>)&#123;</span><br><span class="line">            alert(<span class="string">'图形验证码错误'</span>);</span><br><span class="line">            $(<span class="string">".get_code"</span>).attr(<span class="string">"onclick"</span>, <span class="string">"sendSMSCode();"</span>);</span><br><span class="line">            generateImageCode();</span><br><span class="line">            $(<span class="string">"#imagecode"</span>).val(<span class="string">''</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data.result==<span class="number">3</span>)&#123;</span><br><span class="line">            alert(<span class="string">'请查看手机'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于短信验证码等待60秒功能会在下文Django的框架中实现。</p><h2 id="Django框架"><a href="#Django框架" class="headerlink" title="Django框架"></a>Django框架</h2><p>前后端分离相比于Flas,k所以不需要再写前端代码，只要按照restful的开发格式，返回json数据即可</p><h3 id="短信验证码-1"><a href="#短信验证码-1" class="headerlink" title="短信验证码"></a>短信验证码</h3><p>djang框架实现短信验证码功能，同样使用第三方工具包云通讯功能，云通讯配置及使用方法在上述过程中已有介绍，这里就不在赘述。</p><h4 id="Django框架API接口设计"><a href="#Django框架API接口设计" class="headerlink" title="Django框架API接口设计"></a>Django框架API接口设计</h4><p>访问方式： GET /sms_codes/(?P<mobile>1[3-9]\d{9})/</mobile></p><p>请求参数： 路径参数与查询字符串参数</p><table><thead><tr><th>参数</th><th>类型</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td><font color="#000000">mobile</font></td><td><font color="#000000">str</font></td><td><font color="#000000">是</font></td><td><font color="#000000">手机号</font></td></tr></tbody></table><p>返回数据：json</p><table><thead><tr><th>返回值</th><th>类型</th><th>是否必传</th><th>说明</th></tr></thead><tbody><tr><td><font color="#000000">message</font></td><td><font color="#000000">str</font></td><td><font color="#000000">否</font></td><td><font color="#000000">OK，发送成功</font></td></tr></tbody></table><h4 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h4><p>在应用的urls.py中配置路由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(r<span class="string">'^sms_code/(?P&lt;mobile&gt;1[3-9]\d&#123;9&#125;)/$'</span>,views.SMSCodeView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在应用的views.py中定义视图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class SMSCodeView(APIView):</span><br><span class="line">   </span><br><span class="line">    def get(self, request, mobile):</span><br><span class="line">        <span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">        接收手机号，发送短信验证码</span></span><br><span class="line"><span class="string">        :param mobile: 手机号</span></span><br><span class="line"><span class="string">        :return: 是否成功</span></span><br><span class="line"><span class="string">        '</span><span class="string">''</span></span><br><span class="line">        # 获取redis的连接</span><br><span class="line">        redis_cli = get_redis_connection(<span class="string">'verify_code'</span>)</span><br><span class="line">        # 检查是否在60s内有发送记录</span><br><span class="line">        sms_flag = redis_cli.get(<span class="string">'sms_flag_'</span> + mobile)</span><br><span class="line">        <span class="keyword">if</span> sms_flag:</span><br><span class="line">            raise serializers.ValidationError(<span class="string">'请稍候再发送短信验证码'</span>)</span><br><span class="line">        # 生成短信验证码</span><br><span class="line">        sms_code = str(random.randint(<span class="number">100000</span>, <span class="number">999999</span>))</span><br><span class="line">        # 保存短信验证码与发送记录</span><br><span class="line">        # 存验证码，300秒</span><br><span class="line">        redis_cli.setex(<span class="string">'sms_code_'</span> + mobile, <span class="number">300</span>, sms_code)</span><br><span class="line">        # 存发送标记，60秒</span><br><span class="line">        redis_cli.setex(<span class="string">'sms_flag_'</span> + mobile, <span class="number">60</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        # 发送短信</span><br><span class="line">        CCP.sendTemplateSMS(mobile,sms_code,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'message'</span>: <span class="string">'OK'</span>&#125;)</span><br></pre></td></tr></table></figure><p>用的djang的drf框架，别忘了导入各种包(response对象，redis数据库连接，APIview，云通讯，random，序列化器)</p><h4 id="关于与redis数据库交互的优化"><a href="#关于与redis数据库交互的优化" class="headerlink" title="关于与redis数据库交互的优化"></a>关于与redis数据库交互的优化</h4><p>上边代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 保存短信验证码与发送记录</span><br><span class="line">     # 存验证码，300秒</span><br><span class="line">     redis_cli.setex(<span class="string">'sms_code_'</span> + mobile, <span class="number">300</span>, sms_code)</span><br><span class="line">     # 存发送标记，60秒</span><br><span class="line">     redis_cli.setex(<span class="string">'sms_flag_'</span> + mobile, <span class="number">60</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这部分代码与redis数据库交互了两次，如何进行优化，只交互一次呢？<br>采用redis管道，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 优化redis交互，减少通信的次数，管道pipeline</span><br><span class="line">     redis_pl = redis_cli.pipeline()</span><br><span class="line">     redis_pl.setex(<span class="string">'sms_code_'</span> + mobile, <span class="number">300</span>, sms_code)</span><br><span class="line">     redis_pl.setex(<span class="string">'sms_flag_'</span> + mobile, <span class="number">60</span>, <span class="number">1</span>)</span><br><span class="line">     redis_pl.execute()</span><br></pre></td></tr></table></figure><p>即可优化redis的交互次数。</p>]]></content>
    
    <summary type="html">
    
      基于Flask框架与Django框架的web开发过程中，用户注册功能如何实现图形验证码与短信验证码功能
    
    </summary>
    
      <category term="web开发" scheme="http://zypuu.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="web,验证码" scheme="http://zypuu.com/tags/web-%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>DJANGO框架如何实现用户多认证方式登录与第三方授权登录</title>
    <link href="http://zypuu.com/2018/06/11/DJANGO%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/"/>
    <id>http://zypuu.com/2018/06/11/DJANGO框架如何实现多账号登录与第三方登录/</id>
    <published>2018-06-11T11:38:20.000Z</published>
    <updated>2018-08-29T10:19:12.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多种认证方式登录"><a href="#多种认证方式登录" class="headerlink" title="多种认证方式登录"></a>多种认证方式登录</h2><p>Django框架提供了认证系统，详情看文档<a href="https://yiyibooks.cn/xx/Django_1.11.6/topics/auth/index.html" target="_blank" rel="noopener">Django认证系统官方文档</a></p><p>在这个认证系统中，有一个用户认证的方法authenticate（）来验证一组凭据，默认的是username和password，官方调用源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib.auth import authenticate</span><br><span class="line">user = authenticate(username=&apos;john&apos;, password=&apos;secret&apos;)</span><br><span class="line">if user is not None:</span><br><span class="line">    # A backend authenticated the credentials</span><br><span class="line">else:</span><br><span class="line">    # No backend authenticated the credentials</span><br></pre></td></tr></table></figure><p>所以只需要重写这个方法，就可以实现多凭证登录。<br>方法如下：<br>1.在user应用下新建utils.py文件<br>2.定义类继承Modelbackend，重写authenticate方法<br>3.重写规则，代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 重写authenticate方法，继承ModelBackend这个类来重写方法</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.backends <span class="keyword">import</span> ModelBackend</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> User</span><br><span class="line">class UserModelBackend(ModelBackend):</span><br><span class="line">    def authenticate(self, request, username=None, password=None, **kwargs):</span><br><span class="line">        # 判断用户输入的是手机号还是用户名</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            # 查询对象，如果能查到对象则得到返回的对象</span><br><span class="line">            user = User.objects.filter(mobile=username)</span><br><span class="line">            # 如果不是手机用户，则执行except</span><br><span class="line">        except:</span><br><span class="line">            # 判断是否用户名，与用户名对比</span><br><span class="line">            <span class="keyword">try</span>: </span><br><span class="line">                user = User.objects.filter(username=username)</span><br><span class="line">            except:</span><br><span class="line">                # 都不是返回空</span><br><span class="line">                <span class="keyword">return</span> None</span><br><span class="line">        # 如果查询到用户对象，则检查密码</span><br><span class="line">        <span class="keyword">if</span> user.check_password(password):</span><br><span class="line">            <span class="keyword">return</span> user</span><br><span class="line">        <span class="keyword">return</span> None</span><br></pre></td></tr></table></figure><p>4.配置中设置，settings中添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AUTHENTICATION_BACKENDS=[</span><br><span class="line"><span class="string">'users.utils.UsernameMobileModelBackend'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>即可实现使用用户手机号登录。</p><h2 id="授权第三方登录（QQ为例）"><a href="#授权第三方登录（QQ为例）" class="headerlink" title="授权第三方登录（QQ为例）"></a>授权第三方登录（QQ为例）</h2><p>QQ登录，即第三方登录，用户不在本网站输入账户密码，由第三方授权验证就可以登录本网站。如何实现授权qq登录呢，步骤如下：</p><h3 id="第一步：QQ互联开发者注册"><a href="#第一步：QQ互联开发者注册" class="headerlink" title="第一步：QQ互联开发者注册"></a>第一步：QQ互联开发者注册</h3><p>要想实现第三方QQ登录，需要成为QQ互联的开发者，通过审核后，方可继续下面的步骤，注册参考文档：<a href="http://wiki.connect.qq.com/%E6%88%90%E4%B8%BA%E5%BC%80%E5%8F%91%E8%80%85" target="_blank" rel="noopener">看这里</a><br>登录成功后，填写注册信息，如下图所示<br><img src="/2018/06/11/DJANGO框架如何实现多账号登录与第三方登录/1.jpg"><br>注册成功即可。</p><h3 id="第二步：创建应用"><a href="#第二步：创建应用" class="headerlink" title="第二步：创建应用"></a>第二步：创建应用</h3><p>注册成功后要创建应用，选择创建网站应用还是移动应用，并填写相关资料进行创建。<br>如图所示点击创建应用。<br><img src="/2018/06/11/DJANGO框架如何实现多账号登录与第三方登录/2.jpg"><br>填写相关资料<br><img src="/2018/06/11/DJANGO框架如何实现多账号登录与第三方登录/3.jpg"><br>回调地址与备案信息要写规范<br><img src="/2018/06/11/DJANGO框架如何实现多账号登录与第三方登录/4.jpg"><br>最后创建成功，如图所示<br><img src="/2018/06/11/DJANGO框架如何实现多账号登录与第三方登录/5.jpg"><br>网站应用创建完成，点击“应用管理”，进入管理中心，在管理中心可以查看到网站获取的appid和appkey，如下图所示：<br><img src="/2018/06/11/DJANGO框架如何实现多账号登录与第三方登录/6.jpg"><br>记住这两条数据，后面会用到。</p><h3 id="第三步：设置QQ登录按钮（前端代码）"><a href="#第三步：设置QQ登录按钮（前端代码）" class="headerlink" title="第三步：设置QQ登录按钮（前端代码）"></a>第三步：设置QQ登录按钮（前端代码）</h3><p>按钮的图标样式，还有前端ui规范，以及示例代码，均在官方文档里有详细介绍，这里就不说了，主要是后端代码的开发<br>设置QQ登录按钮：<a href="http://wiki.connect.qq.com/%E6%94%BE%E7%BD%AEqq%E7%99%BB%E5%BD%95%E6%8C%89%E9%92%AE_oauth2-0" target="_blank" rel="noopener">点这里</a></p><h3 id="第四步：网站后端代码开发"><a href="#第四步：网站后端代码开发" class="headerlink" title="第四步：网站后端代码开发"></a>第四步：网站后端代码开发</h3><p>由于后端代码开发流程比较复杂，首先梳理一下授权QQ登录的流程图</p><h4 id="使用QQ登录的流程"><a href="#使用QQ登录的流程" class="headerlink" title="使用QQ登录的流程"></a>使用QQ登录的流程</h4><p>如图所示<br><img src="/2018/06/11/DJANGO框架如何实现多账号登录与第三方登录/7.jpg"><br>由流程可见，后端代码开发需要创建三个视图，下面进行代码实现。</p><h4 id="配置中添加QQ开发者信息"><a href="#配置中添加QQ开发者信息" class="headerlink" title="配置中添加QQ开发者信息"></a>配置中添加QQ开发者信息</h4><p>在settings.py文件中添加如下代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># QQ登录参数</span><br><span class="line">QQ_CLIENT_ID = <span class="string">'你的APPID'</span></span><br><span class="line">QQ_CLIENT_SECRET = ‘你的APPKEY’</span><br><span class="line">QQ_REDIRECT_URI = <span class="string">'网站回调网址'</span></span><br><span class="line">QQ_STATE = '/' # 默认state初始网址为根目录</span><br></pre></td></tr></table></figure><h4 id="新建应用、创建模型类"><a href="#新建应用、创建模型类" class="headerlink" title="新建应用、创建模型类"></a>新建应用、创建模型类</h4><p>在项目目录下的utils文件包内新建models.py（没有utils先建utils），里面添加如下代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"># 创建模型类基类，用于增加数据新建时间和更新时间。</span><br><span class="line">class BaseModel(models.Model):</span><br><span class="line">    <span class="string">""</span><span class="string">"为模型类补充字段"</span><span class="string">""</span></span><br><span class="line">    create_time = models.DateTimeField(auto_now_add=True, verbose_name=<span class="string">"创建时间"</span>)</span><br><span class="line">    update_time = models.DateTimeField(auto_now=True, verbose_name=<span class="string">"更新时间"</span>)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        abstract = True  # 说明是抽象模型类, 用于继承使用，数据库迁移时不会创建BaseModel的表</span><br></pre></td></tr></table></figure><p>然后新建应用oauth，配置url与根目录url，在oauth的models里添加如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> 根目录.utils.models <span class="keyword">import</span> BaseModel</span><br><span class="line"># 新建模型类，user与openid的关联表</span><br><span class="line">class OAuthQQUser(BaseModel):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    QQ登录用户数据</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line"># 定义user，openid字段</span><br><span class="line">    user = models.ForeignKey(<span class="string">'users.User'</span>, on_delete=models.CASCADE, verbose_name=<span class="string">'用户'</span>)</span><br><span class="line">    openid = models.CharField(max_length=<span class="number">64</span>, verbose_name=<span class="string">'openid'</span>, db_index=True)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line"># 表名，与字段后台显示名</span><br><span class="line">        db_table = <span class="string">'tb_oauth_qq'</span></span><br><span class="line">        verbose_name = <span class="string">'QQ登录用户数据'</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br></pre></td></tr></table></figure><p>然后进行数据库迁移，终端命令如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>未来会有很多第三方账户集成登录，所以新建应用oauth<br>并不修改原有表结构，而是新建表，完成第三方登录<br>好处：<br>1.不影响原有操作</p><ol start="2"><li>未来会实现多种登录的可能性，提供出更方便的扩展方案：新建表</li></ol><h4 id="创建qq登录辅助工具"><a href="#创建qq登录辅助工具" class="headerlink" title="创建qq登录辅助工具"></a>创建qq登录辅助工具</h4><p>在oauth应用下新建utils.py文件，在该文件下添加如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode, parse_qs</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> itsdangerous <span class="keyword">import</span> TimedJSONWebSignatureSerializer <span class="keyword">as</span> Serializer, BadData</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . import constants</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">'django'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class OAuthQQ(object):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    QQ认证辅助工具类</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line"># 初始化属性，接收四个参数，客户的appid，appkey，回调地址，初始跳转页面</span><br><span class="line">    def __init__(self, client_id=None, client_secret=None, redirect_uri=None, state=None):</span><br><span class="line"># or：代表if not ，如果接收到参数值，就是用接收的，如果接收none，就用配置的</span><br><span class="line">        self.client_id = client_id or settings.QQ_CLIENT_ID</span><br><span class="line">        self.client_secret = client_secret or settings.QQ_CLIENT_SECRET</span><br><span class="line">        self.redirect_uri = redirect_uri or settings.QQ_REDIRECT_URI</span><br><span class="line">        self.state = state or settings.QQ_STATE  # 用于保存登录成功后的跳转页面路径</span><br><span class="line"></span><br><span class="line"># 定义生成url登录地址的函数，返回登录页面url的函数</span><br><span class="line">    def get_qq_login_url(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        获取qq登录的网址</span></span><br><span class="line"><span class="string">        :return: url网址</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        params = &#123;</span><br><span class="line">            <span class="string">'response_type'</span>: <span class="string">'code'</span>,</span><br><span class="line">            <span class="string">'client_id'</span>: self.client_id,</span><br><span class="line">            <span class="string">'redirect_uri'</span>: self.redirect_uri,</span><br><span class="line">            <span class="string">'state'</span>: self.state,</span><br><span class="line">            <span class="string">'scope'</span>: <span class="string">'get_user_info'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        url = <span class="string">'https://graph.qq.com/oauth2.0/authorize?'</span> + urlencode(params)</span><br><span class="line">        <span class="keyword">return</span> url</span><br></pre></td></tr></table></figure><h4 id="补充技术点1：urllib"><a href="#补充技术点1：urllib" class="headerlink" title="补充技术点1：urllib"></a>补充技术点1：urllib</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.parse.urlencode(query)</span><br></pre></td></tr></table></figure><p>将query字典转换为url路径中的查询字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.parse.parse_qs(qs)</span><br></pre></td></tr></table></figure><p>将qs查询字符串格式数据转换为python的字典</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.request.urlopen(url, data=None)</span><br></pre></td></tr></table></figure><p>发送http请求，如果data为None，发送GET请求，如果data不为None，发送POST请求</p><p>返回response响应对象，可以通过read()读取响应体数据，需要注意读取出的响应体数据为bytes类型</p><h4 id="创建第一个视图函数"><a href="#创建第一个视图函数" class="headerlink" title="创建第一个视图函数"></a>创建第一个视图函数</h4><p>配置第一个视图函数的url：url(r’^qq/authorization/$’, views.QQAuthURLView.as_view())<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class QQAuthURLView(APIView):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    获取QQ登录的url</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    def get(self, request):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        提供用于qq登录的url</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line"># 获取next的地址，即登陆成功后返回之前浏览的页面</span><br><span class="line">        next = request.query_params.get(<span class="string">'next'</span>)</span><br><span class="line"># OAuthQQ是辅助工具的类，创建对象将next赋值给state初始状态的页面</span><br><span class="line">        oauth = OAuthQQ(state=next)</span><br><span class="line"># 调用辅助工具的get_qq_login_url函数得到url</span><br><span class="line">        login_url = oauth.get_qq_login_url()</span><br><span class="line"># 返回URL地址</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'login_url'</span>: login_url&#125;)</span><br></pre></td></tr></table></figure></p><p>到此第一步完成，即返回用户的登录页面，接下里用户进行授权登录</p><h4 id="第二个视图函数"><a href="#第二个视图函数" class="headerlink" title="第二个视图函数"></a>第二个视图函数</h4><p>即用户登陆后，获取登录数据code，然后根据code，去获取accesstoken与openid<br>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class QQAuthUserView(APIView):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    QQ登录的用户</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    def get(self, request):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        获取qq登录的用户数据</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line"># 从请求地址的查询参数中获取code</span><br><span class="line">        code = request.query_params.get(<span class="string">'code'</span>)</span><br><span class="line"># 没有code抛出异常</span><br><span class="line">        <span class="keyword">if</span> not code:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'message'</span>: <span class="string">'缺少code'</span>&#125;, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line"># 创建oauth对象，类来自定义的qq登录辅助工具</span><br><span class="line">        oauth = OAuthQQ()</span><br><span class="line"></span><br><span class="line">        # 获取用户openid</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line"># 通过code获取token</span><br><span class="line">            access_token = oauth.get_access_token(code)</span><br><span class="line"># 通过token获取openid</span><br><span class="line">            openid = oauth.get_openid(access_token)</span><br><span class="line"># 没有获取到的话抛出异常</span><br><span class="line">        except QQAPIError:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'message'</span>: <span class="string">'QQ服务异常'</span>&#125;, status=status.HTTP_503_SERVICE_UNAVAILABLE)</span><br><span class="line"></span><br><span class="line">        # 判断用户是否存在</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line"># 通过openid查询用户，创建的关联表里</span><br><span class="line">            qq_user = OAuthQQUser.objects.get(openid=openid)</span><br><span class="line">        except OAuthQQUser.DoesNotExist:</span><br><span class="line">            # 用户第一次使用QQ登录，显示绑定界面</span><br><span class="line">            token = oauth.generate_save_user_token(openid)</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'access_token'</span>: token&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            # 找到用户，认为登录成功， 生成jwt_token</span><br><span class="line">            user = qq_user.user</span><br><span class="line">            jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">            jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</span><br><span class="line"></span><br><span class="line">            payload = jwt_payload_handler(user)</span><br><span class="line">            token = jwt_encode_handler(payload)</span><br><span class="line"># 响应返回</span><br><span class="line">            response = Response(&#123;</span><br><span class="line">                <span class="string">'token'</span>: token,</span><br><span class="line">                <span class="string">'user_id'</span>: user.id,</span><br><span class="line">                <span class="string">'username'</span>: user.username</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h4 id="QQ辅助工具中添加代码"><a href="#QQ辅助工具中添加代码" class="headerlink" title="QQ辅助工具中添加代码"></a>QQ辅助工具中添加代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">def get_access_token(self, code):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        获取access_token</span></span><br><span class="line"><span class="string">        :param code: qq提供的code</span></span><br><span class="line"><span class="string">        :return: access_token</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">     # 1.构造参数</span><br><span class="line">        params = &#123;</span><br><span class="line">            <span class="string">'grant_type'</span>: <span class="string">'authorization_code'</span>,</span><br><span class="line">            <span class="string">'client_id'</span>: self.client_id,</span><br><span class="line">            <span class="string">'client_secret'</span>: self.client_secret,</span><br><span class="line">            <span class="string">'code'</span>: code,</span><br><span class="line">            <span class="string">'redirect_uri'</span>: self.redirect_uri</span><br><span class="line">        &#125;</span><br><span class="line">        # 2.发起http请求，请求qq服务器</span><br><span class="line">        url = <span class="string">'https://graph.qq.com/oauth2.0/token?'</span> + urlencode(params)</span><br><span class="line">        response = urlopen(url)</span><br><span class="line">        # 3.接收响应数据，解码</span><br><span class="line">        response_data = response.read().decode()</span><br><span class="line">        # access_token=**&amp;expires_in=**&amp;refresh_token=**</span><br><span class="line">转成python字典</span><br><span class="line">        data = parse_qs(response_data)</span><br><span class="line">        # 4.从字典中获取token</span><br><span class="line">        access_token = data.get(<span class="string">'access_token'</span>, None)</span><br><span class="line"># 如果没有token，写日志抛出异常</span><br><span class="line">        <span class="keyword">if</span> not access_token:</span><br><span class="line">            logger.error(<span class="string">'code=%s msg=%s'</span> % (data.get(<span class="string">'code'</span>), data.get(<span class="string">'msg'</span>)))</span><br><span class="line">            raise QQAPIError</span><br><span class="line">        # 取出accesstoken的值的列表的第一个元素</span><br><span class="line">        <span class="keyword">return</span> access_token[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    def get_openid(self, access_token):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        获取用户的openid</span></span><br><span class="line"><span class="string">        :param access_token: qq提供的access_token</span></span><br><span class="line"><span class="string">        :return: open_id</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line"># 发起qq服务器请求</span><br><span class="line">        url = <span class="string">'https://graph.qq.com/oauth2.0/me?access_token='</span> + access_token</span><br><span class="line">        response = urlopen(url)</span><br><span class="line"># 返回数据二进制解码</span><br><span class="line">        response_data = response.read().decode()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">        # 返回的数据 callback( &#123;"client_id":"YOUR_APPID","openid":"YOUR_OPENID"&#125; )\n;cogn</span><br><span class="line"># 将字符串转成字典</span><br><span class="line">            data = json.loads(response_data[<span class="number">10</span>:<span class="number">-4</span>])</span><br><span class="line">        except Exception:</span><br><span class="line"># 没获取到抛出异常</span><br><span class="line">            data = parse_qs(response_data)</span><br><span class="line">            logger.error(<span class="string">'code=%s msg=%s'</span> % (data.get(<span class="string">'code'</span>), data.get(<span class="string">'msg'</span>)))</span><br><span class="line">            raise QQAPIError</span><br><span class="line"># 从字典中获取数据</span><br><span class="line">        openid = data.get(<span class="string">'openid'</span>, None)</span><br><span class="line">        <span class="keyword">return</span> openid</span><br><span class="line"></span><br><span class="line"># 将返回的openid通过itsdangerous加密，然后返回token，发送这个token</span><br><span class="line">@staticmethod</span><br><span class="line">    def generate_save_user_token(openid):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        生成保存用户数据的token</span></span><br><span class="line"><span class="string">        :param openid: 用户的openid</span></span><br><span class="line"><span class="string">        :return: token</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        serializer = Serializer(settings.SECRET_KEY, expires_in=constants.SAVE_QQ_USER_TOKEN_EXPIRES)</span><br><span class="line">        data = &#123;<span class="string">'openid'</span>: openid&#125;</span><br><span class="line">        token = serializer.dumps(data)</span><br><span class="line">        <span class="keyword">return</span> token.decode()</span><br><span class="line"></span><br><span class="line"># 加载读取接收到的token，解密，获取openid</span><br><span class="line">    @staticmethod</span><br><span class="line">    def check_save_user_token(token):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        检验保存用户数据的token</span></span><br><span class="line"><span class="string">        :param token: token</span></span><br><span class="line"><span class="string">        :return: openid or None</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        serializer = Serializer(settings.SECRET_KEY, expires_in=constants.SAVE_QQ_USER_TOKEN_EXPIRES)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = serializer.loads(token)</span><br><span class="line">        except BadData:</span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> data.get(<span class="string">'openid'</span>)</span><br></pre></td></tr></table></figure><p>以上第二步完成，获取到openid，并对用户是否第一次登录，是否需要绑定进行了判断，如果用户是第一次登录，需要绑定，则转到绑定页面，执行第三步。</p><h4 id="补充技术点2：itsdangerous"><a href="#补充技术点2：itsdangerous" class="headerlink" title="补充技术点2：itsdangerous"></a>补充技术点2：itsdangerous</h4><p>官方文档：<a href="http://itsdangerous.readthedocs.io/en/latest/" target="_blank" rel="noopener">点这里</a><br>itsdangerous是一种加密签名方式，可以通过秘钥加密，也可以通过秘钥解密<br>确保自己的数据在返回时没有经过别人的篡改，保证数据传输的安全性<br>安装：<code>pip install itsdangerous</code><br>使用：以时间戳为例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itsdangerous <span class="keyword">import</span> TimedJSONWebSignatureSerializer <span class="keyword">as</span> Serializer</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"># serializer = Serializer(秘钥, 有效期秒)</span><br><span class="line">serializer = Serializer(settings.SECRET_KEY, <span class="number">300</span>)</span><br><span class="line"># serializer.dumps(数据), 返回bytes类型，加密数据</span><br><span class="line">token = serializer.dumps(&#123;<span class="string">'mobile'</span>: <span class="string">'18512345678'</span>&#125;)</span><br><span class="line">token = token.decode()</span><br><span class="line"></span><br><span class="line"># 检验token</span><br><span class="line"># 验证失败，会抛出itsdangerous.BadData异常</span><br><span class="line">serializer = Serializer(settings.SECRET_KEY, <span class="number">300</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"># 加载token数据，解密数据</span><br><span class="line">    data = serializer.loads(token)</span><br><span class="line">except BadData:</span><br><span class="line">    <span class="keyword">return</span> None</span><br></pre></td></tr></table></figure><h4 id="第三个视图函数"><a href="#第三个视图函数" class="headerlink" title="第三个视图函数"></a>第三个视图函数</h4><p>视图代码如下：<br>因为是绑定数据库增加数据，所以在第二个视图函数中继续定义post方法即可，不用单独创建视图类，该视图实现用户绑定的方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def post(self,request):</span><br><span class="line"># 指定序列化器</span><br><span class="line">        serializer = OAuthQQUserSerializer(data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=True)</span><br><span class="line">        user = serializer.save()</span><br><span class="line"></span><br><span class="line">        response = Response(&#123;</span><br><span class="line">            <span class="string">'token'</span>: user.token,</span><br><span class="line">            <span class="string">'user_id'</span>: user.id,</span><br><span class="line">            <span class="string">'username'</span>: user.username</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure></p><p>定义序列器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">class OAuthQQUserSerializer(serializers.ModelSerializer):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    保存QQ用户序列化器</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line"># 添加字段</span><br><span class="line">    sms_code = serializers.CharField(label=<span class="string">'短信验证码'</span>, write_only=True)</span><br><span class="line">    access_token = serializers.CharField(label=<span class="string">'操作凭证'</span>, write_only=True)</span><br><span class="line">    token = serializers.CharField(read_only=True)</span><br><span class="line">    mobile = serializers.RegexField(label=<span class="string">'手机号'</span>, regex=r<span class="string">'^1[3-9]\d&#123;9&#125;$'</span>)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        model = User</span><br><span class="line">        fields = (<span class="string">'mobile'</span>, <span class="string">'password'</span>, <span class="string">'sms_code'</span>, <span class="string">'access_token'</span>, <span class="string">'id'</span>, <span class="string">'username'</span>, <span class="string">'token'</span>)</span><br><span class="line">        extra_kwargs = &#123;</span><br><span class="line">            <span class="string">'username'</span>: &#123;</span><br><span class="line">                <span class="string">'read_only'</span>: True</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'password'</span>: &#123;</span><br><span class="line">                <span class="string">'write_only'</span>: True,</span><br><span class="line">                <span class="string">'min_length'</span>: <span class="number">8</span>,</span><br><span class="line">                <span class="string">'max_length'</span>: <span class="number">20</span>,</span><br><span class="line">                <span class="string">'error_messages'</span>: &#123;</span><br><span class="line">                    <span class="string">'min_length'</span>: <span class="string">'仅允许8-20个字符的密码'</span>,</span><br><span class="line">                    <span class="string">'max_length'</span>: <span class="string">'仅允许8-20个字符的密码'</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"># 验证</span><br><span class="line">    def validate(self, attrs):</span><br><span class="line">        # 检验access_token，获取加密的token值</span><br><span class="line">        access_token = attrs[<span class="string">'access_token'</span>]</span><br><span class="line"># 解密</span><br><span class="line">        openid = OAuthQQ.check_save_user_token(access_token)</span><br><span class="line">        <span class="keyword">if</span> not openid:</span><br><span class="line">            raise serializers.ValidationError(<span class="string">'无效的access_token'</span>)</span><br><span class="line"></span><br><span class="line">        attrs[<span class="string">'openid'</span>] = openid</span><br><span class="line"></span><br><span class="line">        # 检验短信验证码</span><br><span class="line">        mobile = attrs[<span class="string">'mobile'</span>]</span><br><span class="line">        sms_code = attrs[<span class="string">'sms_code'</span>]</span><br><span class="line">        redis_conn = get_redis_connection(<span class="string">'verify_code'</span>)</span><br><span class="line">        real_sms_code = redis_conn.get(<span class="string">'sms_code_%s'</span> % mobile)</span><br><span class="line">        <span class="keyword">if</span> real_sms_code.decode() != sms_code:</span><br><span class="line">            raise serializers.ValidationError(<span class="string">'短信验证码错误'</span>)</span><br><span class="line"></span><br><span class="line">        # 如果用户存在，检查用户密码</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            user = User.objects.get(mobile=mobile)</span><br><span class="line">        except User.DoesNotExist:</span><br><span class="line">            pass</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            password = attrs[<span class="string">'password'</span>]</span><br><span class="line">            <span class="keyword">if</span> not user.check_password(password):</span><br><span class="line">                raise serializers.ValidationError(<span class="string">'密码错误'</span>)</span><br><span class="line"># attrs中添加user数据</span><br><span class="line">            attrs[<span class="string">'user'</span>] = user</span><br><span class="line">        <span class="keyword">return</span> attrs</span><br><span class="line"></span><br><span class="line">    def create(self, validated_data):</span><br><span class="line">        openid = validated_data[<span class="string">'openid'</span>]</span><br><span class="line">        user = validated_data.get(<span class="string">'user'</span>)</span><br><span class="line">        mobile = validated_data[<span class="string">'mobile'</span>]</span><br><span class="line">        password = validated_data[<span class="string">'password'</span>]</span><br><span class="line"># 获取user</span><br><span class="line">        <span class="keyword">if</span> not user:</span><br><span class="line">            # 如果用户不存在，创建用户，绑定openid（创建了OAuthQQUser数据）</span><br><span class="line">            user = User.objects.create_user(username=mobile, mobile=mobile, password=password)</span><br><span class="line"># 在用户与openid中的关联表中添加数据</span><br><span class="line">        OAuthQQUser.objects.create(user=user, openid=openid)</span><br><span class="line"></span><br><span class="line">        # 签发jwt token</span><br><span class="line">        jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">        jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</span><br><span class="line"></span><br><span class="line">        payload = jwt_payload_handler(user)</span><br><span class="line">        token = jwt_encode_handler(payload)</span><br><span class="line"></span><br><span class="line">        user.token = token</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure><p>到此，可实现授权QQ第三方登录的功能</p>]]></content>
    
    <summary type="html">
    
      登录时单用户支持多种方式登录，添加第三方授权登录，腾讯qq为例
    
    </summary>
    
      <category term="web开发" scheme="http://zypuu.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="web,Django" scheme="http://zypuu.com/tags/web-Django/"/>
    
  </entry>
  
  <entry>
    <title>关于Celery的异步服务使用</title>
    <link href="http://zypuu.com/2018/05/26/%E5%85%B3%E4%BA%8ECelery%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8/"/>
    <id>http://zypuu.com/2018/05/26/关于Celery的异步服务使用/</id>
    <published>2018-05-26T01:49:10.000Z</published>
    <updated>2018-08-29T10:19:28.892Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Celery？"><a href="#什么是Celery？" class="headerlink" title="什么是Celery？"></a>什么是Celery？</h3><p>Celery是一个专注于实时处理和任务调度的分布式任务队列。所谓任务就是消息，消息中的有效载荷中包含要执行任务需要的全部数据。</p><h3 id="为什么使用Celery"><a href="#为什么使用Celery" class="headerlink" title="为什么使用Celery"></a>为什么使用Celery</h3><p>在开发应用中，我们难免会遇到耗时操作，或者需要添加一些定时任务，而服务器本身的框架对于多进程、线程等已经写好，这些附加工作就会被耗时处理，而使用Celery则可以很好的处理这些任务，相当于开了一个额外的进程来处理这些耗时任务，增强了执行效率。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>Web应用。当用户触发的一个操作需要较长时间才能执行完成时，可以把它作为任务交给Celery去异步执行，执行完再返回给用户。这段时间用户不需要等待，提高了用户体验与程序执行效率。</li></ol><ol start="2"><li>定时任务。生产环境经常会跑一些定时任务。假如你有上千台的服务器、上千种任务，定时任务的管理很困难，Celery可以帮助我们快速在不同的机器设定不同种任务。</li></ol><ol start="3"><li>同步完成的附加工作都可以异步完成。比如发送短信/邮件、推送消息、清理/设置缓存等。</li></ol><h3 id="Celery架构"><a href="#Celery架构" class="headerlink" title="Celery架构"></a>Celery架构</h3><img src="/2018/05/26/关于Celery的异步服务使用/1.jpg"><p>Celery Beat：任务调度器，Beat进程会读取配置文件的内容，周期性地将配置中到期需要执行的任务发送给任务队列。<br>Result Backend：任务处理完后保存状态信息和结果，以供查询。Celery默认已支持Redis、RabbitMQ、MongoDB、Django ORM、SQLAlchemy等方式，当然Redis应该是最佳选择。</p><h3 id="例：对于django框架web开发中发送短信功能使用Celery优化"><a href="#例：对于django框架web开发中发送短信功能使用Celery优化" class="headerlink" title="例：对于django框架web开发中发送短信功能使用Celery优化"></a>例：对于django框架web开发中发送短信功能使用Celery优化</h3><h4 id="为什么要进行优化"><a href="#为什么要进行优化" class="headerlink" title="为什么要进行优化"></a>为什么要进行优化</h4><p>因为发送短信是一个等待操作，用户那边也会设置一个60秒等待操作，为了提高用户体验，增强效率，采用Celery进行优化，设置异步任务，处理短信发送功能。</p><p>1.在mamange.py同目录下，新建工具包celery_tasks<br>2.创建config.py<br>    设置代理人，指定队列，这里连接redis第14个数据库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broker_url=<span class="string">'redis://‘设置的ip地址’/14'</span></span><br></pre></td></tr></table></figure><p>3.创建main.py，创建Celery的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">from</span> . import config</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">#设置django的配置</span><br><span class="line">os.environ.setdefault(<span class="string">"DJANGO_SETTINGS_MODULE"</span>, <span class="string">"项目的settings"</span>)</span><br><span class="line"># 创建对象</span><br><span class="line">app = Celery(<span class="string">'任意字符串'</span>)</span><br><span class="line"></span><br><span class="line"># 加载配置</span><br><span class="line">app.config_from_object(config)</span><br><span class="line"></span><br><span class="line"># 初始化任务</span><br><span class="line"># 在指定的包中找tasks.py文件，在这个文件中找@app.task的函数</span><br><span class="line">app.autodiscover_tasks([</span><br><span class="line">    <span class="string">'celery_tasks.sms'</span>,</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>4.新建sms工具包，在包中新建tasks.py文件，定义发送短信的函任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.ytx_sdk.sendSMS <span class="keyword">import</span> CCP</span><br><span class="line"><span class="keyword">from</span> celery_tasks.main <span class="keyword">import</span> app</span><br><span class="line"># 发送短信任务</span><br><span class="line">@app.task(name=<span class="string">'sms_send'</span>)</span><br><span class="line">def sms_send(mobile, sms_code, expires, template_id):</span><br><span class="line">    CCP.sendTemplateSMS(mobile, sms_code, expires, template_id)</span><br></pre></td></tr></table></figure><p>5.启动celery的工人<br>    celery -A celery_tasks.main worker -l info</p><p>6.调用：sms_send.delay(参数)</p>]]></content>
    
    <summary type="html">
    
      在web开发中使用Celery异步服务优化需要等待时长的耗时任务
    
    </summary>
    
      <category term="web开发" scheme="http://zypuu.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="web,Celery" scheme="http://zypuu.com/tags/web-Celery/"/>
    
  </entry>
  
  <entry>
    <title>实现Django框架邮箱验证功能</title>
    <link href="http://zypuu.com/2018/05/24/%E5%AE%9E%E7%8E%B0Django%E6%A1%86%E6%9E%B6%E9%82%AE%E7%AE%B1%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD/"/>
    <id>http://zypuu.com/2018/05/24/实现Django框架邮箱验证功能/</id>
    <published>2018-05-24T09:46:10.000Z</published>
    <updated>2018-08-29T10:19:00.002Z</updated>
    
    <content type="html"><![CDATA[<p>Django框架中，实现用户中心页面的设置邮箱功能，并根据用户设置的邮箱，发送验证邮箱，用户通过点击验证地址，完成邮箱验证。</p><h3 id="用户表添加字段"><a href="#用户表添加字段" class="headerlink" title="用户表添加字段"></a>用户表添加字段</h3><p>在用户的user表中添加字段，代表该用户使用的邮箱是否通过验证，true为通过验证，相反为false。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">email_active = models.BooleanField(<span class="keyword">default</span>=False, verbose_name=<span class="string">'邮箱验证状态'</span>)</span><br></pre></td></tr></table></figure></p><p>然后进行数据库迁移，完成字段创建。</p><h3 id="保存用户邮箱，并发送验证邮箱"><a href="#保存用户邮箱，并发送验证邮箱" class="headerlink" title="保存用户邮箱，并发送验证邮箱"></a>保存用户邮箱，并发送验证邮箱</h3><p>用户根据页面输入框输入邮箱后，点击保存，将用户输入的邮箱验证，并保存到数据库user表中，然后根据这个地址，发送验证邮件。</p><h4 id="定义序列化器"><a href="#定义序列化器" class="headerlink" title="定义序列化器"></a>定义序列化器</h4><p>继承自modelserializer<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class EmailSerializer(serializers.ModelSerializer):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    邮箱序列化器</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    # 指定模型类，属性</span><br><span class="line">    class Meta:</span><br><span class="line">        model = User</span><br><span class="line">        fields = (<span class="string">'id'</span>, <span class="string">'email'</span>)</span><br><span class="line">        extra_kwargs = &#123;</span><br><span class="line">            <span class="string">'email'</span>: &#123;</span><br><span class="line"># 验证邮箱为必填字段</span><br><span class="line">                <span class="string">'required'</span>: True</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   # 重写update方法，数据库修改该用户的邮箱</span><br><span class="line">def update(self, instance, validated_data):</span><br><span class="line">        # 从请求体中接收数据，后面向这个邮箱发送邮件</span><br><span class="line">        email = validated_data[<span class="string">'email'</span>]</span><br><span class="line">        # instance要序列化的对象，即user，给email属性赋值</span><br><span class="line">        instance.email = validated_data[<span class="string">'email'</span>]</span><br><span class="line">        # 提交</span><br><span class="line">        instance.save()</span><br></pre></td></tr></table></figure></p><h4 id="定义保存的视图类"><a href="#定义保存的视图类" class="headerlink" title="定义保存的视图类"></a>定义保存的视图类</h4><p>因为不是根据用户id来修改邮箱，而是根据当前登录的用户，所以不传pk，而是重写get_object方法，来获取当前登录的对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class SaveEmail(UpdateAPIView):</span><br><span class="line">    # 验证用户是否登陆，Drf提供的验证功能</span><br><span class="line">    permission_classes = [IsAuthenticated]</span><br><span class="line">    # 指定序列化器</span><br><span class="line">    serializer_class = EmailSerializer</span><br><span class="line">    # 因为不获取ｐｋ，所以保存的时候获取当前登陆用户的对象</span><br><span class="line">    def get_object(self):</span><br><span class="line">        # 将对象存到ｒｅｑｕｅｓｔ里</span><br><span class="line">        <span class="keyword">return</span> self.request.user</span><br></pre></td></tr></table></figure></p><p>然后配置url即可。</p><h4 id="生成验证地址"><a href="#生成验证地址" class="headerlink" title="生成验证地址"></a>生成验证地址</h4><p>保存用户输入的邮箱之后，向这个邮箱发送验证地址，首先需要生成验证地址。<br>在user的models里添加方法，实现生成地址的功能，在拼接地址时要经过加密，导入jwt，使用jwt加密</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 定义生成地址的方法</span><br><span class="line">    def generate_verify_email_url(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        生成验证邮箱的url</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        # 设置itsdangerous加密</span><br><span class="line">        serializer = TJWSSerializer(settings.SECRET_KEY, expires_in=constants.VERIFY_EMAIL_TOKEN_EXPIRES)</span><br><span class="line">        data = &#123;<span class="string">'user_id'</span>: self.id, <span class="string">'email'</span>: self.email&#125;</span><br><span class="line">        token = serializer.dumps(data).decode()</span><br><span class="line">        verify_url = <span class="string">'http://www.meiduo.site:8080/success_verify_email.html?token='</span> + token</span><br><span class="line">        # 返回生成的地址</span><br><span class="line">        <span class="keyword">return</span> verify_url</span><br></pre></td></tr></table></figure><p>然后在序列化器 EmailSerializer下的update方法下添加代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 生成验证链接，调用生成验证连接的函数</span><br><span class="line">       verify_url = instance.generate_verify_email_url()</span><br></pre></td></tr></table></figure><p>接收生成后的url地址</p><h4 id="向用户的邮箱发送验证地址"><a href="#向用户的邮箱发送验证地址" class="headerlink" title="向用户的邮箱发送验证地址"></a>向用户的邮箱发送验证地址</h4><p>发送邮箱，属于等待耗时操作，所以使用Celery异步服务（详情看：<a href="https://zypuu.github.io/2018/08/20/%E5%85%B3%E4%BA%8ECelery%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">点这里</a>）<br>在celery_tasks下新建包email，在包里新建文件tasks.py,然后在main.py里添加<code>&#39;celery_tasks.email&#39;,</code><br>在tasks文件里添加任务代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery_tasks.main <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line">@app.task(name=<span class="string">'send_verify_email'</span>)</span><br><span class="line">def send_verify_email(to_email, verify_url):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    发送验证邮箱邮件</span></span><br><span class="line"><span class="string">    :param to_email: 收件人邮箱</span></span><br><span class="line"><span class="string">    :param verify_url: 验证链接</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    subject = <span class="string">"邮件标题（例：***邮箱验证）"</span></span><br><span class="line">    html_message = <span class="string">'&lt;p&gt;尊敬的用户您好！&lt;/p&gt;'</span> \</span><br><span class="line">                   <span class="string">'&lt;p&gt;感谢您使用*****。&lt;/p&gt;'</span> \</span><br><span class="line">                   <span class="string">'&lt;p&gt;您的邮箱为：%s 。请点击此链接激活您的邮箱：&lt;/p&gt;'</span> \</span><br><span class="line">                   <span class="string">'&lt;p&gt;&lt;a href="%s"&gt;%s&lt;a&gt;&lt;/p&gt;'</span> % (to_email, verify_url, verify_url)</span><br><span class="line"># Django自带的发送邮件功能 </span><br><span class="line">    send_mail(subject, <span class="string">""</span>, settings.EMAIL_FROM, [to_email], html_message=html_message)</span><br></pre></td></tr></table></figure><p>然后在序列化器 EmailSerializer下的update方法下添加代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 发送验证邮件，邮箱，与验证连接作为参数</span><br><span class="line">       # 使用celery异步服务发送验证，在tasks里面</span><br><span class="line">       send_verify_email.delay(email, verify_url)</span><br><span class="line">       # 最后，经过保存，接收验证地址，发送地址等功能后，返回该对象</span><br><span class="line">       <span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure><p>到此发送验证邮件完成</p><h4 id="技术补充点：Django发送邮件"><a href="#技术补充点：Django发送邮件" class="headerlink" title="技术补充点：Django发送邮件"></a>技术补充点：Django发送邮件</h4><p>首先注册一个专门用来发送邮件的邮箱163,126，qq等，然后在这些邮箱配置SMTP服务器（设置中开启，经过手机验证后会收到授权码的短信，然后填写授权码，开启。详情可百度）</p><p>然后在配置中添加代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EMAIL_BACKEND = <span class="string">'django.core.mail.backends.smtp.EmailBackend'</span></span><br><span class="line">EMAIL_HOST = 'smtp.163.com' # （163为例）</span><br><span class="line">EMAIL_PORT = <span class="number">25</span></span><br><span class="line">#发送邮件的邮箱</span><br><span class="line">EMAIL_HOST_USER = <span class="string">'你的账号'</span></span><br><span class="line">#在邮箱中设置的客户端授权密码</span><br><span class="line">EMAIL_HOST_PASSWORD = <span class="string">'你的授权密码'</span></span><br><span class="line">#收件人看到的发件人</span><br><span class="line">EMAIL_FROM = <span class="string">'&lt;你的邮箱&gt;'</span></span><br></pre></td></tr></table></figure><p>使用django发送邮件：</p><p>在django.core.mail模块提供了send_mail来发送邮件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在django.core.mail模块提供了send_mail来发送邮件。</span><br><span class="line"></span><br><span class="line">send_mail(subject, message, from_email, recipient_list,html_message=None)</span><br><span class="line"># 各个参数的含义</span><br><span class="line">subject 邮件标题</span><br><span class="line">message 普通邮件正文， 普通字符串</span><br><span class="line">from_email 发件人</span><br><span class="line">recipient_list 收件人列表</span><br><span class="line">html_message 多媒体邮件正文，可以是html字符串可以呈现html页面</span><br></pre></td></tr></table></figure><h3 id="验证邮箱"><a href="#验证邮箱" class="headerlink" title="验证邮箱"></a>验证邮箱</h3><p>用户在邮箱收到验证邮件后，点击地址进行验证，验证成功返回用户中心页面。</p><h4 id="设置解密"><a href="#设置解密" class="headerlink" title="设置解密"></a>设置解密</h4><p>因为生成的验证邮箱地址时带有itsdangerous加密的token的，所以要先解密，在user的models里添加解密方法，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 设置解密方法</span><br><span class="line">    @staticmethod</span><br><span class="line">    def check_verify_email_token(token):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        检查验证邮件的token</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        # 解密</span><br><span class="line">        serializer = TJWSSerializer(settings.SECRET_KEY, expires_in=constants.VERIFY_EMAIL_TOKEN_EXPIRES)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = serializer.loads(token)</span><br><span class="line">        except BadData:</span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            # 解密之后，获取data里面的数据</span><br><span class="line">            email = data.get(<span class="string">'email'</span>)</span><br><span class="line">            user_id = data.get(<span class="string">'user_id'</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                # 根据数据，获取对象</span><br><span class="line">                user = User.objects.get(id=user_id, email=email)</span><br><span class="line">            except User.DoesNotExist:</span><br><span class="line">                <span class="keyword">return</span> None</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                # 返回对象</span><br><span class="line">                <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure><p>然后新建constants.py常量文件，然后添加代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VERIFY_EMAIL_TOKEN_EXPIRES=<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span></span><br></pre></td></tr></table></figure><p>设置过期时间。</p><h4 id="定义视图函数"><a href="#定义视图函数" class="headerlink" title="定义视图函数"></a>定义视图函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class SendEmail(APIView):</span><br><span class="line">    def get(self, request):</span><br><span class="line">        # 获取token，由jwt签发的token，在查询参数里，获取查询参数</span><br><span class="line">        token = request.query_params.get(<span class="string">'token'</span>)</span><br><span class="line">        <span class="keyword">if</span> not token:</span><br><span class="line">            # 如果没有token，则返回信息，与状态码</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'message'</span>: <span class="string">'缺少token'</span>&#125;, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line">        # 验证过程</span><br><span class="line">        # 取得token后验证token，解密，确定是否被更改</span><br><span class="line">        # 接收解密后返回的对象</span><br><span class="line">        user = User.check_verify_email_token(token)</span><br><span class="line">        <span class="keyword">if</span> user is None:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'message'</span>: <span class="string">'链接信息无效'</span>&#125;, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            # 没被更改即验证成功</span><br><span class="line">            # 数据库在邮箱验证的通过字段添加信息</span><br><span class="line">            user.email_active = True</span><br><span class="line">            # 提交保存</span><br><span class="line">            user.save()</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'message'</span>: <span class="string">'OK'</span>&#125;)</span><br></pre></td></tr></table></figure><p>由前端代码收到这个return后，跳转回用户页面即可。</p>]]></content>
    
    <summary type="html">
    
      填写用户邮箱，保存，然后发送验证邮件，用户验证邮箱，跳转回页面
    
    </summary>
    
      <category term="web开发" scheme="http://zypuu.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="web,Django" scheme="http://zypuu.com/tags/web-Django/"/>
    
  </entry>
  
  <entry>
    <title>Python连接Mysql</title>
    <link href="http://zypuu.com/2018/05/07/Python%E8%BF%9E%E6%8E%A5Mysql/"/>
    <id>http://zypuu.com/2018/05/07/Python连接Mysql/</id>
    <published>2018-05-07T07:55:17.000Z</published>
    <updated>2018-08-30T09:38:06.785Z</updated>
    
    <content type="html"><![CDATA[<p>通过python操作mysql，面向对象的编程思想</p><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><h2 id="面向对象封装"><a href="#面向对象封装" class="headerlink" title="面向对象封装"></a>面向对象封装</h2><h3 id="init初始化方法"><a href="#init初始化方法" class="headerlink" title="init初始化方法"></a>init初始化方法</h3><p>创建连接，建立游标对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class JD(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 　1创建链接对象</span><br><span class="line">        self.conn = connect(host=<span class="string">'主机名'</span>, port=<span class="number">3306</span>, database=<span class="string">'数据库名'</span>, user=<span class="string">'账户名'</span>, password=<span class="string">'密码'</span>,charset=<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">        # 2 创建游标对象</span><br><span class="line">        self.cs = self.conn.cursor()</span><br></pre></td></tr></table></figure></p><h3 id="del方法"><a href="#del方法" class="headerlink" title="del方法"></a>del方法</h3><p>关闭游标，关闭连接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def __del__(self):</span><br><span class="line">        # 5 关闭</span><br><span class="line">        self.cs.close()</span><br><span class="line">        self.conn.close()</span><br></pre></td></tr></table></figure><h3 id="sql语句执行方法"><a href="#sql语句执行方法" class="headerlink" title="sql语句执行方法"></a>sql语句执行方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def my_execute_sql(self,sql):</span><br><span class="line">        <span class="string">""</span><span class="string">"执行ｓｑｌ语句"</span><span class="string">""</span></span><br><span class="line">        self.cs.execute(sql)</span><br><span class="line"></span><br><span class="line">        # 4 获取数据</span><br><span class="line">        content = self.cs.fetchall()</span><br></pre></td></tr></table></figure><h3 id="写sql语句"><a href="#写sql语句" class="headerlink" title="写sql语句"></a>写sql语句</h3><p>例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def show_all_goods(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"显示所有的商品信息"</span><span class="string">""</span></span><br><span class="line">        sql = <span class="string">"select * from goods;"</span></span><br><span class="line"></span><br><span class="line">        self.my_execute_sql(sql)</span><br></pre></td></tr></table></figure></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def run(self):</span><br><span class="line">      self.show_all_goods()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      通过python操作mysql
    
    </summary>
    
      <category term="数据库" scheme="http://zypuu.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库,Mysql" scheme="http://zypuu.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql/"/>
    
  </entry>
  
  <entry>
    <title>关于Mysql的视图与事务</title>
    <link href="http://zypuu.com/2018/04/30/%E5%85%B3%E4%BA%8EMysql%E7%9A%84%E8%A7%86%E5%9B%BE%E3%80%81%E4%BA%8B%E5%8A%A1/"/>
    <id>http://zypuu.com/2018/04/30/关于Mysql的视图、事务/</id>
    <published>2018-04-30T07:54:03.000Z</published>
    <updated>2018-08-30T09:08:27.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。<br>对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。<br>视图是存储在数据库中的查询的SQL 语句，它主要出于两种原因：安全原因， 视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。这个视图就像一个“窗口”，从中只能看到你想看的数据列。这意味着你可以在这个视图上使用SELECT 语句，而你看到的将是你在视图定义里给出的那些数据列。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1.视图能简化用户操作<br>视图机制使用户可以将注意力集中在所关心地数据上。如果这些数据不是直接来自基本表，则可以通过定义视图，使数据库看起来结构简单、清晰，并且可以简化用户的的数据查询操作。<br>2.使用户能以多种角度看待同一数据<br>视图机制能使不同的用户以不同的方式看待同一数据，当许多不同种类的用户共享同一个数据库时，这种灵活性是非常必要的。<br>3.视图对重构数据库提供了一定程度的逻辑独立性<br>数据的物理独立性是指用户的应用程序不依赖于数据库的物理结构。数据的逻辑独立性是指当数据库重构造时，如增加新的关系或对原有的关系增加新的字段，用户的应用程序不会受影响。层次数据库和网状数据库一般能较好地支持数据的物理独立性，而对于逻辑独立性则不能完全的支持。<br>在关许数据库中，数据库的重构造往往是不可避免的。重构数据库最常见的是将一个基本表“垂直”地分成多个基本表。如果使用视图，应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。<br>当然，视图只能在一定程度上提供数据的逻辑独立，比如由于视图的更新是有条件的，因此应用程序中修改数据的语句可能仍会因为基本表构造的改变而改变。<br>4.视图能够对机密数据提供安全保护<br>有了视图机制，就可以在设计数据库应用系统时，对不同的用户定义不同的视图，使机密数据不出现在不应该看到这些数据的用户视图上。这样视图机制就自动提供了对机密数据的安全保护功能。</p><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create view v-表名 <span class="keyword">as</span> 查询语句</span><br></pre></td></tr></table></figure><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view v-表名；</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>所谓事务,它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。</p><h3 id="四大特性（ACID）"><a href="#四大特性（ACID）" class="headerlink" title="四大特性（ACID）"></a>四大特性（ACID）</h3><h4 id="原子性（A）"><a href="#原子性（A）" class="headerlink" title="原子性（A）"></a>原子性（A）</h4><p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性</p><h4 id="一致性（C）"><a href="#一致性（C）" class="headerlink" title="一致性（C）"></a>一致性（C）</h4><p>数据库总是从一个一致性的状态转换到另一个一致性的状态。事务不提交是不会修改数据的。</p><h4 id="隔离性（I）"><a href="#隔离性（I）" class="headerlink" title="隔离性（I）"></a>隔离性（I）</h4><p>通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p><h4 id="持久性（D）"><a href="#持久性（D）" class="headerlink" title="持久性（D）"></a>持久性（D）</h4><p>一旦事务提交，则其所做的修改会永久保存到数据库。</p><h3 id="事务命令"><a href="#事务命令" class="headerlink" title="事务命令"></a>事务命令</h3><p>表的引擎类型必须是innodb类型才可以使用事务，这是mysql表的默认引擎。</p><h4 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">或者</span><br><span class="line">start transaction;</span><br></pre></td></tr></table></figure><h4 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure><h4 id="回滚事务"><a href="#回滚事务" class="headerlink" title="回滚事务"></a>回滚事务</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollback;</span><br></pre></td></tr></table></figure><p>注意：<br>修改数据的命令会自动的触发事务，包括insert、update、delete<br>而在SQL语句中有手动开启事务的原因是：可以进行多次数据的修改，如果成功一起成功，否则一起会滚到之前的数据。</p>]]></content>
    
    <summary type="html">
    
      mysql数据库的视图，事务介绍，使用
    
    </summary>
    
      <category term="数据库" scheme="http://zypuu.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库,Mysql" scheme="http://zypuu.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Django视图使用说明</title>
    <link href="http://zypuu.com/2018/04/25/Django%E8%A7%86%E5%9B%BE%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://zypuu.com/2018/04/25/Django视图使用说明/</id>
    <published>2018-04-25T11:15:15.000Z</published>
    <updated>2018-08-29T10:49:07.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两个基类"><a href="#两个基类" class="headerlink" title="两个基类"></a>两个基类</h2><h3 id="APIView"><a href="#APIView" class="headerlink" title="APIView"></a>APIView</h3><p>APIView是django rest_framework提供的所有视图的基类，继承自django的view父类。<br>导入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rest_framework.views.APIView</span><br></pre></td></tr></table></figure><p>APIView相对于View封装了drf的request对象，response对象，异常捕获功能以及身份认证，权限检查，流量控制等功能。</p><p>提供的属性：<br>authentication_classes 列表或元祖，身份认证类<br>permissoin_classes 列表或元祖，权限检查类<br>throttle_classes 列表或元祖，流量控制类</p><p>经常以常规类视图的定义方法来实现get，post等请求方式。<br>所以在业务逻辑的视图选择时，如果功能上不包含对数据库的操作（增删改查），不包含序列化器，则继承APIView，直接定义请求方式方法即可。</p><h3 id="GenericAPIView"><a href="#GenericAPIView" class="headerlink" title="GenericAPIView"></a>GenericAPIView</h3><p>继承自APIVIew，增加了对于列表视图和详情视图可能用到的通用支持方法。通常使用时，可搭配一个或多个Mixin扩展类。<br>导入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rest_framework.generics.GenericAPIView</span><br></pre></td></tr></table></figure><p>支持定义的属性：</p><p>1.列表视图与详情视图通用：<br>queryset 列表视图的查询集<br>serializer_class 视图使用的序列化器<br>2.列表视图使用：<br>pagination_class 分页控制类<br>filter_backends 过滤控制后端<br>3.详情页视图使用：<br>lookup_field 查询单一数据库对象时使用的条件字段，默认为’pk’<br>lookup_url_kwarg 查询单一数据时URL中的参数关键字名称，默认与look_field相同</p><p>提供的方法：<br>列表视图与详情视图通用：<br>1.get_queryset(self)<br>返回视图使用的查询集，是列表视图与详情视图获取数据的基础，默认返回queryset属性，可以重写，例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def get_queryset(self):</span><br><span class="line">       <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">       提供数据集</span></span><br><span class="line"><span class="string">       "</span><span class="string">""</span></span><br><span class="line">       <span class="keyword">if</span> self.action == <span class="string">'list'</span>:</span><br><span class="line">           # 如果是list方法，则反回省的查询结果，返回省的列表即parent为none的</span><br><span class="line">           <span class="keyword">return</span> Area.objects.filter(parent=None)</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           # 不是list则是retrieve,返回所有</span><br><span class="line">           <span class="keyword">return</span> Area.objects.all()</span><br></pre></td></tr></table></figure><p>可以添加判断，根据不同请求返回指定不同的查询集。<br>2.get_serializer_class(self)</p><p>返回序列化器类，默认返回serializer_class，可以重写，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def get_serializer_class(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        提供序列化器</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> self.action == <span class="string">'list'</span>:</span><br><span class="line">            # 是list，返回省的序列化器</span><br><span class="line">            <span class="keyword">return</span> AreaSerializer</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            # 不是list，返回区县的序列化器</span><br><span class="line">            <span class="keyword">return</span> SubAreaSerializer</span><br></pre></td></tr></table></figure><p>3.get_serializer(self, args, *kwargs)</p><p>返回序列化器对象，被其他视图或扩展类使用，如果我们在视图中想要获取序列化器对象，可以直接调用此方法。</p><p>注意，在提供序列化器对象的时候，REST framework会向对象的context属性补充三个数据：request、format、view，这三个数据对象可以在定义序列化器时使用。<br>详情视图使用：<br>get_object(self) 返回详情视图所需的模型类数据对象，默认使用lookup_field参数来过滤queryset。 在试图中可以调用该方法获取详情信息的模型类对象。</p><p>若详情访问的模型类对象不存在，会返回404。</p><p>该方法会默认使用APIView提供的check_object_permissions方法检查当前对象是否有权限被访问。</p><h2 id="五个扩展类"><a href="#五个扩展类" class="headerlink" title="五个扩展类"></a>五个扩展类</h2><ol><li>ListModelMixin<br>列表视图扩展类，用于查询数据库多个对象，会对list的数据进行过滤和分页，成功返回200</li><li>CreateModelMixin<br>创建视图扩展类，用于增加数据库信息，成功返回201</li><li>RetrieveModelMixin<br>详情视图扩展类，用于单一对象的查询，成功返回200</li><li>UpdateModelMixin<br>更新视图扩展类，用于修改数据库信息，局部更新（partial_update方法），成功返回200</li><li>DestroyModelMixin<br>删除视图扩展类，用于删除数据库信息（一般都是逻辑删除），成功返回204</li></ol><h2 id="可用子类（组合类）"><a href="#可用子类（组合类）" class="headerlink" title="可用子类（组合类）"></a>可用子类（组合类）</h2><p> 1） CreateAPIView</p><p>提供 post 方法</p><p>继承自： GenericAPIView、CreateModelMixin</p><p>2）ListAPIView</p><p>提供 get 方法</p><p>继承自：GenericAPIView、ListModelMixin</p><p>3）RetireveAPIView</p><p>提供 get 方法</p><p>继承自: GenericAPIView、RetrieveModelMixin</p><p>4）DestoryAPIView</p><p>提供 delete 方法</p><p>继承自：GenericAPIView、DestoryModelMixin</p><p>5）UpdateAPIView</p><p>提供 put 和 patch 方法</p><p>继承自：GenericAPIView、UpdateModelMixin</p><p>6）RetrieveUpdateAPIView</p><p>提供 get、put、patch方法</p><p>继承自： GenericAPIView、RetrieveModelMixin、UpdateModelMixin</p><p>7）RetrieveUpdateDestoryAPIView</p><p>提供 get、put、patch、delete方法</p><p>继承自：GenericAPIView、RetrieveModelMixin、UpdateModelMixin、DestoryModelMixin</p><h2 id="视图集ViewSet"><a href="#视图集ViewSet" class="headerlink" title="视图集ViewSet"></a>视图集ViewSet</h2><p>相对于前面的视图类，进一步封装<br>list() 提供一组数据<br>retrieve() 提供单个数据<br>create() 创建数据<br>update() 保存数据<br>destory() 删除数据<br>ViewSet视图集类不再实现get()、post()等方法，而是实现动作 action 如 list() 、create() 等，这些动作与请求方式对应。<br>如果url中使用as_View方法，要把action与请求方式对应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r<span class="string">'路由规则'</span>, ViewSet.as_view(&#123;<span class="string">'get'</span>:<span class="string">'list'</span>&#125;),</span><br></pre></td></tr></table></figure><h3 id="action属性"><a href="#action属性" class="headerlink" title="action属性"></a>action属性</h3><p>可以使用self.action获取当前请求视图的action动作，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def get_serializer_class(self):</span><br><span class="line">    <span class="keyword">if</span> self.action == <span class="string">'create'</span>:</span><br><span class="line">        <span class="keyword">return</span> OrderCommitSerializer</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> OrderDataSerializer</span><br></pre></td></tr></table></figure><p>可以根据请求动作的不同进行if判断，来指定不同的序列化器与查询集</p><h3 id="常用视图集父类"><a href="#常用视图集父类" class="headerlink" title="常用视图集父类"></a>常用视图集父类</h3><p>1） ViewSet</p><p>继承自APIView，作用也与APIView基本类似，提供了身份认证、权限校验、流量管理等。</p><p>在ViewSet中，没有提供任何动作action方法，需要我们自己实现action方法。</p><p>2）GenericViewSet</p><p>继承自GenericAPIView，作用也与GenericAPIVIew类似，提供了get_object、get_queryset等方法便于列表视图与详情信息视图的开发。</p><p>3）ModelViewSet</p><p>继承自GenericAPIVIew，同时包括了ListModelMixin、RetrieveModelMixin、CreateModelMixin、UpdateModelMixin、DestoryModelMixin。</p><p>4）ReadOnlyModelViewSet</p><p>继承自GenericAPIVIew，同时包括了ListModelMixin、RetrieveModelMixin。</p><h3 id="视图定义中附加action动作"><a href="#视图定义中附加action动作" class="headerlink" title="视图定义中附加action动作"></a>视图定义中附加action动作</h3><p>添加自定义动作需要使用装饰器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rest_framework.decorators.action</span><br></pre></td></tr></table></figure><p>该装饰器可以接收两个参数<br>methods: 该action支持的请求方式，列表传递<br>detail: 表示是action中要处理的是否是视图资源的对象（即是否通过url路径获取主键）<br>True 表示使用通过URL获取的主键对应的数据对象<br>False 表示不使用URL获取主键</p><h3 id="路由routers"><a href="#路由routers" class="headerlink" title="路由routers"></a>路由routers</h3><p>在视图集中，可以使用routers快速实现路由信息的配置。<br>首先在urls.py中导入routers</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> routers</span><br></pre></td></tr></table></figure><p>然后创建router对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router = routers.SimpleRouter()</span><br><span class="line">router = routers.DefaultRouter()</span><br></pre></td></tr></table></figure><p>DefaultRouter与SimpleRouter的区别是，DefaultRouter会多附带一个默认的API根视图，返回一个包含所有列表视图的超链接响应数据。<br>接下来注册router</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.register(r<span class="string">'路由'</span>, 视图集, base_name=<span class="string">'路由名称前缀'</span>)</span><br></pre></td></tr></table></figure><p>上述代码会形成的路由如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^路由/$    name: 前缀-list</span><br><span class="line">^路由/&#123;pk&#125;/$   name: 前缀-detail</span><br></pre></td></tr></table></figure><p>然后添加路由数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line">urlpatterns += router.urls</span><br></pre></td></tr></table></figure><p>如果视图中附加了action动作，则形成的路由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^路由/方法名/$    name: 前缀-方法名</span><br><span class="line">^路由/&#123;pk&#125;/方法名/$  name: 前缀-方法名</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Django视图类的知识梳理
    
    </summary>
    
      <category term="web开发" scheme="http://zypuu.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="web,Django" scheme="http://zypuu.com/tags/web-Django/"/>
    
  </entry>
  
  <entry>
    <title>配置缓存</title>
    <link href="http://zypuu.com/2018/04/20/Django%E5%BA%94%E7%94%A8%E7%BC%93%E5%AD%98/"/>
    <id>http://zypuu.com/2018/04/20/Django应用缓存/</id>
    <published>2018-04-20T08:19:05.000Z</published>
    <updated>2018-08-29T10:26:29.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Django配置缓存"><a href="#Django配置缓存" class="headerlink" title="Django配置缓存"></a>Django配置缓存</h2><p>在Django REST framework中使用缓存，可以通过drf-extensions扩展来实现。使用文档<a href="http://chibisov.github.io/drf-extensions/docs/#caching" target="_blank" rel="noopener">点这里</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install drf-extensions</span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="直接添加装饰器"><a href="#直接添加装饰器" class="headerlink" title="直接添加装饰器"></a>直接添加装饰器</h4><p>首先导入工具</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework_extensions.cache.decorators <span class="keyword">import</span> cache_response</span><br></pre></td></tr></table></figure><p>即在视图类里面的方法前添加装饰器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class CityView(views.APIView):</span><br><span class="line">    @cache_response()</span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>cache_response可以添加两个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@cache_response(timeout=<span class="number">60</span>*<span class="number">60</span>, cache=<span class="string">'default'</span>)</span><br></pre></td></tr></table></figure><p>timeout : 缓存的过期时间<br>cache=’default’ ：django的缓存后端，即在settings中的cache配置</p><p>如果不写参数，则使用默认值，默认值在配置中添加代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># DRF扩展</span><br><span class="line">REST_FRAMEWORK_EXTENSIONS = &#123;</span><br><span class="line">    # 缓存时间</span><br><span class="line">    <span class="string">'DEFAULT_CACHE_RESPONSE_TIMEOUT'</span>: <span class="number">60</span> * <span class="number">60</span>,</span><br><span class="line">    # 缓存存储</span><br><span class="line">    <span class="string">'DEFAULT_USE_CACHE'</span>: <span class="string">'default'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用扩展类继承"><a href="#使用扩展类继承" class="headerlink" title="使用扩展类继承"></a>使用扩展类继承</h4><p>除了直接添加装饰器的方法，也可以使用drf-extensions提供的扩展类</p><p>drf-extensions提供了三种扩展类<br>导入工具：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rest_framework_extensions.cache.mixins</span><br></pre></td></tr></table></figure><p>三个扩展类都在里面。</p><p> 1.ListCacheResponseMixin<br> 用于缓存列表数据类的视图，配合ListModelMixin扩展类使用</p><ol start="2"><li>RetrieveCacheResponseMixin<br>用于缓存返回单一数据的视图，与RetrieveModelMixin扩展类配合使用</li><li>CacheResponseMixin<br>为视图集同时补充List和Retrieve两种缓存，与ListModelMixin和RetrieveModelMixin一起配合使用。</li></ol><p>使用方法直接视图类继承即可。<br>在settings中添加配置，即可设置过期时间与cache</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># DRF扩展</span><br><span class="line">REST_FRAMEWORK_EXTENSIONS = &#123;</span><br><span class="line">    # 缓存时间</span><br><span class="line">    <span class="string">'DEFAULT_CACHE_RESPONSE_TIMEOUT'</span>: <span class="number">60</span> * <span class="number">60</span>,</span><br><span class="line">    # 缓存存储</span><br><span class="line">    <span class="string">'DEFAULT_USE_CACHE'</span>: <span class="string">'default'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Flask配置缓存"><a href="#Flask配置缓存" class="headerlink" title="Flask配置缓存"></a>Flask配置缓存</h2>]]></content>
    
    <summary type="html">
    
      对于数据使用频率较高，切不经常更新的可以将数据放到缓存里，减少与mysql数据库的交互次数，Django、Flask配置缓存
    
    </summary>
    
      <category term="web开发" scheme="http://zypuu.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="web" scheme="http://zypuu.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Mysql的常用命令</title>
    <link href="http://zypuu.com/2018/04/03/Mysql%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://zypuu.com/2018/04/03/Mysql的常用命令/</id>
    <published>2018-04-03T11:26:00.000Z</published>
    <updated>2018-08-30T08:10:49.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql两种引擎的区别"><a href="#Mysql两种引擎的区别" class="headerlink" title="Mysql两种引擎的区别"></a>Mysql两种引擎的区别</h2><h3 id="Innodb引擎"><a href="#Innodb引擎" class="headerlink" title="Innodb引擎"></a>Innodb引擎</h3><p>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p><h3 id="MyIASM引擎"><a href="#MyIASM引擎" class="headerlink" title="MyIASM引擎"></a>MyIASM引擎</h3><p>MyIASM引擎没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。</p><h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><p>1、MyIASM是非事务安全的，而InnoDB是事务安全的</p><p>2、MyIASM锁的粒度是表级的，而InnoDB支持行级锁</p><p>3、MyIASM支持全文类型索引，而InnoDB不支持全文索引</p><p>4、MyIASM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyIASM</p><p>5、MyIASM表保存成文件形式，跨平台使用更加方便</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、MyIASM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyIASM<br>2、InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h3><p>1.整数：<code>int</code><br>2.小数：<code>decinal（总位数，小数位数）</code><br>3.字符串：<code>varchar（可变长度），char（固定长度）</code><br>4.日期时间：<code>datetime</code><br>5.枚举类型：<code>（enum）‘选择’</code></p><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit/exit</span><br></pre></td></tr></table></figure><h4 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select version()；</span><br></pre></td></tr></table></figure><h4 id="显示时间"><a href="#显示时间" class="headerlink" title="显示时间"></a>显示时间</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select now()；</span><br></pre></td></tr></table></figure><h4 id="查看当前使用数据库"><a href="#查看当前使用数据库" class="headerlink" title="查看当前使用数据库"></a>查看当前使用数据库</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select datebase（）；</span><br></pre></td></tr></table></figure><h4 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select databases();</span><br></pre></td></tr></table></figure><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database 数据库名；</span><br></pre></td></tr></table></figure><h4 id="查看字符集"><a href="#查看字符集" class="headerlink" title="查看字符集"></a>查看字符集</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create database 数据库名；</span><br></pre></td></tr></table></figure><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database 数据库名；</span><br></pre></td></tr></table></figure><h4 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名；</span><br></pre></td></tr></table></figure><h4 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql dump -uroot -p 数据库名 &gt; 文件名.sql</span><br></pre></td></tr></table></figure><h4 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql dump -uroot -p 数据库名 &lt; 文件名.sql</span><br></pre></td></tr></table></figure><h4 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source 文件名.sql</span><br></pre></td></tr></table></figure><h3 id="数据表的操作"><a href="#数据表的操作" class="headerlink" title="数据表的操作"></a>数据表的操作</h3><h4 id="查看所有表"><a href="#查看所有表" class="headerlink" title="查看所有表"></a>查看所有表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(id int unsigned...)</span><br></pre></td></tr></table></figure><h4 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc 表名</span><br></pre></td></tr></table></figure><h4 id="查看字符集-1"><a href="#查看字符集-1" class="headerlink" title="查看字符集"></a>查看字符集</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table 表名;</span><br></pre></td></tr></table></figure><h4 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add 字段名 数据类型;</span><br></pre></td></tr></table></figure><h4 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 modify 字段名 约束;</span><br><span class="line">alter table 表名 change 原名 新名 约束；</span><br></pre></td></tr></table></figure><h4 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop 字段名;</span><br></pre></td></tr></table></figure><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名;</span><br></pre></td></tr></table></figure><h3 id="数据的操作"><a href="#数据的操作" class="headerlink" title="数据的操作"></a>数据的操作</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 values (),(); # 数据，()按字段位置写入(),()是多行插入</span><br></pre></td></tr></table></figure><h4 id="部分插入"><a href="#部分插入" class="headerlink" title="部分插入"></a>部分插入</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名（字段名） values ();</span><br></pre></td></tr></table></figure><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 字段名=‘’ where 条件；</span><br></pre></td></tr></table></figure><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 where 条件；</span><br></pre></td></tr></table></figure><h3 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h3><h4 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><h4 id="查看字段数据，起名"><a href="#查看字段数据，起名" class="headerlink" title="查看字段数据，起名"></a>查看字段数据，起名</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 表名.字段名 <span class="keyword">as</span> <span class="string">'别名'</span> <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><h4 id="去重复"><a href="#去重复" class="headerlink" title="去重复"></a>去重复</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select distinct 字段 <span class="keyword">from</span> 表名；</span><br><span class="line">select key <span class="keyword">from</span> 表 group by key having count (*)&gt;<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>并不会修改数据。</p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> 表名 where 字段名 &gt; &lt; &gt;= &lt;= != 或&lt;&gt;</span><br><span class="line"># 也可以在条件里加逻辑 and 、or、  not（条件）、</span><br></pre></td></tr></table></figure><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">where like ‘小%’ # 以小字为开头的</span><br><span class="line">% 替换任意个</span><br><span class="line">_ 替换一个</span><br></pre></td></tr></table></figure><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">where  字段名 in （）；# 具体值</span><br><span class="line">not <span class="keyword">in</span></span><br><span class="line">（not）between and # 区间查询</span><br></pre></td></tr></table></figure><h4 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where 字段 is <span class="literal">null</span> （not <span class="literal">null</span>）；</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> 表名 order by 字段 asc；升序 （desc 降序）；</span><br></pre></td></tr></table></figure><h4 id="分组（按字段分组）"><a href="#分组（按字段分组）" class="headerlink" title="分组（按字段分组）"></a>分组（按字段分组）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段 <span class="keyword">from</span> 表名 group by 字段；</span><br></pre></td></tr></table></figure><h4 id="各个小组数据"><a href="#各个小组数据" class="headerlink" title="各个小组数据"></a>各个小组数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count（*）.字段一 【group_concat(字段二)】.字段一 <span class="keyword">from</span> 表名 group by 字段一 having 条件；</span><br></pre></td></tr></table></figure><p>按这个字段一分组，该组的统计，该组的字段二数据<br>注意： 这里的条件用having 不用where</p><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名 limit 0,5；# 第一个参数从第几页开始（显示个数*（第几页-1）），第二个参数显示数量</span><br></pre></td></tr></table></figure><p>分页是为了限制查询，防止数据过大，limit放最后</p><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><h4 id="统计个数"><a href="#统计个数" class="headerlink" title="统计个数"></a>统计个数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count（*） <span class="keyword">from</span> 表名 where 条件；</span><br></pre></td></tr></table></figure><h4 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max（字段）<span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure><h4 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select min（字段）<span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure><h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sum（字段） <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure><h4 id="平均"><a href="#平均" class="headerlink" title="平均"></a>平均</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select round（avg（字段）） from 表名；# 保留小数</span><br></pre></td></tr></table></figure><h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><h4 id="关联查询-1"><a href="#关联查询-1" class="headerlink" title="关联查询"></a>关联查询</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> 表一 inner join 表二 on 表一.字段=表二.字段；</span><br></pre></td></tr></table></figure><p>将表一的字段按表二的字段对应，合成一个表查询<br>后面的表是大表</p><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span>表 where 字段 &gt; (上一个表的查询结果)；</span><br></pre></td></tr></table></figure><h4 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> 表名 <span class="keyword">as</span> 别名一 inner join 表名 <span class="keyword">as</span> 别名二 on 别名一.字段 =别名二.字段</span><br></pre></td></tr></table></figure><h4 id="外键关联"><a href="#外键关联" class="headerlink" title="外键关联"></a>外键关联</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表一 addforeignkey（字段） references 表二（字段）；</span><br></pre></td></tr></table></figure><h3 id="拆表"><a href="#拆表" class="headerlink" title="拆表"></a>拆表</h3><p>已知表一</p><h4 id="创建表二"><a href="#创建表二" class="headerlink" title="创建表二"></a>创建表二</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table <span class="keyword">if</span> not exists （字段属性）</span><br></pre></td></tr></table></figure><p>if not exists 如果不存在</p><h4 id="将表一的数据分组"><a href="#将表一的数据分组" class="headerlink" title="将表一的数据分组"></a>将表一的数据分组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段<span class="keyword">from</span> 表一 group by 字段</span><br></pre></td></tr></table></figure><h4 id="插入新表二"><a href="#插入新表二" class="headerlink" title="插入新表二"></a>插入新表二</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表二（字段） （第二步查询语句）</span><br></pre></td></tr></table></figure><p>用子查询</p><h4 id="连接两个表，更新表一字段为表二的连接字段"><a href="#连接两个表，更新表一字段为表二的连接字段" class="headerlink" title="连接两个表，更新表一字段为表二的连接字段"></a>连接两个表，更新表一字段为表二的连接字段</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update（select * <span class="keyword">from</span> 表一 inner join 表二 on 表二.字段 = 表一.字段） set 表一.字段= 表二.字段</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      mysql数据库的引擎区别，以及mysql的一些常用命令总结。
    
    </summary>
    
      <category term="数据库" scheme="http://zypuu.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库,Mysql" scheme="http://zypuu.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql/"/>
    
  </entry>
  
  <entry>
    <title>关于session与JWT的认证机制</title>
    <link href="http://zypuu.com/2018/03/21/%E5%85%B3%E4%BA%8Esession%E4%B8%8EJWT%E7%9A%84%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://zypuu.com/2018/03/21/关于session与JWT的认证机制/</id>
    <published>2018-03-21T06:45:42.000Z</published>
    <updated>2018-08-29T10:18:54.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是状态保持"><a href="#什么是状态保持" class="headerlink" title="什么是状态保持"></a>什么是状态保持</h2><p>说到状态保持，首先要讲一下什么是无状态，http 就是一种无状态协议，浏览器请求服务器是无状态的。</p><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>指用户请求过一次后，浏览器与服务器无法知道这个用户做过什么，下一次请求还是新的请求。<br><br><br>发生无状态的原因：浏览器与服务器之间是使用socket套接字通讯的，在一次访问结束后，服务器将访问结果返回给浏览器之后，会关闭当前的socket连接，浏览器在关闭后，服务器也会销毁当前的页面对象。</p><h3 id="无状态协议"><a href="#无状态协议" class="headerlink" title="无状态协议"></a>无状态协议</h3><p>1.协议对于事务处理没有记忆能力。<br>2.对同一个 url 请求没有上下文关系。<br>3.每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的4请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况。<br>4.服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器。</p><h3 id="有状态"><a href="#有状态" class="headerlink" title="有状态"></a>有状态</h3><p>与无状态相反，相当于有记忆能力，可以记录之前用户的操作，即状态保持，那怎么实现状态保持呢？</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="Cookie的定义"><a href="#Cookie的定义" class="headerlink" title="Cookie的定义"></a>Cookie的定义</h3><p>指某些网站为了辨别用户身份、进行会话跟踪而储存在用户本地的数据。（通常经过加密）<br><br><br>cookie由服务器端生成，发送给客户端浏览器，浏览器可以将cookie的key/value进行保存，下次请求同一网站时就会将cookie同请求信息发送给服务器。<br><br><br>通过cookie就实现了状态保持，即用户登陆过的信息，访问过的页面数据，都会被放在cookie里进行记录，保存在浏览器，下次请求这个网站时会发送给服务器，服务器就能从cookie中快速获取信息，即知道了用户已经登陆过，访问了哪些数据，保持了用户的登录状态，将相关数据快速呈现。</p><h3 id="使用cookie的注意事项"><a href="#使用cookie的注意事项" class="headerlink" title="使用cookie的注意事项"></a>使用cookie的注意事项</h3><ol><li>cookie是基于域名安全的，不同域名的cookie是不能互相访问的，即同源策略。（在这个页面里可以嵌入窗口iframe，来访问其他域名的cookie）</li><li>Cookie是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用。</li><li>因为cookie被放在请求报文里发送给服务器，所以服务器端可以通过request对象来获取cookie信息，进行操作。</li></ol><h3 id="设置cookie与获取cookie"><a href="#设置cookie与获取cookie" class="headerlink" title="设置cookie与获取cookie"></a>设置cookie与获取cookie</h3><h4 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h4><p>获取response对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.set_cookie(‘键’，‘值’，max_age=<span class="number">3600</span>）</span><br></pre></td></tr></table></figure><p>max_age为过期时间，即第一次访问产生cookie之后，3600秒会自动删除。</p><h4 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h4><p>请求对象request</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.cookies.get(<span class="string">'键'</span>)</span><br></pre></td></tr></table></figure><p>根据之前设置的键就能获取到cookie的值。</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>cookie说到建议不要保存用户的敏感信息，很容易会被破解，那么这些敏感信息怎么解决，比如用户登录的用户名，密码，这就要用到session来认证用户。</p><h3 id="理解session的机制"><a href="#理解session的机制" class="headerlink" title="理解session的机制"></a>理解session的机制</h3><p>对于敏感的信息，要保存在服务器中，不能存储在浏览器中，而服务器采用的状态保持的方案就是session认证。<br><br>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。</p><h3 id="session依赖于cookie"><a href="#session依赖于cookie" class="headerlink" title="session依赖于cookie"></a>session依赖于cookie</h3><p>客户端在访问后，由服务端生成session，根据每一个session都会生成它的唯一标识（uuid），然后以session为键，这个唯一标识为值，存放在cookie里。同时服务端本地也会存session（非关系型数据库存储，如redis），以uuid为键，session的键值对为值，存进服务端本地，访问时，根据这个唯一标识在本地进行读取操作。</p><h4 id="url重写技术"><a href="#url重写技术" class="headerlink" title="url重写技术"></a>url重写技术</h4><p>由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面，附加方式也有两种，一种是作为URL路径的附加信息，表现形式为<code>http://...../xxx;jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764</code><br>另一种是作为查询字符串附加在URL后面，表现形式为<code>http://...../xxx?jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764</code><br>这两种方式对于用户来说是没有区别的，只是服务器在解析的时候处理的方式不同，采用第一种方式也有利于把session id的信息和正常程序参数区分开来。<br>为了在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个session id。</p><h4 id="表单隐藏字段技术"><a href="#表单隐藏字段技术" class="headerlink" title="表单隐藏字段技术"></a>表单隐藏字段技术</h4><p>另一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如下面的表单： </p><pre><code>&lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;/form&gt; 在被传递给客户端之前将被改写成： &lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;jsessionid&quot; value=&quot;ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;/form&gt; </code></pre><p>这种技术使用相对较少了。</p><h3 id="session数据的读写"><a href="#session数据的读写" class="headerlink" title="session数据的读写"></a>session数据的读写</h3><h4 id="读取session数据"><a href="#读取session数据" class="headerlink" title="读取session数据"></a>读取session数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.get(<span class="string">'键'</span>)</span><br></pre></td></tr></table></figure><h4 id="写入session数据"><a href="#写入session数据" class="headerlink" title="写入session数据"></a>写入session数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session[<span class="string">'键'</span>] = <span class="string">'值'</span></span><br></pre></td></tr></table></figure><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="session认证所显露的问题"><a href="#session认证所显露的问题" class="headerlink" title="session认证所显露的问题"></a>session认证所显露的问题</h3><p>1.用户通过session认证，都要在服务器端做一次记录，而session是保存在服务器端的内存中，随着用户的增多，服务器端的开销会明显增大。<br>2.而且用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。<br>3.session是依赖于cookie，如果cookie被截获，很容易受到跨站请求伪造的攻击（csrf），安全性不足。<br><br><br>这就引入了jwt认证机制</p><h3 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h3><p>JWT，全名Json Web Token，是一种基于token的认证机制，类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。<br><br>流程上是这样的：</p><ul><li>用户使用用户名密码来请求服务器 </li><li>服务器进行验证用户的信息 </li><li>服务器通过验证发送给用户一个token</li><li>客户端存储token，并在每次请求时附送上这个token值 </li><li>服务端验证token值，并返回数据</li></ul><h3 id="JWT的构成"><a href="#JWT的构成" class="headerlink" title="JWT的构成"></a>JWT的构成</h3><p>例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure></p><p>如上所示，是一个JWT的token，分为三个部分</p><h4 id="header头部"><a href="#header头部" class="headerlink" title="header头部"></a>header头部</h4><p>第一部分header存两部分信息<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  'typ': 'JWT',  # 声明类型为jwt</span><br><span class="line">  'alg': 'HS256' # 加密算法 HMAC SHA256</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过base64算法加密构成第一部分，<code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code></p><h4 id="payload载荷"><a href="#payload载荷" class="headerlink" title="payload载荷"></a>payload载荷</h4><p>载荷是存放有效信息的地方，有效信息分为三部分：</p><ol><li>标准中注册的声明：<br>iss: jwt签发者<br>sub: jwt所面向的用户<br>aud: 接收jwt的一方<br>exp: jwt的过期时间，这个过期时间必须要大于签发时间<br>nbf: 定义在什么时间之前，该jwt都是不可用的.<br>iat: jwt的签发时间<br>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li><li>公共的声明：<br>添加用户信息，不建议添加敏感信息，因为base64算法是对称算法，可解密</li><li>私有的声明：<br>私有声明是提供者和消费者所共同定义的声明。<br>定义一个payload</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="string">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>base64算法加密后就是第二段<code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</code></p><h4 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h4><p>jwt的第三部分是一个签证信息，签证信息由三部分组成：<br>header<br>payload<br>secret<br>这部分信息将header、payload中的base64加密后的信息连接成字符串，然后通过header里声明的HS256算法加上secret进行加密，就构成了jwt的第三部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> encodedString = base64UrlEncode(header) + <span class="string">'.'</span> + base64UrlEncode(payload);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> signature = HMACSHA256(encodedString, <span class="string">'secret'</span>);</span><br></pre></td></tr></table></figure><p>构成第三部分<code>TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</code><br>三部分构成完整的JWT的token</p><p>PS：secret是保存在服务端的，jwt签发也是在服务端，所以secret是服务端的私钥，不能泄露出去。虽然header和payload可以通过base64解密，但是没有secret是无法进行认证的，这就保证了安全性。</p><h3 id="JWT的应用"><a href="#JWT的应用" class="headerlink" title="JWT的应用"></a>JWT的应用</h3><p>Django rest framework中应用jwt<br>详情可参考文档网站：<a href="http://getblimp.github.io/django-rest-framework-jwt/" target="_blank" rel="noopener">JWT官方文档</a></p><h4 id="安装jwt应用"><a href="#安装jwt应用" class="headerlink" title="安装jwt应用"></a>安装jwt应用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install djangorestframework-jwt</span><br></pre></td></tr></table></figure><h4 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h4><p>指定jwt认证<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class="line">        <span class="string">'rest_framework_jwt.authentication.JSONWebTokenAuthentication'</span>,</span><br><span class="line">        <span class="string">'rest_framework.authentication.SessionAuthentication'</span>,</span><br><span class="line">        <span class="string">'rest_framework.authentication.BasicAuthentication'</span>,</span><br><span class="line">    ),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JWT_AUTH = &#123;</span><br><span class="line">    <span class="string">'JWT_EXPIRATION_DELTA'</span>: datetime.timedelta(days=<span class="number">1</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JWT_EXPIRATION_DELTA指明jwt的有效期</p><h4 id="使用jwt返回token"><a href="#使用jwt返回token" class="headerlink" title="使用jwt返回token"></a>使用jwt返回token</h4><p>生成口令并返回<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework_jwt.settings <span class="keyword">import</span> api_settings</span><br><span class="line"></span><br><span class="line">jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</span><br><span class="line"></span><br><span class="line">payload = jwt_payload_handler(user)</span><br><span class="line">token = jwt_encode_handler(payload)</span><br></pre></td></tr></table></figure></p><p>比如注册中使用token，因为token要返回输出，所以在定义序列化器时要添加token字段</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token = serializers.CharField(label='登录状态token', read_only=True)  # 增加token字段</span><br></pre></td></tr></table></figure><h4 id="登录功能中使用JWT返回指定字段"><a href="#登录功能中使用JWT返回指定字段" class="headerlink" title="登录功能中使用JWT返回指定字段"></a>登录功能中使用JWT返回指定字段</h4><p>将上面的jwt应用于登录认证时，登录成功后，发现api接口只返回了jwt的token，如图所示</p><img src="/2018/03/21/关于session与JWT的认证机制/1.jpg"><p>如果想将用户的其他字段比如用户名，怎么返回呢<br>jwt配合django的内部框架提供了登录验证功能，在Django框架中直接使用jwt的登录验证视图函数obtain_jwt_token</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from rest_framework_jwt.views import obtain_jwt_token # 导入包</span><br><span class="line">url(r'^路由规则$', obtain_jwt_token), # url中配置地址</span><br></pre></td></tr></table></figure><p>定义以上路由地址即可，jwt自带的登录验证便可应用<br>jwt提供的视图obtain_jwt_token内部逻辑：<br>    1.定义视图类，继承自APIView<br>    2.定义序列化器，继承自Serializer，然后调用django内部贡献的authenticate()方法<br>    3.接收用户名、密码<br>    4.查询数据库，进行密码对比<br>    5.如果成功，则生成口令并返回<br>这是查看obtain_jwt_token的源码，和jwt的官方文档，就可以理解这个视图的工作原理。</p><p>然后自定义接口响应值：<br>1.在users应用下新建utils.py。<br>2.创建函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def jwt_response_payload_handler(token, user=None, request=None):</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="string">'token'</span>: token,</span><br><span class="line"><span class="string">'username'</span>:user.username</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在settings.py中配置添加<br>    ‘JWT_RESPONSE_PAYLOAD_HANDLER’:’users.utils.jwt_response_payload_handler’,</p><p>然后重新运行即可，效果如下</p><img src="/2018/03/21/关于session与JWT的认证机制/2.jpg"><h3 id="jwt的优点"><a href="#jwt的优点" class="headerlink" title="jwt的优点"></a>jwt的优点</h3><p>1.因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。<br>2.因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。<br>3.便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。<br>4.它不需要在服务端保存会话信息, 所以它易于应用的扩展</p>]]></content>
    
    <summary type="html">
    
      http状态保持，cookies的作用，session与jwt的认证机制
    
    </summary>
    
      <category term="web开发" scheme="http://zypuu.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="web,状态保持" scheme="http://zypuu.com/tags/web-%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>数据库设计规范与原则</title>
    <link href="http://zypuu.com/2018/03/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E4%B8%8E%E5%8E%9F%E5%88%99/"/>
    <id>http://zypuu.com/2018/03/20/数据库设计规范与原则/</id>
    <published>2018-03-20T09:07:14.000Z</published>
    <updated>2018-08-30T09:20:53.244Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MYSQL数据库设计规范"><a href="#MYSQL数据库设计规范" class="headerlink" title="MYSQL数据库设计规范"></a>MYSQL数据库设计规范</h2><h3 id="1、数据库命名规范"><a href="#1、数据库命名规范" class="headerlink" title="1、数据库命名规范"></a>1、数据库命名规范</h3><p>采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’_’组成;<br>命名简洁明确(长度不能超过30个字符);<br>例如:user, stat, log, 也可以wifi_user, wifi_stat, wifi_log给数据库加个前缀;<br>除非是备份数据库可以加0-9的自然数:user_db_20151210;</p><h3 id="2、数据库表名命名规范"><a href="#2、数据库表名命名规范" class="headerlink" title="2、数据库表名命名规范"></a>2、数据库表名命名规范</h3><p>采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’<em>‘组成;<br>命名简洁明确,多个单词用下划线’</em>‘分隔;<br>例如:user_login, user_profile, user_detail, user_role, user_role_relation,<br>user_role_right, user_role_right_relation<br>表前缀’user_’可以有效的把相同关系的表显示在一起;</p><h3 id="3、数据库表字段名命名规范"><a href="#3、数据库表字段名命名规范" class="headerlink" title="3、数据库表字段名命名规范"></a>3、数据库表字段名命名规范</h3><p>采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’<em>‘组成;<br>命名简洁明确,多个单词用下划线’</em>‘分隔;<br>例如:user_login表字段 user_id, user_name, pass_word, eamil, tickit, status, mobile, add_time;<br>每个表中必须有自增主键,add_time(默认系统时间)<br>表与表之间的相关联字段名称要求尽可能的相同;</p><h3 id="4、数据库表字段类型规范"><a href="#4、数据库表字段类型规范" class="headerlink" title="4、数据库表字段类型规范"></a>4、数据库表字段类型规范</h3><p>用尽量少的存储空间来存数一个字段的数据;<br>例如:能使用int就不要使用varchar、char,能用varchar(16)就不要使用varchar(256);<br>IP地址最好使用int类型;<br>固定长度的类型最好使用char,例如:邮编;<br>能使用tinyint就不要使用smallint,int;<br>最好给每个字段一个默认值,最好不能为null;</p><h3 id="5、数据库表索引规范"><a href="#5、数据库表索引规范" class="headerlink" title="5、数据库表索引规范"></a>5、数据库表索引规范</h3><p>命名简洁明确,例如:user_login表user_name字段的索引应为user_name_index唯一索引;<br>为每个表创建一个主键索引;<br>为每个表创建合理的索引;<br>建立复合索引请慎重;</p><h3 id="6、简单熟悉数据库范式"><a href="#6、简单熟悉数据库范式" class="headerlink" title="6、简单熟悉数据库范式"></a>6、简单熟悉数据库范式</h3><p>第一范式(1NF):字段值具有原子性,不能再分(所有关系型数据库系统都满足第一范式);<br>例如:姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;<br>第二范式(2NF):一个表必须有主键,即每行数据都能被唯一的区分;<br>备注:必须先满足第一范式;<br>第三范式(3NF):一个表中不能包涵其他相关表中非关键字段的信息,即数据表不能有沉余字段;<br>备注:必须先满足第二范式;<br>备注:往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询;<br>例如:相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段;</p><h2 id="MYSQL数据库设计原则"><a href="#MYSQL数据库设计原则" class="headerlink" title="MYSQL数据库设计原则"></a>MYSQL数据库设计原则</h2><h3 id="1、核心原则"><a href="#1、核心原则" class="headerlink" title="1、核心原则"></a>1、核心原则</h3><p>不在数据库做运算;<br>cpu计算务必移至业务层;<br>控制列数量(字段少而精,字段数建议在20以内);<br>平衡范式与冗余(效率优先;往往牺牲范式)<br>拒绝3B(拒绝大sql语句:big sql、拒绝大事物:big transaction、拒绝大批量:big batch);</p><h3 id="2、字段类原则"><a href="#2、字段类原则" class="headerlink" title="2、字段类原则"></a>2、字段类原则</h3><p>用好数值类型(用合适的字段类型节约空间);<br>字符转化为数字(能转化的最好转化,同样节约空间、提高查询性能);<br>避免使用NULL字段(NULL字段很难查询优化、NULL字段的索引需要额外空间、NULL字段的复合索引无效);<br>少用text类型(尽量使用varchar代替text字段);</p><h3 id="3、索引类原则"><a href="#3、索引类原则" class="headerlink" title="3、索引类原则"></a>3、索引类原则</h3><p>合理使用索引(改善查询,减慢更新,索引一定不是越多越好);<br>字符字段必须建前缀索引;<br>不在索引做列运算;<br>innodb主键推荐使用自增列(主键建立聚簇索引,主键不应该被修改,字符串不应该做主键)(理解Innodb的索引保存结构就知道了);<br>不用外键(由程序保证约束);</p><h3 id="4、sql类原则"><a href="#4、sql类原则" class="headerlink" title="4、sql类原则"></a>4、sql类原则</h3><p>sql语句尽可能简单(一条sql只能在一个cpu运算,大语句拆小语句,减少锁时间,一条大sql可以堵死整个库);<br>简单的事务;<br>避免使用trig/func(触发器、函数不用客户端程序取而代之);<br>不用select <em>(消耗cpu,io,内存,带宽,这种程序不具有扩展性);<br>OR改写为IN(or的效率是n级别);<br>OR改写为UNION(mysql的索引合并很弱智);<br>select id from t where phone = ’159′ or name = ‘john’;<br>=&gt;<br>select id from t where phone=’159′<br>union<br>select id from t where name=’jonh’<br>慎用count(</em>);<br>limit高效分页(limit越大,效率越低);<br>使用union all替代union(union有去重开销);<br>少用连接join;<br>使用group by;</p>]]></content>
    
    <summary type="html">
    
      mysql数据库的设计原则规范
    
    </summary>
    
      <category term="数据库" scheme="http://zypuu.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库,Mysql" scheme="http://zypuu.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql/"/>
    
  </entry>
  
</feed>
